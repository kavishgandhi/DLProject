{"text": "'private void setContentViewWithMinimalElements ( ) { // Set data in the RemoteViews programmatically contentView . setImageViewResource ( R . id . imageView , R . drawable . ic_launcher ) ; contentView . setTextViewText ( R . id . title_text_notification , getResources ( ) . getString ( R . string . notification_title ) ) ; contentView . setTextViewText ( R . id . message_notification , getResources ( ) . getString ( R . string . notification_text ) ) ; }'", "label": "'Method to set the contentview with Title Text and Image .'"}
{"text": "'public String getFriendlyNameOfField ( ProfileField < ? > field ) { String name = getStringFromResource ( PROFILE_FIELD_PREFIX + field . getIdentifier ( ) ) ; if ( name == null ) { return field . getIdentifier ( ) ; } return name ; }'", "label": "'Provides the localized friendly name of a field .'"}
{"text": "'@ Override public void onBindViewHolder ( ViewHolder viewHolder , final int position ) { final DeviceGuiElement device = ServicesGuiList . get ( ) . getServices ( ) . get ( position ) ; if ( device . getName ( ) == null || device . getName ( ) . equals ( \"\" ) ) { viewHolder . nameTextView . setText ( \"Name not found, please wait...\" ) ; } else { viewHolder . nameTextView . setText ( device . getName ( ) ) ; } viewHolder . addressTextView . setText ( device . getAddress ( ) ) ; viewHolder . identifierTextView . setText ( device . getIdentifier ( ) ) ; viewHolder . logo . setImageDrawable ( new IconicsDrawable ( context ) . icon ( FontAwesome . Icon . faw_android ) . color ( context . getResources ( ) . getColor ( R . color . red ) ) . sizeDp ( 30 ) ) ; viewHolder . setOnClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { itemClickListener . serviceItemClicked ( device ) ; } } ) ; }'", "label": "'Replace the contents of a view ( invoked by the layout manager )'"}
{"text": "'private void killScheduler ( ) { if ( scheduler != null ) { WfdLog . d ( TAG , \"scheduler killed\" ) ; scheduler . shutdown ( ) ; scheduler = null ; } }'", "label": "'Kill the scheduler to stop the Eternal Connect in any case .'"}
{"text": "'public static synchronized void initialize ( Context context , int goIntent , boolean isAutonomous , ProximityMiddleware . Factory factory ) { if ( context == null || factory == null ) { throw new NullPointerException ( \"Arguments cannot be null\" ) ; } SPF . initialize ( context , goIntent , isAutonomous , factory ) ; sInstance = new SPFContext ( ) ; }'", "label": "'Initializes SPFContext . After this method has been called you can get references to SPFContext and SPF .'"}
{"text": "'public void broadcastEvent ( final int code , final Bundle payload ) { if ( SPFConfig . DEBUG ) { Log . d ( TAG , \"Broadcasting event \" + code + \" with payload \" + payload ) ; } for ( final OnEventListener listener : mEventListeners ) { //TODO is it thread safe? mHandler . post ( new Runnable ( ) { @ Override public void run ( ) { listener . onEvent ( code , payload ) ; } } ) ; } }'", "label": "'Broadcasts an event to all registered listeners . Each listener will receive a reference to the given bundle .'"}
{"text": "'public static ProfileFragment createRemoteProfileFragment ( String personIdentifer ) { Bundle b = new Bundle ( ) ; b . putInt ( EXTRA_VIEW_MODE , Mode . REMOTE . ordinal ( ) ) ; b . putString ( EXTRA_PERSON_IDENTIFIER , personIdentifer ) ; ProfileFragment fragment = new ProfileFragment ( ) ; fragment . setArguments ( b ) ; return fragment ; }'", "label": "'Creates a new instance of { @link ProfileFragment } to show the profile of a remote user . The fragment will allow only to view the fields and not to modify them .'"}
{"text": "'public static ProfileFragment createViewSelfProfileFragment ( ) { Bundle b = new Bundle ( ) ; b . putInt ( EXTRA_VIEW_MODE , Mode . SELF . ordinal ( ) ) ; ProfileFragment fragment = new ProfileFragment ( ) ; fragment . setArguments ( b ) ; return fragment ; }'", "label": "'Creates a new instance of ProfileFragment to show the local profile .'"}
{"text": "'@ Override public Loader < ProfileFieldContainer > onCreateLoader ( int id , Bundle args ) { switch ( id ) { case LoadersConfig . LOAD_PROFILE_LOADER_ID : return new AsyncTaskLoader < ProfileFieldContainer > ( getActivity ( ) ) { @ Override public ProfileFieldContainer loadInBackground ( ) { if ( mMode == Mode . SELF || mMode == Mode . EDIT ) { return SPF . get ( ) . getProfileManager ( ) . getProfileFieldBulk ( mCurrentPersona , ProfilePagerAdapter . DEFAULT_FIELDS ) ; } else { SPFRemoteInstance instance = SPF . get ( ) . getPeopleManager ( ) . getPerson ( mPersonIdentifier ) ; if ( instance == null ) { throw new IllegalStateException ( \"Person \" + mPersonIdentifier + \" not found in proximity\" ) ; } else { String app = getActivity ( ) . getCallingPackage ( ) ; app = app == null ? \"it.polimi.spf.app\" : app ; return instance . getProfileBulk ( ProfileField . toIdentifierList ( ProfilePagerAdapter . DEFAULT_FIELDS ) , app ) ; } } } } ; case LoadersConfig . SAVE_PROFILE_LOADER_ID : if ( mMode != Mode . EDIT ) { Log . e ( TAG , \"SAVE_PROFILE_LOADER initialized in mode \" + mMode ) ; } return new AsyncTaskLoader < ProfileFieldContainer > ( getActivity ( ) ) { @ Override public ProfileFieldContainer loadInBackground ( ) { SPF . get ( ) . getProfileManager ( ) . setProfileFieldBulk ( mContainer , mCurrentPersona ) ; return null ; } } ; default : throw new IllegalArgumentException ( \"No loader for id \" + id ) ; } }'", "label": "'/ * LOADERS - Used to load and save profile data .'"}
{"text": "'private void onProfileDataAvailable ( ) { Log . d ( TAG , \"onProfileDataAvailable\" ) ; mFactory = new ProfileFieldViewFactory ( getActivity ( ) , mMode , mCurrentPersona , mContainer ) ; String [ ] mPageTitles = this . getResources ( ) . getStringArray ( R . array . profileedit_fragments_titles ) ; tabLayout . removeAllTabs ( ) ; tabLayout . addTab ( tabLayout . newTab ( ) . setText ( mPageTitles [ 0 ] . toUpperCase ( Locale . getDefault ( ) ) ) ) ; tabLayout . addTab ( tabLayout . newTab ( ) . setText ( mPageTitles [ 1 ] . toUpperCase ( Locale . getDefault ( ) ) ) ) ; tabLayout . addTab ( tabLayout . newTab ( ) . setText ( mPageTitles [ 2 ] . toUpperCase ( Locale . getDefault ( ) ) ) ) ; tabLayout . setTabGravity ( TabLayout . GRAVITY_FILL ) ; ProfilePagerAdapter mPagerAdapter = new ProfilePagerAdapter ( getChildFragmentManager ( ) , mMode , tabLayout . getTabCount ( ) ) ; mViewPager . setAdapter ( mPagerAdapter ) ; mViewPager . addOnPageChangeListener ( new TabLayout . TabLayoutOnPageChangeListener ( tabLayout ) ) ; tabLayout . setOnTabSelectedListener ( new TabLayout . OnTabSelectedListener ( ) { @ Override public void onTabSelected ( TabLayout . Tab tab ) { mViewPager . setCurrentItem ( tab . getPosition ( ) ) ; } @ Override public void onTabUnselected ( TabLayout . Tab tab ) { } @ Override public void onTabReselected ( TabLayout . Tab tab ) { } } ) ; if ( mMode != Mode . SELF ) { showPicture ( mContainer . getFieldValue ( ProfileField . PHOTO ) ) ; } else { if ( getActivity ( ) instanceof MainActivity ) { ( ( MainActivity ) getActivity ( ) ) . onPhotoReady ( mContainer . getFieldValue ( ProfileField . PHOTO ) ) ; } else if ( getActivity ( ) instanceof ProfileViewActivity ) { //TODO implement this //                ((ProfileViewActivity) getActivity()).onPhotoReady(mContainer.getFieldValue(ProfileField.PHOTO)); } } // Refresh field fragments mPagerAdapter . onRefresh ( ) ; }'", "label": "'Called when the profile data is available thus we can set up the view'"}
{"text": "'public < E > View createViewFor ( ProfileField < E > field , ViewGroup container ) { switch ( mMode ) { case SELF : case REMOTE : return mFactory . createViewForField ( field , container , null ) ; case EDIT : return mFactory . createViewForField ( field , container , new ProfileFieldViewFactory . FieldValueListener < E > ( ) { @ Override public void onFieldValueChanged ( ProfileField < E > field , E value ) { mContainer . setFieldValue ( field , value ) ; } @ Override public void onInvalidFieldValue ( ProfileField < E > field , String fieldFriendlyName ) { Toast . makeText ( getActivity ( ) , \"Invalid value for field \" + fieldFriendlyName , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onCircleAdded ( ProfileField < E > field , String circle ) { Log . d ( TAG , \"Circle \" + circle + \" added to field \" + field + \" of persona \" + mCurrentPersona ) ; SPF . get ( ) . getProfileManager ( ) . addGroupToField ( field , circle , mCurrentPersona ) ; } @ Override public void onCircleRemoved ( ProfileField < E > field , String circle ) { Log . d ( TAG , \"Circle \" + circle + \" removed from field \" + field + \" of persona \" + mCurrentPersona ) ; SPF . get ( ) . getProfileManager ( ) . removeGroupFromField ( field , circle , mCurrentPersona ) ; } } ) ; default : return null ; } }'", "label": "'Creates a view for the given profile field . Depending on the { @link Mode } of visualization the view may allow the modification of the value . This method will not attach the view to the provided { @link ViewGroup }'"}
{"text": "'public void beginCrop ( Uri source ) { Uri destination = Uri . fromFile ( new File ( this . getActivity ( ) . getCacheDir ( ) , \"cropped\" ) ) ; Crop . of ( source , destination ) . asSquare ( ) . start ( this . getActivity ( ) ) ; }'", "label": "'Method to start the activity to crop an image .'"}
{"text": "'public void handleCrop ( int resultCode , Intent result ) { if ( resultCode == Activity . RESULT_OK ) { Uri uri = Crop . getOutput ( result ) ; resultView . setImageURI ( uri ) ; InputStream inputStream = null ; try { inputStream = new FileInputStream ( uri . getPath ( ) ) ; Bitmap myBitmap = BitmapFactory . decodeStream ( inputStream ) ; myBitmap = Bitmap . createScaledBitmap ( myBitmap , 130 , 130 , false ) ; mContainer . setFieldValue ( ProfileField . PHOTO , myBitmap ) ; showPicture ( myBitmap ) ; } catch ( FileNotFoundException e ) { Log . e ( TAG , \"handleCrop FileInputStream-file not found from uri.getpath\" , e ) ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( IOException e ) { Log . e ( TAG , \"handleCrop closing input stream error\" , e ) ; } } } } else if ( resultCode == Crop . RESULT_ERROR ) { Toast . makeText ( this . getActivity ( ) , Crop . getError ( result ) . getMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } }'", "label": "'Method to set an show a cropped imaged .'"}
{"text": "'@ Override public void onItemSelected ( AdapterView < ? > parent , View view , int position , long id ) { SPFPersona persona = ( SPFPersona ) parent . getItemAtPosition ( position ) ; if ( mCurrentPersona . equals ( persona ) ) { return ; } mCurrentPersona = persona ; startLoader ( LoadersConfig . LOAD_PROFILE_LOADER_ID ) ; }'", "label": "'/ * ItemSelectListener for Persona spinner in actionbar'"}
{"text": "'public static < T > T toObject ( final String jsonString , final Class < T > clazz ) throws JsonParseException , JsonMappingException , IOException { return toObject ( jsonString , clazz , false ) ; }'", "label": "'Transforms the given json string into a java object .'"}
{"text": "'public static < T > T toObject ( final String jsonString , final Class < T > clazz , final boolean newMapper ) throws JsonParseException , JsonMappingException , IOException { final ObjectMapper mapper = ObjectMapperFactory . getObjectMapper ( newMapper ) ; final T object = mapper . readValue ( jsonString , clazz ) ; return object ; }'", "label": "'Transforms the given json string into a java object .'"}
{"text": "'public static < T > T toObject ( final String jsonString , final Class < T > clazz , final Module ... modules ) throws JsonParseException , JsonMappingException , IOException { ObjectMapper mapper = ObjectMapperFactory . getObjectMapper ( true ) ; mapper = mapper . registerModules ( modules ) ; final T object = mapper . readValue ( jsonString , clazz ) ; return object ; }'", "label": "'Transforms the given json string into a java object .'"}
{"text": "'public static < T > List < T > toObjectList ( final String jsonString , final Class < T > elementClass ) throws JsonParseException , JsonMappingException , IOException { return ( List < T > ) toObjectCollection ( jsonString , List . class , elementClass ) ; }'", "label": "'Transforms the given json string into a java object { @link List }'"}
{"text": "'public static < T > Collection < T > toObjectCollection ( final String jsonString , @ SuppressWarnings ( \"rawtypes\" ) Class < ? extends Collection > collectionClass , Class < T > elementClass ) throws JsonParseException , JsonMappingException , IOException { final ObjectMapper mapper = ObjectMapperFactory . getObjectMapper ( true ) ; return mapper . readValue ( jsonString , mapper . getTypeFactory ( ) . constructCollectionType ( collectionClass , elementClass ) ) ; }'", "label": "'Transforms the given json string into a java object { @link Collection }'"}
{"text": "'@ Override public void handleRegistrationRequest ( Context context , AppDescriptor descriptor , final Callback callback ) { final DialogView dialogView = new DialogView ( context , descriptor ) ; Dialog dialog = new AlertDialog . Builder ( context ) . setPositiveButton ( R . string . app_permission_dialog_allow , new AlertDialog . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { callback . onRequestAccepted ( dialogView . getSelectedPersona ( ) ) ; } } ) . setNegativeButton ( R . string . app_permission_dialog_deny , new AlertDialog . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { callback . onRequestRefused ( ) ; } } ) . setView ( dialogView . getView ( ) ) . create ( ) ; /*\\n         * Workaround to fix the crash:\\n\\t\\t * android.view.WindowManager$BadTokenException: Unable to add window\\n\\t\\t * android.view.ViewRootImpl$W@3d67307 -- permission denied for this window type\\n\\t\\t * that appears only on Android 6.0 Marshmallow or greater.\\n\\t\\t * Start a dialog fragment to explain the procedure to the user.\\n\\t\\t * When the user accepts, onClickOnUnderstoodButton() will be called.\\n\\t\\t */ if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . M ) { //if android MarshMallow or greater if ( Settings . canDrawOverlays ( context ) ) { dialog . getWindow ( ) . setType ( WindowManager . LayoutParams . TYPE_SYSTEM_ALERT ) ; dialog . show ( ) ; } else { //to prevent a crash Toast . makeText ( context , \"You must activate SPF!\" , Toast . LENGTH_SHORT ) . show ( ) ; } } else { //other older Android\\'s versions dialog . getWindow ( ) . setType ( WindowManager . LayoutParams . TYPE_SYSTEM_ALERT ) ; dialog . show ( ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public static < T > String toJson ( final List < T > list ) throws JsonGenerationException , JsonMappingException , IOException { final ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; final ObjectMapper mapper = new ObjectMapper ( ) ; mapper . writeValue ( out , list ) ; final byte [ ] bytes = out . toByteArray ( ) ; out . close ( ) ; return new String ( bytes ) ; }'", "label": "'Creates from the given { @link List } to a json string .'"}
{"text": "'public static < T > String toJson ( final T object , final boolean newMapper ) throws JsonProcessingException { final ObjectMapper mapper = ObjectMapperFactory . getObjectMapper ( newMapper ) ; final String json = mapper . writeValueAsString ( object ) ; return json ; }'", "label": "'To json .'"}
{"text": "'public < E > E createStub ( final SPFPerson target , Class < E > serviceInterface , ClassLoader classLoader ) { return InvocationStub . from ( serviceInterface , classLoader , new InvocationStub . Target ( ) { @ Override public void prepareArguments ( Object [ ] arguments ) throws ServiceInvocationException { mExecutionInterface . injectActivities ( target . getIdentifier ( ) , arguments ) ; } @ Override public InvocationResponse executeService ( InvocationRequest request ) throws ServiceInvocationException { return mExecutionInterface . executeService ( target . getIdentifier ( ) , request ) ; } } ) ; }'", "label": "'Creates an invocation stub to send service invocation requests to a target { @link SPFPerson } performing method calls . The stub is created from a provided service interface which must be annotated with { @link ServiceInterface } describing the service . The method returns an object implementing the aforementioned interface that can be used to perform method invocation .'"}
{"text": "'public InvocationStub createStub ( final SPFPerson target , SPFServiceDescriptor descriptor ) { return InvocationStub . from ( descriptor , new InvocationStub . Target ( ) { @ Override public void prepareArguments ( Object [ ] arguments ) throws ServiceInvocationException { mExecutionInterface . injectActivities ( target . getIdentifier ( ) , arguments ) ; } @ Override public InvocationResponse executeService ( InvocationRequest request ) { return mExecutionInterface . executeService ( target . getIdentifier ( ) , request ) ; } } ) ; }'", "label": "'Creates an invocation stub to send service invocation requests to a target { @link SPFPerson } providing the name and the parameter list . The object is created from a { @link ServiceDescriptor } containing the required details .'"}
{"text": "'public boolean sendActivity ( String target , SPFActivity activity ) { InvocationResponse resp = mExecutionInterface . sendActivity ( target , activity ) ; if ( resp . isResult ( ) ) { return GsonHelper . gson . fromJson ( resp . getPayload ( ) , Boolean . class ) ; } else { return false ; } }'", "label": "'Dispatches an activity to the SPF instances matching the given identifier . The framework will perform information injection into the activity : such information will be available to the caller once the method ends .'"}
{"text": "'public void addTag ( String tag ) { TagBubble tb = new TagBubble ( getContext ( ) ) ; tb . setText ( tag ) ; tb . setEditable ( editable ) ; tb . setOnRemoveTagListener ( bubbleClickListener ) ; tags . add ( tag . toString ( ) ) ; addView ( tb ) ; }'", "label": "'Adds and shows a new tag .'"}
{"text": "'public void setTags ( List < String > tags ) { this . tags . clear ( ) ; removeAllViews ( ) ; for ( String tag : tags ) { addTag ( tag ) ; } }'", "label": "'Set the list of tags to be displayed .'"}
{"text": "'public static String toXml ( final String jsonString ) throws JSONException { final JSONObject json = new JSONObject ( jsonString ) ; final String xmlString = XML . toString ( json ) ; return xmlString ; }'", "label": "'Transform the given json as { @link String } object to an xml as { @link String } object .'"}
{"text": "'public static < T > String toXml ( final String jsonString , final Class < T > clazz ) throws JsonParseException , JsonMappingException , IOException { final T object = JsonToObjectExtensions . toObject ( jsonString , clazz ) ; final String xmlString = ObjectToXmlExtensions . toXmlWithXStream ( object ) ; return xmlString ; }'", "label": "'Transform the given json as { @link String } object to an xml as { @link String } object .'"}
{"text": "'public long saveTrigger ( SPFTrigger trigger , String appPackageName ) { trigger = mTriggerTable . saveTrigger ( trigger , appPackageName ) ; if ( trigger != null ) { if ( mHandler != null ) mHandler . postAddTrigger ( trigger ) ; return trigger . getId ( ) ; } else { return - 1 ; } }'", "label": "'Saves the trigger on the database .'"}
{"text": "'public boolean deleteTrigger ( long id , String appPackageName ) { boolean success = mTriggerTable . deleteTrigger ( id , appPackageName ) ; if ( success ) { if ( mHandler != null ) mHandler . postRemoveTrigger ( id ) ; } return success ; }'", "label": "'Deletes the trigger specified by its id .'"}
{"text": "'public void start ( ) { this . mHandlerThread = new HandlerThread ( \"notification-handler-thread\" ) ; this . mHandlerThread . start ( ) ; this . mHandler = new SPFNotificationHandler ( mHandlerThread . getLooper ( ) ) ; mHandler . postSetup ( this ) ; isRunning = true ; }'", "label": "'Initialize and start all the threads and resources used by SPFNotification service . Call this method to initialize the logic that handles triggers processing .'"}
{"text": "'private void setup ( ) { List < SPFTrigger > triggers = mTriggerTable . getAllTriggers ( ) ; mTriggerCache = new SPFActionCache ( mContext ) ; mTriggerEngine . refreshTriggers ( triggers ) ; mTriggerCache . refresh ( triggers ) ; }'", "label": "'to be called after on start : initializes the triggers logic'"}
{"text": "'public List < NotificationMessage > getAvailableNotifications ( ) { Log . d ( \"TAG\" , \"notification available: \" + mMessageTable . getAvailableNotifications ( ) . size ( ) ) ; return mMessageTable . getAvailableNotifications ( ) ; }'", "label": "'Notification messages'"}
{"text": "'public void init ( ) { WfdLog . d ( TAG , \"Called init()\" ) ; initAndStartHandler ( ) ; try { mPort = this . requestAvailablePortFromOs ( ) ; } catch ( IOException e ) { mListener . onError ( ) ; return ; } mManager = ( WifiP2pManager ) mContext . getSystemService ( Context . WIFI_P2P_SERVICE ) ; mChannel = mManager . initialize ( mContext , Looper . getMainLooper ( ) , new WifiP2pManager . ChannelListener ( ) { @ Override public void onChannelDisconnected ( ) { WfdLog . d ( TAG , \"Channel disconnected\" ) ; } } ) ; mReceiver . register ( mContext ) ; NineBus . get ( ) . register ( this ) ; }'", "label": "'Method called by {'"}
{"text": "'public void connect ( ) { if ( isConnected ( ) ) { Log . w ( TAG , \"Connect called but isConnected() == true\" ) ; return ; } this . startRegistration ( ) ; this . discoverService ( ) ; WfdLog . d ( TAG , \"-----> \" + isAutonomous + \" , \" + goIntent ) ; if ( this . isAutonomous ( ) && this . goIntent == 15 ) { this . createGroup ( ) ; } this . connected = true ; }'", "label": "'Method to connect . Called by {'"}
{"text": "'private void startRegistration ( ) { //  Create a string map containing information about your service. Map < String , String > mRecordMap = new HashMap <> ( ) ; mRecordMap . put ( Configuration . PORT , Integer . toString ( mPort ) ) ; mRecordMap . put ( Configuration . IDENTIFIER , myIdentifier ) ; // Service information.  Pass it an instance name, service type // Configuration.SERVICE_REG_TYPE , and the map containing // information other devices will want once they connect to this one. WifiP2pDnsSdServiceInfo mInfo = WifiP2pDnsSdServiceInfo . newInstance ( Configuration . SERVICE_INSTANCE + myIdentifier , Configuration . SERVICE_REG_TYPE , mRecordMap ) ; // Add the local service, sending the service info, network channel, // and listener that will be used to indicate success or failure of // the request. mManager . addLocalService ( mChannel , mInfo , new CustomizableActionListener ( this . mContext , TAG , \"Added Local Service\" , null , \"Failed to add a service\" , \"Failed to add a service\" , true ) ) ; //important: sets true to get detailed message when this method fails }'", "label": "'Registers a local service .'"}
{"text": "'private void discoverService ( ) { /*\\n         * Register listeners for DNS-SD services. These are callbacks invoked\\n         * by the system when a service is actually discovered.\\n         */ mManager . setDnsSdResponseListeners ( mChannel , new CustomDnsServiceResponseListener ( this ) , new CustomDnsSdTxtRecordListener ( ) ) ; // After attaching listeners, create a service request and initiate // discovery. WifiP2pDnsSdServiceRequest mServiceRequest = WifiP2pDnsSdServiceRequest . newInstance ( ) ; //initiates discovery mManager . addServiceRequest ( mChannel , mServiceRequest , new CustomizableActionListener ( this . mContext , TAG , \"Added service discovery request\" , null , \"Failed adding service discovery request\" , \"Failed adding service discovery request\" , true ) ) ; //important: sets true to get detailed message when this method fails //starts services discovery mManager . discoverServices ( mChannel , new CustomizableActionListener ( this . mContext , TAG , \"Service discovery initiated\" , null , \"Failed starting service discovery\" , \"Failed starting service discovery\" , true ) ) ; //important: sets true to get detailed message when this method fails }'", "label": "'Method to discover services and put the results in {'"}
{"text": "'public void notifyServiceToGui ( @ NonNull String notificationType , @ Nullable WiFiP2pService service ) { Intent intent = new Intent ( ) ; if ( service != null ) { intent . putExtra ( SERVICE_NAME , service . getDevice ( ) . deviceName ) ; intent . putExtra ( SERVICE_ADDRESS , service . getDevice ( ) . deviceAddress ) ; intent . putExtra ( SERVICE_IDENTIFIER , service . getIdentifier ( ) ) ; } intent . setAction ( notificationType ) ; mContext . sendBroadcast ( intent ) ; }'", "label": "'Method to send in broadcast a new discovered service to the UI .'"}
{"text": "'public void notifyConnectedDeviceToGui ( @ NonNull String notificationType , @ Nullable String id ) { Intent intent = new Intent ( ) ; if ( id != null ) { intent . putExtra ( CLIENT_IDENTIFIER , id ) ; } intent . setAction ( notificationType ) ; mContext . sendBroadcast ( intent ) ; }'", "label": "'Method to send in broadcast a new connected device to the UI'"}
{"text": "'@ Subscribe public void onEternalConnectUpdate ( EternalConnectEvent e ) { if ( e == null || e . getType ( ) == null ) { return ; } WfdLog . d ( TAG , \"onEternalConnectUpdate received event: \" + e . getType ( ) ) ; //if you want, in the future, you can change the behaviour of either a //simple eternal connect reconnection (autonomous go) or a cycle of the eternal connect (clients) switch ( e . getType ( ) ) { case EternalConnectEvent . NEW_EC_CYCLE : case EternalConnectEvent . SIMPLE_EC_RECONNECTION : disconnect ( ) ; init ( ) ; connect ( ) ; break ; } }'", "label": "'subscribe to catch events posted by {'"}
{"text": "'@ Subscribe public void onSendBroadcastMessage ( HandlerSendBroadcastEvent e ) { try { this . sendMessageBroadcast ( e . getMessage ( ) ) ; } catch ( GroupException e1 ) { WfdLog . e ( TAG , \"GroupException \" + e . getMessage ( ) ) ; } catch ( IOException e1 ) { WfdLog . e ( TAG , \"handleMessage IOException\" , e1 ) ; } }'", "label": "'subscribe to catch events posted by {'"}
{"text": "'public RemoteProfile getProfile ( SPF spf ) { SPFRemoteProfile rp = ( SPFRemoteProfile ) spf . getComponent ( SPF . REMOTE_PROFILE ) ; return rp . getProfileOf ( this ) ; }'", "label": "'Shorthand method to retrieve the RemoteProfile of { @code this } person .'"}
{"text": "'public < E > E getServiceInterface ( Class < E > serviceInterface , SPF spf ) { if ( spf == null || serviceInterface == null ) { throw new NullPointerException ( ) ; } return spf . < SPFServiceExecutor > getComponent ( SPF . SERVICE_EXECUTION ) . createStub ( this , serviceInterface , getClass ( ) . getClassLoader ( ) ) ; }'", "label": "'Shorthand method to create an invocation interface for { @code this } person .'"}
{"text": "'public String addAttribute ( final String name , final String value ) { if ( getAttributes ( ) == null ) { this . attributes = MapFactory . newLinkedHashMap ( ) ; } return getAttributes ( ) . put ( name , value ) ; }'", "label": "'Adds the attribute with the given name and value .'"}
{"text": "'public boolean addChild ( final Tag child , final Integer position ) { if ( getChildren ( ) == null ) { this . childTagPositions = ListFactory . newArrayList ( ) ; } final ChildTagPosition childTagPosition = ChildTagPosition . builder ( ) . child ( child ) . position ( position ) . build ( ) ; return getChildren ( ) . add ( childTagPosition ) ; }'", "label": "'Adds the given { @link Tag } child to the given position .'"}
{"text": "'public boolean removeChild ( final Tag child ) { if ( getChildren ( ) != null ) { ChildTagPosition found = null ; for ( final ChildTagPosition childTagPosition : getChildren ( ) ) { if ( childTagPosition . getChild ( ) . equals ( child ) ) { found = childTagPosition ; break ; } } if ( found != null ) { return getChildren ( ) . remove ( found ) ; } } return false ; }'", "label": "'Removes the given { @link Tag } child'"}
{"text": "'public String toXmlString ( ) { final StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( \"<\" ) ; buffer . append ( getName ( ) ) ; Optional < String > attr = TagExtensions . attributesToString ( getAttributes ( ) ) ; if ( attr . isPresent ( ) ) { buffer . append ( attr . get ( ) ) ; } if ( isEndTag ( ) ) { buffer . append ( \">\" ) ; if ( getChildren ( ) != null && ! getChildren ( ) . isEmpty ( ) ) { String processingContent = getContent ( ) ; Integer lastPosition = 0 ; for ( final ChildTagPosition child : getChildren ( ) ) { final String subContent = getContent ( ) . substring ( lastPosition , child . getPosition ( ) ) ; lastPosition = child . getPosition ( ) ; processingContent = processingContent . substring ( lastPosition , processingContent . length ( ) ) ; buffer . append ( subContent ) ; buffer . append ( child . getChild ( ) . toXmlString ( ) ) ; } buffer . append ( processingContent ) ; } else { buffer . append ( getContent ( ) ) ; } buffer . append ( \"</\" ) ; buffer . append ( getName ( ) ) ; buffer . append ( \">\" ) ; } else { buffer . append ( \"/>\" ) ; } return buffer . toString ( ) ; }'", "label": "'Creates from this { @link Tag } object an xml string .'"}
{"text": "'@ Override public List < String > getFormats ( final String baseName ) { if ( baseName == null ) { throw new NullPointerException ( \"baseName is null\" ) ; } return Collections . unmodifiableList ( Arrays . asList ( XML ) ) ; }'", "label": "'{'"}
{"text": "'public < E > E createStub ( Class < E > serviceInterface , ClassLoader classLoader ) { return InvocationStub . from ( serviceInterface , classLoader , mLocalInvocationTarget ) ; }'", "label": "'Creates an invocation stub to send service invocation requests to the local person performing method calls . The stub is created from a provided service interface which must be annotated with { @link ServiceInterface } describing the service . The method returns an object implementing the aforementioned interface that can be used to perform method invocation .'"}
{"text": "'public boolean sendActivityLocally ( SPFActivity activity ) { String token = getAccessToken ( ) ; SPFError err = new SPFError ( ) ; InvocationResponse resp ; try { getService ( ) . injectInformationIntoActivity ( token , activity , err ) ; if ( ! err . isOk ( ) ) { handleError ( err ) ; return false ; } resp = getService ( ) . sendActivityLocally ( token , activity , err ) ; } catch ( RemoteException e ) { // TODO Error Management return false ; } if ( ! err . isOk ( ) ) { handleError ( err ) ; return false ; } if ( ! resp . isResult ( ) ) { return false ; } return GsonHelper . gson . fromJson ( resp . getPayload ( ) , Boolean . class ) ; }'", "label": "'Dispatches an activity to the local SPF instance . The framework will perform information injection into the activity : such information will be available to the caller once the method ends .'"}
{"text": "'public InvocationResponse invokeMethod ( InvocationRequest request ) { String methodName = request . getMethodName ( ) ; if ( ! mMethodIndex . containsKey ( methodName ) ) { String msg = String . format ( ErrorMsg . METHOD_NOT_FOUND , methodName , mServiceDescriptor . getServiceName ( ) ) ; return InvocationResponse . error ( msg ) ; } Method m = mMethodIndex . get ( methodName ) ; Object [ ] params ; try { params = deserializeParameters ( request . getPayload ( ) , m . getGenericParameterTypes ( ) ) ; } catch ( ServiceInvocationException e ) { return InvocationResponse . error ( \"Error deserializing parameters:\" + e . getMessage ( ) ) ; } try { Object result = m . invoke ( mImplementation , params ) ; String json = GsonHelper . gson . toJson ( result ) ; return InvocationResponse . result ( json ) ; } catch ( IllegalAccessException e ) { return InvocationResponse . error ( e ) ; } catch ( IllegalArgumentException e ) { return InvocationResponse . error ( ErrorMsg . ILLEGAL_ARGUMENT ) ; } catch ( InvocationTargetException e ) { return InvocationResponse . error ( e . getCause ( ) ) ; } }'", "label": "'Invokes a method of the service .'"}
{"text": "'@ Override public void onClick ( DialogInterface dialog , int which , boolean isChecked ) { if ( mSelection != null && which < mSelection . length ) { mSelection [ which ] = isChecked ; List < String > selected = getSelectedStrings ( ) ; mProxyAdapter . clear ( ) ; mProxyAdapter . add ( mHelper . sumUpCircles ( selected ) ) ; setSelection ( 0 ) ; if ( mListener != null ) { String item = mItems [ which ] ; if ( isChecked ) { mListener . onItemAdded ( item ) ; } else { mListener . onItemRemoved ( item ) ; } } } else { throw new IllegalArgumentException ( \"Argument \\'which\\' is out of bounds.\" ) ; } }'", "label": "'{'"}
{"text": "'@ SuppressLint ( \"ClickableViewAccessibility\" ) @ Override public boolean performClick ( ) { AlertDialog . Builder builder = new AlertDialog . Builder ( getContext ( ) ) ; builder . setMultiChoiceItems ( mItems , mSelection , this ) ; builder . show ( ) ; return true ; }'", "label": "'{'"}
{"text": "'public void setItems ( String [ ] items ) { mItems = items ; mSelection = new boolean [ mItems . length ] ; Arrays . fill ( mSelection , false ) ; refreshDisplayValue ( ) ; }'", "label": "'Sets the options for this spinner .'"}
{"text": "'public void setItems ( List < String > items ) { mItems = items . toArray ( new String [ items . size ( ) ] ) ; mSelection = new boolean [ mItems . length ] ; Arrays . fill ( mSelection , false ) ; refreshDisplayValue ( ) ; }'", "label": "'Sets the options for this spinner .'"}
{"text": "'public void setSelection ( String [ ] selection ) { for ( String sel : selection ) { for ( int j = 0 ; j < mItems . length ; ++ j ) { if ( mItems [ j ] . equals ( sel ) ) { mSelection [ j ] = true ; } } } refreshDisplayValue ( ) ; }'", "label": "'Sets the selected options based on an array of string .'"}
{"text": "'public void setSelection ( int [ ] selectedIndicies ) { for ( int index : selectedIndicies ) { if ( index >= 0 && index < mSelection . length ) { mSelection [ index ] = true ; } else { throw new IllegalArgumentException ( \"Index \" + index + \" is out of bounds.\" ) ; } } refreshDisplayValue ( ) ; }'", "label": "'Sets the selected options based on an array of positions .'"}
{"text": "'public List < String > getSelectedStrings ( ) { List < String > selection = new LinkedList < String > ( ) ; for ( int i = 0 ; i < mItems . length ; ++ i ) { if ( mSelection [ i ] ) { selection . add ( mItems [ i ] ) ; } } return selection ; }'", "label": "'Returns a list of strings one for each selected item .'"}
{"text": "'public List < Integer > getSelectedIndicies ( ) { List < Integer > selection = new LinkedList < Integer > ( ) ; for ( int i = 0 ; i < mItems . length ; ++ i ) { if ( mSelection [ i ] ) { selection . add ( i ) ; } } return selection ; }'", "label": "'Returns a list of positions one for each selected item .'"}
{"text": "'public static ProfileFieldsFragment newInstance ( ProfileField < ? > [ ] fieldsToShow ) { if ( fieldsToShow == null ) { throw new NullPointerException ( ) ; } Bundle b = new Bundle ( ) ; b . putStringArray ( EXTRA_FIELDS_TO_SHOW , ProfileField . toIdentifierList ( fieldsToShow ) ) ; ProfileFieldsFragment instance = new ProfileFieldsFragment ( ) ; instance . setArguments ( b ) ; return instance ; }'", "label": "'Creates a new instance of { @link ProfileFieldsFragment } to show the given list of profile fields .'"}
{"text": "'public void onRefresh ( ) { mViewContainer . removeAllViews ( ) ; for ( ProfileField < ? > field : mFieldsToShow ) { View child = mParent . createViewFor ( field , mViewContainer ) ; mViewContainer . addView ( child ) ; } }'", "label": "'Refreshes the values of displayed fields .'"}
{"text": "'public AppServiceProxy getProxy ( String componentName ) { synchronized ( this ) { if ( mShutdown ) { throw new IllegalStateException ( \"Communication agent is shutdown\" ) ; } long start = System . nanoTime ( ) ; if ( mProxies . containsKey ( componentName ) ) { AppServiceProxy proxy = mProxies . get ( componentName ) ; unscheduleHousekeeper ( proxy ) ; if ( proxy . isConnected ( ) ) { long st = ( System . nanoTime ( ) - start ) / 1000 ; Log . d ( TAG , \"HIT for \" + componentName + \" in \" + st + \"us\" ) ; scheduleHousekeeper ( proxy ) ; return proxy ; } else { Log . d ( TAG , \"Removed dead proxy (\" + componentName + \")\" ) ; mProxies . remove ( proxy ) ; // Go on with the creation of new proxy } } AppServiceProxy proxy = new AppServiceProxy ( componentName ) ; mProxies . put ( componentName , proxy ) ; Intent serviceIntent = new Intent ( ) ; serviceIntent . setComponent ( ComponentName . unflattenFromString ( componentName ) ) ; boolean bound = mContext . bindService ( serviceIntent , proxy , Context . BIND_AUTO_CREATE ) ; if ( ! bound ) { Log . e ( TAG , \"Cannot bound to app service with intent \" + componentName ) ; return null ; } long st = ( System . nanoTime ( ) - start ) / 1000 ; Log . d ( TAG , \"MISS for \" + componentName + \" in \" + st + \"us\" ) ; scheduleHousekeeper ( proxy ) ; return proxy ; } }'", "label": "'Returns an { @link AppServiceProxy } that can be used to communicate with the remote service identified by the given component name . If an alive proxy for the given component name is found in cache it i returned . Otherwise a new proxy is created stored in the cache and returned .'"}
{"text": "'public void shutdown ( ) { synchronized ( this ) { if ( mShutdown ) { return ; } for ( AppServiceProxy p : mProxies . values ( ) ) { if ( p . isConnected ( ) ) { mContext . unbindService ( p ) ; mProxies . remove ( p ) ; } } mShutdown = true ; } }'", "label": "'Unbinds all proxies available in caches and prevents the creation of new ones .'"}
{"text": "'@ Override public void characters ( final char [ ] buf , final int offset , final int len ) throws SAXException { final String string = new String ( buf , offset , len ) ; if ( stringBuilder == null ) { stringBuilder = new StringBuilder ( string ) ; } else { stringBuilder . append ( string ) ; } }'", "label": "'{'"}
{"text": "'@ Override public void endDocument ( ) throws SAXException { insertNewLine ( ) ; try { insertNewLine ( ) ; writer . flush ( ) ; } catch ( final IOException e ) { throw new SAXException ( \"I/O error\" , e ) ; } }'", "label": "'{'"}
{"text": "'@ Override public void endElement ( final String namespaceURI , final String simpleName , final String qualifiedName ) throws SAXException { writeToBuffer ( ) ; String elementName = simpleName ; if ( \"\" . equals ( elementName ) ) { elementName = qualifiedName ; } write ( \"</\" + elementName + \">\" ) ; }'", "label": "'{'"}
{"text": "'private void insertNewLine ( ) throws SAXException { try { writer . write ( System . getProperty ( \"line.separator\" ) ) ; } catch ( final IOException e ) { throw new SAXException ( \"I/O error\" , e ) ; } }'", "label": "'Insert a new line to the writer'"}
{"text": "'@ Override public void startElement ( final String namespaceURI , final String simpleName , final String qualifiedName , final Attributes attributes ) throws SAXException { writeToBuffer ( ) ; String elementName = simpleName ; if ( \"\" . equals ( elementName ) ) { elementName = qualifiedName ; } write ( \"<\" + elementName ) ; if ( attributes != null ) { for ( int i = 0 ; i < attributes . getLength ( ) ; i ++ ) { String attributeName = attributes . getLocalName ( i ) ; if ( \"\" . equals ( attributeName ) ) { attributeName = attributes . getQName ( i ) ; } write ( \" \" ) ; write ( attributeName + \"=\\\\\"\" + attributes . getValue ( i ) + \"\\\\\"\" ) ; } } write ( \">\" ) ; }'", "label": "'{'"}
{"text": "'private void writeToBuffer ( ) throws SAXException { if ( stringBuilder == null ) { return ; } final String string = stringBuilder . toString ( ) . trim ( ) ; write ( string ) ; stringBuilder = null ; }'", "label": "'Write to buffer .'"}
{"text": "'public static void xmlToXsd ( final File xmlInputFile , final File xsdOutFile ) throws XmlException , IOException { xmlToXsd ( xmlInputFile , xsdOutFile , new Inst2XsdOptions ( ) ) ; }'", "label": "'Creates or update the given xsd output file from the given XML file .'"}
{"text": "'public static void xmlToXsd ( final File xmlInputFile , final File xsdOutFile , final Inst2XsdOptions inst2XsdOptions ) throws XmlException , IOException { xmlToXsd ( xmlInputFile , xsdOutFile , inst2XsdOptions , new XmlOptions ( ) . setSavePrettyPrint ( ) ) ; }'", "label": "'Creates or update the given xsd output file from the given XML file .'"}
{"text": "'public static String xmlToXsd ( final File xmlFile , final Inst2XsdOptions inst2XsdOptions ) throws XmlException , IOException { return xmlToXsd ( xmlFile , inst2XsdOptions , new XmlOptions ( ) . setSavePrettyPrint ( ) ) ; }'", "label": "'Returns a xsd String from the given XML file that can used for several purposes .'"}
{"text": "'public static String xmlToXsd ( final File xmlFile , final Inst2XsdOptions inst2XsdOptions , final XmlOptions xmlOptions ) throws XmlException , IOException { final XmlObject [ ] xmlInstances = new XmlObject [ 1 ] ; xmlInstances [ 0 ] = XmlObject . Factory . parse ( xmlFile ) ; final SchemaDocument [ ] schemaDocs = Inst2Xsd . inst2xsd ( xmlInstances , inst2XsdOptions ) ; final SchemaDocument schema = schemaDocs [ 0 ] ; return schema . xmlText ( xmlOptions ) ; }'", "label": "'Returns a xsd String from the given XML file that can used for several purposes .'"}
{"text": "'public static void xmlToXsd ( final File [ ] xmlFiles , final Inst2XsdOptions inst2XsdOptions , File outDir , String outPrefix ) throws IOException { if ( xmlFiles == null || xmlFiles . length == 0 ) { throw new IllegalArgumentException ( \"XML file array can not be null and not empty.\" ) ; } if ( outDir == null ) { outDir = new File ( \".\" ) ; } if ( outPrefix == null ) { outPrefix = \"schema\" ; } final XmlObject [ ] xmlInstances = new XmlObject [ xmlFiles . length ] ; int i = 0 ; try { for ( i = 0 ; i < xmlFiles . length ; i ++ ) { xmlInstances [ i ] = XmlObject . Factory . parse ( xmlFiles [ i ] ) ; } } catch ( final XmlException e ) { throw new IllegalArgumentException ( \"Invalid xml file: \\'\" + xmlFiles [ i ] . getName ( ) + \"\\'. \\\\n\" + e . getMessage ( ) , e ) ; } catch ( final IOException e ) { throw new IllegalArgumentException ( \"Could not read file: \\'\" + xmlFiles [ i ] . getName ( ) + \"\\'. \" + e . getMessage ( ) , e ) ; } final SchemaDocument [ ] schemaDocs = Inst2Xsd . inst2xsd ( xmlInstances , inst2XsdOptions ) ; try { for ( i = 0 ; i < schemaDocs . length ; i ++ ) { final SchemaDocument schema = schemaDocs [ i ] ; schema . save ( new File ( outDir , outPrefix + i + \".xsd\" ) , new XmlOptions ( ) . setSavePrettyPrint ( ) ) ; } } catch ( final IOException e ) { throw new IOException ( \"Could not write file: \\'\" + outDir + File . pathSeparator + outPrefix + i + \".xsd\" + \"\\'. \" + e . getMessage ( ) , e ) ; } }'", "label": "'Creates or update the given xsd output file from the given XML file .'"}
{"text": "'public static < T > String toJsonQuietly ( final T object ) { try { return ObjectToJsonExtensions . toJson ( object ) ; } catch ( final JsonProcessingException e ) { log . log ( Level . SEVERE , \"An error occured when converting object to String.\\\\nGiven object:\" + object . toString ( ) + \"\\\\n\" , e ) ; } return null ; }'", "label": "'Creates from the given Object a json string . Note if an exception occurs null will be returned .'"}
{"text": "'protected static < C extends Component < C , I > , I extends IInterface > void load ( final Context context , final Descriptor < C , I > descriptor , final ConnectionCallback < C > callback ) { Utils . notNull ( context , \"context must not be null\" ) ; Utils . notNull ( descriptor , \"context must not be null\" ) ; if ( AccessTokenManager . get ( context ) . hasToken ( ) ) { bindToService ( context , descriptor , callback ) ; } else { AccessTokenManager . get ( context ) . requireAccessToken ( context , new AccessTokenManager . RegistrationCallback ( ) { @ Override public void onRegistrationSuccessful ( ) { Log . d ( \"Component\" , \"Access Toekn: \" + descriptor ) ; bindToService ( context , descriptor , callback ) ; } @ Override public void onRegistrationError ( SPFError errorMsg ) { callback . onError ( errorMsg ) ; } } ) ; } }'", "label": "'Loads a local component asynchronously .'"}
{"text": "'private static < C extends Component < C , I > , I extends IInterface > void bindToService ( final Context context , final Descriptor < C , I > descriptor , final ConnectionCallback < C > callback ) { Intent intent = new Intent ( ) ; intent . setComponent ( SPFInfo . getSPFServiceComponentName ( ) ) ; intent . setAction ( descriptor . getActionName ( ) ) ; ServiceConnection connection = new ServiceConnection ( ) { @ Override public void onServiceConnected ( ComponentName name , IBinder binder ) { I service = descriptor . castInterface ( binder ) ; C instance = descriptor . createInstance ( context , service , this , callback ) ; callback . onServiceReady ( instance ) ; } @ Override public void onServiceDisconnected ( ComponentName name ) { callback . onDisconnect ( ) ; } } ; if ( ! context . bindService ( intent , connection , Context . BIND_AUTO_CREATE ) ) { callback . onError ( new SPFError ( SPFError . SPF_NOT_INSTALLED_ERROR_CODE ) ) ; } }'", "label": "'Performs the binding to the remote service'"}
{"text": "'public void disconnect ( ) { try { mContext . unbindService ( mConnection ) ; } catch ( Exception e ) { Log . w ( getClass ( ) . getSimpleName ( ) , \"Exception unbinding from service: \" , e ) ; } }'", "label": "'Disconnects the component from the remote service .'"}
{"text": "'protected void handleError ( SPFError err ) { if ( err . codeEquals ( SPFError . TOKEN_NOT_VALID_ERROR_CODE ) ) { AccessTokenManager . get ( mContext ) . invalidateToken ( ) ; } mCallback . onError ( err ) ; }'", "label": "'Performs common error handling operations . Subclasses may override it to provide specific behavior .'"}
{"text": "'public void refreshTriggers ( List < SPFTrigger > triggers2 ) { triggers . clear ( ) ; for ( SPFTrigger trg : triggers2 ) { triggers . put ( trg . getId ( ) , trg ) ; } }'", "label": "'Update the current set of triggers with the given list .'"}
{"text": "'public static void installAsDefault ( Context c ) { UncaughtExceptionHandler def = Thread . getDefaultUncaughtExceptionHandler ( ) ; UncaughtExceptionHandler newHandler = new ExceptionLogger ( c , def ) ; Thread . setDefaultUncaughtExceptionHandler ( newHandler ) ; }'", "label": "'Installs an instance of { @link ExceptionLogger } as the default in the Thread class'"}
{"text": "'@ Override public void uncaughtException ( Thread thread , Throwable ex ) { Date now = new Date ( ) ; String name = FOLDER + now . getTime ( ) + \".txt\" ; try { File folder = new File ( mContext . getExternalFilesDir ( null ) , FOLDER ) ; if ( ! folder . exists ( ) ) { folder . mkdir ( ) ; } File file = new File ( mContext . getExternalFilesDir ( null ) , name ) ; if ( ! file . exists ( ) ) { file . createNewFile ( ) ; } PrintWriter writer = new PrintWriter ( new FileWriter ( file , false ) ) ; writer . println ( \"Exception in \" + thread . getName ( ) + \" @ \" + DateFormat . getDateFormat ( mContext ) . format ( now ) ) ; ex . printStackTrace ( writer ) ; writer . flush ( ) ; writer . close ( ) ; } catch ( IOException e ) { Log . e ( getClass ( ) . getSimpleName ( ) , \"Exception logging uncaught exception: \" , e ) ; } // Dispatch to default handler to make app crash mDefaultHandler . uncaughtException ( thread , ex ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'private boolean setValue ( String key , String value , String personaIdentifier ) { SQLiteDatabase db = getWritableDatabase ( ) ; // Create a new map of values, where column names are the keys ContentValues values = new ContentValues ( ) ; values . put ( Contract . COLUMN_KEY , key ) ; values . put ( Contract . COLUMN_VALUE , value ) ; values . put ( Contract . COLUMN_PERSONA , personaIdentifier ) ; // Insert the new row, returning the primary key value of the new row long newRowId ; String nullHack = null ; newRowId = db . insert ( Contract . TABLE_PROFILE , nullHack , values ) ; if ( newRowId <= - 1 ) { Log . e ( TAG , \"Failure on inserting key:\" + key + \" value:\" + value ) ; return false ; } return true ; }'", "label": "'Insert a single profile field in the { @link Contract#TABLE_PROFILE }'"}
{"text": "'public boolean hasTag ( String tag , SPFPersona persona ) { SQLiteDatabase db = getReadableDatabase ( ) ; String selection = Contract . COLUMN_VALUE + \" LIKE ? AND \" + Contract . COLUMN_PERSONA + \" = ? \" ; String [ ] selectionArgs = { \"%\" + tag + \"%\" , persona . getIdentifier ( ) } ; String [ ] columns = { Contract . COLUMN_KEY } ; String groupBy = null ; String having = null ; String orderBy = null ; String limit = null ; Cursor c = db . query ( true , // distinct Contract . TABLE_PROFILE , // table name columns , // projection selection , // selection selectionArgs , // selection arguments groupBy , // don\\'t group the rows having , // don\\'t filter by row groups orderBy , // don\\'t order by anything limit ) ; boolean match = c . moveToNext ( ) ; c . close ( ) ; return match ; }'", "label": "'/ ** Check if the profile fields of a given SPFPersona contains the specified tag . Returns true when the tag is contained in at least one profile field value .'"}
{"text": "'List < SPFPersona > getAvailablePersonas ( ) { SQLiteDatabase db = getReadableDatabase ( ) ; String table = Contract . TABLE_PERSONAS ; String [ ] columns = { Contract . COLUMN_PERSONA } ; String selection = null ; String [ ] selectionArgs = null ; String groupBy = null ; String having = null ; String orderBy = null ; Cursor c = db . query ( table , columns , selection , selectionArgs , groupBy , having , orderBy ) ; List < SPFPersona > availablePersonas = new ArrayList < SPFPersona > ( ) ; while ( c . moveToNext ( ) ) { String p = c . getString ( c . getColumnIndex ( Contract . COLUMN_PERSONA ) ) ; SPFPersona pers = new SPFPersona ( p ) ; availablePersonas . add ( pers ) ; } c . close ( ) ; return availablePersonas ; }'", "label": "'Returns the list of all the existing { @link SPFPersona } .'"}
{"text": "'boolean addPersona ( SPFPersona persona ) { SQLiteDatabase db = getWritableDatabase ( ) ; String table = Contract . TABLE_PERSONAS ; String nullColumnHack = null ; ContentValues values = new ContentValues ( ) ; values . put ( Contract . COLUMN_PERSONA , persona . getIdentifier ( ) ) ; if ( db . insert ( table , nullColumnHack , values ) > 0 ) { // copy the unique identifier ProfileFieldContainer pfc = getProfileFieldBulk ( SPFPersona . getDefault ( ) , ProfileField . IDENTIFIER ) ; String id = pfc . getFieldValue ( ProfileField . IDENTIFIER ) ; if ( setValue ( ProfileField . IDENTIFIER . getIdentifier ( ) , id , persona . getIdentifier ( ) ) ) { addCircleToFieldsInternal ( DefaultCircles . PUBLIC , ProfileField . IDENTIFIER , persona , db ) ; addCircleToFieldsInternal ( DefaultCircles . PUBLIC , ProfileField . DISPLAY_NAME , persona , db ) ; return true ; } else { removePersona ( persona ) ; return false ; } } return false ; }'", "label": "'Creates a new SPFPersona .'"}
{"text": "'boolean removePersona ( SPFPersona persona ) { SQLiteDatabase db = getWritableDatabase ( ) ; if ( persona . getIdentifier ( ) . equals ( \"default\" ) ) { return false ; } String table = Contract . TABLE_PERSONAS ; String selection = Contract . COLUMN_PERSONA + \" = ?\" ; String [ ] selectionArgs = { persona . getIdentifier ( ) } ; if ( db . delete ( table , selection , selectionArgs ) > 0 ) { deleteFieldsOf ( persona , db ) ; deleteVisibilityOf ( persona , db ) ; } return true ; }'", "label": "'Delete a SPFPersona . All the information related to the specified persona will be erased .'"}
{"text": "'boolean removeCircleFromField ( String circle , ProfileField < ? > field , SPFPersona p ) { if ( field . getIdentifier ( ) . equals ( ProfileField . IDENTIFIER . getIdentifier ( ) ) || field . getIdentifier ( ) . equals ( ProfileField . DISPLAY_NAME . getIdentifier ( ) ) ) { return false ; } SQLiteDatabase db = getWritableDatabase ( ) ; return removeCircleFromField ( circle , field , p , db ) ; }'", "label": "'Remove a circle from a specified profile field .'"}
{"text": "'Bundle getCirclesOf ( SPFPersona persona ) { SQLiteDatabase db = getReadableDatabase ( ) ; String table = Contract . TABLE_VISIBILITY ; String [ ] columns = { Contract . COLUMN_KEY , Contract . COLUMN_CIRCLE } ; String selection = Contract . COLUMN_PERSONA + \" = ?\" ; String [ ] selectionArgs = { persona . getIdentifier ( ) } ; String groupBy = null ; String having = null ; String orderBy = null ; Cursor c = db . query ( table , columns , selection , selectionArgs , groupBy , having , orderBy ) ; Bundle b = new Bundle ( ) ; while ( c . moveToNext ( ) ) { String key = c . getString ( c . getColumnIndex ( Contract . COLUMN_KEY ) ) ; String circle = c . getString ( c . getColumnIndex ( Contract . COLUMN_CIRCLE ) ) ; ArrayList < String > list = b . getStringArrayList ( key ) ; if ( list == null ) { list = new ArrayList < String > ( ) ; } list . add ( circle ) ; b . putStringArrayList ( key , list ) ; } c . close ( ) ; return b ; }'", "label": "'Returns a { @link Bundle } with profile fields identifiers as keys and { @link ArrayList<String > } as circles .'"}
{"text": "'private List < String > visibleFields ( PersonAuth pAuth , SPFPersona persona , String [ ] fields ) { SQLiteDatabase db = getReadableDatabase ( ) ; String table = Contract . TABLE_VISIBILITY ; String [ ] columns = { Contract . COLUMN_KEY , Contract . COLUMN_CIRCLE } ; String inClause = getInClause ( fields ) ; String selection = Contract . COLUMN_PERSONA + \" = ? AND \" + Contract . COLUMN_KEY + \" IN \" + inClause ; String [ ] selectionArgs = { persona . getIdentifier ( ) } ; String groupBy = null ; String having = null ; String orderBy = null ; Cursor c = db . query ( table , columns , selection , selectionArgs , groupBy , having , orderBy ) ; List < String > fieldKeys = new ArrayList < String > ( ) ; List < String > privateFields = new ArrayList < String > ( ) ; boolean allCircles = pAuth . getCircles ( ) . contains ( DefaultCircles . ALL_CIRCLE ) ; while ( c . moveToNext ( ) ) { String key = c . getString ( c . getColumnIndex ( Contract . COLUMN_KEY ) ) ; String circle = c . getString ( c . getColumnIndex ( Contract . COLUMN_CIRCLE ) ) ; if ( circle . equals ( DefaultCircles . PRIVATE ) ) { privateFields . add ( circle ) ; } else if ( allCircles || pAuth . getCircles ( ) . contains ( circle ) ) { fieldKeys . add ( key ) ; } } c . close ( ) ; fieldKeys . removeAll ( privateFields ) ; return fieldKeys ; }'", "label": "'Filters the parameter fields and retruns only the field that can be accessed given the permission provided with the { @link PersonAuth } parameter .'"}
{"text": "'private String getInClause ( String [ ] fields ) { StringBuilder builder = new StringBuilder ( \"( \" ) ; if ( fields . length != 0 ) { for ( int i = 0 ; i < fields . length ; i ++ ) { builder . append ( \"\\'\" ) ; builder . append ( fields [ i ] ) ; builder . append ( \"\\'\" ) ; if ( i != fields . length - 1 ) { builder . append ( \" , \" ) ; } } } builder . append ( \" )\" ) ; return builder . toString ( ) ; }'", "label": "'Return a SQL IN set parameter with the specified array of string e . g . ( arg1 arg2 arg3 )'"}
{"text": "'public boolean registerService ( SPFServiceDescriptor descriptor ) { String appId = descriptor . getAppIdentifier ( ) ; String serviceName = descriptor . getServiceName ( ) ; for ( String verb : descriptor . getConsumedVerbs ( ) ) { if ( ! registerServiceInternal ( verb , serviceName , appId ) ) { return false ; } Log . v ( TAG , \"Registered service as Activity consumer: \" + descriptor . getServiceName ( ) ) ; } return true ; }'", "label": "'Registers the capabilities of a service to consume activities . If the descriptor doesn t declare the service as capable of handling activities no action will be performed .'"}
{"text": "'public Collection < ActivityVerb > getVerbSupport ( ) { Map < String , ActivityVerb > entries = new HashMap < String , ActivityVerb > ( ) ; String [ ] columns = { Contract . APP_ID , Contract . SERVICE_NAME , Contract . VERB } ; Cursor c = getReadableDatabase ( ) . query ( true , Contract . TABLE_SERVICES , columns , null , null , null , null , null , null ) ; int appIndex = c . getColumnIndexOrThrow ( Contract . APP_ID ) ; int verbIndex = c . getColumnIndexOrThrow ( Contract . VERB ) ; int svcIndex = c . getColumnIndexOrThrow ( Contract . SERVICE_NAME ) ; while ( c . moveToNext ( ) ) { String verb = c . getString ( verbIndex ) ; String appId = c . getString ( appIndex ) ; String svcName = c . getString ( svcIndex ) ; ActivityVerb d = entries . get ( verb ) ; if ( d == null ) { d = new ActivityVerb ( verb ) ; entries . put ( verb , d ) ; } d . addSupportingService ( new ServiceIdentifier ( appId , svcName ) ) ; } c . close ( ) ; for ( ActivityVerb d : entries . values ( ) ) { d . setDefaultApp ( getServiceForInternal ( d . getVerb ( ) ) ) ; } return entries . values ( ) ; }'", "label": "'Returns a list containing the default service for each verb as an instance of { @link ActivityVerb }'"}
{"text": "'AppAuth getAppAuthorizationByAppId ( String appId ) { String where = Contract . COLUMN_APP_IDENTIFIER + \" = ?\" ; String args [ ] = { appId } ; Cursor c = mRegistryTable . getReadableDatabase ( ) . query ( Contract . TABLE_NAME , null , where , args , null , null , null ) ; AppAuth auth = null ; if ( c . moveToFirst ( ) ) { auth = appAuthFromCursor ( c ) ; } c . close ( ) ; return auth ; }'", "label": "'Retrieves an appauth given the identifier of an application'"}
{"text": "'public String registerApplication ( AppDescriptor descriptor , SPFPersona persona ) { String token = mTokenGenerator . generateAccessToken ( ) ; ContentValues cv = new ContentValues ( ) ; cv . put ( Contract . COLUMN_APP_NAME , descriptor . getAppName ( ) ) ; cv . put ( Contract . COLUMN_ACCESS_TOKEN , token ) ; cv . put ( Contract . COLUMN_APP_IDENTIFIER , descriptor . getAppIdentifier ( ) ) ; cv . put ( Contract . COLUMN_PERMISSION_CODE , descriptor . getPermissionCode ( ) ) ; cv . put ( Contract . COLUMN_PERSONA , persona . getIdentifier ( ) ) ; SQLiteDatabase db = mRegistryTable . getWritableDatabase ( ) ; if ( db . insert ( Contract . TABLE_NAME , null , cv ) == - 1 ) { return null ; // TODO handle insertion error } return token ; }'", "label": "'Low level method to register applications . It will not validate the descriptor given as parameter .'"}
{"text": "'public boolean unregisterApplication ( String appIdentifier ) { String where = Contract . COLUMN_APP_IDENTIFIER + \" = ?\" ; String [ ] whereArgs = { appIdentifier } ; if ( mRegistryTable . getWritableDatabase ( ) . delete ( Contract . TABLE_NAME , where , whereArgs ) == 0 ) { return false ; } if ( SPF . get ( ) . getServiceRegistry ( ) . unregisterAllServicesOfApp ( appIdentifier ) ) { Intent i = new Intent ( DEREGISTRATION_INTENT ) ; i . putExtra ( DEREGISTERED_APP , appIdentifier ) ; mContext . sendBroadcast ( i ) ; return true ; } return false ; }'", "label": "'To be called from application uninstall monitor'"}
{"text": "'public SPFPersona getPersonaOf ( String appIdentifier ) { SQLiteDatabase db = mRegistryTable . getReadableDatabase ( ) ; String table = Contract . TABLE_NAME ; String [ ] columns = { Contract . COLUMN_PERSONA } ; String selection = Contract . COLUMN_APP_IDENTIFIER + \" = ? \" ; String [ ] selectionArgs = { appIdentifier } ; String groupBy = null ; String having = null ; String orderBy = null ; Cursor c = db . query ( table , columns , selection , selectionArgs , groupBy , having , orderBy ) ; if ( c . moveToNext ( ) ) { String persona = c . getString ( c . getColumnIndex ( Contract . COLUMN_PERSONA ) ) ; return new SPFPersona ( persona ) ; } c . close ( ) ; return SPFPersona . DEFAULT ; }'", "label": "'Returns the SPFPersona associated to the specified application . If the application does not exist returns the default SPFPersona .'"}
{"text": "'void onClientConnected ( String identifier , GOInternalClient gOInternalClient ) throws InterruptedException { WfdLog . d ( TAG , \"New client connected id : \" + identifier ) ; NineBus . get ( ) . post ( new GOConnectionEvent ( GOConnectionEvent . CONNECTED , identifier ) ) ; connectionSemaphore . acquire ( ) ; Set < String > clients = new HashSet <> ( goInternalClients . keySet ( ) ) ; clients . add ( super . myIdentifier ) ; GOInternalClient c = goInternalClients . put ( identifier , gOInternalClient ) ; signalNewInstanceToGroup ( identifier ) ; signalGroupToNewClient ( gOInternalClient , clients ) ; connectionSemaphore . release ( ) ; if ( c != null ) { c . recycle ( ) ; } }'", "label": "'called from GoInternalClient'"}
{"text": "'void onClientDisconnected ( String identifier ) throws InterruptedException { connectionSemaphore . acquire ( ) ; NineBus . get ( ) . post ( new GOConnectionEvent ( GOConnectionEvent . DISCONNECTED , identifier ) ) ; WfdLog . d ( TAG , \"Client lost id : \" + identifier ) ; GOInternalClient c = null ; if ( identifier != null ) { c = goInternalClients . remove ( identifier ) ; if ( c != null ) { signalInstanceLossToGroup ( identifier ) ; } } connectionSemaphore . release ( ) ; if ( c != null ) { c . recycle ( ) ; } }'", "label": "'called from GoInternalClient'"}
{"text": "'void onMessageReceived ( final WfdMessage msg ) { threadPool . execute ( new Runnable ( ) { @ Override public void run ( ) { if ( msg . getReceiverId ( ) . equals ( myIdentifier ) ) { handle ( msg ) ; } else { route ( msg ) ; } } } ) ; }'", "label": "'called from the GOInternalClient'"}
{"text": "'public void addClientIfNotPresent ( DeviceGuiElement device ) { boolean add = true ; for ( DeviceGuiElement element : clients ) { if ( element != null && element . getName ( ) . equals ( device . getName ( ) ) && element . getAddress ( ) . equals ( device . getAddress ( ) ) ) { add = false ; //already in the list } } if ( add ) { clients . add ( device ) ; } }'", "label": "'Method to add a client inside the list in a secure way . The client is added only if isn t already inside the list .'"}
{"text": "'synchronized static void initialize ( Context context , int goIntent , boolean isAutonomous , ProximityMiddleware . Factory factory ) { if ( singleton == null ) { singleton = new SPF ( context , goIntent , isAutonomous , factory ) ; } }'", "label": "'Initializes SPF with a { @link Context } reference . Called by { @link SPFContext#initialize ( int Context ProximityMiddleware . Factory ) } .'"}
{"text": "'public void connect ( ) { if ( ! mMiddleware . isConnected ( ) ) { mMiddleware . connect ( ) ; } if ( ! mNotificationManager . isRunning ( ) ) { mNotificationManager . start ( ) ; } if ( mAdvertiseManager . isAdvertisingEnabled ( ) ) { mMiddleware . registerAdvertisement ( mAdvertiseManager . generateAdvProfile ( ) . toJSON ( ) , 10000 ) ; } }'", "label": "'Life - cycle methods'"}
{"text": "'public void sendSearchSignal ( String queryId , String query ) { mMiddleware . sendSearchSignal ( getUniqueIdentifier ( ) , queryId , query ) ; }'", "label": "'TODO this class should handle only components life - cycle move search primitives elsewhere'"}
{"text": "'public < E > E getFieldValue ( ProfileField < E > field ) { if ( field == null ) { throw new NullPointerException ( ) ; } String val = mFields . getString ( field . getIdentifier ( ) ) ; return val == null ? null : ProfileFieldConverter . forField ( field ) . fromStorageString ( val ) ; }'", "label": "'Gets the value of a field from the container'"}
{"text": "'public < E > void setFieldValue ( ProfileField < E > field , E value ) { if ( field == null || value == null ) { throw new NullPointerException ( ) ; } if ( getStatus ( field ) == FieldStatus . UNACCESSIBLE ) { throw new IllegalStateException ( \"Cannot write an unaccessible field\" ) ; } String newVal = ProfileFieldConverter . forField ( field ) . toStorageString ( value ) ; String currentVal = mFields . getString ( field . getIdentifier ( ) ) ; if ( newVal . equals ( currentVal ) ) { return ; } if ( getStatus ( field ) == FieldStatus . ORIGINAL ) { setStatus ( field . getIdentifier ( ) , FieldStatus . MODIFIED ) ; } mFields . putString ( field . getIdentifier ( ) , newVal ) ; }'", "label": "'Sets the value of a field in the container . After the first set of a field calling { @link ProfileFieldContainer#isModified ( ProfileField )) } with it as parameter will return true .'"}
{"text": "'public boolean isModified ( ) { for ( String key : mStatus . keySet ( ) ) { FieldStatus status = getStatus ( key ) ; if ( status == FieldStatus . DELETED || status == FieldStatus . MODIFIED ) { return true ; } } return false ; }'", "label": "'Returns whether at least one field in the container has been modified'"}
{"text": "'public void clearModified ( ) { for ( String field : mStatus . keySet ( ) ) { switch ( getStatus ( field ) ) { case DELETED : mStatus . remove ( field ) ; break ; case MODIFIED : setStatus ( field , FieldStatus . ORIGINAL ) ; break ; default : continue ; } } }'", "label": "'Clears the modified state of fields . After this call and before any call to {'"}
{"text": "'@ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeBundle ( mFields ) ; dest . writeBundle ( mStatus ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "\"@ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { super . onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; final int width = MeasureSpec . getSize ( widthMeasureSpec ) ; int height = MeasureSpec . getSize ( heightMeasureSpec ) ; // increment the x position as we progress through a line int xpos = getPaddingLeft ( ) ; // increment the y position as we progress through the lines int ypos = getPaddingTop ( ) ; // the height of the current line int line_height = 0 ; // go through children // to work out the height required for this view measureChildren ( widthMeasureSpec , heightMeasureSpec ) ; View child ; MarginLayoutParams childMarginLayoutParams ; int childWidth , childHeight , childMarginLeft , childMarginRight , childMarginTop , childMarginBottom ; for ( int i = 0 ; i < getChildCount ( ) ; i ++ ) { child = getChildAt ( i ) ; if ( child . getVisibility ( ) != GONE ) { childWidth = child . getMeasuredWidth ( ) ; childHeight = child . getMeasuredHeight ( ) ; if ( child . getLayoutParams ( ) != null && child . getLayoutParams ( ) instanceof MarginLayoutParams ) { childMarginLayoutParams = ( MarginLayoutParams ) child . getLayoutParams ( ) ; childMarginLeft = childMarginLayoutParams . leftMargin ; childMarginRight = childMarginLayoutParams . rightMargin ; childMarginTop = childMarginLayoutParams . topMargin ; childMarginBottom = childMarginLayoutParams . bottomMargin ; } else { childMarginLeft = 0 ; childMarginRight = 0 ; childMarginTop = 0 ; childMarginBottom = 0 ; } if ( xpos + childMarginLeft + childWidth + childMarginRight + getPaddingRight ( ) > width ) { // this child will need to go on a new line xpos = getPaddingLeft ( ) ; ypos += line_height ; line_height = childMarginTop + childHeight + childMarginBottom ; } else // enough space for this child on the current line line_height = Math . max ( line_height , childMarginTop + childHeight + childMarginBottom ) ; xpos += childMarginLeft + childWidth + childMarginRight ; } } ypos += line_height + getPaddingBottom ( ) ; if ( MeasureSpec . getMode ( heightMeasureSpec ) == MeasureSpec . UNSPECIFIED ) // set height as measured since there's no height restrictions height = ypos ; else if ( MeasureSpec . getMode ( heightMeasureSpec ) == MeasureSpec . AT_MOST && ypos < height ) // set height as measured since it's less than the maximum allowed height = ypos ; setMeasuredDimension ( width , height ) ; }\"", "label": "'from http : // adilatwork . blogspot . it / 2012 / 12 / android - horizontal - flow - layout . html'"}
{"text": "'public void startSearch ( final int tag , SPFSearchDescriptor searchDescriptor , final SearchCallback callback ) { // replace equivalent query ( equivalent == same tag ) if ( mTagToId . get ( tag ) != null ) { Log . d ( \"start search\" , \"mTagToId.get(tag) != null\" ) ; String queryId = mTagToId . get ( tag ) ; Log . d ( \"start search\" , \"mTagToId.get(tag)= \" + mTagToId . get ( tag ) ) ; mTagToId . delete ( tag ) ; SearchCallback state = mCallbacks . remove ( queryId ) ; if ( queryId != null && state != null ) { Log . d ( \"start search\" , \"queryId: \" + queryId + \", state: \" + state ) ; mSearchInterface . stopSearch ( queryId ) ; Log . d ( \"start search\" , \"stopSearch\" ) ; } } Log . d ( \"start search\" , \"startSearch\" ) ; mSearchInterface . startSearch ( searchDescriptor , new SPFSearchCallbackImpl ( callback , tag ) ) ; }'", "label": "'Starts a search for remote people . The application must provide a tag used to replace equivalent queries a { @link SearchDescriptor } containing the configuration of the search and a { @link SearchCallback } to be notified of found results .'"}
{"text": "'public void stopSearch ( int tag ) { String queryId = mTagToId . get ( tag ) ; mTagToId . delete ( tag ) ; if ( queryId != null && mCallbacks . remove ( queryId ) != null ) { mSearchInterface . stopSearch ( queryId ) ; } }'", "label": "'Stops a previously registered search request performed by the application . The application must provide the tag it registered the search with . The callback associated to the search does not receive any further notification .'"}
{"text": "'public void stopAllSearches ( ) { mTagToId . clear ( ) ; String [ ] queryIds = mCallbacks . keySet ( ) . toArray ( new String [ ] { } ) ; mCallbacks . clear ( ) ; for ( String queryId : queryIds ) { mSearchInterface . stopSearch ( queryId ) ; } }'", "label": "'Stops all searches registered by the application .'"}
{"text": "'public SPFPerson lookup ( String identifier ) { boolean isReachable = mSearchInterface . lookup ( identifier ) ; if ( isReachable ) { return new SPFPerson ( identifier ) ; } else { return null ; } }'", "label": "'Allows to retrieve a reference to a remote person given its identifier . This reference is valid until the given person is reachable from the proximity middleware .'"}
{"text": "'static void validateInterface ( Class < ? > serviceInterface , int validationType ) { // Verify serviceInterface is an interface. assertThat ( serviceInterface . isInterface ( ) , ErrorMsg . INTERFACE_REQUIRED ) ; // Verify serviceInterface has the right annotation. ServiceInterface service = serviceInterface . getAnnotation ( ServiceInterface . class ) ; assertThat ( service != null , ErrorMsg . MISSING_ANNOTATION ) ; // Verify service name is not empty assertThat ( ! isStringEmpty ( service . name ( ) ) , ErrorMsg . MISSING_SERVICE_NAME ) ; // Verify service app name is not empty for remote services assertThat ( ! ( validationType == TYPE_REMOTE && isStringEmpty ( service . app ( ) ) ) , ErrorMsg . MISSING_APP_NAME ) ; // Analyze methods for ( Method m : serviceInterface . getMethods ( ) ) { if ( m . isAnnotationPresent ( ActivityConsumer . class ) ) { validateActivityConsumer ( service . name ( ) , m ) ; } else { validateStandardMethod ( service . name ( ) , m ) ; } } }'", "label": "'Validates the interface of a service . In case of failed validation an unchecked { @link IllegalServiceException } is thrown .'"}
{"text": "'public ProfileFieldContainer getProfileFieldBulk ( SPFPersona persona , ProfileField < ? > ... fields ) { return mProfileTable . getProfileFieldBulk ( persona , fields ) ; }'", "label": "'Returns a { @link ProfileFieldContainer } filled with the values specified in the request .'"}
{"text": "'public ProfileFieldContainer getProfileFieldBulk ( PersonAuth auth , SPFPersona persona , String [ ] fields ) { return mProfileTable . getProfileFieldBulk ( persona , fields , auth ) ; }'", "label": "'Method for proximity interface to provide access to local profile to remote spf instances'"}
{"text": "'public ProfileFieldContainer getProfileFieldBulk ( String [ ] fields , SPFPersona persona ) { return mProfileTable . getProfileFieldBulk ( persona , fields ) ; }'", "label": "'Returns a { @link ProfileFieldContainer } filled with the values specified in the request .'"}
{"text": "'public BaseInfo getBaseInfo ( SPFPersona persona ) { ProfileFieldContainer pfc = getProfileFieldBulk ( persona , ProfileField . IDENTIFIER , ProfileField . DISPLAY_NAME ) ; return new BaseInfo ( pfc . getFieldValue ( ProfileField . IDENTIFIER ) , pfc . getFieldValue ( ProfileField . DISPLAY_NAME ) ) ; }'", "label": "'Returns the display_name of the user . If there is no display_name the method returns its identifier .'"}
{"text": "'public boolean addGroupToField ( ProfileField < ? > field , String group , SPFPersona persona ) { return mProfileTable . addCircleToFields ( group , field , persona ) ; }'", "label": "'Adds a circle to a specified { @link ProfileField } .'"}
{"text": "'public boolean removeGroupFromField ( ProfileField < ? > field , String group , SPFPersona persona ) { return mProfileTable . removeCircleFromField ( group , field , persona ) ; }'", "label": "'Remove a circle from a specified profile field .'"}
{"text": "'@ Deprecated public boolean addCircleToField ( ProfileField < ? > field , String circle , SPFPersona persona ) { return mProfileTable . addCircleToFields ( circle , field , persona ) ; }'", "label": "'Adds a circle to a specified { @link ProfileField } .'"}
{"text": "'@ Deprecated public boolean removeCircleFromField ( ProfileField < ? > field , String circle , SPFPersona persona ) { return mProfileTable . removeCircleFromField ( circle , field , persona ) ; }'", "label": "'Remove a circle from a specified profile field .'"}
{"text": "'@ Override public ViewHolder onCreateViewHolder ( ViewGroup viewGroup , int viewType ) { // Create a new view. View v = LayoutInflater . from ( viewGroup . getContext ( ) ) . inflate ( R . layout . device_card_view , viewGroup , false ) ; return new ViewHolder ( v ) ; }'", "label": "'Create new views ( invoked by the layout manager )'"}
{"text": "'@ Override public void onBindViewHolder ( ViewHolder viewHolder , final int position ) { final DeviceGuiElement device = ClientsGuiList . get ( ) . getClients ( ) . get ( position ) ; viewHolder . identifierTextView . setText ( device . getIdentifier ( ) ) ; viewHolder . logo . setImageDrawable ( new IconicsDrawable ( context ) . icon ( FontAwesome . Icon . faw_android ) . color ( context . getResources ( ) . getColor ( R . color . red ) ) . sizeDp ( 30 ) ) ; viewHolder . setOnClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { itemClickListener . clientItemClicked ( device ) ; } } ) ; }'", "label": "'Replace the contents of a view ( invoked by the layout manager )'"}
{"text": "'public static NodeList getNodeList ( final String xml , final String xpathExpression ) throws XPathExpressionException , ParserConfigurationException , SAXException , IOException { final DocumentBuilderFactory domFactory = DocumentBuilderFactory . newInstance ( ) ; domFactory . setNamespaceAware ( true ) ; final DocumentBuilder builder = domFactory . newDocumentBuilder ( ) ; final Document doc = builder . parse ( xml ) ; final XPath xpath = XPathFactory . newInstance ( ) . newXPath ( ) ; final XPathExpression expr = xpath . compile ( xpathExpression ) ; final Object result = expr . evaluate ( doc , XPathConstants . NODESET ) ; final NodeList nodes = ( NodeList ) result ; return nodes ; }'", "label": "'Gets the node list from the given xml file and the given xpath expression .'"}
{"text": "'public static < E > E onMainThread ( Class < E > callbackInterface , final E callback ) { Utils . notNull ( callbackInterface , \"callbackInterface must not be null\" ) ; Utils . notNull ( callback , \"callback must not be null\" ) ; final Handler handler = new Handler ( Looper . getMainLooper ( ) ) ; final String tag = callback . getClass ( ) . getSimpleName ( ) ; Object proxy = Proxy . newProxyInstance ( callbackInterface . getClassLoader ( ) , new Class < ? > [ ] { callbackInterface } , new InvocationHandler ( ) { @ Override public Object invoke ( Object proxy , final Method method , final Object [ ] args ) throws Throwable { handler . post ( new Runnable ( ) { @ Override public void run ( ) { try { method . invoke ( callback , args ) ; } catch ( IllegalAccessException e ) { Log . e ( tag , \"Error executing method \" + method . getName ( ) + \" on main thread.\" , e ) ; } catch ( IllegalArgumentException e ) { Log . e ( tag , \"Error executing method \" + method . getName ( ) + \" on main thread.\" , e ) ; } catch ( InvocationTargetException e ) { Log . e ( tag , \"Error executing method \" + method . getName ( ) + \" on main thread.\" , e ) ; } } } ) ; return null ; } } ) ; return callbackInterface . cast ( proxy ) ; }'", "label": "'Wraps a callback into a proxy that executes its methods on the main thread . Return types are not supported a method with return type other than void always returns null when called on the proxy .'"}
{"text": "'public PersonAuth getPersonAuthFrom ( String receivedTkn ) { if ( receivedTkn . equals ( \"\" ) ) { return PersonAuth . getPublicAuth ( ) ; } String selection = RelationshipEntry . COLUMN_TKN + \" = ? AND \" + RelationshipEntry . COLUMN_REQUEST_STATUS + \" = ?\" ; String [ ] selectionArgs = { receivedTkn , Integer . toString ( REQUEST_ACCEPTED ) } ; String [ ] columns = { RelationshipEntry . COLUMN_USER_UUID } ; SQLiteDatabase db = getReadableDatabase ( ) ; Cursor cursor = db . query ( RelationshipEntry . TABLE_PERSON_AUTH , columns , selection , selectionArgs , /* groupBy */ null , /* having */ null , /* orderBy */ null ) ; PersonAuth auth ; if ( cursor . moveToNext ( ) ) { String uniqueIdentifier = cursor . getString ( cursor . getColumnIndex ( RelationshipEntry . COLUMN_USER_UUID ) ) ; auth = generatePermissionFor ( uniqueIdentifier , db ) ; } else { auth = PersonAuth . getPublicAuth ( ) ; } cursor . close ( ) ; return auth ; }'", "label": "'Call this method every time you receive a remote request .'"}
{"text": "'public String createEntryForSentRequest ( String targetUid , String password ) throws GeneralSecurityException { // TODO Add it back later // if (entryExistsFor(targetUid) != REQUEST_NOT_EXIST) { // return ; // } String user_uuid = targetUid ; String token = new IdentifierGenerator ( ) . generateAccessToken ( ) ; int request_status = REQUEST_ACCEPTED ; insertNewEntry ( user_uuid , token , request_status ) ; return TokenCipher . encryptToken ( token , password ) ; }'", "label": "'Creates a pending request associated to the target id .'"}
{"text": "'public boolean createEntryForReceivedRequest ( ContactRequest fr ) { String user_uuid = fr . getUserIdentifier ( ) ; String receive_token = fr . getAccessToken ( ) ; int request_status = REQUEST_PENDING ; if ( insertNewEntry ( user_uuid , receive_token , request_status ) ) { return true ; } return false ; }'", "label": "'Creates a pending request with the information contained in the message .'"}
{"text": "'public int entryExistsFor ( String userUID ) { String selection = RelationshipEntry . COLUMN_USER_UUID + \" = ?\" ; String [ ] selectionArgs = { userUID } ; String [ ] columns = { RelationshipEntry . COLUMN_REQUEST_STATUS } ; SQLiteDatabase db = getReadableDatabase ( ) ; Cursor cursor = db . query ( RelationshipEntry . TABLE_PERSON_AUTH , columns , selection , selectionArgs , /* groupBy */ null , /* having */ null , /* orderBy */ null ) ; if ( cursor . moveToNext ( ) ) { return cursor . getInt ( cursor . getColumnIndex ( RelationshipEntry . COLUMN_REQUEST_STATUS ) ) ; } cursor . close ( ) ; return REQUEST_NOT_EXIST ; }'", "label": "'check if an entry for the specified user id exists . Returns the entry state .'"}
{"text": "'public boolean confirmRequest ( String targetUID , String password ) throws GeneralSecurityException , WrongPassphraseException { SQLiteDatabase db = getWritableDatabase ( ) ; String table = RelationshipEntry . TABLE_PERSON_AUTH ; String [ ] columns = { RelationshipEntry . COLUMN_TKN , RelationshipEntry . COLUMN_REQUEST_STATUS , RelationshipEntry . COLUMN_PASSWORD } ; String selection = RelationshipEntry . COLUMN_USER_UUID + \" = ? \" ; String [ ] selectionArgs = { targetUID } ; String groupBy = null ; String having = null ; String orderBy = null ; String limit = null ; Cursor c = db . query ( table , columns , selection , selectionArgs , groupBy , having , orderBy , limit ) ; if ( c . moveToNext ( ) ) { String token = c . getString ( c . getColumnIndex ( RelationshipEntry . COLUMN_TKN ) ) ; String decryptedTkn = TokenCipher . decryptToken ( token , password ) ; if ( decryptedTkn != null ) { return commitConfirmation ( targetUID , password , decryptedTkn ) ; } else { return false ; } } return false ; }'", "label": "'Confirm a friendship request . the status of the entry associated with the specified person will be REQUEST_ACCEPTED'"}
{"text": "'public List < SPFTrigger > listTrigger ( ) { try { SPFError err = new SPFError ( SPFError . NONE_ERROR_CODE ) ; List < SPFTrigger > trgs = getService ( ) . listTrigger ( getAccessToken ( ) , err ) ; if ( ! err . codeEquals ( SPFError . NONE_ERROR_CODE ) ) { handleError ( err ) ; } return trgs ; } catch ( RemoteException e ) { catchRemoteException ( e ) ; return new ArrayList < SPFTrigger > ( 0 ) ; } }'", "label": "'/ *'"}
{"text": "'@ Override protected void write ( final String s ) throws SAXException { try { if ( s . startsWith ( \"$\" ) ) { final String newValue = data . get ( s . substring ( 1 , s . length ( ) ) ) ; getWriter ( ) . append ( newValue ) ; } else { getWriter ( ) . append ( s ) ; } } catch ( final IOException e ) { throw new SAXException ( \"I/O error\" , e ) ; } }'", "label": "'{'"}
{"text": "\"private Binding < ? > findBinding ( Injectee injectee ) { Key < ? > key = BindingUtils . toKey ( injectee ) ; if ( key == null ) { return null ; } // We can't do anything about HK2 @Contracts if ( BindingUtils . isHk2Contract ( injectee ) ) { return null ; } // Classes with a @Contract annotation are SPIs. They either exist or // not. They must be explicit bindings in the world of Guice. if ( BindingUtils . isJerseyContract ( injectee ) ) { return injector . getExistingBinding ( key ) ; } // We've to use Injector#getBinding() to cover Just-In-Time bindings // which may fail with an Exception because Guice doesn't know how to // construct the requested object. return injector . getBinding ( key ) ; }\"", "label": "'Returns a {'"}
{"text": "'public static void install ( Injector injector ) { // This binding is provided by JerseyGuiceModule ServiceLocator locator = injector . getInstance ( ServiceLocator . class ) ; GuiceServiceLocatorGenerator generator = getOrCreateGuiceServiceLocatorGenerator ( ) ; generator . add ( locator ) ; }'", "label": "'Installs the given { @link Injector } .'"}
{"text": "'private static synchronized boolean isProviderPresent ( ) { if ( ! SPI_CHECKED ) { SPI_CHECKED = true ; ServiceLocatorGenerator generator = lookupSPI ( ) ; if ( generator instanceof GuiceServiceLocatorGeneratorStub ) { SPI_PRESENT = true ; } if ( ! SPI_PRESENT ) { LOG . warn ( \"It appears jersey2-guice-spi is either not present or in conflict with some other Jar: {}\" , generator ) ; } } return SPI_PRESENT ; }'", "label": "'Returns {'"}
{"text": "'public static ServiceLocator newServiceLocator ( String name , ServiceLocator parent ) { if ( parent != null && ! ( parent instanceof ServiceLocatorImpl ) ) { throw new IllegalArgumentException ( \"name=\" + name + \", parent=\" + parent ) ; } if ( name == null ) { name = PREFIX ; } if ( name . endsWith ( \"-\" ) ) { name += NTH . incrementAndGet ( ) ; } GuiceServiceLocator locator = new GuiceServiceLocator ( name , parent ) ; DynamicConfigurationImpl config = new DynamicConfigurationImpl ( locator ) ; config . bind ( Utilities . getLocatorDescriptor ( locator ) ) ; ActiveDescriptor < InjectionResolver < javax . inject . Inject > > threeThirtyResolver = newThreeThirtyInjectionResolverDescriptor ( locator ) ; config . addActiveDescriptor ( threeThirtyResolver ) ; config . addActiveDescriptor ( newGuiceInjectionResolverDescriptor ( locator , threeThirtyResolver ) ) ; config . bind ( BuilderHelper . link ( DynamicConfigurationServiceImpl . class , false ) . to ( DynamicConfigurationService . class ) . in ( Singleton . class . getName ( ) ) . localOnly ( ) . build ( ) ) ; config . bind ( BuilderHelper . createConstantDescriptor ( new DefaultClassAnalyzer ( locator ) ) ) ; config . bind ( BuilderHelper . createDescriptorFromClass ( ServiceLocatorRuntimeImpl . class ) ) ; config . bind ( BuilderHelper . createConstantDescriptor ( new InstantiationServiceImpl ( ) ) ) ; config . commit ( ) ; return locator ; }'", "label": "'Creates and returns a { @link ServiceLocator } .'"}
{"text": "'public static ServiceLocator link ( ServiceLocator locator , Injector injector ) { Map < Key < ? > , Binding < ? > > bindings = gatherBindings ( injector ) ; Set < Binder > binders = toBinders ( bindings ) ; return link ( locator , injector , binders ) ; }'", "label": "'This method links the {'"}
{"text": "'private static Map < Key < ? > , Binding < ? > > gatherBindings ( Injector injector ) { Map < Key < ? > , Binding < ? > > dst = new HashMap < Key < ? > , Binding < ? > > ( ) ; Injector current = injector ; while ( current != null ) { dst . putAll ( current . getBindings ( ) ) ; current = current . getParent ( ) ; } return dst ; }'", "label": "'Gathers Guice {'"}
{"text": "'@ SuppressWarnings ( { \"unchecked\" , \"rawtypes\" } ) private static Set < Binder > toBinders ( Map < Key < ? > , Binding < ? > > bindings ) { Set < Binder > binders = new HashSet <> ( ) ; for ( Map . Entry < Key < ? > , Binding < ? > > entry : bindings . entrySet ( ) ) { Key < ? > key = entry . getKey ( ) ; Binding < ? > binding = entry . getValue ( ) ; Object source = binding . getSource ( ) ; if ( ! ( source instanceof ElementSource ) ) { // Things like the Injector itself don\\'t have an ElementSource. if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( \"Adding binding: key={}, source={}\" , key , source ) ; } binders . add ( new GuiceBinder ( key , binding ) ) ; continue ; } ElementSource element = ( ElementSource ) source ; List < String > names = element . getModuleClassNames ( ) ; String name = names . get ( 0 ) ; // Skip everything that is declared in a JerseyModule try { Class < ? > module ; // Attempt to load the classes via the context class loader first, in order to support // environments that enforce tighter constraints on class loading (such as in an OSGi container) ClassLoader classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( classLoader != null ) { module = classLoader . loadClass ( name ) ; } else { module = Class . forName ( name ) ; } if ( JerseyModule . class . isAssignableFrom ( module ) ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( \"Ignoring binding {} in {}\" , key , module ) ; } continue ; } } catch ( ClassNotFoundException err ) { // Some modules may not be able to be instantiated directly here as a class if we\\'re running // in a container that enforcer tighter class loader constraints (such as the // org.ops4j.peaberry.osgi.OSGiModule Guice module when running in an OSGi container), // so we\\'re only logging a warning here instead of throwing a hard exception if ( LOG . isWarnEnabled ( ) ) { LOG . warn ( \"Unavailable to load class in order to validate module: name={}\" , name ) ; } } binders . add ( new GuiceBinder ( key , binding ) ) ; } return binders ; }'", "label": "'Turns the given Guice {'"}
{"text": "'public static ActiveDescriptor < InjectionResolver < javax . inject . Inject > > newThreeThirtyInjectionResolverDescriptor ( ServiceLocator locator ) { GuiceThreeThirtyResolver resolver = new GuiceThreeThirtyResolver ( locator ) ; Set < Annotation > qualifiers = Collections . < Annotation > singleton ( new NamedImpl ( SYSTEM_RESOLVER_NAME ) ) ; return newActiveDescriptor ( locator , resolver , qualifiers , SYSTEM_RESOLVER_NAME , javax . inject . Inject . class ) ; }'", "label": "'Creates and returns a { @link InjectionResolver } for { @link javax . inject . Inject } .'"}
{"text": "'public static ActiveDescriptor < InjectionResolver < com . google . inject . Inject > > newGuiceInjectionResolverDescriptor ( ServiceLocator locator , ActiveDescriptor < ? extends InjectionResolver < ? > > threeThirtyResolver ) { GuiceInjectionResolver resolver = new GuiceInjectionResolver ( threeThirtyResolver ) ; Set < Annotation > qualifiers = Collections . emptySet ( ) ; return newActiveDescriptor ( locator , resolver , qualifiers , GUICE_RESOLVER_NAME , com . google . inject . Inject . class ) ; }'", "label": "'Creates and returns a { @link InjectionResolver } for { @link com . google . inject . Inject }'"}
{"text": "\"public static boolean isNullable ( Injectee injectee ) { // HK2's optional if ( injectee . isOptional ( ) ) { return true ; } // Guice's optional AnnotatedElement element = injectee . getParent ( ) ; if ( isGuiceOptional ( element ) ) { return true ; } // Any @Nullable? int position = injectee . getPosition ( ) ; if ( element instanceof Field ) { return Nullability . allowsNull ( ( ( Field ) element ) . getAnnotations ( ) ) ; } else if ( element instanceof Method ) { Annotation annotations [ ] [ ] = ( ( Method ) element ) . getParameterAnnotations ( ) ; return Nullability . allowsNull ( annotations [ position ] ) ; } else if ( element instanceof Constructor < ? > ) { Annotation annotations [ ] [ ] = ( ( Constructor < ? > ) element ) . getParameterAnnotations ( ) ; return Nullability . allowsNull ( annotations [ position ] ) ; } return false ; }\"", "label": "'Returns { @code true } if the given { @link Injectee } can be { @code null } .'"}
{"text": "'private static boolean isGuiceOptional ( AnnotatedElement element ) { com . google . inject . Inject inject = element . getAnnotation ( com . google . inject . Inject . class ) ; if ( inject != null ) { return inject . optional ( ) ; } return false ; }'", "label": "'Returns { @code true } if the given { @link AnnotatedElement } has a { @link com . google . inject . Inject } { @link Annotation } and it s marked as being optional .'"}
{"text": "'public static boolean isHk2Contract ( Injectee injectee ) { Type type = injectee . getRequiredType ( ) ; return isContact ( type , org . jvnet . hk2 . annotations . Contract . class ) ; }'", "label": "'Returns { @code true } if the { @link Injectee } has a HK2 SPI { @link org . jvnet . hk2 . annotations . Contract } annotation .'"}
{"text": "'public static boolean isJerseyContract ( Injectee injectee ) { Type type = injectee . getRequiredType ( ) ; return isContact ( type , org . glassfish . jersey . spi . Contract . class ) ; }'", "label": "'Returns { @code true } if the { @link Injectee } has a Jersey SPI { @link org . glassfish . jersey . spi . Contract } annotation .'"}
{"text": "'public static javax . inject . Named toThreeThirtyNamed ( com . google . inject . name . Named qualifier ) { return new NamedImpl ( qualifier . value ( ) ) ; }'", "label": "'Turns a {'"}
{"text": "'public static Key < ? > toKey ( Injectee injectee ) { Type type = injectee . getRequiredType ( ) ; Set < Annotation > qualifiers = getQualifiers ( injectee ) ; return newKey ( type , qualifiers ) ; }'", "label": "'Creates and returns a {'"}
{"text": "\"public static < T > Set < Annotation > getQualifiers ( Key < T > key ) { Annotation annotation = key . getAnnotation ( ) ; if ( annotation != null ) { // Replace 'com.google.inject.name.Named' with 'javax.inject.Named'  if ( annotation instanceof com . google . inject . name . Named ) { annotation = toThreeThirtyNamed ( ( com . google . inject . name . Named ) annotation ) ; } Class < ? extends Annotation > type = annotation . annotationType ( ) ; if ( type . isAnnotationPresent ( Qualifier . class ) ) { return Collections . singleton ( annotation ) ; } return Collections . < Annotation > singleton ( new GuiceQualifier <> ( key ) ) ; } Class < ? extends Annotation > annotationType = key . getAnnotationType ( ) ; if ( annotationType != null ) { return Collections . < Annotation > singleton ( new GuiceQualifier <> ( key ) ) ; } return Collections . emptySet ( ) ; }\"", "label": "'Returns a { @link Set } of qualifier { @link Annotation } s for the given { @link Key } .'"}
{"text": "'private static Key < ? > newKey ( Type type , Set < ? extends Annotation > qualifiers ) { if ( qualifiers . isEmpty ( ) ) { return Key . get ( type ) ; } // There can be only one qualifier. if ( qualifiers . size ( ) == 1 ) { for ( Annotation first : qualifiers ) { return Key . get ( type , first ) ; } } return null ; }'", "label": "'Creates and returns a {'"}
{"text": "\"private static Set < Annotation > getQualifiers ( Injectee injectee ) { // JSR 330's @Qualifier Set < Annotation > qualifiers = injectee . getRequiredQualifiers ( ) ; if ( ! qualifiers . isEmpty ( ) ) { return qualifiers ; } AnnotatedElement element = injectee . getParent ( ) ; int position = injectee . getPosition ( ) ; // Guice's @BindingAnnotation is the same as @Qualifier Annotation annotation = getBindingAnnotation ( element , position ) ; if ( annotation != null ) { return Collections . singleton ( annotation ) ; } return Collections . emptySet ( ) ; }\"", "label": "'NOTE : There can be only one { @link Annotation } that is a { @link Qualifier } or { @link BindingAnnotation } . They re the same but HK2 does not know about { @link BindingAnnotation } .'"}
{"text": "'private static Annotation getBindingAnnotation ( AnnotatedElement element , int position ) { if ( element instanceof Field ) { return getBindingAnnotation ( ( ( Field ) element ) . getAnnotations ( ) ) ; } if ( element instanceof Method ) { Annotation annotations [ ] [ ] = ( ( Method ) element ) . getParameterAnnotations ( ) ; return getBindingAnnotation ( annotations [ position ] ) ; } if ( element instanceof Constructor < ? > ) { Annotation annotations [ ] [ ] = ( ( Constructor < ? > ) element ) . getParameterAnnotations ( ) ; return getBindingAnnotation ( annotations [ position ] ) ; } return null ; }'", "label": "'Returns a {'"}
{"text": "'private static Annotation getBindingAnnotation ( Annotation [ ] annotations ) { for ( Annotation annotation : annotations ) { Class < ? extends Annotation > type = annotation . annotationType ( ) ; if ( type . isAnnotationPresent ( BindingAnnotation . class ) ) { return annotation ; } } return null ; }'", "label": "'Returns the first { @link Annotation } from the given array that is a { @link BindingAnnotation } .'"}
{"text": "'@ Override protected Resource doCreateResource ( URI uri , URIResourceFactory parent ) { try { return JarResource . create ( uri , parent ) ; } catch ( URISyntaxException e ) { throw new IllegalArgumentException ( uri . toString ( ) , e ) ; } }'", "label": "'Method that needs to be implemented by children ..'"}
{"text": "'public Object block ( Object key ) { if ( log . isDebugEnabled ( ) ) log . debug ( LangUtils . shortIdentityString ( this ) + \".block(\" + key + \")\" ) ; _lock . lock ( ) ; try { _waitingForBlock . add ( key ) ; _blockCondition . signalAll ( ) ; long endTime = System . currentTimeMillis ( ) + _timeout . getDurationInMilliseconds ( ) ; while ( ! _waitingForUnblock . containsKey ( key ) ) { try { ConcurrentUtils . awaitUntil ( _unblockCondition , endTime ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } catch ( TimeoutException e ) { throw new RuntimeException ( e ) ; } } return _waitingForUnblock . remove ( key ) ; } finally { _lock . unlock ( ) ; } }'", "label": "'This method is usually called from within a mock object to execute the call associated to the given key . It will block until another thread calls one of the <code > unblock< / code > method with the object to return .'"}
{"text": "'public Object blockWithException ( Object key ) throws Exception { Object value = block ( key ) ; if ( value instanceof Exception ) { Exception exception = ( Exception ) value ; throw exception ; } return value ; }'", "label": "'This method is usually called from within a mock object to execute the call associated to the given key . It will block until another thread calls one of the <code > unblock< / code > method with the object to return . If the object to return is an exception it will throw it instead!'"}
{"text": "'public void unblock ( Object key , Object value ) { if ( log . isDebugEnabled ( ) ) log . debug ( LangUtils . shortIdentityString ( this ) + \".unblock(\" + key + \", \" + value + \")\" ) ; _lock . lock ( ) ; try { try { waitForBlock ( key ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } catch ( TimeoutException e ) { throw new RuntimeException ( e ) ; } _waitingForBlock . remove ( key ) ; _waitingForUnblock . put ( key , value ) ; _unblockCondition . signalAll ( ) ; } finally { _lock . unlock ( ) ; } }'", "label": "'This method is called from one thread while another is going to call <code > block< / code > . It is basically a synchronization point as this method will block until <code > block< / code > is called and will then release the thread who called <code > block< / code > in the first place .'"}
{"text": "'public void waitForBlock ( Object key , Timespan timeout ) throws TimeoutException , InterruptedException { _lock . lock ( ) ; try { long endTime = System . currentTimeMillis ( ) + timeout . getDurationInMilliseconds ( ) ; while ( ! _waitingForBlock . contains ( key ) ) { ConcurrentUtils . awaitUntil ( _blockCondition , endTime ) ; } } finally { _lock . unlock ( ) ; } }'", "label": "'Blocking call to wait for a thread to call <code > block< / code > .'"}
{"text": "'public String urlEncode ( String original ) { // see http://www.w3.org/TR/html40/appendix/notes.html#non-ascii-chars // for an explanation of the character encoding String s = null ; try { s = URLEncoder . encode ( original , _characterEncoding ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } if ( _encodeDot ) { // we encode . as well because it can cause problems in url in emails. s = TextUtils . searchAndReplace ( s , \".\" , \"%2E\" ) ; } return s ; }'", "label": "'Encapsulates the call to encoding a URL'"}
{"text": "'public String urlDecode ( String original ) { try { return URLDecoder . decode ( original , _characterEncoding ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }'", "label": "'Encapsulates the call to decoding a URL so that we don t have to deal with the encoding .'"}
{"text": "'@ Override public void addXMLDecl ( String versionInfo , String encoding , boolean standalone ) { _xml . addXMLDecl ( versionInfo , encoding , standalone ) ; }'", "label": "'Adds the XML declaration ( <code > &lt ; ?xml version = 1 . 0 encoding = UTF - 8 standalone = yes ?&gt ; < / code > )'"}
{"text": "'@ Override public void addClosingTag ( String tagName ) { _indent . dec ( ) ; _xml . addXML ( _indent . toString ( ) ) ; _xml . addClosingTag ( tagName ) ; _xml . addXML ( \"\\\\n\" ) ; }'", "label": "'Adds a closing tag'"}
{"text": "'@ Override public void addEmptyTag ( String tagName ) { _xml . addXML ( _indent . toString ( ) ) ; _xml . addEmptyTag ( tagName ) ; _xml . addXML ( \"\\\\n\" ) ; }'", "label": "'Adds an empty tag'"}
{"text": "'@ Override public void addTag ( String tagName , String tagValue ) { _xml . addXML ( _indent . toString ( ) ) ; _xml . addTag ( tagName , tagValue ) ; _xml . addXML ( \"\\\\n\" ) ; }'", "label": "'Adds a tag'"}
{"text": "'@ Override public void addEmptyTag ( String tagName , String attrName , String attrValue ) { _xml . addXML ( _indent . toString ( ) ) ; _xml . addEmptyTag ( tagName , attrName , attrValue ) ; _xml . addXML ( \"\\\\n\" ) ; }'", "label": "'Adds an empty tag which contains an attribute'"}
{"text": "'@ Override public void addOpeningTag ( String tagName , Map attributes ) { _xml . addXML ( _indent . toString ( ) ) ; _xml . addOpeningTag ( tagName , attributes ) ; _xml . addXML ( \"\\\\n\" ) ; _indent . inc ( ) ; }'", "label": "'Adds an opening tag which contains the attributes specified . All the properties will be turned into attributes .'"}
{"text": "'public static boolean deleteFile ( File file ) throws IOException { if ( ! file . exists ( ) ) return false ; File [ ] files = file . listFiles ( ) ; if ( files != null ) { for ( int i = 0 ; i < files . length ; i ++ ) { File childFile = files [ i ] ; if ( childFile . equals ( file ) ) continue ; if ( childFile . isDirectory ( ) ) deleteFile ( childFile ) ; else childFile . delete ( ) ; } } return file . delete ( ) ; }'", "label": "'Deletes the file provided . If it is a directory recursively deletes a directory and its content .'"}
{"text": "'public static boolean createNewDirectory ( File directory ) throws IOException { if ( directory . exists ( ) ) return false ; if ( ! directory . mkdirs ( ) ) throw new IOException ( \"cannot create the directory: \" + directory ) ; return true ; }'", "label": "'Creates a new directory . This method creates automatically all the parent directories if necesary . Contrary to <code > File . mkdirs< / code > this method will fail if the directory cannot be created . The returned value is also different in meaning : <code > false< / code > means that the directory was not created because it already existed as opposed to it was not created because we don t know .'"}
{"text": "'public static File createTempDirectory ( String namespace , String name ) throws IOException { File dir = File . createTempFile ( namespace , \"\" ) ; if ( dir . exists ( ) ) deleteFile ( dir ) ; createNewDirectory ( dir ) ; File tempDir = new File ( dir , name ) ; createNewDirectory ( tempDir ) ; return tempDir . getCanonicalFile ( ) ; }'", "label": "'Creates a temporary directory .'"}
{"text": "'public static < T extends Serializable > byte [ ] serialize ( T ser ) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = new ObjectOutputStream ( baos ) ; try { oos . writeObject ( ser ) ; } finally { oos . close ( ) ; } return baos . toByteArray ( ) ; }'", "label": "'Turns the object into a <code > byte [] < / code > by serializing it in memory .'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public static < T extends Serializable > T deserialize ( byte [ ] array ) throws IOException , ClassNotFoundException { return ( T ) ( deserialize ( array , false ) ) ; }'", "label": "'This is the opposite of { @link #serialize ( Serializable ) } .'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public static < T extends Serializable > T deserialize ( byte [ ] array , boolean useContextClassLoader ) throws IOException , ClassNotFoundException { ByteArrayInputStream bais = new ByteArrayInputStream ( array ) ; ObjectInputStream ois ; if ( useContextClassLoader ) { ois = new ObjectInputStreamWithClassLoader ( bais , null ) ; } else { ois = new ObjectInputStream ( bais ) ; } try { return ( T ) ois . readObject ( ) ; } finally { ois . close ( ) ; } }'", "label": "'This is the opposite of { @link #serialize ( Serializable ) } .'"}
{"text": "'public static void copy ( InputStream in , OutputStream out , int num_bytes ) throws IOException { if ( num_bytes == 0 ) return ; int n ; if ( num_bytes < 0 ) { byte [ ] b = new byte [ 2048 ] ; while ( ( n = in . read ( b , 0 , b . length ) ) > 0 ) out . write ( b , 0 , n ) ; } else { int offset = 0 ; byte [ ] b = new byte [ num_bytes ] ; while ( num_bytes > 0 && ( n = in . read ( b , offset , num_bytes ) ) > 0 ) { offset += n ; num_bytes -= n ; } out . write ( b ) ; } }'", "label": "'Copies the input stream into the output stream ( num_bytes )'"}
{"text": "'public static void copy ( Reader in , Writer out , int num_bytes ) throws IOException { if ( num_bytes == 0 ) return ; int n ; if ( num_bytes < 0 ) { char [ ] b = new char [ 2048 ] ; while ( ( n = in . read ( b , 0 , b . length ) ) > 0 ) out . write ( b , 0 , n ) ; } else { int offset = 0 ; char [ ] b = new char [ num_bytes ] ; while ( num_bytes > 0 && ( n = in . read ( b , offset , num_bytes ) ) > 0 ) { offset += n ; num_bytes -= n ; } out . write ( b ) ; } }'", "label": "'Copies the reader into the writer ( num_bytes )'"}
{"text": "'@ Override public InternalResource doBuildResource ( String path ) { return new FileResource ( this , path , new File ( _root , path ) ) ; }'", "label": "'Builds a resource given a path . Only subclasses know how to do that .'"}
{"text": "'@ Override public InternalResourceProvider doCreateResourceProvider ( String rootPath ) { try { return new FileResourceProvider ( new File ( _root , rootPath ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }'", "label": "'Creates a new resource provider given the new path .'"}
{"text": "'@ Override public boolean doList ( String path , ResourceFilter filter ) { File file = null ; try { file = new File ( _root , path ) . getCanonicalFile ( ) ; } catch ( IOException e ) { if ( log . isDebugEnabled ( ) ) log . debug ( \"exception (ignored) while converting canonical file \" + new File ( _root , path ) , e ) ; return false ; } if ( ! file . isDirectory ( ) ) return false ; File [ ] files = file . listFiles ( ) ; for ( File f : files ) { filter . accept ( new FileResource ( this , path + f . getName ( ) , f ) ) ; } return true ; }'", "label": "'If the path denotes a directory then it will return all resources that are contained in the directory .'"}
{"text": "'@ Override public byte [ ] decode ( String s ) throws CannotDecodeException { if ( s == null || s . length ( ) <= 0 ) { throw new CannotDecodeException ( \"Cannot decode null or empty String\" ) ; } else { return new BigInteger ( s , 16 ) . toByteArray ( ) ; } }'", "label": "'Decodes the <code > String< / code > into a byte array'"}
{"text": "'@ Override public String encode ( byte [ ] byteArray ) { int len = byteArray . length ; char [ ] encoded = new char [ len * 2 ] ; int j = 0 ; for ( int i = 0 ; i < byteArray . length ; i ++ ) { int b = byteArray [ i ] & 0xFF ; String hexa = HEXA_VALUES [ b ] ; encoded [ j ++ ] = hexa . charAt ( 0 ) ; encoded [ j ++ ] = hexa . charAt ( 1 ) ; } return new String ( encoded ) ; }'", "label": "'Encode the array into a <code > String< / code >'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public static Object getProxiedObject ( Object proxy ) { if ( Proxy . isProxyClass ( proxy . getClass ( ) ) ) { InvocationHandler invocationHandler = Proxy . getInvocationHandler ( proxy ) ; if ( invocationHandler instanceof ObjectProxy ) { ObjectProxy objectProxy = ( ObjectProxy ) invocationHandler ; // recursively fetch the proxy return getProxiedObject ( objectProxy . getProxiedObject ( ) ) ; } else return proxy ; } else return proxy ; }'", "label": "'Given a proxy returns the object proxied . If the object is not a proxy then return the object itself .'"}
{"text": "'public static ClassLoader getDefaultClassLoader ( ) { ClassLoader cl = null ; try { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( Throwable ex ) { if ( log . isDebugEnabled ( ) ) log . debug ( \"Cannot access thread context ClassLoader - falling back to system class loader\" , ex ) ; } if ( cl == null ) { // No thread context class loader -> use class loader of this class. cl = ReflectUtils . class . getClassLoader ( ) ; } return cl ; }'", "label": "'Return a the default class loader ( the one associated to the current thread or the one from this class )'"}
{"text": "'public static Class forName ( String name , ClassLoader classLoader ) throws ClassNotFoundException , LinkageError { if ( classLoader == null ) { classLoader = getDefaultClassLoader ( ) ; } return Class . forName ( name , true , classLoader ) ; }'", "label": "'Wraps <code > Class . forName< / code > to be context class loader aware .'"}
{"text": "'public static Class forName ( Class clazz , ClassLoader classLoader ) throws ClassNotFoundException , LinkageError { if ( clazz == null ) return null ; if ( classLoader == null ) { classLoader = getDefaultClassLoader ( ) ; } if ( clazz . getClassLoader ( ) == null || clazz . getClassLoader ( ) . equals ( classLoader ) ) return clazz ; else return forName ( clazz . getName ( ) , classLoader ) ; }'", "label": "'Convenient call to return a class in a different class loader ... note that it will handle correctly a class in the same class loader'"}
{"text": "'public static < T > T executeWithClassLoader ( ClassLoader classLoader , Callable < T > callable ) throws Exception { ClassLoader previousClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { Thread . currentThread ( ) . setContextClassLoader ( classLoader ) ; return callable . call ( ) ; } finally { Thread . currentThread ( ) . setContextClassLoader ( previousClassLoader ) ; } }'", "label": "'Execute the call within the given class loader ... handle setting / reverting to previous class loader in a safe manner .'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public static String computeSignature ( Method m ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( m . getName ( ) ) . append ( \\' \\' ) ; Class [ ] parameterTypes = m . getParameterTypes ( ) ; for ( int i = 0 ; i < parameterTypes . length ; i ++ ) { if ( i > 0 ) sb . append ( \\' \\' ) ; Class parameterType = parameterTypes [ i ] ; sb . append ( parameterType . getName ( ) ) ; } sb . append ( \\' \\' ) ; return sb . toString ( ) ; }'", "label": "'Computes the signature of a method . Note that if 2 methods are declared in different classes or interfaces then I1 . m and I2 . m are different but they can still have the same signature ...'"}
{"text": "'public static Class [ ] extractAllInterfaces ( Object o ) { Set < Class > interfaces = new LinkedHashSet < Class > ( ) ; Class c = o . getClass ( ) ; do { interfaces . addAll ( Arrays . asList ( c . getInterfaces ( ) ) ) ; c = c . getSuperclass ( ) ; } while ( c != null ) ; return interfaces . toArray ( new Class [ interfaces . size ( ) ] ) ; }'", "label": "'Utility which extract the interfaces implemented by o : it goes up the chain of inheritance to find all the interfaces .'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public static < T > T createProxy ( InvocationHandler handler , Class < T > itface ) { if ( handler instanceof ObjectProxy ) { ObjectProxy proxy = ( ObjectProxy ) handler ; if ( ! ReflectUtils . isSubClassOrInterfaceOf ( proxy . getProxiedObject ( ) . getClass ( ) , itface ) ) throw new IllegalArgumentException ( proxy . getProxiedObject ( ) . getClass ( ) + \" does not extend \" + itface ) ; } return ( T ) Proxy . newProxyInstance ( itface . getClassLoader ( ) , new Class < ? > [ ] { itface } , handler ) ; }'", "label": "'Convenient call which creates a proxy using the handler and the interface . It will also check that the object bien proxied ( if implements <code > ObjectProxy< / code > ) properly implement the interface ...'"}
{"text": "'public static Object createProxy ( InvocationHandler handler , Class < ? > ... itfaces ) { if ( handler instanceof ObjectProxy ) { ObjectProxy proxy = ( ObjectProxy ) handler ; Class < ? > proxyClass = proxy . getProxiedObject ( ) . getClass ( ) ; for ( Class < ? > itface : itfaces ) { if ( ! ReflectUtils . isSubClassOrInterfaceOf ( proxyClass , itface ) ) throw new IllegalArgumentException ( proxyClass + \" does not extend \" + itface ) ; } } List < ClassLoader > classLoaders = new ArrayList < ClassLoader > ( ) ; for ( Class < ? > itface : itfaces ) { classLoaders . add ( itface . getClassLoader ( ) ) ; } ClassLoader classLoader = ClassLoaderChain . createChain ( classLoaders ) ; return Proxy . newProxyInstance ( classLoader , itfaces , handler ) ; }'", "label": "'Convenient call which creates a proxy using the handler and the interfaces . It will also check that the object bien proxied ( if implements <code > ObjectProxy< / code > ) properly implement the right interfaces ...'"}
{"text": "'public static void awaitUntil ( Condition condition , long endTime ) throws InterruptedException , TimeoutException { awaitUntil ( SystemClock . INSTANCE , condition , endTime ) ; }'", "label": "'Waits on the condition but if end time is expired then throws an exception . On purpose this method does not synchronize on the lock because it must be called from a block which synchronizes on it'"}
{"text": "'public static void awaitUntil ( Clock clock , Condition condition , long endTime ) throws InterruptedException , TimeoutException { if ( endTime <= 0 ) condition . await ( ) ; else { long now = clock . currentTimeMillis ( ) ; if ( now >= endTime ) throw new TimeoutException ( \"timeout reached while waiting on the lock: \" + condition ) ; if ( ! condition . await ( endTime - now , TimeUnit . MILLISECONDS ) ) throw new TimeoutException ( \"timeout reached while waiting on the lock: \" + condition ) ; } }'", "label": "'Waits on the condition but if end time is expired then throws an exception . On purpose this method does not synchronize on the lock because it must be called from a block which synchronizes on it'"}
{"text": "'public static void awaitUntil ( Object lock , long endTime ) throws InterruptedException , TimeoutException { awaitUntil ( SystemClock . INSTANCE , lock , endTime ) ; }'", "label": "'Waits on the lock but if end time is expired then throws an exception . On purpose this method does not synchronize on the lock because it must be called from a block which synchronizes on it'"}
{"text": "'public static void awaitUntil ( Clock clock , Object lock , long endTime ) throws InterruptedException , TimeoutException { if ( endTime <= 0 ) lock . wait ( ) ; else { long now = clock . currentTimeMillis ( ) ; if ( now >= endTime ) throw new TimeoutException ( \"timeout reached while waiting on the lock: \" + lock ) ; lock . wait ( endTime - now ) ; } }'", "label": "'Waits on the lock but if end time is expired then throws an exception . On purpose this method does not synchronize on the lock because it must be called from a block which synchronizes on it'"}
{"text": "'public static void joinUntil ( Clock clock , Thread thread , long endTime ) throws InterruptedException , TimeoutException { if ( endTime <= 0 ) thread . join ( ) ; else { while ( thread . isAlive ( ) ) { long now = clock . currentTimeMillis ( ) ; if ( now >= endTime ) throw new TimeoutException ( \"timeout reached while joining on: \" + thread ) ; thread . join ( endTime - now ) ; } } }'", "label": "'Joins on the thread but if end time is expired then throws an exception .'"}
{"text": "'public static void joinFor ( Clock clock , Thread thread , Object timeout ) throws InterruptedException , TimeoutException { joinUntil ( clock , thread , ClockUtils . toEndTime ( timeout ) ) ; }'", "label": "'Joins on the thread but if end time is expired then throws an exception .'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public static < T > T createProxy ( Class < T > interfaceToProxy , T objectToProxy ) { // since there is only one interface in the array, we know that the proxy must implement it! return ( T ) Proxy . newProxyInstance ( interfaceToProxy . getClassLoader ( ) , new Class < ? > [ ] { interfaceToProxy } , new ObjectProxyInvocationHandler ( objectToProxy ) ) ; }'", "label": "'This is a convenient call when you want to proxy an object with the unique given interface . Note that you can use the more general call { @link Proxy#newProxyInstance ( ClassLoader Class [] InvocationHandler ) } if you want to do something different .'"}
{"text": "'public static Resource create ( List < Resource > resources ) { if ( resources . size ( ) == 1 ) return resources . get ( 0 ) . chroot ( \".\" ) ; List < InternalResourceProvider > providers = new ArrayList < InternalResourceProvider > ( resources . size ( ) ) ; for ( Resource resource : resources ) { resource = resource . chroot ( \".\" ) ; InternalResourceProvider provider = ( InternalResourceProvider ) ( ( InternalResource ) resource ) . getResourceProvider ( ) ; if ( provider instanceof ResourceProviderChain ) { ResourceProviderChain resourceProviderChain = ( ResourceProviderChain ) provider ; providers . addAll ( resourceProviderChain . getResourceProviders ( ) ) ; } else { providers . add ( provider ) ; } } return new ResourceProviderChain ( providers ) . getRootResource ( ) ; }'", "label": "'Convenient method to create a chain from a list of resources . All the resources are turned into roots before chaining ( otherwise it does not make a lot of sense ... )'"}
{"text": "'@ Override public String encode ( byte [ ] byteArray ) { MessageDigest md = null ; try { md = ( MessageDigest ) _md . clone ( ) ; } catch ( CloneNotSupportedException e ) { // should not happen... already tested in constructor!! throw new RuntimeException ( e ) ; } return _codec . encode ( md . digest ( byteArray ) ) ; }'", "label": "'Encode the array into a <code > String< / code >'"}
{"text": "'private static OneWayMessageDigestCodec createWellKnownInstance ( String algorithm , String password , OneWayCodec codec ) { try { return new OneWayMessageDigestCodec ( algorithm , password , codec ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( e ) ; } }'", "label": "'This creates a well known instance .. the difference with the constructor is that all exceptions are caught and rethrown as RuntimeExcpetion because they should not happen .'"}
{"text": "'@ Override public boolean doList ( String path , ResourceFilter filter ) { if ( _root == null ) return false ; RAMEntry entry = _root . getEntryByPath ( path ) ; if ( entry instanceof RAMDirectory ) { RAMDirectory ramDirectory = ( RAMDirectory ) entry ; for ( RAMEntry ramEntry : ramDirectory . ls ( ) ) { String resourcePath = PathUtils . addPaths ( path , ramEntry . name ( ) ) ; filter . accept ( new RAMResource ( this , getFullPath ( resourcePath ) , resourcePath ) ) ; } return true ; } else return false ; }'", "label": "'If the path denotes a directory then it will return all resources that are contained in the directory .'"}
{"text": "'public void appendPath ( String path , boolean encodePath ) { if ( path == null ) return ; if ( encodePath ) path = urlEncode ( path ) ; if ( path . startsWith ( \"/\" ) ) path = path . substring ( 1 ) ; if ( _path == null || \"\" . equals ( _path ) ) { StringBuilder sb = new StringBuilder ( \"/\" ) ; sb . append ( path ) ; _path = sb . toString ( ) ; } else { StringBuilder sb = new StringBuilder ( _path ) ; if ( _path . endsWith ( \"/\" ) ) sb . append ( path ) ; else sb . append ( \\' \\' ) . append ( path ) ; _path = sb . toString ( ) ; } }'", "label": "'Appends the given path . The path is conditionaly escaped . After this call <code > newpath = oldpath + / + path< / code > . As a consequence this method cannot be used to set a relative path .'"}
{"text": "'public URLBuilder addQueryParameter ( String name , String value ) { if ( value == null ) throw new IllegalArgumentException ( \"value is null for \" + name ) ; _query . addParameter ( name , value ) ; return this ; }'", "label": "'Adds the query parameter'"}
{"text": "'public URLBuilder addQueryParameter ( String name , int [ ] values ) { String [ ] params = new String [ values . length ] ; int idx = 0 ; if ( values . length > 0 ) { for ( int value : values ) { params [ idx ++ ] = String . valueOf ( value ) ; } _query . addParameters ( name , params ) ; } return this ; }'", "label": "'Adds the query parameter'"}
{"text": "'public URLBuilder addQueryParameter ( String name , String [ ] values ) { if ( values != null && values . length > 0 ) { _query . addParameters ( name , values ) ; } return this ; }'", "label": "'Adds the query parameter'"}
{"text": "'public String [ ] replaceQueryParameter ( String name , String value ) { return _query . replaceParameter ( name , value ) ; }'", "label": "'Remove parameter with given name and return its previous value .'"}
{"text": "'public void reset ( ) { _scheme = null ; _userInfo = null ; _host = null ; _port = - 1 ; _path = null ; _query = new QueryBuilder ( ) ; _fragment = null ; _escapeFragment = true ; }'", "label": "'Call this method when you want to reset the internal string to start from scratch again'"}
{"text": "'public static String urlEncode ( String original , String encoding ) throws UnsupportedEncodingException { return new URLCodec ( true , encoding ) . urlEncode ( original ) ; }'", "label": "'Encapsulates the call to encoding a URL'"}
{"text": "'public static String urlDecode ( String original , String encoding ) throws UnsupportedEncodingException { return new URLCodec ( true , encoding ) . urlDecode ( original ) ; }'", "label": "'Encapsulates the call to decoding a URL so that we don t have to deal with the encoding .'"}
{"text": "'public static URLBuilder createFromPath ( String path ) { URLBuilder res = new URLBuilder ( ) ; res . setPath ( path ) ; return res ; }'", "label": "'Factory method from a path'"}
{"text": "'public static URLBuilder createFromURL ( String url ) throws URISyntaxException { if ( url == null ) { return null ; } else { url = url . trim ( ) ; } URI uri = new URI ( url ) ; if ( uri . isOpaque ( ) ) throw new URISyntaxException ( url , \"opaque uris not supported\" ) ; URLBuilder res = new URLBuilder ( ) ; res . setScheme ( uri . getScheme ( ) ) ; res . setUserInfo ( uri . getUserInfo ( ) ) ; // CA-1599 -- Java\\'s URI fails to parse the hostname if it has underscores in it. // this is because _ is not a valid char in hostnames, yet there are systems out there // that have it. Java\\'s URL, however, handles it fine. if ( uri . getHost ( ) == null && res . getHasScheme ( ) ) { try { java . net . URL u = new java . net . URL ( url ) ; res . setHost ( u . getHost ( ) ) ; res . setPort ( u . getPort ( ) ) ; } catch ( java . net . MalformedURLException e ) { URISyntaxException uex = new URISyntaxException ( url , e . getMessage ( ) ) ; uex . initCause ( e ) ; // keep the original exception throw uex ; } } else { res . setHost ( uri . getHost ( ) ) ; res . setPort ( uri . getPort ( ) ) ; } res . setPath ( uri . getRawPath ( ) ) ; res . setFragment ( uri . getFragment ( ) ) ; res . addQuery ( uri ) ; return res ; }'", "label": "'Factory method from a url'"}
{"text": "'public static URLBuilder createFromURL ( URL url ) { if ( url == null ) return null ; // fast implementation if ( url instanceof URLBuilder ) { URLBuilder urlBuilder = ( URLBuilder ) url ; return urlBuilder . deepClone ( ) ; } try { return createFromURL ( url . getURL ( ) ) ; } catch ( URISyntaxException e ) { throw new RuntimeException ( \"bad url!\" + url . getURL ( ) ) ; } }'", "label": "'Factory method from a url'"}
{"text": "'public static URL addQueryParameter ( URL url , String name , String value ) { URLBuilder ub = createFromURL ( url ) ; ub . addQueryParameter ( name , value ) ; return ub ; }'", "label": "'Convenient call which adds a query parameter to the give url .'"}
{"text": "'public static String [ ] getPathComponents ( String requestURI , String servletPath ) { ArrayList < String > tokens = new ArrayList < String > ( ) ; if ( requestURI != null && servletPath != null && servletPath . length ( ) > 0 ) { int servletPathStartPos = requestURI . indexOf ( servletPath ) ; if ( servletPathStartPos != - 1 ) { String components = requestURI . substring ( servletPathStartPos + servletPath . length ( ) ) ; StringTokenizer st = new StringTokenizer ( components , \"/\" ) ; while ( st . hasMoreTokens ( ) ) { tokens . add ( urlDecode ( st . nextToken ( ) ) ) ; } } } return tokens . toArray ( new String [ tokens . size ( ) ] ) ; }'", "label": "'Returns an array of the / delimited components for a URL path starting just after the servlet path . For example if requestURI is leo / a / b / c / d / and servletPath is / a then the array returned will be { b c d } . The path components are returned decoded ( not htmlified )'"}
{"text": "'@ Override public Resource createResource ( URI uri ) throws UnsupportedURIException { if ( uri . getScheme ( ) == null ) return FileResource . createFromRoot ( new File ( uri . getPath ( ) ) ) ; SchemeURIResourceFactory factory = _factories . get ( uri . getScheme ( ) ) ; if ( factory == null ) throw new UnsupportedURIException ( \"unsupported scheme \" + uri . getScheme ( ) ) ; return factory . createResource ( uri , this ) ; }'", "label": "'Based on the URI returns the right resource'"}
{"text": "'@ Override public String getParameter ( String name ) { String [ ] params = getParameterValues ( name ) ; if ( params == null ) return null ; return params [ 0 ] ; }'", "label": "'Get the first parameter given its name'"}
{"text": "\"private void addQueryParameter ( String name , String value ) { if ( _query . length ( ) > 0 ) _query . append ( ' ' ) ; _query . append ( encode ( name ) ) ; _query . append ( ' ' ) ; _query . append ( encode ( value ) ) ; }\"", "label": "'Add query parameter to query string .'"}
{"text": "'public void addParameter ( String name , String value ) { addQueryParameter ( name , value ) ; if ( _queryParameters != null ) addParameterToMap ( name , value ) ; }'", "label": "'Adds the query parameter'"}
{"text": "'private void addParameterToMap ( String name , String value ) { String [ ] params = getParameterValues ( name ) ; if ( params == null ) { params = new String [ 1 ] ; params [ 0 ] = value ; _queryParameters . put ( name , params ) ; } else { int len = params . length ; String [ ] newParams = new String [ len + 1 ] ; System . arraycopy ( params , 0 , newParams , 0 , len ) ; newParams [ len ] = value ; _queryParameters . put ( name , newParams ) ; } }'", "label": "'Adds the query parameter'"}
{"text": "\"public void addParameters ( String name , String [ ] values ) { if ( _query . length ( ) > 0 ) _query . append ( ' ' ) ; String encodedName = encode ( name ) ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( i > 0 ) _query . append ( ' ' ) ; _query . append ( encodedName ) ; _query . append ( ' ' ) ; _query . append ( encode ( values [ i ] ) ) ; } if ( _queryParameters != null ) addParametersToMap ( name , values ) ; }\"", "label": "'Adds the query parameter'"}
{"text": "'public void addParameters ( Map < String , String [ ] > parameters ) { for ( Map . Entry < String , String [ ] > entry : parameters . entrySet ( ) ) { addParameters ( entry . getKey ( ) , entry . getValue ( ) ) ; } }'", "label": "'Adds the map of parameters'"}
{"text": "'private void addParametersToMap ( String name , String [ ] values ) { String [ ] params = getParameterValues ( name ) ; if ( params == null ) { _queryParameters . put ( name , values ) ; } else { int len = params . length ; String [ ] newParams = new String [ len + values . length ] ; System . arraycopy ( params , 0 , newParams , 0 , len ) ; System . arraycopy ( values , 0 , newParams , len , values . length ) ; _queryParameters . put ( name , newParams ) ; } }'", "label": "'Adds the query parameter'"}
{"text": "'public void addIndexedParameter ( String name , String value , int ... indices ) { addParameter ( getIndexedParamName ( name , indices ) , value ) ; }'", "label": "'Adds a parameter that comes from an array at the provided index ( can have multiple dimensions! )'"}
{"text": "'public void addIndexedParameter ( String name , int value , int index ) { addParameter ( getIndexedParamName ( name , index ) , value ) ; }'", "label": "'Adds a parameter that comes from an array at the provided index'"}
{"text": "'public void addQuery ( URI uri ) { try { addQuery ( uri . getRawQuery ( ) , false ) ; } catch ( URISyntaxException e ) { // should not happen! throw new RuntimeException ( e ) ; } }'", "label": "'Adds the query extracted from the URI . No Exception is thrown because the uri could not be built if it was not correct .'"}
{"text": "'private void addQuery ( String query , boolean validate ) throws URISyntaxException { if ( query == null ) return ; if ( \"\" . equals ( query ) ) return ; if ( validate ) validateQuery ( query ) ; if ( _query . length ( ) > 0 ) _query . append ( \\' \\' ) ; _query . append ( query ) ; if ( _queryParameters != null ) addQueryToMap ( query ) ; }'", "label": "'Simply adds the query provided . It is assumed that the query is properly encoded for url!'"}
{"text": "'private void validateQuery ( String query ) throws URISyntaxException { if ( query . length ( ) == 0 ) return ; Iterator < String > iter = SS . splitToIterator ( query ) ; while ( iter . hasNext ( ) ) { String s = iter . next ( ) ; if ( s . length ( ) > 0 ) { int idx = s . indexOf ( \\' \\' ) ; if ( idx == - 1 ) throw new URISyntaxException ( query , \"missing equal sign in \" + s ) ; if ( s . lastIndexOf ( \\' \\' ) != idx ) throw new URISyntaxException ( query , \"extra equal sign in \" + s ) ; } } }'", "label": "'Internal method in charge of validating the query provided . Exception when query is not valid .'"}
{"text": "\"private void addQueryToMap ( String query ) { String [ ] params = SS . split ( query ) ; for ( int i = 0 ; i < params . length ; i ++ ) { String param = params [ i ] ; if ( param . length ( ) == 0 ) continue ; int idx = param . indexOf ( ' ' ) ; if ( idx == - 1 ) addParameterToMap ( decode ( param ) , null ) ; else addParameterToMap ( decode ( param . substring ( 0 , idx ) ) , decode ( param . substring ( idx + 1 ) ) ) ; } }\"", "label": "'Simply adds the query provided . It is assumed that the query is properly encoded for url!'"}
{"text": "'public void addQuery ( Query query ) { if ( query == null ) return ; try { if ( ! query . getEncoding ( ) . equals ( getEncoding ( ) ) ) throw new RuntimeException ( \"TODO\" ) ; addQuery ( query . getQuery ( ) , false ) ; } catch ( URISyntaxException e ) { // shouldn\\'t happen since a query is already properly formatted throw new RuntimeException ( e ) ; } }'", "label": "'Simply adds the query provided .'"}
{"text": "'private Map < String , String [ ] > getMap ( ) { if ( _queryParameters != null ) return _queryParameters ; _queryParameters = new LinkedHashMap < String , String [ ] > ( ) ; addQueryToMap ( _query . toString ( ) ) ; return _queryParameters ; }'", "label": "'Internal call that will return the map . If <code > null< / code > then first populate it'"}
{"text": "\"public static String getIndexedParamName ( String paramPrefix , int ... indices ) { StringBuilder sb = new StringBuilder ( paramPrefix ) ; for ( int index : indices ) { sb . append ( ' ' ) . append ( index ) ; } return sb . toString ( ) ; }\"", "label": "'Returns the name of the param that represent an entry in an array . This is the method used by <code > addIndexed * < / code > methods .'"}
{"text": "'private void rebuildQuery ( ) { Map < String , String [ ] > map = getMap ( ) ; // reset query instance and re-populate it again _query . setLength ( 0 ) ; for ( String key : map . keySet ( ) ) { String [ ] parameters = map . get ( key ) ; for ( String param : parameters ) { addQueryParameter ( key , param ) ; } } }'", "label": "'Rebuild query instance with values in the map .'"}
{"text": "'public void removeParameters ( String ... parameterNames ) { Map < String , String [ ] > map = getMap ( ) ; boolean needsRebuild = false ; for ( String name : parameterNames ) { if ( map . remove ( name ) != null ) needsRebuild = true ; } if ( needsRebuild ) rebuildQuery ( ) ; }'", "label": "'Remove parameter with given name and return its previous value .'"}
{"text": "'public String [ ] removeParameter ( String name ) { Map < String , String [ ] > map = getMap ( ) ; String [ ] v = map . remove ( name ) ; if ( v != null ) rebuildQuery ( ) ; return v ; }'", "label": "'Remove parameter with given name and return its previous value .'"}
{"text": "'public String [ ] replaceParameter ( String name , String value ) { Map < String , String [ ] > map = getMap ( ) ; String [ ] v = map . put ( name , new String [ ] { value } ) ; rebuildQuery ( ) ; return v ; }'", "label": "'Replace existing or add new parameter with given value . Any existing parameter values are deleted prior to adding the new value .'"}
{"text": "'@ Override public InternalResourceProvider doCreateResourceProvider ( String rootPath ) { try { return new URLResourceProvider ( _baseURL , getFullPath ( rootPath ) ) ; } catch ( UnsupportedURIException e ) { throw new RuntimeException ( e ) ; } catch ( URISyntaxException e ) { throw new RuntimeException ( e ) ; } }'", "label": "'Creates a new resource provider given the new path .'"}
{"text": "'@ Override public InternalResource doBuildResource ( String path ) { try { URI uri = _baseURL . toURI ( ) ; URI newURI = new URI ( uri . getScheme ( ) , uri . getUserInfo ( ) , uri . getHost ( ) , uri . getPort ( ) , getFullPath ( path ) , null , null ) ; return new URLResource ( this , path , newURI . toURL ( ) , _connectTimeout , _readTimeout ) ; } catch ( URISyntaxException e ) { // should not happen throw new RuntimeException ( e ) ; } catch ( MalformedURLException e ) { // should not happen throw new RuntimeException ( e ) ; } }'", "label": "'Builds a resource given a path . Only subclasses know how to do that .'"}
{"text": "'@ Override public InternalResource doBuildResource ( String path ) { return new JarResource ( this , path , _jarResource , getFullPath ( path ) ) ; }'", "label": "'Builds a resource given a path . Only subclasses know how to do that .'"}
{"text": "'@ Override public boolean doList ( String path , ResourceFilter filter ) { try { JarFile jarFile = new JarFile ( _jarResource . getFile ( ) ) ; try { return doList ( path , filter , jarFile ) ; } finally { jarFile . close ( ) ; } } catch ( IOException e ) { if ( log . isDebugEnabled ( ) ) log . debug ( \"exception (ignored) while listing path \" + path , e ) ; return false ; } }'", "label": "'If the path denotes a directory then it will return all resources that are contained in the directory .'"}
{"text": "'@ Override public Object invoke ( Object o , Method method , Object [ ] objects ) throws Throwable { // throws ShutdownRequestedException when in shutdown mode _shutdown . startCall ( ) ; try { return method . invoke ( _object , objects ) ; } catch ( InvocationTargetException e ) { Throwable th = e . getTargetException ( ) ; try { throw th ; } catch ( Exception ex ) { throw ex ; } catch ( Throwable throwable ) { log . error ( method . toString ( ) , throwable ) ; throw throwable ; } } finally { _shutdown . endCall ( ) ; } }'", "label": "'Method from the interface . Checks for shutdown then dispatches the call'"}
{"text": "'public static Object createShutdownProxy ( Object o , Shutdown shutdown ) { return createShutdownProxy ( o , null , shutdown ) ; }'", "label": "'Creates the proxy to check for shutdown . Uses all interfaces defined by this object ( and recursively ) .'"}
{"text": "'public static Object createShutdownProxy ( Object o , Class [ ] interfaces , Shutdown shutdown ) { if ( interfaces == null ) interfaces = ReflectUtils . extractAllInterfaces ( o ) ; return Proxy . newProxyInstance ( o . getClass ( ) . getClassLoader ( ) , interfaces , new ShutdownProxy ( o , shutdown ) ) ; }'", "label": "'Creates the proxy to check for shutdown .'"}
{"text": "'public static int compareTo ( Date d1 , Date d2 ) { if ( d1 == null ) { if ( d2 == null ) return 0 ; else return - 1 ; } if ( d2 == null ) { // here d1 is not null (already tested..) return 1 ; } // here d1 and d2 are not null long delta = d1 . getTime ( ) - d2 . getTime ( ) ; if ( delta > 0 ) { return 1 ; } else if ( delta < 0 ) { return - 1 ; } else { return 0 ; } }'", "label": "'This method compares 2 dates . It is mainly written to account for a bug in jdk15 which throws a ClassCastException when calling d1 . compareTo ( d2 ) . It also adds handling of <code > null< / code > values .'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public static < T extends Serializable > T deepClone ( T serializable , ClassLoader classLoader ) { if ( serializable == null ) return null ; try { return ( T ) IOUtils . deserialize ( IOUtils . serialize ( serializable ) , classLoader ) ; } catch ( IOException e ) { throw new InternalException ( e ) ; } catch ( ClassNotFoundException e ) { throw new InternalException ( e ) ; } }'", "label": "'Clone by serializing / deserializing ... only works if the object is actually serializable!'"}
{"text": "'public static boolean convertToBoolean ( Object o ) { if ( o == null ) return false ; if ( o instanceof Boolean ) { return ( Boolean ) o ; } return convertToBoolean ( o . toString ( ) ) ; }'", "label": "'Converts the object into a boolean value .'"}
{"text": "'public static boolean convertToBoolean ( String s ) { if ( s == null ) return false ; if ( s . equals ( \"false\" ) || s . equals ( \"no\" ) || s . equals ( \"off\" ) ) return false ; //    if(s.equals(\"true\") || s.equals(\"yes\") || s.equals(\"on\")) //      return true; return true ; }'", "label": "'Converts the string into a boolean value . <code > true< / code > or <code > yes< / code > are considered to be <code > true< / code > . <code > false< / code > or <code > no< / code > are <code > false< / code > .'"}
{"text": "'public static String getStackTrace ( Throwable th ) { StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; th . printStackTrace ( pw ) ; return sw . toString ( ) ; }'", "label": "'Returns the stack trace of the throwable as a string'"}
{"text": "'public static String addPaths ( String path1 , String path2 ) { if ( path1 . endsWith ( \"/\" ) ) { if ( path2 . startsWith ( \"/\" ) ) return path1 . substring ( 0 , path1 . length ( ) - 1 ) + path2 ; else return path1 + path2 ; } else { if ( path2 . startsWith ( \"/\" ) ) return path1 + path2 ; else return path1 + \"/\" + path2 ; } }'", "label": "'Adds 2 paths taking into consideration the /'"}
{"text": "'public static String removeTrailingSlash ( String path ) { if ( path . endsWith ( \"/\" ) ) return path . substring ( 0 , path . length ( ) - 1 ) ; else return path ; }'", "label": "'Removes a trailing slash if exists'"}
{"text": "'public String [ ] split ( String s ) { List < String > ss = splitAsList ( s ) ; if ( ss == null ) return null ; return ss . toArray ( new String [ ss . size ( ) ] ) ; }'", "label": "'Splits the string into an array of strings using the delimiter provided in the constructor .'"}
{"text": "'public List < String > splitAsList ( String s ) { if ( s == null ) return null ; int len = s . length ( ) ; if ( len == 0 ) { return Collections . emptyList ( ) ; } if ( _blockIgnore == null ) return splitNoBlockIgnore ( s ) ; else return splitBlockIgnore ( s ) ; }'", "label": "'Splits the string into an array of strings using the delimiter provided in the constructor .'"}
{"text": "'public Set < String > splitAsSet ( String s ) { String [ ] ss = split ( s ) ; if ( ss == null ) return null ; Set < String > res = new TreeSet < String > ( ) ; for ( int i = 0 ; i < ss . length ; i ++ ) res . ( ss [ i ] ) ; return res ; } /**\\n   * Splits the string and return an iterator using the delimiter\\n   * provided in the constructor.\\n   *\\n   * @param s the string to split\\n   * @return iterator of <code>String</code> (<code>null</code> if <code>s</code> is\\n   *         <code>null</code>) */ public Iterator < String > splitToIterator ( String s ) { if ( s == null ) return null ; if ( _blockIgnore == null ) return new SplitNoBlockIgnoreIterator ( s ) ; else throw new RuntimeException ( \"TODO\" ) ; } /**\\n   * Called when no block ignore */ private List < String > splitNoBlockIgnore  ( String s ) { int len = s . length ( ) ; ArrayList < String > res = new ArrayList < String > ( ) ; int idx = 0 ; int prev = 0 ; while ( true ) { idx = s . indexOf ( _delim , idx ) ; if ( idx == - 1 ) { res . add ( ( prev == len ) ? \"\" : s . substring ( prev ) ) ; break ; } if ( prev == idx ) { res . add ( \"\" ) ; } else { res . add ( s . substring ( prev , idx ) ) ; } prev = ++ idx ; } return res ; } /**\\n   * The iterator */ private class SplitNoBlockIgnoreIterator implements Iterator < String > { private final String _s ; private int _idx = 0 ; private int _prev = 0 ; private String _next = null ; private SplitNoBlockIgnoreIterator ( String s ) { _s = s ; if ( _s . length ( ) == 0 ) { _next = null ; _idx = - 1 ; } else _next = advanceNext ( ) ; } @ Override public boolean hasNext ( ) { return _next != null ; } @ Override public String next ( ) { String next = _next ; if ( next == null ) throw new NoSuchElementException ( ) ; _next = advanceNext ( ) ; return next ; } private String advanceNext ( ) { if ( _idx == - 1 ) return null ; _idx = _s . indexOf ( _delim , _idx ) ; if ( _idx == - 1 ) return ( _prev == _s . length ( ) ) ? \"\" : _s . substring ( _prev ) ; try { if ( _prev == _idx ) return \"\" ; else return _s . substring ( _prev , _idx ) ; } finally { _prev = ++ _idx ; } } @ Override public void remove ( ) { throw new UnsupportedOperationException ( \"not supported!\" ) ; } } /**\\n   * Called when block ignore */ private List < String > splitBlockIgnore  ( String s ) { if ( s . indexOf ( _blockIgnore ) == - 1 ) // if the character is not present then we can call the other method return splitNoBlockIgnore ( s ) ; boolean inBlockIgnore = false ; int blockIgnoreIdx = 0 ; StringBuffer sb = new StringBuffer ( ) ; ArrayList < String > al = new ArrayList < String > ( ) ; int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = s . charAt ( i ) ; if ( c == _blockIgnore . charAt ( blockIgnoreIdx ) ) { blockIgnoreIdx ++ ; if ( _blockIgnore . length ( ) == blockIgnoreIdx ) { blockIgnoreIdx = 0 ; inBlockIgnore = ! inBlockIgnore ; } sb . append ( c ) ; } else { blockIgnoreIdx = 0 ; if ( c == _delim ) { if ( inBlockIgnore ) sb . append ( c ) ; else { al . add ( sb . toString ( ) ) ; sb = new StringBuffer ( ) ; } } else sb . append ( c ) ; } } al . add ( sb . toString ( ) ) ; //     if(inBlockIgnore) //       throw new IllegalArgumentException(\"Wrong block ignore in string \" + s); return al ; } }'", "label": "'Splits the string into an array of strings using the delimiter provided in the constructor .'"}
{"text": "'@ Override public InternalResource doBuildResource ( String path ) { return new NullResource ( this , normalizePath ( path ) , normalizePath ( getFullPath ( path ) ) ) ; }'", "label": "'Builds a resource given a path . Only subclasses know how to do that .'"}
{"text": "'private static String normalizePath ( String path ) { path = PathUtils . removeTrailingSlash ( path ) ; path = PathUtils . addLeadingSlash ( path ) ; return path ; }'", "label": "'The path never represents a directory = > should not end with /'"}
{"text": "'public Resource createResource ( URI uri , URIResourceFactory parent ) { if ( ! getScheme ( ) . equals ( uri . getScheme ( ) ) ) throw new IllegalArgumentException ( \"cannot handle: \" + uri . getScheme ( ) ) ; return doCreateResource ( uri , parent ) ; }'", "label": "'Based on the URI returns the right resource'"}
{"text": "'@ Override public void waitForShutdown ( Object timeout ) throws InterruptedException , IllegalStateException , TimeoutException { if ( ! _shutdown ) throw new IllegalStateException ( \"call shutdown first\" ) ; pendingCallsCount . waitForCounter ( timeout ) ; }'", "label": "'Waits for shutdown to be completed . After calling shutdown there may still be some pending work that needs to be accomplised . This method will block until it is done but no longer than the timeout .'"}
{"text": "'static void addXMLDecl ( StringBuilder xml , String versionInfo ) { xml . append ( \"<?xml version=\\\\\"\" ) . append ( versionInfo ) . append ( \"\\\\\"?>\\\\n\" ) ; }'", "label": "'Adds the XML declaration ( <code > &lt ; ?xml version = 1 . 0 ?&gt ; < / code > )'"}
{"text": "'@ Override public void addXMLDecl ( String versionInfo , String encoding , boolean standalone ) { _xml . append ( \"<?xml version=\\\\\"\" ) . append ( versionInfo ) ; _xml . append ( \"\\\\\" encoding=\\\\\"\" ) ; _xml . append ( encoding ) . append ( \"\\\\\" standalone=\\\\\"\" ) ; _xml . append ( standalone ? \"yes\" : \"no\" ) ; _xml . append ( \"\\\\\"?>\\\\n\" ) ; }'", "label": "'Adds the XML declaration ( <code > &lt ; ?xml version = 1 . 0 encoding = UTF - 8 standalone = yes ?&gt ; < / code > )'"}
{"text": "'@ Override public void addTag ( String tagName , String tagValue ) { if ( tagValue == null ) addEmptyTag ( tagName ) ; else { addOpeningTag ( tagName ) ; _xml . append ( XMLUtils . xmlEncode ( tagValue ) ) ; addClosingTag ( tagName ) ; } }'", "label": "'Adds a tag'"}
{"text": "'@ Override public void addEmptyTag ( String tagName , Map attributes ) { _xml . append ( \\' \\' ) . append ( tagName ) ; addAttributes ( attributes ) ; _xml . append ( \" />\" ) ; }'", "label": "'Adds an empty tag which contains the attributes specified . All the properties will be turned into attributes .'"}
{"text": "'@ Override public void addEmptyTag ( String tagName , String attrName , String attrValue ) { _xml . append ( \\' \\' ) . append ( tagName ) ; addAttribute ( attrName , attrValue ) ; _xml . append ( \" />\" ) ; }'", "label": "'Adds an empty tag which contains an attribute'"}
{"text": "'private void addAttribute ( String attrName , String attrValue ) { if ( attrName == null ) return ; _xml . append ( \\' \\' ) ; _xml . append ( attrName ) . append ( \"=\\\\\"\" ) ; _xml . append ( XMLUtils . xmlEncode ( attrValue ) ) . append ( \\' \\' ) ; }'", "label": "'Adds the attribute'"}
{"text": "'private void addAttributes ( Map attributes ) { if ( attributes == null ) return ; Iterator iter = attributes . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String attrName = ( String ) iter . next ( ) ; Object attrValue = attributes . get ( attrName ) ; if ( attrValue != null ) addAttribute ( attrName , attrValue . toString ( ) ) ; } }'", "label": "'Adds the attributes . All the properties will be used as attributes'"}
{"text": "'@ Override public InputStream getInputStream ( ) throws IOException { URLConnection urlConnection = _url . openConnection ( ) ; urlConnection . setDoInput ( true ) ; urlConnection . setDoOutput ( false ) ; urlConnection . setUseCaches ( false ) ; urlConnection . setConnectTimeout ( new Long ( _connectTimeout . getDurationInMilliseconds ( ) ) . intValue ( ) ) ; urlConnection . setReadTimeout ( new Long ( _readTimeout . getDurationInMilliseconds ( ) ) . intValue ( ) ) ; urlConnection . connect ( ) ; return urlConnection . getInputStream ( ) ; }'", "label": "'Important note : the caller of this method is responsible for properly closing the input stream!'"}
{"text": "'public static ResourceInfo extractInfo ( URL url ) throws IOException { URLConnection urlConnection = url . openConnection ( ) ; urlConnection . setDoInput ( true ) ; urlConnection . setDoOutput ( false ) ; urlConnection . setUseCaches ( false ) ; urlConnection . connect ( ) ; InputStream is = urlConnection . getInputStream ( ) ; try { return new StaticInfo ( urlConnection . getContentLength ( ) , urlConnection . getLastModified ( ) ) ; } finally { is . close ( ) ; } }'", "label": "'Extracts the info from the url'"}
{"text": "'public static Resource create ( URL url ) { URLBuilder rootURL = URLBuilder . createFromPath ( \"/\" ) ; rootURL . setScheme ( url . getProtocol ( ) ) ; rootURL . setHost ( url . getHost ( ) ) ; rootURL . setPort ( url . getPort ( ) ) ; rootURL . setUserInfo ( url . getUserInfo ( ) ) ; return create ( rootURL . toJavaURL ( ) , \"/\" ) . createRelative ( url . getPath ( ) ) ; }'", "label": "'Creates the resource from a url ...'"}
{"text": "'public static Resource createFromRoot ( URL url ) { String urlPath = url . getPath ( ) ; String path = \"/\" ; if ( ! urlPath . endsWith ( \"/\" ) ) { urlPath = PathUtils . addLeadingSlash ( urlPath ) ; int idx = urlPath . lastIndexOf ( \"/\" ) ; // there will always be one due to previous line... path = urlPath . substring ( idx + 1 ) ; urlPath = urlPath . substring ( 0 , idx ) ; } URLBuilder rootURL = URLBuilder . createFromPath ( urlPath ) ; rootURL . setScheme ( url . getProtocol ( ) ) ; rootURL . setHost ( url . getHost ( ) ) ; rootURL . setPort ( url . getPort ( ) ) ; rootURL . setUserInfo ( url . getUserInfo ( ) ) ; return create ( rootURL . toJavaURL ( ) , \"/\" ) . createRelative ( path ) ; }'", "label": "'Creates the resource from a url ... The root will be at the path of this url ( ex : if url is http : // localhost / a / b / c / foo . html then root is / a / b / c ) .'"}
{"text": "'public static Resource create ( URL url , String rootPath ) { try { return new URLResourceProvider ( url , rootPath ) . getRootResource ( ) ; } catch ( UnsupportedURIException e ) { throw new RuntimeException ( e ) ; } catch ( URISyntaxException e ) { throw new RuntimeException ( e ) ; } }'", "label": "'Creates the resource from a url ...'"}
{"text": "'@ Override protected Resource doCreateResource ( URI uri , URIResourceFactory parent ) { try { return URLResource . createFromRoot ( uri . toURL ( ) ) ; } catch ( MalformedURLException e ) { throw new IllegalArgumentException ( uri . toString ( ) , e ) ; } }'", "label": "'Method that needs to be implemented by children ..'"}
{"text": "'@ Override public Resource createResource ( String path ) { if ( path == null ) return null ; URI uri = URI . create ( path ) . normalize ( ) ; if ( uri . isAbsolute ( ) ) throw new IllegalArgumentException ( path + \" => only path with no scheme are supported...\" ) ; path = uri . toString ( ) ; return doBuildResource ( PathUtils . addLeadingSlash ( path ) ) ; }'", "label": "'The path to the resource is absolute . Whether it starts with / or not it will be made absolute . <p / > Note that it follows the same convention as { @link File } class in the sense that a resource simply represents a handle and does not imply that the resource exists .'"}
{"text": "'@ Override public InternalResource chroot ( InternalResource resource ) { String path = resource . getPath ( ) ; // when it is a directory, we simply use the provided resource if ( resource . isDirectory ( ) ) { return doCreateResourceProvider ( path ) . getRootResource ( ) ; } else { // when not a directory, we do a chroot to the parent and then we return the resource // that points to it return ( InternalResource ) resource . chroot ( \"..\" ) . createRelative ( resource . getFilename ( ) ) ; } }'", "label": "'Returns a new resource with the root resource set to this resource .'"}
{"text": "'@ Override public InternalResource [ ] list ( InternalResource resource , final ResourceFilter filter ) throws IOException { final List < Resource > resources = new ArrayList < Resource > ( ) ; String path = PathUtils . addTrailingSlash ( resource . getPath ( ) ) ; if ( doList ( path , new ResourceFilter ( ) { @ Override public boolean accept ( Resource resource ) { boolean res = filter . accept ( resource ) ; if ( res ) resources . add ( resource ) ; return res ; } } ) ) { return resources . toArray ( new InternalResource [ resources . size ( ) ] ) ; } else return null ; }'", "label": "'If this resource denotes a directory then it will return all resources that are contained in the directory .'"}
{"text": "'@ Override public Resource chroot ( String relativePath ) { return _resourceProvider . chroot ( ( InternalResource ) createRelative ( relativePath ) ) ; }'", "label": "'Returns a new resource with the root resource set to the relative path provided . Note that the new resource points at the new root as well .'"}
{"text": "'public static InternalException throwInternalException ( String module , InvocationTargetException ite ) throws InternalException { try { throw ite . getTargetException ( ) ; } catch ( Error e ) { throw e ; } catch ( RuntimeException e ) { throw e ; } catch ( Throwable e ) { throw new InternalException ( module , e ) ; } }'", "label": "'Convenient call to adapt the <code > InvocationTargetException< / code > into an <code > InternalException< / code >'"}
{"text": "'public static String xmlEncodeRaw ( String s ) { if ( s == null ) return null ; char [ ] chars = s . toCharArray ( ) ; final int len = chars . length ; StringBuilder sb = new StringBuilder ( len ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = chars [ i ] ; if ( c < _chars . length ) { sb . append ( _chars [ c ] ) ; } else if ( Character . isHighSurrogate ( c ) ) { int j = i + 1 ; if ( j < len && Character . isLowSurrogate ( chars [ j ] ) ) { sb . append ( \"&#x\" ) . append ( Integer . toHexString ( Character . toCodePoint ( c , chars [ j ] ) ) ) . append ( \\' \\' ) ; i = j ; } // else ignore this character, a single high surrogate is an invalid char } else if ( ! Character . isLowSurrogate ( c ) ) { sb . append ( \"&#x\" ) . append ( Integer . toHexString ( c ) ) . append ( \\' \\' ) ; } } return sb . toString ( ) ; }'", "label": "'Encodes the string so that it is XML safe : all characters &lt ; = 127 will not be encoded ( converts &lt ; &gt ; &amp ; &apos ; into their equivalent ( &amp ; lt ; &amp ; gt ; &amp ; amp ; &amp ; apos ; )) . All characters &gt ; 127 will be encoded as &amp ; #xxxx ; with xxxx the hexadecimal value of the character . This method differs from <code > xmlEncode< / code > because it encodes all values &gt ; 127 into a pure ascii xml safe string . In most cases this method is NOT necessary because with an xml message you can specify the encoding so there is no need to encode those characters .'"}
{"text": "'public static String xmlDecode ( String s ) throws IllegalArgumentException { if ( s == null ) return s ; int idxS = s . indexOf ( \\' \\' ) ; if ( idxS < 0 ) return s ; StringBuilder sb = new StringBuilder ( s . length ( ) ) ; int idxE , idx , size ; char c , c_1 ; int prev = 0 ; while ( idxS != - 1 ) { idxE = s . indexOf ( \\' \\' , idxS ) ; if ( idxE < 0 ) throw new IllegalArgumentException ( \"missing \\';\\' in: \" + s . substring ( idxS ) ) ; sb . append ( s . substring ( prev , idxS ) ) ; idx = idxS + 1 ; size = idxE - idxS - 1 ; if ( size < 2 ) throw new IllegalArgumentException ( \"invalid escape tag: \" + s . substring ( idxS , idxE + 1 ) ) ; c = s . charAt ( idx ) ; c_1 = s . charAt ( idx + 1 ) ; switch ( c ) { case \\' \\' : if ( size != 2 ) throw new IllegalArgumentException ( \"invalid escape tag: \" + s . substring ( idxS , idxE + 1 ) ) ; if ( c_1 == \\' \\' ) sb . append ( \\' \\' ) ; else throw new IllegalArgumentException ( \"invalid escape tag: \" + s . substring ( idxS , idxE + 1 ) ) ; break ; case \\' \\' : if ( size != 2 ) throw new IllegalArgumentException ( \"invalid escape tag: \" + s . substring ( idxS , idxE + 1 ) ) ; if ( c_1 == \\' \\' ) sb . append ( \\' \\' ) ; else throw new IllegalArgumentException ( \"invalid escape tag: \" + s . substring ( idxS , idxE + 1 ) ) ; break ; case \\' \\' : if ( size != 4 ) throw new IllegalArgumentException ( \"invalid escape tag: \" + s . substring ( idxS , idxE + 1 ) ) ; if ( c_1 != \\' \\' || s . charAt ( idx + 2 ) != \\' \\' || s . charAt ( idx + 3 ) != \\' \\' ) throw new IllegalArgumentException ( \"invalid escape tag: \" + s . substring ( idxS , idxE + 1 ) ) ; else sb . append ( \\' \\' ) ; break ; case \\' \\' : if ( size == 3 ) { if ( c_1 != \\' \\' || s . charAt ( idx + 2 ) != \\' \\' ) throw new IllegalArgumentException ( \"invalid escape tag: \" + s . substring ( idxS , idxE + 1 ) ) ; else sb . append ( \\' \\' ) ; } else if ( size == 4 ) { if ( c_1 != \\' \\' || s . charAt ( idx + 2 ) != \\' \\' || s . charAt ( idx + 3 ) != \\' \\' ) throw new IllegalArgumentException ( \"invalid escape tag: \" + s . substring ( idxS , idxE + 1 ) ) ; else sb . append ( \\' \\' ) ; } else throw new IllegalArgumentException ( \"invalid escape tag: \" + s . substring ( idxS , idxE + 1 ) ) ; break ; case \\' \\' : int codePoint ; try { codePoint = ( c_1 == \\' \\' ) ? Integer . parseInt ( s . substring ( idx + 2 , idxE ) , 16 ) : Integer . parseInt ( s . substring ( idx + 1 , idxE ) ) ; } catch ( NumberFormatException ex ) { throw new IllegalArgumentException ( \"invalid escape tag: \" + s . substring ( idxS , idxE + 1 ) ) ; } if ( codePoint < 0 ) throw new IllegalArgumentException ( \"invalid character codepoint: \" + s . substring ( idxS , idxE + 1 ) ) ; if ( codePoint < Character . MIN_SUPPLEMENTARY_CODE_POINT ) sb . append ( ( char ) codePoint ) ; else sb . append ( Character . toChars ( codePoint ) ) ; break ; default : throw new IllegalArgumentException ( \"invalid escape tag: \" + s . substring ( idxS , idxE + 1 ) ) ; } prev = idxE + 1 ; idxS = s . indexOf ( \"&\" , prev ) ; } if ( prev < s . length ( ) ) sb . append ( s . substring ( prev ) ) ; return sb . toString ( ) ; }'", "label": "'This method descodes a string that was previously encoded for being XML safe . It is the exact opposite of xmlEncode'"}
{"text": "'@ Override public boolean doList ( String path , final ResourceFilter filter ) { ResourceFilter newFilter = new ResourceFilter ( ) { @ Override public boolean accept ( Resource resource ) { return filter . accept ( doBuildResource ( resource ) ) ; } } ; return _resourceProvider . doList ( path , newFilter ) ; }'", "label": "'If the path denotes a directory then it will return all resources that are contained in the directory .'"}
{"text": "'@ Override public ResourceInfo getInfo ( ) throws IOException { if ( _file . exists ( ) ) return new FileInfo ( ) ; else throw new FileNotFoundException ( _file . getPath ( ) ) ; }'", "label": "'Efficiently returns all information about the resource .'"}
{"text": "'public static Resource create ( File file ) { try { String path = file . getCanonicalPath ( ) ; if ( file . isDirectory ( ) ) path = PathUtils . addTrailingSlash ( path ) ; return create ( new File ( \"/\" ) , path ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( \"invalid file \" + file , e ) ; } }'", "label": "'Creates a file resource from a file'"}
{"text": "'public static Resource createFromRoot ( File rootFile ) { File root = rootFile ; String path = \"/\" ; if ( ! root . isDirectory ( ) ) { root = rootFile . getParentFile ( ) ; path = rootFile . getName ( ) ; } return create ( root , path ) ; }'", "label": "'Creates a file resource from a file with the root as this file ( if it is a directory otherwise its parent ) .'"}
{"text": "'public static Resource create ( File root , String path ) { FileResourceProvider frp = null ; try { frp = new FileResourceProvider ( root ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return frp . createResource ( path ) ; }'", "label": "'Creates a file resource with the root provided and the path ( relative to the root ) .'"}
{"text": "'public void start ( ) throws IOException { _process = _processBuilder . start ( ) ; _out = new InputReader ( new BufferedInputStream ( _process . getInputStream ( ) ) ) ; _err = new InputReader ( new BufferedInputStream ( _process . getErrorStream ( ) ) ) ; _out . start ( ) ; _err . start ( ) ; }'", "label": "'After creating the command you have to start it ...'"}
{"text": "'public int waitFor ( ) throws InterruptedException { if ( _process == null ) throw new IllegalStateException ( \"you must call start first\" ) ; _out . join ( ) ; _err . join ( ) ; return _process . waitFor ( ) ; }'", "label": "'Properly waits until everything is complete : joins on the thread that reads the output joins on the thread that reads the error and finally wait for the process to be finished . @return the status code of the process .'"}
{"text": "'public int waitFor ( long timeout ) throws InterruptedException , TimeoutException { if ( _process == null ) throw new IllegalStateException ( \"you must call start first\" ) ; Chronos c = new Chronos ( ) ; _out . join ( timeout ) ; timeout -= c . tick ( ) ; if ( timeout <= 0 ) throw new TimeoutException ( \"Wait timed out\" ) ; _err . join ( timeout ) ; timeout -= c . tick ( ) ; if ( timeout <= 0 ) throw new TimeoutException ( \"Wait timed out\" ) ; // there is no timeout in this API, not much we can do here // waiting on the other two threads should give us some safety return _process . waitFor ( ) ; }'", "label": "'Properly waits until everything is complete : joins on the thread that reads the output joins on the thread that reads the error and finally wait for the process to be finished . If the process has not completed before the timeout throws a { @link TimeoutException } @return the status code of the process .'"}
{"text": "'public static ExternalCommand create ( List < String > commands ) { ExternalCommand ec = new ExternalCommand ( new ProcessBuilder ( commands ) ) ; return ec ; }'", "label": "'Creates an external process from the command . It is not started and you have to call start on it!'"}
{"text": "'public static ExternalCommand start ( String ... commands ) throws IOException { ExternalCommand ec = new ExternalCommand ( new ProcessBuilder ( commands ) ) ; ec . start ( ) ; return ec ; }'", "label": "'Creates an external process from the command . The command is executed .'"}
{"text": "'public static ExternalCommand execute ( File workingDirectory , String command , String ... args ) throws IOException , InterruptedException { try { return executeWithTimeout ( workingDirectory , command , 0 , args ) ; } catch ( TimeoutException e ) { // Can\\'t happen! throw new IllegalStateException ( MODULE + \".execute: Unexpected timeout occurred!\" ) ; } }'", "label": "'Executes the external command in the given working directory and waits for it to be finished .'"}
{"text": "'public static ExternalCommand executeWithTimeout ( File workingDirectory , String command , long timeout , String ... args ) throws IOException , InterruptedException , TimeoutException { List < String > arguments = new ArrayList < String > ( args . length + 1 ) ; arguments . add ( new File ( workingDirectory , command ) . getAbsolutePath ( ) ) ; arguments . addAll ( Arrays . asList ( args ) ) ; ExternalCommand cmd = ExternalCommand . create ( arguments ) ; cmd . setWorkingDirectory ( workingDirectory ) ; cmd . setRedirectErrorStream ( true ) ; cmd . start ( ) ; /* Use timeout if it is a valid value! */ if ( timeout <= 0 ) cmd . waitFor ( ) ; else cmd . waitFor ( timeout ) ; if ( log . isDebugEnabled ( ) ) log . debug ( cmd . getStringOutput ( ) ) ; return cmd ; }'", "label": "'Executes the external command in the given working directory and waits ( until timeout is elapsed ) for it to be finished .'"}
{"text": "'public long tick ( ) { long tick = _clock . currentTimeMillis ( ) ; long diff = tick - _tick ; _tick = tick ; return diff ; }'", "label": "'Returns the number of milliseconds ellapsed since the last call to this function .'"}
{"text": "'public String getElapsedTime ( ) { StringBuilder sb = new StringBuilder ( \"Time: \" ) ; sb . append ( this . tick ( ) ) ; sb . append ( \" ms\" ) ; return sb . toString ( ) ; }'", "label": "'Returns a string that represents the time elapsed'"}
{"text": "'@ Override public InputStream getInputStream ( ) throws IOException { JarFile contentJarFile = getContentJarFile ( ) ; try { CloseJarFileInputStream jarFileInputStream = new CloseJarFileInputStream ( this , contentJarFile , _fullPath ) ; // we are delegating the closure of the jar file to the input stream... contentJarFile = null ; return jarFileInputStream ; } finally { if ( contentJarFile != null ) contentJarFile . close ( ) ; } }'", "label": "'Important note : the caller of this method is responsible for properly closing the input stream!'"}
{"text": "'@ Override public ResourceInfo getInfo ( ) throws IOException { // represents the root... if ( _fullPath . equals ( \"\" ) ) { return new StaticInfo ( 0 , // root is a directory... _jarResource . getInfo ( ) . getLastModified ( ) ) ; // last modified is the jar file itself! } JarFile contentJarFile = getContentJarFile ( ) ; try { JarEntry jarEntry = contentJarFile . getJarEntry ( _fullPath ) ; if ( jarEntry == null ) throw new ResourceNotFoundException ( toURI ( ) ) ; return new StaticInfo ( jarEntry . getSize ( ) , jarEntry . getTime ( ) ) ; } finally { contentJarFile . close ( ) ; } }'", "label": "'Efficiently returns all information about the resource .'"}
{"text": "'public static Resource create ( URI uri ) throws URISyntaxException , IOException { return create ( uri , URIResourceFactory . DEFAULT ) ; }'", "label": "'Factory method .'"}
{"text": "'public static Resource create ( URI uri , URIResourceFactory factory ) throws URISyntaxException { String path = \"/\" ; // case when the URI is already a jar uri if ( \"jar\" . equals ( uri . getScheme ( ) ) ) { String schemeSpecificPart = uri . getSchemeSpecificPart ( ) ; if ( schemeSpecificPart == null ) throw new URISyntaxException ( uri . toString ( ) , \"no scheme specific part found...\" ) ; int idx = schemeSpecificPart . indexOf ( \"!/\" ) ; if ( idx == - 1 ) throw new URISyntaxException ( uri . toString ( ) , \"couldn\\'t find !/\" ) ; uri = new URI ( schemeSpecificPart . substring ( 0 , idx ) ) ; path = schemeSpecificPart . substring ( idx + 1 ) ; } // case when the URI points directly to the jar resource try { ResourceProvider provider = new JarResourceProvider ( factory . createResource ( uri ) ) ; return provider . createResource ( \"/\" ) . createRelative ( path ) ; } catch ( UnsupportedURIException e ) { URISyntaxException ex = new URISyntaxException ( uri . toString ( ) , \"cannot create resource\" ) ; ex . initCause ( e ) ; throw ex ; } }'", "label": "'Factory method .'"}
{"text": "'public static Resource create ( Resource jarResource , String rootPath ) { return new JarResourceProvider ( jarResource , rootPath ) . getRootResource ( ) ; }'", "label": "'Convenient call to create a resource from the jar resource ( points at rootPath in the jar ... )'"}
{"text": "'@ Override public void addTag ( String tagName , double value ) { addTag ( tagName , String . valueOf ( value ) ) ; }'", "label": "'Adds a tag'"}
{"text": "'@ Override public void addTag ( String tagName , int value , String attrName , String attrValue ) { addTag ( tagName , String . valueOf ( value ) , attrName , attrValue ) ; }'", "label": "'Adds a tag which contains an attribute'"}
{"text": "'@ Override public void addTag ( String tagName , int value , Map attributes ) { addTag ( tagName , String . valueOf ( value ) , attributes ) ; }'", "label": "'Adds a tag which contains the attributes specified . All the properties will be turned into attributes .'"}
{"text": "\"public static String indentBlock ( String block , Indent indent ) { StringBuilder sb = new StringBuilder ( ) ; BufferedReader br = new BufferedReader ( new StringReader ( block ) ) ; String line ; try { while ( ( line = br . readLine ( ) ) != null ) sb . append ( indent ) . append ( line ) . append ( ' ' ) ; } catch ( IOException ex ) { // on a String ? I doubt... } return sb . toString ( ) ; }\"", "label": "'Indents a block of text . You provide the block of text as a String and the indent object and it returns another String with each line properly indented .'"}
{"text": "'@ Override public InputStream getInputStream ( ) throws IOException { RAMEntry entry = getRAMEntry ( ) ; if ( entry == null || entry instanceof RAMDirectory ) throw new ResourceNotFoundException ( toURI ( ) ) ; return new ByteArrayInputStream ( ( ( RAMFile ) entry ) . getContent ( ) ) ; }'", "label": "'Important note : the caller of this method is responsible for properly closing the input stream!'"}
{"text": "'@ Override public ResourceInfo getInfo ( ) throws IOException { RAMEntry entry = getRAMEntry ( ) ; if ( entry != null ) return new StaticInfo ( entry . getContentLength ( ) , entry . lastModified ( ) ) ; else throw new ResourceNotFoundException ( toURI ( ) ) ; }'", "label": "'Efficiently returns all information about the resource .'"}
{"text": "'public static Timespan toTimespan ( Object t ) { if ( t == null ) return null ; if ( t instanceof Timespan ) { return ( Timespan ) t ; } return Timespan . parse ( t . toString ( ) ) ; }'", "label": "'Converts the object into a timespan . If already a timespan then simply return the object . Otherwise call { @link Timespan#parse ( String ) } on <code > t . toString () < / code > . Works well for long and <code > String< / code >'"}
{"text": "'public static long toEndTime ( Clock clock , Object timeout ) { Timespan t = toTimespan ( timeout ) ; if ( t == null ) return 0 ; if ( clock == null ) clock = SystemClock . INSTANCE ; if ( t . getDurationInMilliseconds ( ) == 0 ) return 0 ; return t . futureTimeMillis ( clock ) ; }'", "label": "'Computes the end time = now + timeout'"}
{"text": "'public RAMEntry touch ( String name , long lastModifiedDate ) { RAMEntry ramEntry = _directoryContent . get ( name ) ; if ( ramEntry == null ) { ramEntry = add ( new RAMFile ( _clock , name , new byte [ 0 ] ) ) ; } ramEntry . touch ( lastModifiedDate ) ; return ramEntry ; }'", "label": "'Equivalent to touch unix command : updates the last modified date to the value provided and if the entry does not create it it creates an empty file!'"}
{"text": "'public RAMEntry add ( RAMEntry entry ) { touch ( ) ; _directoryContent . put ( entry . name ( ) , entry ) ; return entry ; }'", "label": "'Copy the entry in this directory with the provided name'"}
{"text": "'public RAMFile add ( String name , byte [ ] content ) { return ( RAMFile ) add ( new RAMFile ( _clock , name , content ) ) ; }'", "label": "'Creates a file with the content and add it to the directory with this name'"}
{"text": "'public RAMFile add ( String name , String content ) { try { return add ( name , content . getBytes ( \"UTF-8\" ) ) ; } catch ( UnsupportedEncodingException e ) { // should not happen throw new RuntimeException ( e ) ; } }'", "label": "'Creates a file with the content and add it to the directory with this name'"}
{"text": "'public RAMDirectory mkdir ( String name ) throws IOException { RAMEntry entry = getEntry ( name ) ; if ( entry instanceof RAMDirectory ) { RAMDirectory ramDirectory = ( RAMDirectory ) entry ; return ramDirectory ; } else { if ( entry == null ) { RAMDirectory directory = new RAMDirectory ( _clock , name ) ; return ( RAMDirectory ) add ( directory ) ; } else { throw new IOException ( \"File exists: \" + name ) ; } } }'", "label": "'Creates an empty directory and add it to this directory with this name . If the directory already exists it does not recreate it .'"}
{"text": "'public RAMDirectory mkdirhier ( String path ) throws IOException { RAMDirectory directory = this ; String [ ] pathComponents = path . split ( \"/\" ) ; for ( String pathComponent : pathComponents ) { // we skip empty path components (caused by leading / + double //) if ( pathComponent . equals ( \"\" ) ) continue ; RAMEntry entry = directory . getEntry ( pathComponent ) ; if ( entry == null ) { directory = directory . mkdir ( pathComponent ) ; } else { if ( entry instanceof RAMDirectory ) { directory = ( RAMDirectory ) entry ; } else { throw new IOException ( \"File exists: \" + pathComponent ) ; } } } return directory ; }'", "label": "'Creates an empty directory and add it to this directory with this path ( equivalent to unix command ) : create all intermediary directories'"}
{"text": "'@ Override protected Resource doCreateResource ( URI uri , URIResourceFactory parent ) { return FileResource . create ( new File ( \"/\" ) , uri . getPath ( ) ) ; }'", "label": "'Method that needs to be implemented by children ..'"}
{"text": "'@ Override public InternalResource doBuildResource ( String path ) { // since the list is not empty, this variable will never remain null... InternalResource resource = null ; for ( InternalResourceProvider resourceProvider : _resourceProviders ) { resource = resourceProvider . doBuildResource ( path ) ; if ( resource . exists ( ) ) break ; } return new ResourceChain ( this , path , resource ) ; }'", "label": "'Builds a resource given a path . Only subclasses know how to do that .'"}
{"text": "'@ Override public InternalResourceProvider doCreateResourceProvider ( String rootPath ) { List < InternalResourceProvider > resourceProviders = new ArrayList < InternalResourceProvider > ( _resourceProviders . size ( ) ) ; for ( InternalResourceProvider resourceProvider : _resourceProviders ) { resourceProviders . add ( resourceProvider . doCreateResourceProvider ( rootPath ) ) ; } return new ResourceProviderChain ( resourceProviders ) ; }'", "label": "'Creates a new resource provider given the new path .'"}
{"text": "'@ Override public boolean doList ( String path , final ResourceFilter filter ) { boolean isDirectory = false ; ResourceFilter newFilter = new ResourceFilter ( ) { @ Override public boolean accept ( Resource resource ) { return filter . accept ( new ResourceChain ( ResourceProviderChain . this , resource . getPath ( ) , resource ) ) ; } } ; for ( InternalResourceProvider resourceProvider : _resourceProviders ) { isDirectory |= resourceProvider . doList ( path , newFilter ) ; } return isDirectory ; }'", "label": "'If the path denotes a directory then it will return all resources that are contained in the directory .'"}
{"text": "'public static String encodeString ( OneWayCodec codec , String s ) { try { return codec . encode ( s . getBytes ( \"UTF-8\" ) ) ; } catch ( UnsupportedEncodingException ex ) { // shouldn\\'t happen throw new RuntimeException ( ex ) ; } }'", "label": "'Encodes the string using the codec provided .'"}
{"text": "'public static String decodeString ( Codec codec , String s ) throws Codec . CannotDecodeException { try { return new String ( codec . decode ( s ) , \"UTF-8\" ) ; } catch ( UnsupportedEncodingException ex ) { // shouldn\\'t happen throw new RuntimeException ( ex ) ; } }'", "label": "'Decodes the string using the codec provided . Returns a string'"}
{"text": "'public static Random createRandom ( String password ) { if ( password == null ) return null ; byte [ ] bytes ; try { MessageDigest md = MessageDigest . getInstance ( \"SHA-1\" ) ; bytes = md . digest ( password . getBytes ( \"UTF-8\" ) ) ; } catch ( NoSuchAlgorithmException e ) { // should not happen throw new RuntimeException ( e ) ; } catch ( UnsupportedEncodingException e ) { // should not happen throw new RuntimeException ( e ) ; } int len = bytes . length ; // we only take at most 6 bytes => 48 bits if ( len > 6 ) len = 6 ; long seed = 0 ; if ( len > 0 ) { seed = bytes [ 0 ] ; for ( int i = 1 ; i < len ; i ++ ) { seed <<= 8 ; seed |= bytes [ i ] ; } } int k = 0 ; for ( int i = len ; i < bytes . length ; i ++ ) { seed ^= ( ( ( long ) bytes [ i ] ) << ( k * 8 ) ) ; if ( k ++ == 5 ) k = 0 ; } return new Random ( seed ) ; }'", "label": "'Create a <code > Random< / code > object by extracting the seed from the password .'"}
{"text": "'public static String searchAndReplace ( String s , String src , String dst ) { if ( s == null ) return null ; StringBuilder result = new StringBuilder ( ) ; int i = 0 ; int len = s . length ( ) ; int len2 = src . length ( ) ; while ( i < len ) { int index = s . indexOf ( src , i ) ; if ( index == - 1 ) { if ( i == 0 ) return s ; result . append ( s . substring ( i ) ) ; break ; } result . append ( s . substring ( i , index ) ) ; result . append ( dst ) ; i = index + len2 ; } return result . toString ( ) ; }'", "label": "'Searches in the string <code > s< / code > all occurences of the substring <code > src< / code > and replaces it with the string <code > dst< / code > .'"}
{"text": "\"public static ClassLoader createChain ( List < ClassLoader > classLoaders , Boolean createNew ) { List < ClassLoader > list = new ArrayList < ClassLoader > ( classLoaders . size ( ) ) ; for ( ClassLoader classLoader : classLoaders ) { // we skip null class loaders if ( classLoader == null ) continue ; // we skip null class loaders if ( classLoader instanceof NullClassLoader ) continue ; // we 'flatten' the chain... no need to have a chain of a chain... if ( classLoader instanceof ClassLoaderChain ) { ClassLoaderChain classLoaderChain = ( ClassLoaderChain ) classLoader ; list . addAll ( classLoaderChain . _classLoaders ) ; } else { list . add ( classLoader ) ; } } if ( list . size ( ) == 0 ) return NullClassLoader . instance ( ) ; // remove duplicates ClassLoader previous = null ; Iterator < ClassLoader > iter = list . iterator ( ) ; while ( iter . hasNext ( ) ) { ClassLoader next = iter . next ( ) ; if ( next . equals ( previous ) ) iter . remove ( ) ; previous = next ; } //TODO: create a new entry point, and keeping old behavior unchanged.  if ( list . size ( ) == 1 && ! createNew ) return list . get ( 0 ) ; return new ClassLoaderChain ( list ) ; }\"", "label": "'Creates a chain of class loaders . Handles <code > null< / code > properly .'"}
{"text": "'private synchronized void init ( ) { // already initialized if ( _resourceInfo != null ) return ; // make a local copy of the file try { InputStream is = _resource . getInputStream ( ) ; try { File file = GCFile . createTempFile ( LocalCacheLeafResource . class . getName ( ) , _resource . getFilename ( ) ) ; FileOutputStream fos = new FileOutputStream ( file ) ; try { BufferedOutputStream out = new BufferedOutputStream ( fos ) ; IOUtils . copy ( new BufferedInputStream ( is ) , out ) ; out . flush ( ) ; } finally { fos . close ( ) ; } ResourceInfo info = _resource . getInfo ( ) ; _localFile = file ; _resourceInfo = new StaticInfo ( info . getContentLength ( ) , info . getLastModified ( ) ) ; _ioException = null ; } finally { is . close ( ) ; } } catch ( IOException e ) { _localFile = null ; _resourceInfo = new StaticInfo ( 0 , 0 ) ; _ioException = e ; } }'", "label": "'Initializes the fields ( safe to call multiple times ) . Thread safe .'"}
{"text": "'public static LeafResource create ( Resource resource ) { try { // if we can access the file then there is no reason to decorate it... resource . getFile ( ) ; return new LeafResourceImpl ( resource ) ; } catch ( IOException e ) { return new LocalCacheLeafResource ( resource ) ; } }'", "label": "'Decorates the resource to implement a caching strategy .'"}
{"text": "'public static < T > T [ ] reverse ( T [ ] array ) { if ( array == null ) return array ; int s = 0 ; int e = array . length - 1 ; while ( s < e ) { // swap index e and s T tmp = array [ e ] ; array [ e ] = array [ s ] ; array [ s ] = tmp ; s ++ ; e -- ; } return array ; }'", "label": "'Reverses the array in place .'"}
{"text": "'public static < T extends Enum < T > > EnumSet < T > toEnumSet ( Class < T > clazz , T ... ts ) { if ( ts == null ) return null ; EnumSet < T > res = EnumSet . noneOf ( clazz ) ; for ( T t : ts ) { res . add ( t ) ; } return res ; }'", "label": "'Turns an array of enumeration values into an enum set'"}
{"text": "'public static Properties loadProperties ( File file ) throws IOException { if ( file == null ) return null ; FileReader reader = new FileReader ( file ) ; try { return loadProperties ( reader ) ; } finally { reader . close ( ) ; } }'", "label": "'Convenient call to load a properties file from the provided file'"}
{"text": "'public static Properties loadProperties ( Reader reader ) throws IOException { if ( reader == null ) return null ; Properties properties = new Properties ( ) ; properties . load ( reader ) ; return properties ; }'", "label": "'Convenient call to load a properties file from the provided reader'"}
{"text": "'public Timespan add ( Timespan other ) { if ( getTimeUnit ( ) == other . getTimeUnit ( ) ) return new Timespan ( getDuration ( ) + other . getDuration ( ) , getTimeUnit ( ) ) ; return new Timespan ( getDurationInMilliseconds ( ) + other . getDurationInMilliseconds ( ) , TimeUnit . MILLISECOND ) ; }'", "label": "'Adds another timespan to this timespan and return a brand new one . Note that the unit is preserved if <code > other< / code > has the same unit as this .'"}
{"text": "'public EnumMap < TimeUnit , Timespan > getAsTimespans ( TimeUnit ... timeUnits ) { return getAsTimespans ( CollectionsUtils . toEnumSet ( TimeUnit . class , timeUnits ) ) ; }'", "label": "'Decomposes this timespan as a map for each unit provided . Example : if this timespan represents 63s and you provide m / s / ms then you will get 3 timespans in the map : one of 1mn one for 3s and one for 0ms . ( Convenient call ) .'"}
{"text": "'public String getAsString ( EnumSet < TimeUnit > timeUnits ) { StringBuilder sb = new StringBuilder ( ) ; EnumMap < TimeUnit , Timespan > canonicalTimespans = getAsTimespans ( timeUnits ) ; for ( TimeUnit timeUnit : TIME_UNIT_ORDER ) { if ( canonicalTimespans . containsKey ( timeUnit ) ) { long duration = canonicalTimespans . get ( timeUnit ) . getDuration ( ) ; if ( duration > 0 ) { sb . append ( duration ) . append ( timeUnit . getDisplayChar ( ) ) ; } } } if ( sb . length ( ) == 0 ) { sb . append ( 0 ) ; if ( timeUnits . contains ( getTimeUnit ( ) ) ) sb . append ( getTimeUnit ( ) . getDisplayChar ( ) ) ; } return sb . toString ( ) ; }'", "label": "'Returns a string representing this timespan expressed with the units provided .'"}
{"text": "'@ Override public int compareTo ( Timespan timespan ) { if ( timespan . getTimeUnit ( ) == getTimeUnit ( ) ) return LangUtils . compare ( getDuration ( ) , timespan . getDuration ( ) ) ; else return LangUtils . compare ( getDurationInMilliseconds ( ) , timespan . getDurationInMilliseconds ( ) ) ; }'", "label": "'Compares 2 timespan . Based on duration in milliseconds .'"}
{"text": "'public static Timespan parseTimespan ( String timespan ) { if ( timespan == null ) return null ; int len = timespan . length ( ) ; if ( len == 0 ) return ZERO_MILLISECONDS ; int count = 0 ; int timeUnitOrderIdx = 0 ; int timeUnitOrderLen = TIME_UNIT_ORDER . length ; Timespan [ ] timespans = new Timespan [ timeUnitOrderLen ] ; int startDigitsIdx = 0 ; boolean expectingDigits = true ; for ( int i = 0 ; i < len ; i ++ ) { char c = timespan . charAt ( i ) ; if ( c >= \\' \\' && c <= \\' \\' ) { expectingDigits = false ; continue ; } if ( expectingDigits ) throw new IllegalArgumentException ( \"found \" + c + \" was expecting a digit\" ) ; for ( ; timeUnitOrderIdx < timeUnitOrderLen ; timeUnitOrderIdx ++ ) { TimeUnit timeUnit = TIME_UNIT_ORDER [ timeUnitOrderIdx ] ; String displayChar = timeUnit . getDisplayChar ( ) ; if ( displayChar . length ( ) == 0 ) throw new IllegalArgumentException ( \"found nothing was expecting: \" + c ) ; if ( c == displayChar . charAt ( 0 ) ) { try { long duration = Long . parseLong ( timespan . substring ( startDigitsIdx , i ) ) ; timespans [ timeUnitOrderIdx ++ ] = new Timespan ( duration , timeUnit ) ; startDigitsIdx = i + 1 ; expectingDigits = true ; count ++ ; break ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( e ) ; } } } } if ( startDigitsIdx < len ) { try { long duration = Long . parseLong ( timespan . substring ( startDigitsIdx , len ) ) ; timespans [ timeUnitOrderLen - 1 ] = new Timespan ( duration , TimeUnit . MILLISECOND ) ; count ++ ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( e ) ; } } Timespan [ ] ts = new Timespan [ count ] ; for ( int i = 0 , idx = 0 ; i < timespans . length ; i ++ ) { Timespan t = timespans [ i ] ; if ( t != null ) ts [ idx ++ ] = t ; } return create ( ts ) ; }'", "label": "'Parses the provided string as a timespan . It should follow the pattern returned by { @link #getCanonicalString () } . Example : 10m30s'"}
{"text": "'public String getFractionalSizeAsString ( ) { if ( _size == 0 ) return \"0\" ; long sizeInBytes = getSizeInBytes ( ) ; // determine the biggest size unit with non 0 size for ( SizeUnit sizeUnit : ORDERED_SIZE_UNIT ) { if ( sizeUnit == SizeUnit . BYTE ) return String . valueOf ( sizeInBytes ) ; if ( sizeInBytes >= sizeUnit . getBytesCount ( ) ) { double fractionalSize = ( double ) sizeInBytes / sizeUnit . getBytesCount ( ) ; return String . format ( \"%.2f%s\" , fractionalSize , sizeUnit . getDisplayChar ( ) ) ; } } throw new RuntimeException ( \"should not reach this line...\" ) ; }'", "label": "'Returns this memory size as a fractional size representation using the biggest unit size possible . ex : 1 . 23g'"}
{"text": "'public MemorySize truncate ( SizeUnit sizeUnit ) { if ( getSizeUnit ( ) == sizeUnit ) return this ; long sizeInBytes = getSizeInBytes ( ) ; if ( sizeInBytes >= sizeUnit . getBytesCount ( ) ) { return new MemorySize ( sizeInBytes / sizeUnit . getBytesCount ( ) , sizeUnit ) ; } else { return ZERO_SIZES . get ( sizeUnit ) ; } }'", "label": "'Return a new instance of MemorySize that is truncated to the given unit'"}
{"text": "'public MemorySize add ( MemorySize other ) { if ( other == null ) throw new NullPointerException ( ) ; if ( getSizeUnit ( ) == other . getSizeUnit ( ) ) return new MemorySize ( getSize ( ) + other . getSize ( ) , getSizeUnit ( ) ) ; return new MemorySize ( getSizeInBytes ( ) + other . getSizeInBytes ( ) , SizeUnit . BYTE ) ; }'", "label": "'Return a new instance of MemorySize that adds up the size of this object with that of the other'"}
{"text": "'public String getAsString ( SizeUnit ... sizeUnits ) { if ( sizeUnits == null || sizeUnits . length == 0 ) return toString ( ) ; return getAsString ( CollectionsUtils . toEnumSet ( SizeUnit . class , sizeUnits ) ) ; }'", "label": "'Return a string representation of this instance using the given units E . g . 2g3m4k given units g / m - > 2g3m 2g3m4k given units g / k - > 2g3076k 3m4k given units t / g - > 0g 2g3m given units k / b - > 2100224k'"}
{"text": "'public String getAsString ( EnumSet < SizeUnit > sizeUnits ) { if ( sizeUnits == null || sizeUnits . size ( ) == 0 ) return toString ( ) ; StringBuilder sb = new StringBuilder ( ) ; MemorySize ms = this ; MemorySize prevMs ; // IMPORTANT:  // according to javadoc for EnumSet: // \"The iterator returned by the iteratormethod traverses the elements in their natural order  // (the order in which the enum constants are declared)\" and the toArray() method of AbstractCollection // guarantees such an order Object [ ] unitsAsArr = sizeUnits . toArray ( ) ; int len = unitsAsArr . length ; for ( int i = len - 1 ; i > - 1 ; i -- ) { prevMs = ms ; ms = ms . truncate ( ( SizeUnit ) unitsAsArr [ i ] ) ; if ( ms . getSize ( ) > 0 ) { sb . append ( ms . getSize ( ) ) . append ( ms . getSizeUnit ( ) . getDisplayChar ( ) ) ; } ms = prevMs . subtract ( ms ) ; } if ( sb . length ( ) == 0 ) { SizeUnit smallestUnit = ( SizeUnit ) unitsAsArr [ 0 ] ; sb . append ( \"0\" ) . append ( smallestUnit . getDisplayChar ( ) ) ; } return sb . toString ( ) ; }'", "label": "'Return a string representation of this instance using the given units E . g . 2g3m4k given units g / m - > 2g3m 2g3m4k given units g / k - > 2g3076k 3m4k given units t / g - > 0g 2g3m given units k / b - > 2100224k'"}
{"text": "'@ Override public int compareTo ( MemorySize memorySize ) { // according to javadoc for interface Comparable<T>, a NullPointerException // should be thrown when the object to be compared with is null // http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Comparable.html#compareTo(T) if ( memorySize == null ) throw new NullPointerException ( ) ; if ( getSizeUnit ( ) == memorySize . getSizeUnit ( ) ) return LangUtils . compare ( getSize ( ) , memorySize . getSize ( ) ) ; return LangUtils . compare ( getSizeInBytes ( ) , memorySize . getSizeInBytes ( ) ) ; }'", "label": "'Compare with another instance of MemorySize based on size in bytes'"}
{"text": "'public static MemorySize create ( MemorySize ... memorySizes ) { if ( memorySizes == null ) return null ; if ( memorySizes . length == 0 ) return ZERO_BYTES ; MemorySize res = memorySizes [ 0 ] ; for ( int i = 1 ; i < memorySizes . length ; i ++ ) { MemorySize memorySize = memorySizes [ i ] ; if ( memorySize != null ) res = res . add ( memorySize ) ; } return res ; }'", "label": "'Create a new instance of MemorySize by adding up the given array of memorySizes'"}
{"text": "'public static MemorySize parseMemorySize ( String memorySizeAsStr ) { if ( memorySizeAsStr == null || memorySizeAsStr . length ( ) == 0 ) return null ; int len = memorySizeAsStr . length ( ) ; int orderedSizeUnitIdx = 0 ; int orderedSizeUnitLen = ORDERED_SIZE_UNIT . length ; int startDigitsIdx = 0 ; boolean expectingDigits = true ; MemorySize ms = ZERO_BYTES ; for ( int i = 0 ; i < len ; i ++ ) { char c = memorySizeAsStr . charAt ( i ) ; if ( c >= \\' \\' && c <= \\' \\' ) { expectingDigits = false ; continue ; } if ( expectingDigits ) throw new IllegalArgumentException ( \"Unable to parse \\'\" + memorySizeAsStr + \"\\': found \\'\" + c + \"\\' at pos \" + i + \", was expecting a digit\" ) ; for ( ; orderedSizeUnitIdx < orderedSizeUnitLen ; orderedSizeUnitIdx ++ ) { SizeUnit sizeUnit = ORDERED_SIZE_UNIT [ orderedSizeUnitIdx ] ; String displayChar = sizeUnit . getDisplayChar ( ) ; if ( displayChar . length ( ) > 0 && c == displayChar . charAt ( 0 ) ) { try { long size = Long . parseLong ( memorySizeAsStr . substring ( startDigitsIdx , i ) ) ; ms = ms . add ( new MemorySize ( size , sizeUnit ) ) ; orderedSizeUnitIdx ++ ; startDigitsIdx = i + 1 ; expectingDigits = true ; break ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( \"Unable to parse \\'\" + memorySizeAsStr + \"\\'\" , e ) ; } } } if ( orderedSizeUnitIdx == orderedSizeUnitLen ) throw new IllegalArgumentException ( \"Unable to parse \\'\" + memorySizeAsStr + \"\\': found invalid character \\'\" + c + \"\\' at pos \" + i ) ; } if ( startDigitsIdx < len ) { try { long size = Long . parseLong ( memorySizeAsStr . substring ( startDigitsIdx , len ) ) ; ms = ms . add ( new MemorySize ( size , SizeUnit . BYTE ) ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( \"Unable to parse \\'\" + memorySizeAsStr + \"\\'\" , e ) ; } } return ms ; }'", "label": "'Create a new instance of MemorySize by parsing the given string of format e . g . 2g3m4k5'"}
{"text": "'public static < V > Future < V > execute ( Callable < V > callable ) { FutureTask < V > futureTask = new FutureTask < V > ( callable ) ; new Thread ( futureTask ) . start ( ) ; return futureTask ; }'", "label": "'Executes the callable in a separate thread and return the future to get the result . Note that this implementation is not efficient and should be used very carefully .'"}
{"text": "'private ArrayList < IconMarker > createIconMarkers ( ) { final ArrayList < IconMarker > iconMarkers = new ArrayList <> ( LOCATIONS . length ) ; iconMarkers . add ( new IconMarker ( LOCATIONS [ 0 ] , R . drawable . bread , R . drawable . bread_c ) ) ; iconMarkers . add ( new IconMarker ( LOCATIONS [ 1 ] , R . drawable . butcher , R . drawable . butcher_c ) ) ; iconMarkers . add ( new IconMarker ( LOCATIONS [ 2 ] , R . drawable . fruits , R . drawable . fruits_c ) ) ; iconMarkers . add ( new IconMarker ( LOCATIONS [ 3 ] , R . drawable . grocery , R . drawable . grocery_c ) ) ; iconMarkers . add ( new IconMarker ( LOCATIONS [ 4 ] , R . drawable . patisserie , R . drawable . patisserie_c ) ) ; return iconMarkers ; }'", "label": "'Icons courtesy of https : // mapicons . mapsmarker . com /'"}
{"text": "'public void addMarker ( T marker ) { final MarkerOptions markerOptions = new MarkerOptions ( ) ; marker . setMarkerManager ( this ) ; marker . prepareMarker ( markerOptions ) ; markerCache . put ( marker , googleMap . addMarker ( markerOptions ) ) ; marker . onAdd ( ) ; }'", "label": "'Add a marker to the map .'"}
{"text": "'public void removeMarker ( T marker ) { final Marker realMarker = markerCache . get ( marker ) ; if ( realMarker != null ) { realMarker . remove ( ) ; } markerCache . remove ( marker ) ; }'", "label": "'Remove a marker from the map .'"}
{"text": "'public static BitmapDescriptor fromView ( View view ) { // TODO: Single views have trouble with measure. final int spec = View . MeasureSpec . makeMeasureSpec ( 0 , View . MeasureSpec . UNSPECIFIED ) ; view . measure ( spec , spec ) ; final int width = view . getMeasuredWidth ( ) ; final int height = view . getMeasuredHeight ( ) ; view . layout ( 0 , 0 , width , height ) ; final Bitmap bitmap = Bitmap . createBitmap ( width , height , Bitmap . Config . ARGB_8888 ) ; final Canvas canvas = new Canvas ( bitmap ) ; view . draw ( canvas ) ; return BitmapDescriptorFactory . fromBitmap ( bitmap ) ; }'", "label": "'Returns a bitmap icon showing a screenshot of the view passed in .'"}
{"text": "\"public final static Observable < byte [ ] > tailFile ( File file , long startPosition , long sampleTimeMs , int chunkSize ) { Preconditions . checkNotNull ( file ) ; Observable < Object > events = from ( file , StandardWatchEventKinds . ENTRY_CREATE , StandardWatchEventKinds . ENTRY_MODIFY , StandardWatchEventKinds . OVERFLOW ) // don't care about the event details, just that there // is one . cast ( Object . class ) // get lines once on subscription so we tail the lines // in the file at startup . startWith ( new Object ( ) ) ; return tailFile ( file , startPosition , sampleTimeMs , chunkSize , events ) ; }\"", "label": "'Returns an { @link Observable } that uses NIO { @link WatchService } ( and a dedicated thread ) to push modified events to an observable that reads and reports new sequences of bytes to a subscriber . The NIO { @link WatchService } events are sampled according to <code > sampleTimeMs< / code > so that lots of discrete activity on a file ( for example a log file with very frequent entries ) does not prompt an inordinate number of file reads to pick up changes .'"}
{"text": "'public final static Observable < byte [ ] > tailFile ( File file , long startPosition , long sampleTimeMs , int chunkSize , Observable < ? > events ) { Preconditions . checkNotNull ( file ) ; return sampleModifyOrOverflowEventsOnly ( events , sampleTimeMs ) // tail file triggered by events . lift ( new OperatorFileTailer ( file , startPosition , chunkSize ) ) ; }'", "label": "'Returns an { @link Observable } that uses given given observable to push modified events to an observable that reads and reports new sequences of bytes to a subscriber . The NIO { @link WatchService } MODIFY and OVERFLOW events are sampled according to <code > sampleTimeMs< / code > so that lots of discrete activity on a file ( for example a log file with very frequent entries ) does not prompt an inordinate number of file reads to pick up changes . File create events are not sampled and are always passed through .'"}
{"text": "'public final static Observable < String > tailTextFile ( File file , long startPosition , long sampleTimeMs , Charset charset ) { return toLines ( tailFile ( file , startPosition , sampleTimeMs , DEFAULT_MAX_BYTES_PER_EMISSION ) , charset ) ; }'", "label": "'Returns an { @link Observable } that uses NIO { @link WatchService } ( and a dedicated thread ) to push modified events to an observable that reads and reports new lines to a subscriber . The NIO WatchService MODIFY and OVERFLOW events are sampled according to <code > sampleTimeMs< / code > so that lots of discrete activity on a file ( for example a log file with very frequent entries ) does not prompt an inordinate number of file reads to pick up changes . File create events are not sampled and are always passed through .'"}
{"text": "'public final static Observable < String > tailTextFile ( File file , long startPosition , int chunkSize , Charset charset , Observable < ? > events ) { Preconditions . checkNotNull ( file ) ; Preconditions . checkNotNull ( charset ) ; Preconditions . checkNotNull ( events ) ; return toLines ( events . lift ( new OperatorFileTailer ( file , startPosition , chunkSize ) ) . onBackpressureBuffer ( ) , charset ) ; }'", "label": "'Returns an { @link Observable } of String that uses the given events stream to trigger checks on file change so that new lines can be read and emitted .'"}
{"text": "'public final static Observable < WatchEvent < ? > > from ( WatchService watchService , Scheduler scheduler , long pollDuration , TimeUnit pollDurationUnit , long pollInterval , TimeUnit pollIntervalUnit , BackpressureStrategy backpressureStrategy ) { Preconditions . checkNotNull ( watchService ) ; Preconditions . checkNotNull ( scheduler ) ; Preconditions . checkNotNull ( pollDurationUnit ) ; Preconditions . checkNotNull ( backpressureStrategy ) ; Observable < WatchEvent < ? > > o = Observable . create ( new OnSubscribeWatchServiceEvents ( watchService , scheduler , pollDuration , pollDurationUnit , pollInterval , pollIntervalUnit ) ) ; if ( backpressureStrategy == BackpressureStrategy . BUFFER ) { return o . onBackpressureBuffer ( ) ; } else if ( backpressureStrategy == BackpressureStrategy . DROP ) return o . onBackpressureDrop ( ) ; else if ( backpressureStrategy == BackpressureStrategy . LATEST ) return o . onBackpressureLatest ( ) ; else throw new RuntimeException ( \"unrecognized backpressureStrategy \" + backpressureStrategy ) ; }'", "label": "'Returns an { @link Observable } of { @link WatchEvent } s from a { @link WatchService } .'"}
{"text": "'public final static Observable < WatchEvent < ? > > from ( WatchService watchService ) { return from ( watchService , rx . schedulers . Schedulers . trampoline ( ) , Long . MAX_VALUE , TimeUnit . MILLISECONDS , 0 , TimeUnit . SECONDS , BackpressureStrategy . BUFFER ) ; }'", "label": "'Returns an { @link Observable } of { @link WatchEvent } s from a { @link WatchService } .'"}
{"text": "'@ SafeVarargs public final static Observable < WatchEvent < ? > > from ( final File file , Kind < ? > ... kinds ) { return from ( file , null , kinds ) ; }'", "label": "'If file does not exist at subscribe time then is assumed to not be a directory . If the file is not a directory ( bearing in mind the aforesaid assumption ) then a { @link WatchService } is set up on its parent and { @link WatchEvent } s of the given kinds are filtered to concern the file in question . If the file is a directory then a { @link WatchService } is set up on the directory and all events are passed through of the given kinds .'"}
{"text": "'public final static Observable < WatchEvent < ? > > from ( final File file , List < Kind < ? > > kinds ) { return from ( file , null , kinds . toArray ( new Kind < ? > [ ] { } ) ) ; }'", "label": "'If file does not exist at subscribe time then is assumed to not be a directory . If the file is not a directory ( bearing in mind the aforesaid assumption ) then a { @link WatchService } is set up on its parent and { @link WatchEvent } s of the given kinds are filtered to concern the file in question . If the file is a directory then a { @link WatchService } is set up on the directory and all events are passed through of the given kinds .'"}
{"text": "'public final static Observable < WatchEvent < ? > > from ( final File file , final Action0 onWatchStarted , Kind < ? > ... kinds ) { return watchService ( file , kinds ) // when watch service created call onWatchStarted . doOnNext ( new Action1 < WatchService > ( ) { @ Override public void call ( WatchService w ) { if ( onWatchStarted != null ) onWatchStarted . call ( ) ; } } ) // emit events from the WatchService . flatMap ( TO_WATCH_EVENTS ) // restrict to events related to the file . filter ( onlyRelatedTo ( file ) ) ; }'", "label": "'If file does not exist at subscribe time then is assumed to not be a directory . If the file is not a directory ( bearing in mind the aforesaid assumption ) then a { @link WatchService } is set up on its parent and { @link WatchEvent } s of the given kinds are filtered to concern the file in question . If the file is a directory then a { @link WatchService } is set up on the directory and all events are passed through of the given kinds .'"}
{"text": "'@ SafeVarargs public final static Observable < WatchService > watchService ( final File file , final Kind < ? > ... kinds ) { return Observable . defer ( new Func0 < Observable < WatchService > > ( ) { @ Override public Observable < WatchService > call ( ) { try { final Path path = getBasePath ( file ) ; WatchService watchService = path . getFileSystem ( ) . newWatchService ( ) ; path . register ( watchService , kinds ) ; return Observable . just ( watchService ) ; } catch ( Exception e ) { return Observable . error ( e ) ; } } } ) ; }'", "label": "'Creates a { @link WatchService } on subscribe for the given file and event kinds .'"}
{"text": "'private final static Func1 < WatchEvent < ? > , Boolean > onlyRelatedTo ( final File file ) { return new Func1 < WatchEvent < ? > , Boolean > ( ) { @ Override public Boolean call ( WatchEvent < ? > event ) { final boolean ok ; if ( file . isDirectory ( ) ) ok = true ; else if ( StandardWatchEventKinds . OVERFLOW . equals ( event . kind ( ) ) ) ok = true ; else { Object context = event . context ( ) ; if ( context != null && context instanceof Path ) { Path p = ( Path ) context ; Path basePath = getBasePath ( file ) ; File pFile = new File ( basePath . toFile ( ) , p . toString ( ) ) ; ok = pFile . getAbsolutePath ( ) . equals ( file . getAbsolutePath ( ) ) ; } else ok = false ; } return ok ; } } ; }'", "label": "'Returns true if and only if the path corresponding to a WatchEvent represents the given file . This will be the case for Create Modify Delete events .'"}
{"text": "'private static boolean emitEvents ( WatchService watchService , Subscriber < ? super WatchEvent < ? > > subscriber , long pollDurationMs , long pollIntervalMs ) { // get the first event WatchKey key = nextKey ( watchService , subscriber , pollDurationMs ) ; if ( key != null ) { if ( subscriber . isUnsubscribed ( ) ) return false ; // we have a polled event, now we traverse it and // receive all the states from it for ( WatchEvent < ? > event : key . pollEvents ( ) ) { if ( subscriber . isUnsubscribed ( ) ) return false ; else subscriber . onNext ( event ) ; } boolean valid = key . reset ( ) ; if ( ! valid && ! subscriber . isUnsubscribed ( ) ) { subscriber . onCompleted ( ) ; return false ; } else if ( ! valid ) return false ; } return true ; }'", "label": "'returns true if and only there may be more events'"}
{"text": "'private StateListDrawable getSelectorDrawable ( ) { StateListDrawable d = null ; try { d = new StateListDrawable ( ) ; ShapeDrawable selectedDrawable = new ShapeDrawable ( new OvalShape ( ) ) ; selectedDrawable . getPaint ( ) . setColor ( mItemSelectedColor ) ; selectedDrawable . setIntrinsicHeight ( mItemRadius * 2 ) ; selectedDrawable . setIntrinsicWidth ( mItemRadius * 2 ) ; ShapeDrawable unselectedDrawable = new ShapeDrawable ( new OvalShape ( ) ) ; unselectedDrawable . getPaint ( ) . setColor ( mItemUnselectedColor ) ; unselectedDrawable . setIntrinsicHeight ( mItemRadius * 2 ) ; unselectedDrawable . setIntrinsicWidth ( mItemRadius * 2 ) ; d . addState ( new int [ ] { android . R . attr . state_checked } , selectedDrawable ) ; d . addState ( new int [ ] { } , unselectedDrawable ) ; } catch ( Exception e ) { Log . e ( TAG , getMessageFor ( e ) ) ; } return d ; }'", "label": "'Create a StateListDrawable for the pager indicator'"}
{"text": "'public void initWithViewPager ( ViewPager viewPager ) throws IllegalStateException { if ( viewPager == null ) return ; if ( viewPager . getAdapter ( ) == null ) throw new IllegalStateException ( \"ViewPager has no adapter set.\" ) ; try { mViewPager = viewPager ; mViewPager . addOnPageChangeListener ( mOnPageChangeListener ) ; addViews ( ) ; } catch ( Exception e ) { Log . e ( TAG , getMessageFor ( e ) ) ; } }'", "label": "'Initialize ViewPagerIndicator with a properly set up ViewPager'"}
{"text": "'private void addViews ( ) { try { if ( mViewPager == null || mViewPager . getAdapter ( ) == null || mViewPager . getAdapter ( ) . getCount ( ) == 0 ) return ; removeAllViews ( ) ; AppCompatRadioButton firstItem = new AppCompatRadioButton ( getContext ( ) ) ; firstItem . setText ( \"\" ) ; firstItem . setButtonDrawable ( mButtonDrawable . getConstantState ( ) . newDrawable ( ) ) ; ViewPagerIndicator . LayoutParams params = new LayoutParams ( LayoutParams . WRAP_CONTENT , LayoutParams . WRAP_CONTENT ) ; firstItem . setLayoutParams ( params ) ; firstItem . setClickable ( false ) ; addView ( firstItem ) ; for ( int i = 1 ; i < mViewPager . getAdapter ( ) . getCount ( ) ; i ++ ) { AppCompatRadioButton item = new AppCompatRadioButton ( getContext ( ) ) ; item . setText ( \"\" ) ; item . setButtonDrawable ( mButtonDrawable . getConstantState ( ) . newDrawable ( ) ) ; params = new LayoutParams ( LayoutParams . WRAP_CONTENT , LayoutParams . WRAP_CONTENT ) ; params . setMargins ( mItemDividerWidth , 0 , 0 , 0 ) ; item . setLayoutParams ( params ) ; item . setClickable ( false ) ; addView ( item ) ; } check ( firstItem . getId ( ) ) ; } catch ( Exception e ) { Log . e ( TAG , getMessageFor ( e ) ) ; } }'", "label": "'Add page indicators based on the attached ViewPager'"}
{"text": "'private String getMessageFor ( Exception e ) { if ( e == null ) return TAG + \": No Message.\" ; return e != null && e . getMessage ( ) != null ? e . getMessage ( ) : e . getClass ( ) . getName ( ) + \": No Message.\" ; }'", "label": "'Always get a message for an exception'"}
{"text": "'private void constructFromLongs ( long hi , long lo ) { content [ 0 ] = ( byte ) ( hi >> 56 ) ; content [ 1 ] = ( byte ) ( hi >> 48 ) ; content [ 2 ] = ( byte ) ( hi >> 40 ) ; content [ 3 ] = ( byte ) ( hi >> 32 ) ; content [ 4 ] = ( byte ) ( hi >> 24 ) ; content [ 5 ] = ( byte ) ( hi >> 16 ) ; content [ 6 ] = ( byte ) ( hi >> 8 ) ; content [ 7 ] = ( byte ) ( hi ) ; content [ 8 ] = ( byte ) ( lo >> 56 ) ; content [ 9 ] = ( byte ) ( lo >> 48 ) ; content [ 10 ] = ( byte ) ( lo >> 40 ) ; content [ 11 ] = ( byte ) ( lo >> 32 ) ; content [ 12 ] = ( byte ) ( lo >> 24 ) ; content [ 13 ] = ( byte ) ( lo >> 16 ) ; content [ 14 ] = ( byte ) ( lo >> 8 ) ; content [ 15 ] = ( byte ) ( lo ) ; }'", "label": "'This method sets the content based on the values of two longs representing the first and second half of the UUID . This method is called from the UUID ( java . util . UUID ) and UUID ( long long ) constructors .'"}
{"text": "\"public static boolean isValidUUID ( char [ ] ch ) { return ch != null && ch . length == 36 && validHex ( ch [ 0 ] ) && validHex ( ch [ 1 ] ) && validHex ( ch [ 2 ] ) && validHex ( ch [ 3 ] ) && validHex ( ch [ 4 ] ) && validHex ( ch [ 5 ] ) && validHex ( ch [ 6 ] ) && validHex ( ch [ 7 ] ) && ch [ 8 ] == ' ' && validHex ( ch [ 9 ] ) && validHex ( ch [ 10 ] ) && validHex ( ch [ 11 ] ) && validHex ( ch [ 12 ] ) && ch [ 13 ] == ' ' && validHex ( ch [ 14 ] ) && validHex ( ch [ 15 ] ) && validHex ( ch [ 16 ] ) && validHex ( ch [ 17 ] ) && ch [ 18 ] == ' ' && validHex ( ch [ 19 ] ) && validHex ( ch [ 20 ] ) && validHex ( ch [ 21 ] ) && validHex ( ch [ 22 ] ) && ch [ 23 ] == ' ' && validHex ( ch [ 24 ] ) && validHex ( ch [ 25 ] ) && validHex ( ch [ 26 ] ) && validHex ( ch [ 27 ] ) && validHex ( ch [ 28 ] ) && validHex ( ch [ 29 ] ) && validHex ( ch [ 30 ] ) && validHex ( ch [ 31 ] ) && validHex ( ch [ 32 ] ) && validHex ( ch [ 33 ] ) && validHex ( ch [ 34 ] ) && validHex ( ch [ 35 ] ) ; }\"", "label": "'This method validates a character array as the expected format for a printed representation of a UUID . The expected format is 36 characters long with - at the 8th 13th 18th and 23rd characters . The remaining characters are expected to be valid hex meaning in the range ( 0 - 9 a - f A - F ) inclusive . If a character array is valid then it can be used to construct a UUID . This method has been written unrolled and verbosely with the theory that this is simpler and faster than using loops or a regex .'"}
{"text": "'public static void useSequentialIds ( ) { if ( ! sequential ) { // get string that changes every 10 minutes TimeZone tz = TimeZone . getTimeZone ( \"UTC\" ) ; DateFormat df = new SimpleDateFormat ( \"yyyyMMddHHmm\" ) ; df . setTimeZone ( tz ) ; String date = df . format ( new Date ( ) ) . substring ( 0 , 11 ) ; // run an md5 hash of the string, no reason this needs to be secure byte [ ] digest ; try { MessageDigest md = MessageDigest . getInstance ( \"MD5\" ) ; digest = md . digest ( date . getBytes ( \"UTF-8\" ) ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Could not create hash of date for the sequential counter\" , e ) ; } // create integer from first 4 bytes of md5 hash int x ; x = ( ( int ) digest [ 0 ] & 0xFF ) ; x |= ( ( int ) digest [ 1 ] & 0xFF ) << 8 ; x |= ( ( int ) digest [ 2 ] & 0xFF ) << 16 ; x |= ( ( int ) digest [ 3 ] & 0xFF ) << 24 ; COUNTER . set ( x ) ; } sequential = true ; }'", "label": "'Toggle UUID generator into sequential mode so the random segment is in order and increases by one . In sequential mode there is presumably a desire that UUIDs generated around the same time should begin with similar characters but this is difficult in a distributed environment . The solution is to set the counter value based on a hash of the UTC date and time up to a 10 minute precision . This means that UUID classes initialized at similar times should start with similar counter values but this is not guaranteed . If one of these classes is generating vastly more UUIDs than others then these counters can become skewed .'"}
{"text": "'private static int intValue ( char x ) { if ( x >= \\' \\' && x <= \\' \\' ) return x - \\' \\' ; if ( x >= \\' \\' && x <= \\' \\' ) return x - \\' \\' + 10 ; if ( x >= \\' \\' && x <= \\' \\' ) return x - \\' \\' + 10 ; throw new RuntimeException ( \"Error parsing UUID at character: \" + x ) ; }'", "label": "'This method maps a hex character to its 4 - bit representation in an int .'"}
{"text": "'private static byte mapToByte ( char a , char b ) { int ai = intValue ( a ) ; int bi = intValue ( b ) ; return ( byte ) ( ( ai << 4 ) | bi ) ; }'", "label": "'Map two hex characters to 4 - bit numbers and combine them to produce 8 - bit number in byte .'"}
{"text": "'public long getMostSignificantBits ( ) { long a ; a = ( ( long ) content [ 0 ] & 0xFF ) << 56 ; a |= ( ( long ) content [ 1 ] & 0xFF ) << 48 ; a |= ( ( long ) content [ 2 ] & 0xFF ) << 40 ; a |= ( ( long ) content [ 3 ] & 0xFF ) << 32 ; a |= ( ( long ) content [ 4 ] & 0xFF ) << 24 ; a |= ( ( long ) content [ 5 ] & 0xFF ) << 16 ; a |= ( ( long ) content [ 6 ] & 0xFF ) << 8 ; a |= ( ( long ) content [ 7 ] & 0xFF ) ; return a ; }'", "label": "'Get the most significant bits ( the first half ) of the UUID content as a 64 - bit long .'"}
{"text": "'public long getLeastSignificantBits ( ) { long b ; b = ( ( long ) content [ 8 ] & 0xFF ) << 56 ; b |= ( ( long ) content [ 9 ] & 0xFF ) << 48 ; b |= ( ( long ) content [ 10 ] & 0xFF ) << 40 ; b |= ( ( long ) content [ 11 ] & 0xFF ) << 32 ; b |= ( ( long ) content [ 12 ] & 0xFF ) << 24 ; b |= ( ( long ) content [ 13 ] & 0xFF ) << 16 ; b |= ( ( long ) content [ 14 ] & 0xFF ) << 8 ; b |= ( ( long ) content [ 15 ] & 0xFF ) ; return b ; }'", "label": "'Get the least significant bits ( the second half ) of the UUID content as a 64 - bit long .'"}
{"text": "'public Date getTimestamp ( ) { if ( getVersion ( ) != VERSION ) return null ; long time ; time = ( ( long ) content [ 10 ] & 0xFF ) << 40 ; time |= ( ( long ) content [ 11 ] & 0xFF ) << 32 ; time |= ( ( long ) content [ 12 ] & 0xFF ) << 24 ; time |= ( ( long ) content [ 13 ] & 0xFF ) << 16 ; time |= ( ( long ) content [ 14 ] & 0xFF ) << 8 ; time |= ( ( long ) content [ 15 ] & 0xFF ) ; return new Date ( time ) ; }'", "label": "'Extract timestamp from raw UUID bytes and return as int . If the UUID is not the default type then we can t parse the timestamp out and null is returned .'"}
{"text": "\"public byte [ ] getMacFragment ( ) { if ( getVersion ( ) != ' ' ) return null ; byte [ ] x = new byte [ 6 ] ; x [ 0 ] = 0 ; x [ 1 ] = 0 ; x [ 2 ] = ( byte ) ( content [ 6 ] & 0xF ) ; x [ 3 ] = content [ 7 ] ; x [ 4 ] = content [ 8 ] ; x [ 5 ] = content [ 9 ] ; return x ; }\"", "label": "'Extract MAC address fragment from raw UUID bytes setting missing values to 0 thus the first 2 and a half bytes will be 0 followed by 3 and a half bytes of the active MAC address when the UUID was generated .'"}
{"text": "'private static byte [ ] macAddress ( ) { try { Enumeration < NetworkInterface > interfaces = NetworkInterface . getNetworkInterfaces ( ) ; byte [ ] mac = null ; while ( interfaces . hasMoreElements ( ) && ( mac == null || mac . length != 6 ) ) { NetworkInterface netInterface = interfaces . nextElement ( ) ; if ( netInterface . isLoopback ( ) || netInterface . isVirtual ( ) ) continue ; mac = netInterface . getHardwareAddress ( ) ; } // if the machine is not connected to a network it has no active MAC address if ( mac == null ) mac = new byte [ ] { 0 , 0 , 0 , 0 , 0 , 0 } ; return mac ; } catch ( Exception e ) { throw new RuntimeException ( \"Could not get MAC address\" ) ; } }'", "label": "'Get the active MAC address on the current machine as a byte array . This is called when generating a new UUID . Note that a machine can have multiple or no active MAC addresses . This method works by iterating through the list of network interfaces ignoring the loopback interface and any virtual interfaces ( which often have made - up addresses ) and returning the first one we find . If no valid addresses are found then a byte array of the same length with all zeros is returned .'"}
{"text": "'private static int processId ( ) { // Note: may fail in some JVM implementations // something like \\'<pid>@<hostname>\\', at least in SUN / Oracle JVMs final String jvmName = ManagementFactory . getRuntimeMXBean ( ) . getName ( ) ; final int index = jvmName . indexOf ( \\' \\' ) ; if ( index < 1 ) throw new RuntimeException ( \"Could not get PID\" ) ; try { return Integer . parseInt ( jvmName . substring ( 0 , index ) ) % MAX_PID ; } catch ( NumberFormatException e ) { throw new RuntimeException ( \"Could not get PID\" ) ; } }'", "label": "'Get the process id of this JVM . I haven t tested this extensively so its possible that this performs differently on esoteric JVMs . I copied this from : http : // stackoverflow . com / questions / 35842 / how - can - a - java - program - get - its - own - process - id'"}
{"text": "'@ Override public IOCContainer init ( Context context ) { return init ( context , getSystem ( ) . getBeanConfig ( context ) ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public IOCContainer init ( Context context , String ... paths ) { try { return initWithContainer ( context , paths ) ; } catch ( Exception e ) { if ( logger != null ) { logger . error ( SocializeLogger . INITIALIZE_FAILED , e ) ; } else { SocializeLogger . e ( e . getMessage ( ) , e ) ; } } return null ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void initAsync ( Context context , SocializeInitListener listener ) { initAsync ( context , listener , getSystem ( ) . getBeanConfig ( context ) ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void initAsync ( Context context , SocializeInitListener listener , String ... paths ) { new InitTask ( this , context , paths , listener , logger ) . execute ( ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "\"protected int binarySearch ( String [ ] array , String str ) { // No longer a binary search because we don't want the list to be sorted as this distrubs the priority for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] . equals ( str ) ) { return i ; } } return - 1 ; }\"", "label": "'So we can mock'"}
{"text": "'@ Override public synchronized void init ( Context context , final IOCContainer container ) { init ( context , container , getSystem ( ) . getSystemInitListener ( ) ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public synchronized void destroy ( boolean force ) { if ( force ) { if ( AsyncTaskManager . isManaged ( ) ) { AsyncTaskManager . terminateAll ( 10 , TimeUnit . SECONDS ) ; } if ( container != null ) { if ( logger != null && logger . isDebugEnabled ( ) ) { logger . debug ( \"Destroying IOC container\" ) ; } container . destroy ( ) ; } config . destroy ( ) ; system . destroy ( ) ; initCount = 0 ; initPaths = null ; entityLoader = null ; session = null ; authProviders = null ; } else { destroy ( ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public synchronized void authenticate ( Context context , SocializeAuthListener authListener ) { if ( assertInitialized ( context , authListener ) ) { userSystem . authenticate ( context , authListener , this ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public boolean isAuthenticatedForRead ( AuthProviderType providerType , String ... permissions ) { return isAuthenticated ( providerType , true , permissions ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public boolean isAuthenticatedForWrite ( AuthProviderType providerType , String ... permissions ) { return isAuthenticated ( providerType , false , permissions ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Deprecated @ Override public boolean isAuthenticated ( AuthProviderType providerType ) { return isAuthenticated ( providerType , false , FacebookFacade . DEFAULT_PERMISSIONS ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void handle ( final Activity context , final SocializeAction action , Location location , final String text , final SocialNetworkListener listener ) { ShareType shareType = getShareType ( ) ; final SocialNetwork network = SocialNetwork . valueOf ( shareType ) ; PropagationInfoResponse propagationInfoResponse = action . getPropagationInfoResponse ( ) ; if ( propagationInfoResponse != null ) { final PropagationInfo propagationInfo = propagationInfoResponse . getPropagationInfo ( shareType ) ; if ( propagationInfo != null ) { try { if ( loopyService . isLoopyEnabled ( ) ) { if ( shareType . equals ( ShareType . OTHER ) ) { loopyService . showShareDialog ( context , \"\" , text , action . getEntity ( ) , propagationInfo , listener ) ; } else { loopyService . getTrackableUrl ( action . getEntity ( ) , shareType , propagationInfo . getEntityUrl ( ) , new ShareCallback ( ) { @ Override public void onResult ( Item item , Throwable error ) { PropagationInfo infoInUse = loopyService . setShortlinks ( propagationInfo , item , error ) ; try { handle ( context , action , text , infoInUse , listener ) ; } catch ( Exception e ) { if ( logger != null ) { logger . error ( \"Error handling share\" , e ) ; } if ( listener != null ) { listener . onNetworkError ( context , network , e ) ; } } } } ) ; } } else { handle ( context , action , text , propagationInfo , listener ) ; } } catch ( Exception e ) { if ( logger != null ) { logger . error ( \"Error handling share\" , e ) ; } if ( listener != null ) { listener . onNetworkError ( context , network , e ) ; } } } else { logError ( context , network , \"No propagation info found for type [\" + shareType + \"].  Share will not propagate\" , listener ) ; } } else { logError ( context , network , \"No propagation info found for type [\" + shareType + \"].  Share will not propagate\" , listener ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void executeDemo ( final String text ) { if ( ! FacebookUtils . isLinkedForRead ( this , FacebookFacade . READ_PERMISSIONS ) ) { FacebookUtils . linkForRead ( this , new SocializeAuthListener ( ) { @ Override public void onError ( SocializeException error ) { handleError ( PostToWallActivity . this , error ) ; } @ Override public void onCancel ( ) { handleCancel ( ) ; } @ Override public void onAuthSuccess ( SocializeSession session ) { doPost ( text ) ; } @ Override public void onAuthFail ( SocializeException error ) { handleError ( PostToWallActivity . this , error ) ; } } , FacebookFacade . READ_PERMISSIONS ) ; } else { doPost ( text ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public String getBeanName ( Object parent , Container container ) { if ( FORCE_V2 ) { return v2BeanName ; } if ( beanName == null ) { try { Class . forName ( \"com.facebook.Session\" ) ; // We assume that if this class exists, we are v3+ beanName = v3BeanName ; } catch ( ClassNotFoundException e ) { beanName = v2BeanName ; } } return beanName ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public OAuthConsumer createConsumer ( String key , String secret ) { return new CommonsHttpOAuthConsumer ( key , secret ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void executeDemo ( final String text ) { // Link if we need to FacebookUtils . linkForWrite ( this , new SocializeAuthListener ( ) { @ Override public void onError ( SocializeException error ) { handleError ( OpenGraphActivity . this , error ) ; } @ Override public void onCancel ( ) { handleCancel ( ) ; } @ Override public void onAuthSuccess ( SocializeSession session ) { // This could be a custom Open Graph path in the form namespace:action final String graphPath = \"me/og.likes\" ; FacebookUtils . postEntity ( OpenGraphActivity . this , entity , text , new SocialNetworkShareListener ( ) { @ Override public boolean onBeforePost ( Activity parent , SocialNetwork socialNetwork , PostData postData ) { // Add/Change the contents of the post to fit with open graph postData . setPath ( graphPath ) ; // Facebook like requires an \"object\" parameter postData . getPostValues ( ) . put ( \"object\" , postData . getPropagationInfo ( ) . getEntityUrl ( ) ) ; return false ; } @ Override public void onNetworkError ( Activity context , SocialNetwork network , Exception error ) { handleError ( OpenGraphActivity . this , error ) ; } @ Override public void onCancel ( ) { handleCancel ( ) ; } @ Override public void onAfterPost ( Activity parent , SocialNetwork socialNetwork , JSONObject responseObject ) { try { handleResult ( responseObject . toString ( 4 ) ) ; } catch ( JSONException e ) { handleError ( OpenGraphActivity . this , e ) ; } } } ) ; } @ Override public void onAuthFail ( SocializeException error ) { handleError ( OpenGraphActivity . this , error ) ; } } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public void setProperty ( String key , String value ) { if ( properties == null ) { properties = createProperties ( ) ; } if ( value != null ) { value = value . trim ( ) ; properties . put ( key , value ) ; } else { properties . remove ( key ) ; } }'", "label": "'Sets a custom property . This will override settings in socialize . properties .'"}
{"text": "'public void setTwitterKeySecret ( String consumerKey , String consumerSecret ) { setProperty ( SocializeConfig . TWITTER_CONSUMER_KEY , consumerKey ) ; setProperty ( SocializeConfig . TWITTER_CONSUMER_SECRET , consumerSecret ) ; }'", "label": "'Sets the Twitter App consumer key / secret pair for Twitter authentication .'"}
{"text": "'@ Deprecated public void setFacebookUserCredentials ( String userId , String token ) { setProperty ( SocializeConfig . FACEBOOK_USER_ID , userId ) ; setProperty ( SocializeConfig . FACEBOOK_USER_TOKEN , token ) ; }'", "label": "'Sets the FB credentials for the current user if available .'"}
{"text": "'public void setSocializeCredentials ( String consumerKey , String consumerSecret ) { setProperty ( SocializeConfig . SOCIALIZE_CONSUMER_KEY , consumerKey ) ; setProperty ( SocializeConfig . SOCIALIZE_CONSUMER_SECRET , consumerSecret ) ; }'", "label": "'Sets the Socialize credentials for your App .'"}
{"text": "'public void merge ( Properties other , Set < String > toBeRemoved ) { if ( properties == null ) { properties = createProperties ( ) ; } if ( other != null && other . size ( ) > 0 ) { Set < Entry < Object , Object > > entrySet = other . entrySet ( ) ; for ( Entry < Object , Object > entry : entrySet ) { properties . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } if ( toBeRemoved != null && toBeRemoved . size ( ) > 0 ) { for ( String key : toBeRemoved ) { properties . remove ( key ) ; } toBeRemoved . clear ( ) ; } }'", "label": "'Merge properties into the config .'"}
{"text": "'@ Override public void addShare ( Context context , SocializeSession session , Entity entity , String text , ShareType shareType , Location location , ShareListener listener ) { addShare ( context , session , entity , text , shareType , null , location , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getSharesByEntity ( SocializeSession session , String key , int startIndex , int endIndex , ShareListener listener ) { listAsync ( session , ENDPOINT , key , null , null , startIndex , endIndex , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getSharesByApplication ( SocializeSession session , int startIndex , int endIndex , ShareListener listener ) { listAsync ( session , ENDPOINT , null , null , null , startIndex , endIndex , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getSharesByUser ( SocializeSession session , long userId , int startIndex , int endIndex , ShareListener listener ) { String endpoint = \"/user/\" + userId + ENDPOINT ; listAsync ( session , endpoint , startIndex , endIndex , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getShare ( SocializeSession session , long id , ShareListener listener ) { getAsync ( session , ENDPOINT , String . valueOf ( id ) , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getSharesById ( SocializeSession session , ShareListener listener , long ... ids ) { if ( ids != null ) { String [ ] strIds = new String [ ids . length ] ; for ( int i = 0 ; i < ids . length ; i ++ ) { strIds [ i ] = String . valueOf ( ids [ i ] ) ; } listAsync ( session , ENDPOINT , null , 0 , SocializeConfig . MAX_LIST_RESULTS , listener , strIds ) ; } else { if ( listener != null ) { listener . onError ( new SocializeException ( \"No ids supplied\" ) ) ; } } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public ShareOptions getUserShareOptions ( Context context ) { ShareOptions options = new ShareOptions ( ) ; populateActionOptions ( context , options ) ; return options ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void showLinkDialog ( Activity context , AuthDialogListener listener ) { authDialogFactory . show ( context , listener , ! config . isAllowSkipAuthOnAllActions ( ) ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void showShareDialog ( final Activity context , final Entity entity , int options , final SocialNetworkShareListener socialNetworkListener , final ShareDialogListener dialogListener ) { shareDialogFactory . show ( context , entity , socialNetworkListener , new ShareDialogListener ( ) { SharePanelView dialogView ; @ Override public void onCancel ( Dialog dialog ) { if ( dialogListener != null ) { dialogListener . onCancel ( dialog ) ; } } @ Override public void onShow ( Dialog dialog , SharePanelView dialogView ) { if ( dialogListener != null ) { dialogListener . onShow ( dialog , dialogView ) ; } this . dialogView = dialogView ; } @ Override public void onSimpleShare ( ShareType type ) { if ( dialogListener != null ) { dialogListener . onSimpleShare ( type ) ; } } @ Override public void onFlowInterrupted ( DialogFlowController controller ) { // Will not be called. } @ Override public boolean onContinue ( final Dialog dialog , boolean remember , final SocialNetwork ... networks ) { boolean consumed = false ; if ( dialogListener != null ) { consumed = dialogListener . onContinue ( dialog , remember , networks ) ; } if ( ! consumed ) { doShare ( dialog , context , entity , socialNetworkListener , networks ) ; } else { dialogListener . onFlowInterrupted ( new DialogFlowController ( ) { @ Override public void onContinue ( String text ) { ShareOptions options = new ShareOptions ( ) ; options . setText ( text ) ; doShare ( dialog , context , entity , socialNetworkListener , options , networks ) ; } @ Override public void onCancel ( ) { if ( dialogView != null ) { dialogView . getContinueButton ( ) . setEnabled ( true ) ; } dialogListener . onCancel ( dialog ) ; } } ) ; } return false ; } } , options ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void registerShare ( Activity context , Entity entity , ShareOptions shareOptions , ShareAddListener listener , SocialNetwork ... networks ) { String text = null ; if ( shareOptions != null ) text = shareOptions . getText ( ) ; if ( text == null ) text = \"\" ; ShareType shareType = ShareType . OTHER ; if ( networks != null && networks . length > 0 ) { if ( networks . length == 1 ) { shareType = ShareType . valueOf ( networks [ 0 ] ) ; } } shareSystem . addShare ( context , getSocialize ( ) . getSession ( ) , entity , text , shareType , listener , networks ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void shareViaEmail ( Activity context , Entity entity , ShareAddListener listener ) { doShare ( context , entity , ShareType . EMAIL , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void shareViaGooglePlus ( Activity context , Entity entity , ShareAddListener listener ) { doShare ( context , entity , ShareType . GOOGLE_PLUS , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void shareViaOther ( Activity context , Entity entity , ShareAddListener listener ) { doShare ( context , entity , ShareType . OTHER , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void shareViaSMS ( Activity context , Entity entity , ShareAddListener listener ) { doShare ( context , entity , ShareType . SMS , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'protected void doShare ( final Activity context , final Entity entity , final ShareType shareType , final ShareAddListener shareAddListener ) { final SocializeSession session = getSocialize ( ) . getSession ( ) ; shareSystem . addShare ( context , session , entity , \"\" , shareType , null , new ShareAddListener ( ) { @ Override public void onError ( SocializeException error ) { if ( shareAddListener != null ) { shareAddListener . onError ( error ) ; } } @ Override public void onCreate ( Share share ) { if ( share != null && shareSystem != null ) { handleNonNetworkShare ( context , session , shareType , share , \"\" , null , shareAddListener ) ; } } } ) ; }'", "label": "'Creates the socialize share object .'"}
{"text": "'protected void handleNonNetworkShare ( Activity activity , final SocializeSession session , final ShareType shareType , final Share share , String shareText , Location location , final ShareAddListener shareAddListener ) { SocialNetworkListener snListener = new SocialNetworkListener ( ) { @ Override public void onNetworkError ( Activity context , SocialNetwork network , Exception error ) { if ( shareAddListener != null ) { shareAddListener . onError ( SocializeException . wrap ( error ) ) ; } } @ Override public void onCancel ( ) { if ( shareAddListener != null ) { shareAddListener . onCancel ( ) ; } } @ Override public boolean onBeforePost ( Activity parent , SocialNetwork socialNetwork , PostData postData ) { return shareAddListener instanceof SocialNetworkListener && ( ( SimpleShareListener ) shareAddListener ) . onBeforePost ( parent , socialNetwork , postData ) ; } @ Override public void onAfterPost ( Activity parent , SocialNetwork socialNetwork , JSONObject responseObject ) { if ( shareAddListener != null ) { shareAddListener . onCreate ( share ) ; } } } ; shareSystem . share ( activity , session , share , shareText , location , shareType , snListener ) ; }'", "label": "'Handles a non - network share like email or SMS .'"}
{"text": "'@ Override public void shareViaSocialNetworks ( Activity context , final Entity entity , final ShareOptions shareOptions , final SocialNetworkShareListener listener , final SocialNetwork ... networks ) { final SocializeSession session = getSocialize ( ) . getSession ( ) ; if ( isDisplayAuthDialog ( context , session , shareOptions , networks ) ) { authDialogFactory . show ( context , new AuthDialogListener ( ) { @ Override public void onShow ( Dialog dialog , AuthPanelView dialogView ) { } @ Override public void onCancel ( Dialog dialog ) { if ( listener != null ) { listener . onCancel ( ) ; } } @ Override public void onSkipAuth ( Activity context , Dialog dialog ) { dialog . dismiss ( ) ; doShare ( context , entity , listener , shareOptions , networks ) ; } @ Override public void onError ( Activity context , Dialog dialog , Exception error ) { dialog . dismiss ( ) ; if ( listener != null ) { listener . onError ( SocializeException . wrap ( error ) ) ; } } @ Override public void onAuthenticate ( Activity context , Dialog dialog , SocialNetwork network ) { dialog . dismiss ( ) ; doShare ( context , entity , listener , shareOptions , network ) ; } } , ! config . isAllowSkipAuthOnAllActions ( ) ) ; } else { doShare ( context , entity , listener , shareOptions , networks ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getShare ( Activity context , ShareGetListener listener , long id ) { shareSystem . getShare ( getSocialize ( ) . getSession ( ) , id , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getShares ( Activity context , ShareListListener listener , long ... ids ) { shareSystem . getSharesById ( getSocialize ( ) . getSession ( ) , listener , ids ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getSharesByUser ( Activity context , User user , int start , int end , ShareListListener listener ) { shareSystem . getSharesByUser ( getSocialize ( ) . getSession ( ) , user . getId ( ) , start , end , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getSharesByEntity ( Activity context , String entityKey , int start , int end , ShareListListener listener ) { shareSystem . getSharesByEntity ( getSocialize ( ) . getSession ( ) , entityKey , start , end , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getSharesByApplication ( Activity context , int start , int end , ShareListListener listener ) { shareSystem . getSharesByApplication ( getSocialize ( ) . getSession ( ) , start , end , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public static void addComment ( Activity context , Entity entity , String text , CommentAddListener listener ) { proxy . addComment ( context , entity , text , listener ) ; }'", "label": "'Adds a comment to the given entity . This method will also prompt the user to share their comment .'"}
{"text": "'public static void deleteComment ( Activity context , long id , CommentDeleteListener listener ) { proxy . deleteComment ( context , id , listener ) ; }'", "label": "'Deletes a comment . Only the person that created the comment can delete it .'"}
{"text": "'public static void addComment ( Activity context , Entity entity , String text , CommentOptions commentOptions , CommentAddListener listener , SocialNetwork ... networks ) { proxy . addComment ( context , entity , text , commentOptions , listener , networks ) ; }'", "label": "'Adds a comment to the given entity . This method will NOT prompt the user to share their comment as the desired networks are passed as a parameter .'"}
{"text": "'public static void getComment ( Activity context , CommentGetListener listener , long id ) { proxy . getComment ( context , id , listener ) ; }'", "label": "'Retrieves a single comment based on ID .'"}
{"text": "'public static void getComments ( Activity context , CommentListListener listener , long ... ids ) { proxy . getComments ( context , listener , ids ) ; }'", "label": "'Retrieves comments based on a set of IDs .'"}
{"text": "'public static void getCommentsByUser ( Activity context , User user , int start , int end , CommentListListener listener ) { proxy . getCommentsByUser ( context , user , start , end , listener ) ; }'", "label": "'Retrieves all comments made by the given user .'"}
{"text": "'public static void getCommentsByEntity ( Activity context , String entityKey , int start , int end , CommentListListener listener ) { proxy . getCommentsByEntity ( context , entityKey , start , end , listener ) ; }'", "label": "'Retrieves all comments associated with the given entity .'"}
{"text": "'public static void getCommentsByApplication ( Activity context , int start , int end , CommentListListener listener ) { proxy . getCommentsByApplication ( context , start , end , listener ) ; }'", "label": "'Retrieves all comments across all entities .'"}
{"text": "'public static void showCommentView ( Activity context , Entity entity , OnCommentViewActionListener listener ) { proxy . showCommentView ( context , entity , listener ) ; }'", "label": "'Shows the comments for an entity .'"}
{"text": "'@ Override public boolean launch ( Activity context , Bundle data ) { if ( entityLoaderUtils != null ) { entityLoaderUtils . initEntityLoader ( ) ; } // Expect an action id Object idObj = data . get ( Socialize . ACTION_ID ) ; String actionType = data . getString ( Socialize . ACTION_TYPE ) ; if ( idObj != null && ! StringUtils . isEmpty ( actionType ) ) { long id = Long . parseLong ( idObj . toString ( ) ) ; try { ActionType type = ActionType . valueOf ( actionType ) ; SocializeSession session = notificationAuthenticator . authenticate ( context ) ; SocializeAction action = activitySystem . getAction ( session , id , type ) ; if ( action != null ) { CommentUtils . showCommentView ( context , action . getEntity ( ) ) ; return true ; } else { handleWarn ( \"No action found for id [\" + id + \"].\" ) ; } } catch ( SocializeException e ) { handleError ( \"Failed to load entity\" , e ) ; } } else { handleWarn ( \"No action id found.  Action based notification cannot be handled\" ) ; } return false ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public JSONObject parseObject ( String json ) throws JSONException { json = json . trim ( ) ; if ( json . startsWith ( \"[\" ) ) { JSONArray array = new JSONArray ( json ) ; JSONObject obj = new JSONObject ( ) ; obj . put ( \"data\" , array ) ; return obj ; } else { return new JSONObject ( json ) ; } }'", "label": "'Detects whether the inbound string is a JSONArray and if so wraps the array in an object with a single field called data'"}
{"text": "'public static String openUrl ( String url , String method , Bundle params ) throws MalformedURLException , IOException { // random string as boundary for multi-part http post String strBoundary = \"3i2ndDfv2rTHiSisAbouNdArYfORhtTPEefj3q2f\" ; String endLine = \"\\\\r\\\\n\" ; OutputStream os ; if ( method . equals ( \"GET\" ) ) { url = url + \"?\" + encodeUrl ( params ) ; } Util . logd ( \"Facebook-Util\" , method + \" URL: \" + url ) ; HttpURLConnection conn = ( HttpURLConnection ) new URL ( url ) . openConnection ( ) ; conn . setRequestProperty ( \"User-Agent\" , System . getProperties ( ) . getProperty ( \"http.agent\" ) + \" FacebookAndroidSDK\" ) ; if ( ! method . equals ( \"GET\" ) ) { Bundle dataparams = new Bundle ( ) ; for ( String key : params . keySet ( ) ) { Object parameter = params . get ( key ) ; if ( parameter instanceof byte [ ] ) { dataparams . putByteArray ( key , ( byte [ ] ) parameter ) ; } } // use method override if ( ! params . containsKey ( \" method \" ) ) { params . putString ( \" method \" , method ) ; } if ( params . containsKey ( \"access_token\" ) ) { String decoded_token = URLDecoder . decode ( params . getString ( \"access_token\" ) ) ; params . putString ( \"access_token\" , decoded_token ) ; } conn . setRequestMethod ( \"POST\" ) ; conn . setRequestProperty ( \"Content-Type\" , \"multipart/form-data;boundary=\" + strBoundary ) ; conn . setDoOutput ( true ) ; conn . setDoInput ( true ) ; conn . setRequestProperty ( \"Connection\" , \"Keep-Alive\" ) ; conn . connect ( ) ; os = new BufferedOutputStream ( conn . getOutputStream ( ) ) ; os . write ( ( \"--\" + strBoundary + endLine ) . getBytes ( ) ) ; os . write ( ( encodePostBody ( params , strBoundary ) ) . getBytes ( ) ) ; os . write ( ( endLine + \"--\" + strBoundary + endLine ) . getBytes ( ) ) ; if ( ! dataparams . isEmpty ( ) ) { for ( String key : dataparams . keySet ( ) ) { os . write ( ( \"Content-Disposition: form-data; filename=\\\\\"\" + key + \"\\\\\"\" + endLine ) . getBytes ( ) ) ; os . write ( ( \"Content-Type: content/unknown\" + endLine + endLine ) . getBytes ( ) ) ; os . write ( dataparams . getByteArray ( key ) ) ; os . write ( ( endLine + \"--\" + strBoundary + endLine ) . getBytes ( ) ) ; } } os . flush ( ) ; } String response = \"\" ; try { response = read ( conn . getInputStream ( ) ) ; } catch ( FileNotFoundException e ) { // Error Stream contains JSON that we can parse to a FB error response = read ( conn . getErrorStream ( ) ) ; } return response ; } private static String read  ( InputStream in ) throws IOException { StringBuilder sb = new StringBuilder ( ) ; BufferedReader r = new BufferedReader ( new InputStreamReader ( in ) , 1000 ) ; for ( String line = r . readLine ( ) ; line != null ; line = r . readLine ( ) ) { sb . append ( line ) ; } in . close ( ) ; return sb . toString ( ) ; } public static void clearCookies  ( Context context ) { // Edge case: an illegal state exception is thrown if an instance of // CookieSyncManager has not be created.  CookieSyncManager is normally // created by a WebKit view, but this might happen if you start the // app, restore saved state, and click logout before running a UI // dialog in a WebView -- in which case the app crashes @ SuppressWarnings ( \"unused\" ) CookieSyncManager cookieSyncMngr = CookieSyncManager . createInstance ( context ) ; CookieManager cookieManager = CookieManager . getInstance ( ) ; cookieManager . removeAllCookie ( ) ; }'", "label": "'Connect to an HTTP URL and return the response as a string .'"}
{"text": "'public static JSONObject parseJson ( String response ) throws JSONException , FacebookError { // Edge case: when sending a POST request to /[post_id]/likes // the return value is \\'true\\' or \\'false\\'. Unfortunately // these values cause the JSONObject constructor to throw // an exception. if ( response . equals ( \"false\" ) ) { throw new FacebookError ( \"request failed\" ) ; } if ( response . equals ( \"true\" ) ) { response = \"{value : true}\" ; } JSONObject json = new JSONObject ( response ) ; // errors set by the server are not consistent // they depend on the method and endpoint if ( json . has ( \"error\" ) ) { JSONObject error = json . getJSONObject ( \"error\" ) ; throw new FacebookError ( error . getString ( \"message\" ) , error . getString ( \"type\" ) , 0 ) ; } if ( json . has ( \"error_code\" ) && json . has ( \"error_msg\" ) ) { throw new FacebookError ( json . getString ( \"error_msg\" ) , \"\" , Integer . parseInt ( json . getString ( \"error_code\" ) ) ) ; } if ( json . has ( \"error_code\" ) ) { throw new FacebookError ( \"request failed\" , \"\" , Integer . parseInt ( json . getString ( \"error_code\" ) ) ) ; } if ( json . has ( \"error_msg\" ) ) { throw new FacebookError ( json . getString ( \"error_msg\" ) ) ; } if ( json . has ( \"error_reason\" ) ) { throw new FacebookError ( json . getString ( \"error_reason\" ) ) ; } return json ; }'", "label": "'Parse a server response into a JSON Object . This is a basic implementation using org . json . JSONObject representation . More sophisticated applications may wish to do their own parsing .'"}
{"text": "'public static void showAlert ( Context context , String title , String text ) { Builder alertBuilder = new Builder ( context ) ; alertBuilder . setTitle ( title ) ; alertBuilder . setMessage ( text ) ; alertBuilder . create ( ) . show ( ) ; }'", "label": "'Display a simple alert dialog with the given text and title .'"}
{"text": "'public static void logd ( String tag , String msg ) { if ( ENABLE_LOG ) { Log . d ( tag , msg ) ; } }'", "label": "'A proxy for Log . d api that kills log messages in release build . It not recommended to send sensitive information to log output in shipping apps .'"}
{"text": "'@ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; // Initialize socialize Socialize . initAsync ( this , new SocializeInitListener ( ) { @ Override public void onError ( SocializeException error ) { // Handle error } @ Override public void onInit ( Context context , IOCContainer container ) { // If you want to access Socialize directly, do it here } } ) ; }'", "label": "'begin - snippet - 0'"}
{"text": "'private Type getRuntimeTypeIfMoreSpecific ( Type type , Object value ) { if ( value != null && ( type == Object . class || type instanceof TypeVariable < ? > || type instanceof Class < ? > ) ) { type = value . getClass ( ) ; } return type ; }'", "label": "'Finds a compatible runtime type if it is more specific'"}
{"text": "'@ Override public void link ( Activity context , SocializeAuthListener listener ) { getSocialize ( ) . authenticateForWrite ( context , AuthProviderType . TWITTER , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void link ( Activity context , String token , String secret , SocializeAuthListener listener ) { TwitterAuthProviderInfo twInfo = new TwitterAuthProviderInfo ( ) ; twInfo . setConsumerKey ( config . getProperty ( SocializeConfig . TWITTER_CONSUMER_KEY ) ) ; twInfo . setConsumerSecret ( config . getProperty ( SocializeConfig . TWITTER_CONSUMER_SECRET ) ) ; DefaultUserProviderCredentials credentials = new DefaultUserProviderCredentials ( ) ; credentials . setAuthProviderInfo ( twInfo ) ; credentials . setAccessToken ( token ) ; credentials . setTokenSecret ( secret ) ; getSocialize ( ) . authenticateKnownUser ( context , credentials , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void unlink ( Context context ) { SocializeSession session = getSocialize ( ) . getSession ( ) ; session . clear ( AuthProviderType . TWITTER ) ; session . getUserSettings ( ) . setAutoPostTwitter ( false ) ; userSystem . saveSession ( context , session ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void setCredentials ( Context context , String consumerKey , String consumerSecret ) { config . setTwitterKeySecret ( consumerKey , consumerSecret ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void executeDemo ( String text ) { CommentUtils . addComment ( this , entity , text , new CommentAddListener ( ) { @ Override public void onError ( SocializeException error ) { handleError ( AddCommentActivity . this , error ) ; } @ Override public void onCreate ( Comment comment ) { handleSocializeResult ( comment ) ; } @ Override public void onCancel ( ) { handleCancel ( ) ; } } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public void setEntitySafe ( Entity entity ) { if ( StringUtils . isEmpty ( entity . getName ( ) ) ) { setEntityKey ( entity . getKey ( ) ) ; } else { setEntity ( entity ) ; } }'", "label": "'Reverts to only set the entity key if the name is not defined . This ensures an existing entity name is not wiped out when the action is saved .'"}
{"text": "'public String getDisplayText ( ) { if ( entity != null ) { String name = entity . getName ( ) ; String key = entity . getKey ( ) ; if ( ! StringUtils . isEmpty ( name ) ) { return name ; } return key ; } return entityKey ; }'", "label": "'Returns the text to display for this action when rendering on screen ( e . g . in a list )'"}
{"text": "'public String buildProfileImageUrl ( String id ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( \"http://graph.facebook.com/\" ) ; builder . append ( id ) ; builder . append ( \"/picture?type=large\" ) ; return builder . toString ( ) ; }'", "label": "'Constructs the URL to access the FB graph API and retrieve a profile image for the user with the given facebook id .'"}
{"text": "'public synchronized void authenticate ( final String consumerKey , final String consumerSecret , final TwitterAuthListener listener ) { TwitterOAuthProvider provider = newTwitterOAuthProvider ( ) ; CommonsHttpOAuthConsumer consumer = newCommonsHttpOAuthConsumer ( consumerKey , consumerSecret ) ; OAuthRequestListener oAuthRequestListener = newOAuthRequestListener ( listener , provider , consumer ) ; twitterWebViewClient . setOauthRequestListener ( oAuthRequestListener ) ; provider . retrieveRequestTokenAsync ( consumer , TwitterOAuthProvider . OAUTH_CALLBACK_URL , newOAuthRequestTokenUrlListener ( listener ) ) ; }'", "label": "'Starts the authentication process using the given twitter key / secret .'"}
{"text": "'public void onImageChange ( Bitmap bitmap ) { if ( bitmap != null ) { Bitmap scaled = bitmapUtils . getScaledBitmap ( bitmap , 200 , 200 ) ; content . onProfilePictureChange ( scaled ) ; } }'", "label": "'Called when the profile picture has been changed by the user .'"}
{"text": "\"public String generate ( ) throws OAuthMessageSignerException { try { String normalizedUrl = normalizeRequestUrl ( ) ; String normalizedParams = normalizeRequestParameters ( ) ; return request . getMethod ( ) + ' ' + OAuth . percentEncode ( normalizedUrl ) + ' ' + OAuth . percentEncode ( normalizedParams ) ; } catch ( Exception e ) { throw new OAuthMessageSignerException ( e ) ; } }\"", "label": "'Builds the signature base string from the data this instance was configured with .'"}
{"text": "'public String normalizeRequestParameters ( ) throws IOException { if ( requestParameters == null ) { return \"\" ; } StringBuilder sb = new StringBuilder ( ) ; Iterator < String > iter = requestParameters . keySet ( ) . iterator ( ) ; for ( int i = 0 ; iter . hasNext ( ) ; i ++ ) { String param = iter . next ( ) ; if ( OAuth . OAUTH_SIGNATURE . equals ( param ) || \"realm\" . equals ( param ) ) { continue ; } if ( i > 0 ) { sb . append ( \"&\" ) ; } sb . append ( requestParameters . getAsQueryString ( param ) ) ; } return sb . toString ( ) ; }'", "label": "'Normalizes the set of request parameters this instance was configured with as per OAuth spec section 9 . 1 . 1 .'"}
{"text": "'@ Override public void onMessage ( Context context , Intent intent ) { try { if ( notificationCallback != null ) { if ( logger != null && logger . isDebugEnabled ( ) ) { logger . debug ( \"SocializeC2DMReceiver received message\" ) ; } Bundle extras = intent . getExtras ( ) ; if ( extras != null ) { notificationCallback . onMessage ( context , extras ) ; } else { logWarn ( \"No extras bundle found in notification intent.  Notification cannot be processed\" ) ; } } else { logWarn ( \"No notificationCallback found in GCM receiver.  Initialization may have failed.\" ) ; } } catch ( Exception e ) { logError ( \"Error processing GCM message\" , e ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void onError ( Context context , String errorId ) { if ( logger != null ) { logger . error ( \"GCM registration failed with error: \" + errorId ) ; } if ( notificationCallback != null ) { notificationCallback . onError ( context , errorId ) ; } else { logWarn ( \"No notificationCallback found in GCM receiver.  Initialization may have failed.\" ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void onRegistered ( Context context , String registrationId ) { try { if ( notificationCallback != null ) { notificationCallback . onRegister ( context , registrationId ) ; } else { logWarn ( \"No notificationCallback found in GCM receiver.  Initialization may have failed.\" ) ; } } catch ( Exception e ) { logError ( \"GCM registration failed\" , e ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void onUnregistered ( Context context ) { if ( notificationCallback != null ) { notificationCallback . onUnregister ( context ) ; if ( logger != null && logger . isDebugEnabled ( ) ) { logger . debug ( \"SocializeC2DMReceiver successfully unregistered\" ) ; } } else { logWarn ( \"No notificationCallback found in GCM receiver.  Initialization may have failed.\" ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void onCreate ( Context context ) { if ( logger != null && logger . isDebugEnabled ( ) ) { logger . debug ( \"SocializeC2DMReceiver creating..\" ) ; } try { container . onCreate ( context ) ; initBeans ( ) ; } catch ( Exception e ) { logError ( \"Error initializing GCM receiver!\" , e ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override protected void doShare ( Activity context , Entity entity , PropagationInfo urlSet , String comment , SocialNetworkListener listener , ActionType type ) throws SocializeException { Tweet tweet = new Tweet ( ) ; switch ( type ) { case SHARE : if ( StringUtils . isEmpty ( comment ) ) comment = \"Shared \" + entity . getDisplayName ( ) ; break ; case LIKE : comment = \"\\\\u2764 likes \" + entity . getDisplayName ( ) ; break ; case VIEW : comment = \"Viewed \" + entity . getDisplayName ( ) ; break ; } StringBuilder status = new StringBuilder ( ) ; if ( StringUtils . isEmpty ( comment ) ) { status . append ( entity . getDisplayName ( ) ) ; } else { status . append ( comment ) ; } status . append ( \", \" ) ; status . append ( urlSet . getEntityUrl ( ) ) ; tweet . setText ( status . toString ( ) ) ; UserSettings settings = UserUtils . getUserSettings ( context ) ; if ( settings != null && settings . isLocationEnabled ( ) ) { tweet . setLocation ( LocationUtils . getLastKnownLocation ( context ) ) ; tweet . setShareLocation ( true ) ; } twitterUtils . tweet ( context , tweet , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public void authorize ( Activity activity , final DialogListener listener ) { authorize ( activity , new String [ ] { } , DEFAULT_AUTH_ACTIVITY_CODE , listener ) ; }'", "label": "'Default authorize method . Grants only basic permissions .'"}
{"text": "'public void authorize ( Activity activity , String [ ] permissions , int activityCode , final DialogListener listener ) { boolean singleSignOnStarted = false ; mAuthDialogListener = listener ; // Prefer single sign-on, where available. if ( activityCode >= 0 ) { singleSignOnStarted = startSingleSignOn ( activity , mAppId , permissions , activityCode ) ; } // Otherwise fall back to traditional dialog. if ( ! singleSignOnStarted ) { startDialogAuth ( activity , permissions ) ; } }'", "label": "'Full authorize method .'"}
{"text": "'private boolean startSingleSignOn ( Activity activity , String applicationId , String [ ] permissions , int activityCode ) { boolean didSucceed = true ; Intent intent = new Intent ( ) ; intent . setClassName ( \"com.facebook.katana\" , \"com.facebook.katana.ProxyAuth\" ) ; intent . putExtra ( \"client_id\" , applicationId ) ; if ( permissions . length > 0 ) { intent . putExtra ( \"scope\" , TextUtils . join ( \",\" , permissions ) ) ; } // Verify that the application whose package name is // com.facebook.katana.ProxyAuth // has the expected FB app signature. if ( ! validateActivityIntent ( activity , intent ) ) { return false ; } mAuthActivity = activity ; mAuthPermissions = permissions ; mAuthActivityCode = activityCode ; try { activity . startActivityForResult ( intent , activityCode ) ; } catch ( ActivityNotFoundException e ) { didSucceed = false ; } return didSucceed ; }'", "label": "'Internal method to handle single sign - on backend for authorize () .'"}
{"text": "'private boolean validateActivityIntent ( Context context , Intent intent ) { ResolveInfo resolveInfo = context . getPackageManager ( ) . resolveActivity ( intent , 0 ) ; if ( resolveInfo == null ) { return false ; } return validateAppSignatureForPackage ( context , resolveInfo . activityInfo . packageName ) ; }'", "label": "'Helper to validate an activity intent by resolving and checking the provider s package signature .'"}
{"text": "'private void startDialogAuth ( Activity activity , String [ ] permissions ) { Bundle params = new Bundle ( ) ; if ( permissions . length > 0 ) { params . putString ( \"scope\" , TextUtils . join ( \",\" , permissions ) ) ; } CookieSyncManager . createInstance ( activity ) ; dialog ( activity , LOGIN , params , new DialogListener ( ) { public void onComplete ( Bundle values ) { // ensure any cookies set by the dialog are saved CookieSyncManager . getInstance ( ) . sync ( ) ; setAccessToken ( values . getString ( TOKEN ) ) ; setAccessExpiresIn ( values . getString ( EXPIRES ) ) ; if ( isSessionValid ( ) ) { Util . logd ( \"Facebook-authorize\" , \"Login Success! access_token=\" + getAccessToken ( ) + \" expires=\" + getAccessExpires ( ) ) ; mAuthDialogListener . onComplete ( values ) ; } else { mAuthDialogListener . onFacebookError ( new FacebookError ( \"Failed to receive access token.\" ) ) ; } } public void onError ( DialogError error ) { Util . logd ( \"Facebook-authorize\" , \"Login failed: \" + error ) ; mAuthDialogListener . onError ( error ) ; } public void onFacebookError ( FacebookError error ) { Util . logd ( \"Facebook-authorize\" , \"Login failed: \" + error ) ; mAuthDialogListener . onFacebookError ( error ) ; } public void onCancel ( ) { Util . logd ( \"Facebook-authorize\" , \"Login canceled\" ) ; mAuthDialogListener . onCancel ( ) ; } } ) ; }'", "label": "'Internal method to handle dialog - based authentication backend for authorize () .'"}
{"text": "'public void authorizeCallback ( int requestCode , int resultCode , Intent data ) { if ( requestCode == mAuthActivityCode ) { // Successfully redirected. if ( resultCode == Activity . RESULT_OK ) { // Check OAuth 2.0/2.10 error code. String error = data . getStringExtra ( \"error\" ) ; if ( error == null ) { error = data . getStringExtra ( \"error_type\" ) ; } // A Facebook error occurred. if ( error != null ) { if ( error . equals ( SINGLE_SIGN_ON_DISABLED ) || error . equals ( \"AndroidAuthKillSwitchException\" ) ) { Util . logd ( \"Facebook-authorize\" , \"Hosted auth currently \" + \"disabled. Retrying dialog auth...\" ) ; startDialogAuth ( mAuthActivity , mAuthPermissions ) ; } else if ( error . equals ( \"access_denied\" ) || error . equals ( \"OAuthAccessDeniedException\" ) ) { Util . logd ( \"Facebook-authorize\" , \"Login canceled by user.\" ) ; mAuthDialogListener . onCancel ( ) ; } else { String description = data . getStringExtra ( \"error_description\" ) ; if ( description != null ) { error = error + \":\" + description ; } Util . logd ( \"Facebook-authorize\" , \"Login failed: \" + error ) ; mAuthDialogListener . onFacebookError ( new FacebookError ( error ) ) ; } // No errors. } else { setAccessToken ( data . getStringExtra ( TOKEN ) ) ; setAccessExpiresIn ( data . getStringExtra ( EXPIRES ) ) ; if ( isSessionValid ( ) ) { Util . logd ( \"Facebook-authorize\" , \"Login Success! access_token=\" + getAccessToken ( ) + \" expires=\" + getAccessExpires ( ) ) ; mAuthDialogListener . onComplete ( data . getExtras ( ) ) ; } else { mAuthDialogListener . onFacebookError ( new FacebookError ( \"Failed to receive access token.\" ) ) ; } } // An error occurred before we could be redirected. } else if ( resultCode == Activity . RESULT_CANCELED ) { // An Android error occured. if ( data != null ) { Util . logd ( \"Facebook-authorize\" , \"Login failed: \" + data . getStringExtra ( \"error\" ) ) ; mAuthDialogListener . onError ( new DialogError ( data . getStringExtra ( \"error\" ) , data . getIntExtra ( \"error_code\" , - 1 ) , data . getStringExtra ( \"failing_url\" ) ) ) ; // User pressed the \\'back\\' button. } else { Util . logd ( \"Facebook-authorize\" , \"Login canceled by user.\" ) ; mAuthDialogListener . onCancel ( ) ; } } } }'", "label": "'IMPORTANT : This method must be invoked at the top of the calling activity s onActivityResult () function or Facebook authentication will not function properly!'"}
{"text": "'public boolean extendAccessToken ( Context context , ServiceListener serviceListener ) { Intent intent = new Intent ( ) ; intent . setClassName ( \"com.facebook.katana\" , \"com.facebook.katana.platform.TokenRefreshService\" ) ; // Verify that the application whose package name is // com.facebook.katana // has the expected FB app signature. if ( ! validateServiceIntent ( context , intent ) ) { return false ; } return context . bindService ( intent , new TokenRefreshServiceConnection ( context , serviceListener ) , Context . BIND_AUTO_CREATE ) ; }'", "label": "'Refresh OAuth access token method . Binds to Facebook for Android stand - alone application application to refresh the access token . This method tries to connect to the Facebook App which will handle the authentication flow and return a new OAuth access token . This method will automatically replace the old token with a new one . Note that this method is asynchronous and the callback will be invoked in the original calling thread ( not in a background thread ) .'"}
{"text": "'public String logout ( Context context ) throws MalformedURLException , IOException { Util . clearCookies ( context ) ; Bundle b = new Bundle ( ) ; b . putString ( \"method\" , \"auth.expireSession\" ) ; String response = request ( b ) ; setAccessToken ( null ) ; setAccessExpires ( 0 ) ; return response ; }'", "label": "'Invalidate the current user session by removing the access token in memory clearing the browser cookie and calling auth . expireSession through the API .'"}
{"text": "'public String request ( Bundle parameters ) throws MalformedURLException , IOException { if ( ! parameters . containsKey ( \"method\" ) ) { throw new IllegalArgumentException ( \"API method must be specified. \" + \"(parameters must contain key \\\\\"method\\\\\" and value). See\" + \" http://developers.facebook.com/docs/reference/rest/\" ) ; } return request ( null , parameters , \"GET\" ) ; }'", "label": "'Make a request to Facebook s old ( pre - graph ) API with the given parameters . One of the parameter keys must be method and its value should be a valid REST server API method .'"}
{"text": "'public String request ( String graphPath , Bundle parameters ) throws MalformedURLException , IOException { return request ( graphPath , parameters , \"GET\" ) ; }'", "label": "'Make a request to the Facebook Graph API with the given string parameters using an HTTP GET ( default method ) .'"}
{"text": "'public void dialog ( Context context , String action , Bundle parameters , final DialogListener listener ) { String endpoint = DIALOG_BASE_URL + action ; parameters . putString ( \"display\" , \"touch\" ) ; parameters . putString ( \"redirect_uri\" , REDIRECT_URI ) ; if ( action . equals ( LOGIN ) ) { parameters . putString ( \"type\" , \"user_agent\" ) ; parameters . putString ( \"client_id\" , mAppId ) ; } else { parameters . putString ( \"app_id\" , mAppId ) ; } if ( isSessionValid ( ) ) { parameters . putString ( TOKEN , getAccessToken ( ) ) ; } String url = endpoint + \"?\" + Util . encodeUrl ( parameters ) ; if ( context . checkCallingOrSelfPermission ( Manifest . permission . INTERNET ) != PackageManager . PERMISSION_GRANTED ) { Util . showAlert ( context , \"Error\" , \"Application requires permission to access the Internet\" ) ; } else { new FbDialog ( context , url , listener ) . show ( ) ; } }'", "label": "'Generate a UI dialog for the request action in the given Android context with the provided parameters .'"}
{"text": "'public void setAccessExpiresIn ( String expiresIn ) { if ( expiresIn != null ) { long expires = expiresIn . equals ( \"0\" ) ? 0 : System . currentTimeMillis ( ) + Long . parseLong ( expiresIn ) * 1000L ; setAccessExpires ( expires ) ; } }'", "label": "'Set the current session s duration ( in seconds since Unix epoch ) or 0 if session doesn t expire .'"}
{"text": "'@ Override public void put ( AuthProviderType type , UserProviderCredentials data ) { map . put ( type , data ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public JsonElement serialize ( Date src , Type typeOfSrc , JsonSerializationContext context ) { synchronized ( localFormat ) { String dateFormatAsString = enUsFormat . format ( src ) ; return new JsonPrimitive ( dateFormatAsString ) ; } }'", "label": "'See issue 162'"}
{"text": "'@ Override public String getString ( String key ) { if ( properties != null ) { String property = properties . getProperty ( key ) ; if ( property == null ) { return key ; } else { return property ; } } return null ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Deprecated public static void link ( Activity context , SocializeAuthListener listener ) { proxy . link ( context , listener ) ; }'", "label": "'Links the current user to a facebook account . The user will be presented with the Facebook authentication dialog .'"}
{"text": "'@ Deprecated public static void link ( Activity context , SocializeAuthListener listener , String ... permissions ) { proxy . link ( context , listener , permissions ) ; }'", "label": "'Links the current user to a facebook account with custom FB permissions . The user will be presented with the Facebook authentication dialog .'"}
{"text": "'@ Deprecated public static void link ( Activity context , String token , boolean verifyPermissions , SocializeAuthListener listener ) { proxy . link ( context , token , verifyPermissions , listener ) ; }'", "label": "'Links an existing Facebook access token with the current user . No authentication dialog will be shown .'"}
{"text": "'public static void postEntity ( final Activity context , final Entity entity , final String text , final SocialNetworkShareListener listener ) { if ( proxy . isLinkedForWrite ( context ) ) { proxy . postEntity ( context , entity , text , listener ) ; } else { proxy . linkForWrite ( context , new SocializeAuthListener ( ) { @ Override public void onError ( SocializeException error ) { if ( listener != null ) { listener . onNetworkError ( context , SocialNetwork . FACEBOOK , error ) ; } } @ Override public void onCancel ( ) { if ( listener != null ) { listener . onCancel ( ) ; } } @ Override public void onAuthSuccess ( SocializeSession session ) { proxy . postEntity ( context , entity , text , listener ) ; } @ Override public void onAuthFail ( SocializeException error ) { if ( listener != null ) { listener . onNetworkError ( context , SocialNetwork . FACEBOOK , error ) ; } } } ) ; } }'", "label": "'Posts an entity to the user s Facebook wall . Post data can be customized by implementing the onBeforePost method in the given SocialNetworkListener .'"}
{"text": "'public static void post ( final Activity context , final String graphPath , final Map < String , Object > params , final SocialNetworkPostListener listener ) { if ( proxy . isLinkedForWrite ( context ) ) { proxy . post ( context , graphPath , params , listener ) ; } else { proxy . linkForWrite ( context , new SocializeAuthListener ( ) { @ Override public void onError ( SocializeException error ) { if ( listener != null ) { listener . onNetworkError ( context , SocialNetwork . FACEBOOK , error ) ; } } @ Override public void onCancel ( ) { if ( listener != null ) { listener . onCancel ( ) ; } } @ Override public void onAuthSuccess ( SocializeSession session ) { proxy . post ( context , graphPath , params , listener ) ; } @ Override public void onAuthFail ( SocializeException error ) { if ( listener != null ) { listener . onNetworkError ( context , SocialNetwork . FACEBOOK , error ) ; } } } ) ; } }'", "label": "'Calls the Facebook graph API directly with a POST . This will NOT create a share object in Socialize and is simply a raw call to Facebook . NOTE : The current user must first be authenticated using a call to link . This method is asynchronous and can be run from the main UI thread .'"}
{"text": "'public static byte [ ] getImageForPost ( Activity context , Uri imagePath ) throws IOException { return proxy . getImageForPost ( context , imagePath ) ; }'", "label": "'Returns image data suitable for posting to facebook .'"}
{"text": "'public static byte [ ] getImageForPost ( Activity context , Bitmap image , CompressFormat format ) throws IOException { return proxy . getImageForPost ( context , image , format ) ; }'", "label": "'Returns image data suitable for posting to facebook .'"}
{"text": "'@ Deprecated public static void extendAccessToken ( Activity context , SocializeAuthListener listener ) { proxy . extendAccessToken ( context , listener ) ; }'", "label": "'Extends the user s Facebook access token if needed .'"}
{"text": "'public static void getCurrentPermissions ( Activity context , String token , OnPermissionResult callback ) { proxy . getCurrentPermissions ( context , token , callback ) ; }'", "label": "'Retrieves the current permissions for token provided .'"}
{"text": "'public static String [ ] getHashKeys ( Activity context ) throws NoSuchAlgorithmException { PackageInfo packageInfo = null ; String [ ] keys = null ; try { packageInfo = context . getPackageManager ( ) . getPackageInfo ( context . getPackageName ( ) , PackageManager . GET_SIGNATURES ) ; if ( packageInfo != null && packageInfo . signatures != null && packageInfo . signatures . length > 0 ) { keys = new String [ packageInfo . signatures . length ] ; for ( int i = 0 ; i < packageInfo . signatures . length ; i ++ ) { Signature signature = packageInfo . signatures [ i ] ; MessageDigest md = MessageDigest . getInstance ( \"SHA1\" ) ; md . update ( signature . toByteArray ( ) ) ; String hash = new String ( Base64 . encode ( md . digest ( ) , 0 ) ) ; keys [ i ] = hash ; } } } catch ( PackageManager . NameNotFoundException e ) { e . printStackTrace ( ) ; } return keys ; }'", "label": "'Returns the hash key used to authenticate this application with Facebook . Useful for debugging .'"}
{"text": "'@ Override protected void handle ( Activity context , SocializeAction action , String text , PropagationInfo info , SocialNetworkListener listener ) throws Exception { boolean shareCancelled = false ; Entity entity = action . getEntity ( ) ; HashMap < String , Object > postValues = new HashMap < String , Object > ( ) ; postValues . put ( ShareUtils . EXTRA_TEXT , shareMessageBuilder . buildShareMessage ( action . getEntity ( ) , info , text , false , true ) ) ; DefaultPostData postData = new DefaultPostData ( ) ; postData . setEntity ( entity ) ; postData . setPropagationInfo ( info ) ; postData . setPostValues ( postValues ) ; if ( listener != null ) { shareCancelled = listener . onBeforePost ( context , null , postData ) ; } if ( ! shareCancelled ) { String body = String . valueOf ( postValues . get ( ShareUtils . EXTRA_TEXT ) ) ; Intent sendIntent = getIntent ( context ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . KITKAT ) { sendIntent . putExtra ( Intent . EXTRA_TEXT , body ) ; } else { sendIntent . putExtra ( \"sms_body\" , body ) ; } context . startActivity ( sendIntent ) ; } if ( listener != null ) { listener . onAfterPost ( context , null , null ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public static void saveEntity ( Activity context , Entity e , EntityAddListener listener ) { proxy . saveEntity ( context , e , listener ) ; }'", "label": "'Saves or Creates an entity'"}
{"text": "'public static void getEntity ( Activity context , String key , EntityGetListener listener ) { proxy . getEntity ( context , key , listener ) ; }'", "label": "'Retrieves an entity based on its key .'"}
{"text": "'public static void getEntity ( Activity context , long id , EntityGetListener listener ) { proxy . getEntity ( context , id , listener ) ; }'", "label": "'Retrieves an entity based on its id .'"}
{"text": "'public static void getEntities ( Activity context , int start , int end , EntityListListener listener ) { proxy . getEntities ( context , start , end , SortOrder . CREATION_DATE , listener ) ; }'", "label": "'Retrieves all entities sorted by creation date .'"}
{"text": "'public static void getEntities ( Activity context , EntityListListener listener , String ... keys ) { proxy . getEntities ( context , SortOrder . CREATION_DATE , listener , keys ) ; }'", "label": "'Retrieves the entities designated by the given keys .'"}
{"text": "'public static void showEntity ( Activity context , String key , EntityGetListener listener ) { proxy . showEntity ( context , key , listener ) ; }'", "label": "'Uses the registered entity loader ( if one exists ) to load the entity denoted by the given entity key .'"}
{"text": "'public static void showEntity ( Activity context , long id , EntityGetListener listener ) { proxy . showEntity ( context , id , listener ) ; }'", "label": "'Uses the registered entity loader ( if one exists ) to load the entity denoted by the given entity ID .'"}
{"text": "'@ Override public boolean onCreateContextMenu ( SocializeUIActivity activity , ContextMenu menu , View v , ContextMenu . ContextMenuInfo menuInfo ) { return false ; }'", "label": "'Called BEFORE the default activity onCreateContextMenu event .'"}
{"text": "'protected Dialog newDialog ( Context context ) { Dialog dialog = new Dialog ( context , android . R . style . Theme_Dialog ) ; dialog . requestWindowFeature ( Window . FEATURE_NO_TITLE ) ; // Register to prevent window leakage DialogRegistration . register ( context , dialog ) ; return dialog ; }'", "label": "'So we can mock'"}
{"text": "'public static void subscribe ( Activity context , Entity e , SubscriptionType type , SubscriptionResultListener listener ) { subscriptionUtils . subscribe ( context , e , type , listener ) ; }'", "label": "'Subscribes the current user to notifications for new comments on this entity .'"}
{"text": "'public static void isSubscribed ( Activity context , Entity e , SubscriptionType type , SubscriptionCheckListener listener ) { subscriptionUtils . isSubscribed ( context , e , type , listener ) ; }'", "label": "'Determines if the current user is subscribed to notifications on new comments for the given entity .'"}
{"text": "'@ Override public SimpleNotificationMessage translate ( Context context , Bundle data , NotificationMessage message ) throws SocializeException { SimpleNotificationMessage notify = new SimpleNotificationMessage ( ) ; if ( message . getEntityId ( ) != null ) { notify . setTitle ( message . getText ( ) ) ; notify . setText ( message . getText ( ) ) ; data . putLong ( Socialize . ENTITY_ID , message . getEntityId ( ) ) ; } else { throw new SocializeException ( \"No entity id found in notification of type [\" + message . getNotificationType ( ) + \"]\" ) ; } return notify ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void executeDemo ( final String text ) { // start Facebook Login Session . OpenRequest auth = new Session . OpenRequest ( this ) ; String [ ] permissions = { \"publish_actions\" , \"user_status\" } ; auth . setPermissions ( Arrays . asList ( permissions ) ) ; auth . setLoginBehavior ( SessionLoginBehavior . SSO_WITH_FALLBACK ) ; auth . setCallback ( new Session . StatusCallback ( ) { // callback when session changes state @ Override public void call ( Session session , SessionState state , Exception exception ) { switch ( state ) { case OPENING : System . out . println ( \"OPENING\" ) ; break ; case OPENED : System . out . println ( \"OPENED\" ) ; if ( session . isOpened ( ) ) { // make request to the /me API Request . executeMeRequestAsync ( session , new Request . GraphUserCallback ( ) { // callback after Graph API response with user object @ Override public void onCompleted ( GraphUser user , Response response ) { if ( response . getError ( ) != null ) { handleError ( V3LoginActivity . this , response . getError ( ) . getException ( ) ) ; } else if ( user != null ) { handleResult ( \"Success! \" + user . getUsername ( ) ) ; } } } ) ; } break ; case CREATED : System . out . println ( \"CREATED\" ) ; break ; case CREATED_TOKEN_LOADED : System . out . println ( \"CREATED_TOKEN_LOADED\" ) ; break ; case OPENED_TOKEN_UPDATED : System . out . println ( \"OPENED_TOKEN_UPDATED\" ) ; break ; case CLOSED : System . out . println ( \"CLOSED\" ) ; if ( exception != null ) { handleError ( V3LoginActivity . this , exception ) ; } else { handleCancel ( ) ; } break ; case CLOSED_LOGIN_FAILED : System . out . println ( \"CLOSED_LOGIN_FAILED\" ) ; if ( exception != null ) { handleError ( V3LoginActivity . this , exception ) ; } else { handleCancel ( ) ; } break ; } } } ) ; Session session = new Session . Builder ( this ) . setApplicationId ( \"268891373224435\" ) . build ( ) ; Session . setActiveSession ( session ) ; session . openForPublish ( auth ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void executeDemo ( String text ) { ShareUtils . getSharesByEntity ( this , entity . getKey ( ) , 0 , PAGE_SIZE , new ShareListListener ( ) { @ Override public void onList ( ListResult < Share > shares ) { handleSocializeResult ( shares ) ; } @ Override public void onError ( SocializeException error ) { handleError ( GetSharesByEntityActivity . this , error ) ; } } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override protected Boolean doInBackground ( Void ... params ) { try { return launcher . launch ( context , extras ) ; } catch ( Exception e ) { error = e ; } return false ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public boolean assertAuthenticated ( SocializeService service , SocializeSession session , SocializeListener listener ) { if ( session != null ) { return true ; } else { if ( listener != null ) { if ( logger != null ) { listener . onError ( new SocializeException ( logger . getMessage ( SocializeLogger . NOT_AUTHENTICATED ) ) ) ; } else { listener . onError ( new SocializeException ( \"Not authenticated\" ) ) ; } } if ( logger != null ) logger . error ( SocializeLogger . NOT_AUTHENTICATED ) ; } return false ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void executeDemo ( String text ) { // We need additional permissions for this String [ ] permissions = { \"user_friends\" } ; FacebookUtils . linkForRead ( this , new SocializeAuthListener ( ) { @ Override public void onError ( SocializeException error ) { handleError ( ListFriendsActivity . this , error ) ; } @ Override public void onCancel ( ) { handleCancel ( ) ; } @ Override public void onAuthSuccess ( SocializeSession session ) { FacebookUtils . get ( ListFriendsActivity . this , \"me/friends\" , null , new SocialNetworkPostListener ( ) { @ Override public void onNetworkError ( Activity context , SocialNetwork network , Exception error ) { handleError ( context , error ) ; } @ Override public void onCancel ( ) { handleCancel ( ) ; } @ Override public void onAfterPost ( Activity parent , SocialNetwork socialNetwork , JSONObject responseObject ) { try { JSONArray jsonArray = responseObject . getJSONArray ( \"data\" ) ; StringBuilder builder = new StringBuilder ( ) ; int len = jsonArray . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { JSONObject jsonObject = jsonArray . getJSONObject ( i ) ; if ( jsonObject . has ( \"name\" ) ) { if ( i > 0 ) { builder . append ( \"\\\\n\" ) ; } builder . append ( jsonObject . get ( \"name\" ) ) ; } } handleResult ( builder . toString ( ) ) ; } catch ( JSONException e ) { handleError ( parent , e ) ; } } } ) ; } @ Override public void onAuthFail ( SocializeException error ) { handleError ( ListFriendsActivity . this , error ) ; } } , permissions ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void addEntity ( SocializeSession session , Entity entity , EntityListener listener ) { List < Entity > list = new ArrayList < Entity > ( 1 ) ; list . add ( entity ) ; postAsync ( session , ENDPOINT , list , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getEntity ( SocializeSession session , final String key , final EntityListener listener ) { listAsync ( session , ENDPOINT , key , null , null , 0 , 1 , getListenerForGet ( listener , \"No entity found with key [\" + key + \"]\" ) ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getEntities ( SocializeSession session , SortOrder sortOrder , EntityListener listener , String ... keys ) { Map < String , String > extraParams = null ; if ( ! sortOrder . equals ( SortOrder . CREATION_DATE ) ) { extraParams = new HashMap < String , String > ( ) ; extraParams . put ( \"sort\" , sortOrder . name ( ) . toLowerCase ( ) ) ; } listAsync ( session , ENDPOINT , null , \"entity_key\" , extraParams , 0 , SocializeConfig . MAX_LIST_RESULTS , listener , keys ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public boolean checkRegistrations ( Context context , SocializeSession session ) { boolean checked = false ; if ( ! checking ) { checking = true ; try { if ( appUtils . isNotificationsAvailable ( context ) ) { if ( config . getBooleanProperty ( SocializeConfig . SOCIALIZE_CHECK_NOTIFICATIONS , true ) ) { if ( logger != null && logger . isDebugEnabled ( ) ) { logger . debug ( \"Checking GCM registration state\" ) ; } boolean c2DMRegistered = notificationRegistrationSystem . isRegisteredC2DM ( context ) ; boolean socRegistered = notificationRegistrationSystem . isRegisteredSocialize ( context , session . getUser ( ) ) ; if ( ! c2DMRegistered || ! socRegistered ) { // Reload notificationRegistrationState . reload ( context ) ; c2DMRegistered = notificationRegistrationSystem . isRegisteredC2DM ( context ) ; socRegistered = notificationRegistrationSystem . isRegisteredSocialize ( context , session . getUser ( ) ) ; if ( ! c2DMRegistered || ! socRegistered ) { if ( ! c2DMRegistered && config . getBooleanProperty ( SocializeConfig . GCM_REGISTRATION_ENABLED , true ) ) { if ( notificationRegistrationSystem . isRegistrationPending ( ) ) { if ( logger != null && logger . isDebugEnabled ( ) ) { logger . debug ( \"GCM Registration already pending\" ) ; } } else { if ( logger != null && logger . isInfoEnabled ( ) ) { logger . info ( \"Not registered with GCM, sending registration request...\" ) ; } notificationRegistrationSystem . registerC2DMAsync ( context ) ; } } else if ( ! socRegistered && ! StringUtils . isEmpty ( notificationRegistrationState . getC2DMRegistrationId ( ) ) ) { if ( notificationRegistrationSystem . isSocializeRegistrationPending ( ) ) { if ( logger != null && logger . isDebugEnabled ( ) ) { logger . debug ( \"Registration already pending with Socialize for GCM\" ) ; } } else { if ( logger != null && logger . isInfoEnabled ( ) ) { logger . info ( \"Not registered with Socialize for GCM, registering...\" ) ; } notificationRegistrationSystem . registerSocialize ( context , notificationRegistrationState . getC2DMRegistrationId ( ) ) ; } } } else { if ( logger != null && logger . isDebugEnabled ( ) ) { logger . debug ( \"GCM registration OK\" ) ; } } } else { if ( logger != null && logger . isDebugEnabled ( ) ) { logger . debug ( \"GCM registration OK\" ) ; } } checked = true ; } else { if ( logger != null && logger . isWarnEnabled ( ) ) { logger . warn ( \"GCM registration check skipped\" ) ; } } } else { if ( logger != null && logger . isInfoEnabled ( ) ) { logger . info ( \"Notifications not enabled.  Check the AndroidManifest.xml for correct configuration.\" ) ; } checked = true ; } } finally { checking = false ; } } return checked ; }'", "label": "'Called at application startup .'"}
{"text": "'@ Override public void onReceive ( Context context , Intent intent ) { getSocialize ( ) . handleBroadcastIntent ( context , intent ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void setAction ( Context context , final SocializeAction action ) { try { doSetAction ( action ) ; } catch ( Exception e ) { setText ( \"Error!\" ) ; if ( logger != null ) { logger . error ( \"Error rendering action text\" , e ) ; } else { SocializeLogger . e ( e . getMessage ( ) , e ) ; } } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void executeDemo ( String text ) { TwitterUtils . link ( this , new SocializeAuthListener ( ) { @ Override public void onError ( SocializeException error ) { handleError ( GetTokenActivity . this , error ) ; } @ Override public void onCancel ( ) { handleCancel ( ) ; } @ Override public void onAuthSuccess ( SocializeSession session ) { UserProviderCredentials userProviderCredentials = session . getUserProviderCredentials ( AuthProviderType . TWITTER ) ; handleResult ( userProviderCredentials . getAccessToken ( ) ) ; } @ Override public void onAuthFail ( SocializeException error ) { handleError ( GetTokenActivity . this , error ) ; } } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public JsonToken peek ( ) throws IOException { if ( token != null ) { return token ; } switch ( stack [ stackSize - 1 ] ) { case EMPTY_DOCUMENT : if ( lenient ) { consumeNonExecutePrefix ( ) ; } stack [ stackSize - 1 ] = JsonScope . NONEMPTY_DOCUMENT ; JsonToken firstToken = nextValue ( ) ; if ( ! lenient && token != JsonToken . BEGIN_ARRAY && token != JsonToken . BEGIN_OBJECT ) { throw new IOException ( \"Expected JSON document to start with \\'[\\' or \\'{\\' but was \" + token + \" at line \" + getLineNumber ( ) + \" column \" + getColumnNumber ( ) ) ; } return firstToken ; case EMPTY_ARRAY : return nextInArray ( true ) ; case NONEMPTY_ARRAY : return nextInArray ( false ) ; case EMPTY_OBJECT : return nextInObject ( true ) ; case DANGLING_NAME : return objectValue ( ) ; case NONEMPTY_OBJECT : return nextInObject ( false ) ; case NONEMPTY_DOCUMENT : int c = nextNonWhitespace ( false ) ; if ( c == - 1 ) { return JsonToken . END_DOCUMENT ; } pos -- ; if ( ! lenient ) { throw syntaxError ( \"Expected EOF\" ) ; } return nextValue ( ) ; case CLOSED : throw new IllegalStateException ( \"JsonReader is closed\" ) ; default : throw new AssertionError ( ) ; } }'", "label": "'Returns the type of the next token without consuming it .'"}
{"text": "'public String nextString ( ) throws IOException { peek ( ) ; if ( token != JsonToken . STRING && token != JsonToken . NUMBER ) { throw new IllegalStateException ( \"Expected a string but was \" + peek ( ) + \" at line \" + getLineNumber ( ) + \" column \" + getColumnNumber ( ) ) ; } String result = value ; advance ( ) ; return result ; }'", "label": "'Returns the { @link JsonToken#STRING string } value of the next token consuming it . If the next token is a number this method will return its string form .'"}
{"text": "'public boolean nextBoolean ( ) throws IOException { peek ( ) ; if ( token != JsonToken . BOOLEAN ) { throw new IllegalStateException ( \"Expected a boolean but was \" + token + \" at line \" + getLineNumber ( ) + \" column \" + getColumnNumber ( ) ) ; } boolean result = ( value == TRUE ) ; advance ( ) ; return result ; }'", "label": "'Returns the { @link JsonToken#BOOLEAN boolean } value of the next token consuming it .'"}
{"text": "'public void nextNull ( ) throws IOException { peek ( ) ; if ( token != JsonToken . NULL ) { throw new IllegalStateException ( \"Expected null but was \" + token + \" at line \" + getLineNumber ( ) + \" column \" + getColumnNumber ( ) ) ; } advance ( ) ; }'", "label": "'Consumes the next token from the JSON stream and asserts that it is a literal null .'"}
{"text": "'public double nextDouble ( ) throws IOException { peek ( ) ; if ( token != JsonToken . STRING && token != JsonToken . NUMBER ) { throw new IllegalStateException ( \"Expected a double but was \" + token + \" at line \" + getLineNumber ( ) + \" column \" + getColumnNumber ( ) ) ; } double result = Double . parseDouble ( value ) ; if ( ( result >= 1.0d && value . startsWith ( \"0\" ) ) ) { throw new MalformedJsonException ( \"JSON forbids octal prefixes: \" + value + \" at line \" + getLineNumber ( ) + \" column \" + getColumnNumber ( ) ) ; } if ( ! lenient && ( Double . isNaN ( result ) || Double . isInfinite ( result ) ) ) { throw new MalformedJsonException ( \"JSON forbids NaN and infinities: \" + value + \" at line \" + getLineNumber ( ) + \" column \" + getColumnNumber ( ) ) ; } advance ( ) ; return result ; }'", "label": "'Returns the { @link JsonToken#NUMBER double } value of the next token consuming it . If the next token is a string this method will attempt to parse it as a double using { @link Double#parseDouble ( String ) } .'"}
{"text": "'public long nextLong ( ) throws IOException { peek ( ) ; if ( token != JsonToken . STRING && token != JsonToken . NUMBER ) { throw new IllegalStateException ( \"Expected a long but was \" + token + \" at line \" + getLineNumber ( ) + \" column \" + getColumnNumber ( ) ) ; } long result ; try { result = Long . parseLong ( value ) ; } catch ( NumberFormatException ignored ) { double asDouble = Double . parseDouble ( value ) ; // don\\'t catch this NumberFormatException result = ( long ) asDouble ; if ( result != asDouble ) { throw new NumberFormatException ( \"Expected a long but was \" + value + \" at line \" + getLineNumber ( ) + \" column \" + getColumnNumber ( ) ) ; } } if ( result >= 1L && value . startsWith ( \"0\" ) ) { throw new MalformedJsonException ( \"JSON forbids octal prefixes: \" + value + \" at line \" + getLineNumber ( ) + \" column \" + getColumnNumber ( ) ) ; } advance ( ) ; return result ; }'", "label": "'Returns the { @link JsonToken#NUMBER long } value of the next token consuming it . If the next token is a string this method will attempt to parse it as a long . If the next token s numeric value cannot be exactly represented by a Java { @code long } this method throws .'"}
{"text": "'public int nextInt ( ) throws IOException { peek ( ) ; if ( token != JsonToken . STRING && token != JsonToken . NUMBER ) { throw new IllegalStateException ( \"Expected an int but was \" + token + \" at line \" + getLineNumber ( ) + \" column \" + getColumnNumber ( ) ) ; } int result ; try { result = Integer . parseInt ( value ) ; } catch ( NumberFormatException ignored ) { double asDouble = Double . parseDouble ( value ) ; // don\\'t catch this NumberFormatException result = ( int ) asDouble ; if ( result != asDouble ) { throw new NumberFormatException ( \"Expected an int but was \" + value + \" at line \" + getLineNumber ( ) + \" column \" + getColumnNumber ( ) ) ; } } if ( result >= 1L && value . startsWith ( \"0\" ) ) { throw new MalformedJsonException ( \"JSON forbids octal prefixes: \" + value + \" at line \" + getLineNumber ( ) + \" column \" + getColumnNumber ( ) ) ; } advance ( ) ; return result ; }'", "label": "'Returns the { @link JsonToken#NUMBER int } value of the next token consuming it . If the next token is a string this method will attempt to parse it as an int . If the next token s numeric value cannot be exactly represented by a Java { @code int } this method throws .'"}
{"text": "'public void close ( ) throws IOException { value = null ; token = null ; stack [ 0 ] = JsonScope . CLOSED ; stackSize = 1 ; in . close ( ) ; }'", "label": "'Closes this JSON reader and the underlying {'"}
{"text": "\"private boolean fillBuffer ( int minimum ) throws IOException { char [ ] buffer = this . buffer ; // Before clobbering the old characters, update where buffer starts // Using locals here saves ~2%. int line = bufferStartLine ; int column = bufferStartColumn ; for ( int i = 0 , p = pos ; i < p ; i ++ ) { if ( buffer [ i ] == ' ' ) { line ++ ; column = 1 ; } else { column ++ ; } } bufferStartLine = line ; bufferStartColumn = column ; if ( limit != pos ) { limit -= pos ; System . arraycopy ( buffer , pos , buffer , 0 , limit ) ; } else { limit = 0 ; } pos = 0 ; int total ; while ( ( total = in . read ( buffer , limit , buffer . length - limit ) ) != - 1 ) { limit += total ; // if this is the first read, consume an optional byte order mark (BOM) if it exists if ( bufferStartLine == 1 && bufferStartColumn == 1 && limit > 0 && buffer [ 0 ] == ' ' ) { pos ++ ; bufferStartColumn -- ; } if ( limit >= minimum ) { return true ; } } return false ; }\"", "label": "'Returns true once {'"}
{"text": "'private char readEscapeCharacter ( ) throws IOException { if ( pos == limit && ! fillBuffer ( 1 ) ) { throw syntaxError ( \"Unterminated escape sequence\" ) ; } char escaped = buffer [ pos ++ ] ; switch ( escaped ) { case \\' \\' : if ( pos + 4 > limit && ! fillBuffer ( 4 ) ) { throw syntaxError ( \"Unterminated escape sequence\" ) ; } // Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16); char result = 0 ; for ( int i = pos , end = i + 4 ; i < end ; i ++ ) { char c = buffer [ i ] ; result <<= 4 ; if ( c >= \\' \\' && c <= \\' \\' ) { result += ( c - \\' \\' ) ; } else if ( c >= \\' \\' && c <= \\' \\' ) { result += ( c - \\' \\' + 10 ) ; } else if ( c >= \\' \\' && c <= \\' \\' ) { result += ( c - \\' \\' + 10 ) ; } else { throw new NumberFormatException ( \"\\\\\\\\u\" + stringPool . get ( buffer , pos , 4 ) ) ; } } pos += 4 ; return result ; case \\' \\' : return \\' \\' ; case \\' \\' : return \\' \\' ; case \\' \\' : return \\' \\' ; case \\' \\' : return \\' \\' ; case \\' \\' : return \\' \\' ; case \\' \\' : case \\' \\' : case \\' \\' : default : return escaped ; } }'", "label": "'Unescapes the character identified by the character or characters that immediately follow a backslash . The backslash \\\\ should have already been read . This supports both unicode escapes u000A and two - character escapes \\\\ n .'"}
{"text": "'public static void showShareDialog ( Activity context , Entity entity ) { proxy . showShareDialog ( context , entity , DEFAULT , null , null ) ; }'", "label": "'Displays the default share dialog . In most cases this is the simplest version to use .'"}
{"text": "'public static void showShareDialog ( Activity context , Entity entity , SocialNetworkDialogListener listener ) { proxy . showShareDialog ( context , entity , DEFAULT , listener , listener ) ; }'", "label": "'Displays the default share dialog and allows for the handling of share dialog events .'"}
{"text": "'public static void shareViaEmail ( Activity context , Entity entity , ShareAddListener listener ) { proxy . shareViaEmail ( context , entity , listener ) ; }'", "label": "'Shares the given entity via email . This method with launch the default email application on the device .'"}
{"text": "'public static void shareViaGooglePlus ( Activity context , Entity entity , ShareAddListener listener ) { proxy . shareViaGooglePlus ( context , entity , listener ) ; }'", "label": "'Shares the given entity via Google + . This method with launch the Google + application on the device .'"}
{"text": "'public static void shareViaOther ( Activity context , Entity entity , ShareAddListener listener ) { proxy . shareViaOther ( context , entity , listener ) ; }'", "label": "'Shares the given entity via a user selected medium . This method with launch the default application share dialog on the device .'"}
{"text": "'public static void shareViaSMS ( Activity context , Entity entity , ShareAddListener listener ) { proxy . shareViaSMS ( context , entity , listener ) ; }'", "label": "'Shares the given entity via SMS . This method with launch the default SMS application on the device .'"}
{"text": "'public static void shareViaSocialNetworks ( Activity context , Entity entity , ShareOptions shareOptions , SocialNetworkShareListener listener , SocialNetwork ... networks ) { proxy . shareViaSocialNetworks ( context , entity , shareOptions , listener , networks ) ; }'", "label": "'Shares the given entity via a Social Network such as Twitter or Facebook . This will prompt the user to select a network .'"}
{"text": "'public static void getShare ( Activity context , ShareGetListener listener , long id ) { proxy . getShare ( context , listener , id ) ; }'", "label": "'Retrieves a single share event based on ID .'"}
{"text": "'public static void getShares ( Activity context , ShareListListener listener , long ... ids ) { proxy . getShares ( context , listener , ids ) ; }'", "label": "'Retrieves multiple share events based on ID .'"}
{"text": "'public static void getSharesByUser ( Activity context , User user , int start , int end , ShareListListener listener ) { proxy . getSharesByUser ( context , user , start , end , listener ) ; }'", "label": "'Retrieves all share events performed by the given user .'"}
{"text": "'public static void getSharesByEntity ( Activity context , String entityKey , int start , int end , ShareListListener listener ) { proxy . getSharesByEntity ( context , entityKey , start , end , listener ) ; }'", "label": "'Retrieves all share events performed on the given entity .'"}
{"text": "'public static void getSharesByApplication ( Activity context , int start , int end , ShareListListener listener ) { proxy . getSharesByApplication ( context , start , end , listener ) ; }'", "label": "'Retrieves all share events across all entities .'"}
{"text": "'public static void registerShare ( Activity context , Entity entity , ShareOptions shareOptions , ShareAddListener listener , SocialNetwork ... networks ) { proxy . registerShare ( context , entity , shareOptions , listener , networks ) ; }'", "label": "'Creates a simple Socialize Share object . NOTE : This does NOT perform any actual sharing ( propagation ) . It is used to simply record the fact that a share is taking place . This is useful when you want to utilize the auto - generated entity links returned in the propagation info response to post directly to Facebook or Twitter .'"}
{"text": "'@ Override public void executeDemo ( final String text ) { EntityUtils . getEntity ( this , text , new EntityGetListener ( ) { @ Override public void onGet ( Entity entity ) { handleBasicSocializeResult ( entity ) ; } @ Override public void onError ( SocializeException error ) { if ( isNotFoundError ( error ) ) { handleResult ( \"No entity found with key [\" + text + \"]\" ) ; } else { handleError ( GetEntityByKeyActivity . this , error ) ; } } } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void show ( ) { if ( deviceUtils != null && deviceUtils . hasCamera ( ) ) { final String items [ ] = { \"From Gallery\" , \"From Camera\" } ; AlertDialog . Builder ab = new AlertDialog . Builder ( context ) ; ab . setTitle ( \"New Profile Picture\" ) ; ab . setItems ( items , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface d , int choice ) { if ( choice == 0 ) { launchGallery ( ) ; } else if ( choice == 1 ) { launchCamera ( ) ; } } } ) ; ab . setNegativeButton ( \"Cancel\" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { dialog . cancel ( ) ; } } ) ; ab . show ( ) ; } else { launchGallery ( ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void authenticateWithActivity ( Activity context , FacebookAuthProviderInfo info , boolean sso , final AuthProviderListener listener ) { final String listenerKey = \"auth\" ; holder . push ( listenerKey , new AuthProviderListener ( ) { @ Override public void onError ( SocializeException error ) { holder . remove ( listenerKey ) ; listener . onError ( error ) ; } @ Override public void onAuthSuccess ( AuthProviderResponse response ) { holder . remove ( listenerKey ) ; listener . onAuthSuccess ( response ) ; } @ Override public void onAuthFail ( SocializeException error ) { holder . remove ( listenerKey ) ; listener . onAuthFail ( error ) ; } @ Override public void onCancel ( ) { holder . remove ( listenerKey ) ; listener . onCancel ( ) ; } } ) ; Intent i = new Intent ( context , FacebookActivity . class ) ; i . putExtra ( \"appId\" , info . getAppId ( ) ) ; i . putExtra ( \"sso\" , sso ) ; i . putExtra ( \"type\" , info . getPermissionType ( ) . toString ( ) ) ; switch ( info . getPermissionType ( ) ) { case READ : if ( info . getReadPermissions ( ) != null ) { i . putExtra ( \"permissions\" , info . getReadPermissions ( ) ) ; } break ; case WRITE : if ( info . getWritePermissions ( ) != null ) { i . putExtra ( \"permissions\" , info . getWritePermissions ( ) ) ; } break ; } context . startActivity ( i ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Deprecated @ Override public void link ( Activity context , SocializeAuthListener listener ) { linkForWrite ( context , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Deprecated @ Override public void link ( Activity context , SocializeAuthListener listener , String ... permissions ) { getSocialize ( ) . authenticate ( context , AuthProviderType . FACEBOOK , listener , permissions ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public String getAccessToken ( Context context ) { UserProviderCredentials creds = getSocialize ( ) . getSession ( ) . getUserProviderCredentials ( AuthProviderType . FACEBOOK ) ; if ( creds != null ) { return creds . getAccessToken ( ) ; } return null ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void unlink ( final Context context , final SocializeDeAuthListener listener ) { // Clear the FB session try { new AsyncTask < Void , Void , Void > ( ) { @ Override protected Void doInBackground ( Void ... params ) { try { SocializeSession session = getSocialize ( ) . getSession ( ) ; session . clear ( AuthProviderType . FACEBOOK ) ; UserSettings userSettings = session . getUserSettings ( ) ; if ( userSettings != null ) { userSettings . setAutoPostFacebook ( false ) ; } userSystem . saveSession ( context , session ) ; logout ( context ) ; if ( listener != null ) { listener . onSuccess ( ) ; } } catch ( Exception e ) { if ( listener != null ) { listener . onError ( SocializeException . wrap ( e ) ) ; } } return null ; } } . execute ( ) ; } catch ( Exception e ) { if ( logger != null ) { logger . error ( \"Error while logging out of Facebook\" , e ) ; } else { e . printStackTrace ( ) ; } } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void postLike ( Activity parent , Entity entity , PropagationInfo propInfo , SocialNetworkListener listener ) { if ( config . isOGLike ( ) ) { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( \"object\" , propInfo . getEntityUrl ( ) ) ; post ( parent , \"me/og.likes\" , params , listener ) ; } else { post ( parent , entity , \"\" , propInfo , listener ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void postEntity ( Activity context , Entity entity , String text , SocialNetworkShareListener listener ) { ShareOptions options = ShareUtils . getUserShareOptions ( context ) ; options . setText ( text ) ; options . setShowAuthDialog ( false ) ; ShareUtils . shareViaSocialNetworks ( context , entity , options , listener , SocialNetwork . FACEBOOK ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void postComment ( Activity parent , Entity entity , String comment , PropagationInfo propInfo , SocialNetworkListener listener ) { post ( parent , entity , comment , propInfo , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void postOG ( Activity parent , Entity entity , String message , String action , PropagationInfo propInfo , SocialNetworkListener listener ) { String entityUrl = propInfo . getEntityUrl ( ) ; String linkName = entityUrl ; String link = entityUrl ; if ( entity != null ) { linkName = entity . getDisplayName ( ) ; } final Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( \"name\" , linkName ) ; params . put ( \"message\" , message ) ; params . put ( \"link\" , link ) ; params . put ( \"type\" , \"link\" ) ; DefaultPostData postData = new DefaultPostData ( ) ; postData . setPostValues ( params ) ; postData . setEntity ( entity ) ; postData . setPropagationInfo ( propInfo ) ; post ( parent , listener , postData ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void post ( Activity parent , Entity entity , String message , PropagationInfo propInfo , SocialNetworkListener listener ) { postOG ( parent , entity , message , null , propInfo , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void post ( Activity parent , SocialNetworkListener listener , PostData postData ) { doFacebookCall ( parent , postData . getPostValues ( ) , \"me/feed\" , HttpMethod . POST , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void post ( Activity parent , String graphPath , Map < String , Object > postData , SocialNetworkPostListener listener ) { doFacebookCall ( parent , postData , graphPath , HttpMethod . POST , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void get ( Activity parent , String graphPath , Map < String , Object > postData , SocialNetworkPostListener listener ) { doFacebookCall ( parent , postData , graphPath , HttpMethod . GET , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void delete ( Activity parent , String graphPath , Map < String , Object > postData , SocialNetworkPostListener listener ) { doFacebookCall ( parent , postData , graphPath , HttpMethod . DELETE , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public String buildShareSubject ( Entity entity ) { String entityKey = entity . getKey ( ) ; String entityName = entity . getName ( ) ; StringBuilder builder = new StringBuilder ( ) ; SocializeSession session = getSocialize ( ) . getSession ( ) ; User currentUser = null ; if ( session != null ) { currentUser = session . getUser ( ) ; } String sharingText = localizationService . getString ( I18NConstants . SHARE_TEXT_SHARING ) ; String sharedText = localizationService . getString ( I18NConstants . SHARE_TEXT_SHARED ) ; if ( currentUser != null ) { String name = currentUser . getDisplayName ( ) ; if ( StringUtils . isEmpty ( name ) ) { builder . append ( sharingText ) ; builder . append ( \" \" ) ; } else { builder . append ( name ) ; builder . append ( \" \" ) ; builder . append ( sharedText ) ; builder . append ( \" \" ) ; } } else { builder . append ( sharingText ) ; builder . append ( \" \" ) ; } if ( ! StringUtils . isEmpty ( entityName ) ) { builder . append ( entityName ) ; } else { builder . append ( entityKey ) ; } return builder . toString ( ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'protected ITwitterAuthWebView newTwitterAuthWebView ( Context context ) { if ( twitterAuthWebViewFactory != null ) { return twitterAuthWebViewFactory . getBean ( ) ; } return new TwitterAuthWebView ( context ) ; }'", "label": "'So we can mock'"}
{"text": "'@ Override public void show ( Context context , final Entity entity , final SocialNetworkListener socialNetworkListener , final ShareDialogListener shareDialoglistener , final int displayOptions ) { showDialog ( context , new BeanCreationListener < SharePanelView > ( ) { @ Override public void onError ( String name , Exception e ) { } @ Override public void onCreate ( SharePanelView bean ) { bean . setSocialNetworkListener ( socialNetworkListener ) ; bean . setEntity ( entity ) ; bean . setShareDialogListener ( shareDialoglistener ) ; bean . setDisplayOptions ( displayOptions ) ; bean . applyDisplayOptions ( ) ; bean . updateNetworkButtonState ( ) ; } } , new ShareDialogListener ( ) { @ Override public void onShow ( Dialog dialog , SharePanelView dialogView ) { recordEvent ( \"show\" ) ; if ( shareDialoglistener != null ) { shareDialoglistener . onShow ( dialog , dialogView ) ; } } @ Override public void onSimpleShare ( ShareType type ) { recordEvent ( \"share\" , type . name ( ) ) ; if ( shareDialoglistener != null ) { shareDialoglistener . onSimpleShare ( type ) ; } } @ Override public void onCancel ( Dialog dialog ) { recordEvent ( \"close\" ) ; if ( shareDialoglistener != null ) { shareDialoglistener . onCancel ( dialog ) ; } } @ Override public boolean onContinue ( Dialog dialog , boolean remember , SocialNetwork ... networks ) { recordEvent ( \"share\" , networks ) ; return shareDialoglistener != null && shareDialoglistener . onContinue ( dialog , remember , networks ) ; } @ Override public void onFlowInterrupted ( DialogFlowController controller ) { if ( shareDialoglistener != null ) { shareDialoglistener . onFlowInterrupted ( controller ) ; } } } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void onClick ( View v ) { // Show a progress bar... final ProgressDialog progress = progressDialogFactory . show ( context , I18NConstants . DLG_SETTINGS , I18NConstants . PLEASE_WAIT ) ; // Get the updated info UserSettings profile = new UserSettings ( ) ; profile . setFirstName ( view . getFirstNameEdit ( ) . getText ( ) . toString ( ) . trim ( ) ) ; profile . setLastName ( view . getLastNameEdit ( ) . getText ( ) . toString ( ) . trim ( ) ) ; // Settings will only be changed if the image was altered // See ProfileView#onImageChange Drawable imageOn = view . getProfilePictureEditView ( ) . getProfileImage ( ) ; if ( imageOn instanceof BitmapDrawable ) { profile . setImage ( ( ( BitmapDrawable ) imageOn ) . getBitmap ( ) ) ; } if ( view . getAutoPostFacebook ( ) != null ) { profile . setAutoPostFacebook ( view . getAutoPostFacebook ( ) . isChecked ( ) ) ; } if ( view . getAutoPostTwitter ( ) != null ) { profile . setAutoPostTwitter ( view . getAutoPostTwitter ( ) . isChecked ( ) ) ; } if ( view . getNotificationsEnabledCheckbox ( ) != null ) { profile . setNotificationsEnabled ( view . getNotificationsEnabledCheckbox ( ) . isChecked ( ) ) ; } if ( view . getLocationEnabledCheckbox ( ) != null ) { profile . setLocationEnabled ( view . getLocationEnabledCheckbox ( ) . isChecked ( ) ) ; } profileSaver . save ( context , profile , new UserSaveListener ( ) { @ Override public void onError ( SocializeException error ) { progress . dismiss ( ) ; if ( errorHandler != null ) { errorHandler . handleError ( context , error ) ; } } @ Override public void onUpdate ( User entity ) { progress . dismiss ( ) ; context . setResult ( CommentActivity . PROFILE_UPDATE ) ; context . finish ( ) ; } } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public synchronized < T > T fromJSON ( String json , Class < T > cls ) { return gson . fromJson ( json , cls ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'protected PendingIntent getPendingIntent ( Context context , NotificationMessage message , Intent notificationIntent ) { return PendingIntent . getActivity ( context , getNotificationId ( message ) , notificationIntent , PendingIntent . FLAG_CANCEL_CURRENT ) ; }'", "label": "'So we can mock'"}
{"text": "'protected Notification newNotification ( int icon , String text , long time ) { return new Notification ( icon , text , time ) ; }'", "label": "'So we can mock'"}
{"text": "'@ Override public boolean isAvailableOnDevice ( Context context ) { try { context . getPackageManager ( ) . getPackageInfo ( PLUS_PACKAGE , 0 ) ; return true ; } catch ( NameNotFoundException e ) { return false ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override protected void handle ( Activity context , SocializeAction action , String text , PropagationInfo info , SocialNetworkListener listener ) throws Exception { boolean shareCancelled = false ; Entity entity = action . getEntity ( ) ; HashMap < String , Object > postValues = new HashMap < String , Object > ( ) ; postValues . put ( ShareUtils . EXTRA_SUBJECT , shareMessageBuilder . buildShareSubject ( entity ) ) ; postValues . put ( ShareUtils . EXTRA_TEXT , shareMessageBuilder . buildShareMessage ( entity , info , text , false , true ) ) ; DefaultPostData postData = new DefaultPostData ( ) ; postData . setEntity ( entity ) ; postData . setPropagationInfo ( info ) ; postData . setPostValues ( postValues ) ; if ( listener != null ) { shareCancelled = listener . onBeforePost ( context , null , postData ) ; } if ( ! shareCancelled ) { String body = String . valueOf ( postValues . get ( ShareUtils . EXTRA_TEXT ) ) ; String subject = String . valueOf ( postValues . get ( ShareUtils . EXTRA_SUBJECT ) ) ; Intent shareIntent = new Intent ( ) . setAction ( Intent . ACTION_SEND ) ; shareIntent . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET ) ; shareIntent . putExtra ( Intent . EXTRA_TEXT , body ) ; shareIntent . putExtra ( Intent . EXTRA_SUBJECT , subject ) ; shareIntent . setType ( \"text/plain\" ) ; shareIntent . setPackage ( PLUS_PACKAGE ) ; context . startActivity ( shareIntent ) ; } if ( listener != null ) { listener . onAfterPost ( context , null , null ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public static void like ( Activity context , Entity entity , LikeAddListener listener ) { proxy . like ( context , entity , listener ) ; }'", "label": "'Records a like against the given entity for the current user . This method will also prompt the user to share their like .'"}
{"text": "'public static void like ( Activity context , Entity entity , LikeOptions likeOptions , LikeAddListener listener , SocialNetwork ... networks ) { proxy . like ( context , entity , likeOptions , listener , networks ) ; }'", "label": "'Records a like against the given entity for the current user . This method will NOT prompt the user to share their like .'"}
{"text": "'public static void unlike ( Activity context , String entityKey , LikeDeleteListener listener ) { proxy . unlike ( context , entityKey , listener ) ; }'", "label": "'Removes a like previously created for the current user .'"}
{"text": "'public static void getLike ( Activity context , String entityKey , LikeGetListener listener ) { proxy . getLike ( context , entityKey , listener ) ; }'", "label": "'Retrieves a like for an entity and the current user .'"}
{"text": "'public static void getLike ( Activity context , long id , LikeGetListener listener ) { proxy . getLike ( context , id , listener ) ; }'", "label": "'Retrieves a like based on its ID .'"}
{"text": "'public static void isLiked ( Activity context , String entityKey , IsLikedListener listener ) { proxy . getLike ( context , entityKey , listener ) ; }'", "label": "'Determines if the given entity has been liked by the current user .'"}
{"text": "'public static void getLikesByUser ( Activity context , User user , int start , int end , LikeListListener listener ) { proxy . getLikesByUser ( context , user , start , end , listener ) ; }'", "label": "'Lists all likes for the given user .'"}
{"text": "'public static void getLikesByEntity ( Activity context , String entityKey , int start , int end , LikeListListener listener ) { proxy . getLikesByEntity ( context , entityKey , start , end , listener ) ; }'", "label": "'Lists all likes for the given entity .'"}
{"text": "'public static void getLikesByApplication ( Activity context , int start , int end , LikeListListener listener ) { proxy . getLikesByApplication ( context , start , end , listener ) ; }'", "label": "'Lists all likes for all entities /'"}
{"text": "'public static void makeLikeButton ( Activity context , CompoundButton button , Entity entity , LikeButtonListener listener ) { proxy . makeLikeButton ( context , button , entity , listener ) ; }'", "label": "'Turns a regular CompoundButton ( CheckBox ToggleButton etc ) into a Socialize Like button .'"}
{"text": "'@ Deprecated @ Override public synchronized Facebook getFacebook ( Context context ) { if ( facebook == null ) { facebook = new Facebook ( config . getProperty ( SocializeConfig . FACEBOOK_APP_ID ) ) ; } return facebook ; }'", "label": "'DO NOT CALL'"}
{"text": "'@ Override public void linkForRead ( Activity context , SocializeAuthListener listener , String ... permissions ) { facebookFacade . linkForRead ( context , listener , permissions ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Deprecated @ Override public void link ( Activity context , SocializeAuthListener listener ) { facebookFacade . link ( context , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Deprecated @ Override public void link ( final Activity context , final String token , final boolean verifyPermissions , final SocializeAuthListener listener ) { facebookFacade . link ( context , token , verifyPermissions , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void unlink ( final Context context , final SocializeDeAuthListener listener ) { facebookFacade . unlink ( context , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public boolean isLinkedForRead ( Context context , String ... permissions ) { return facebookFacade . isLinkedForRead ( context , permissions ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public boolean isLinkedForWrite ( Context context , String ... permissions ) { return facebookFacade . isLinkedForWrite ( context , permissions ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public boolean isAvailable ( Context context ) { return authProviderInfoBuilder . isSupported ( AuthProviderType . FACEBOOK ) && ( facebookFacade . getSDKMajorVersion ( ) == 2 || appUtils . isActivityAvailable ( context , \"com.facebook.LoginActivity\" ) ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void setAppId ( Context context , String appId ) { SocializeConfig config = ConfigUtils . getConfig ( context ) ; config . setFacebookAppId ( appId ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override protected void onResume ( ) { super . onResume ( ) ; StringBuilder builder = new StringBuilder ( ) ; builder . append ( \"isLinkedForRead:\" ) . append ( FacebookUtils . isLinkedForRead ( this ) ) . append ( \"\\\\n\\\\n\" ) . append ( \"isLinkedForWrite:\" ) . append ( FacebookUtils . isLinkedForWrite ( this ) ) ; Toast . makeText ( this , builder . toString ( ) , Toast . LENGTH_LONG ) . show ( ) ; }'", "label": "'}'"}
{"text": "'@ Override public void onScroll ( AbsListView view , int firstVisibleItem , int visibleItemCount , int totalItemCount ) { // what is the bottom item that is visible int lastInScreen = firstVisibleItem + visibleItemCount ; boolean last = ( lastInScreen == totalItemCount ) ; if ( last && callback . hasMoreItems ( ) && ! callback . isLoading ( ) ) { // Get next set... callback . onGetNextSet ( ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'protected void completeOAuthParameters ( HttpParameters out ) { if ( ! out . containsKey ( OAuth . OAUTH_CONSUMER_KEY ) ) { out . put ( OAuth . OAUTH_CONSUMER_KEY , consumerKey , true ) ; } if ( ! out . containsKey ( OAuth . OAUTH_SIGNATURE_METHOD ) ) { out . put ( OAuth . OAUTH_SIGNATURE_METHOD , messageSigner . getSignatureMethod ( ) , true ) ; } if ( ! out . containsKey ( OAuth . OAUTH_TIMESTAMP ) ) { out . put ( OAuth . OAUTH_TIMESTAMP , generateTimestamp ( ) , true ) ; } if ( ! out . containsKey ( OAuth . OAUTH_NONCE ) ) { out . put ( OAuth . OAUTH_NONCE , generateNonce ( ) , true ) ; } if ( ! out . containsKey ( OAuth . OAUTH_VERSION ) ) { out . put ( OAuth . OAUTH_VERSION , OAuth . VERSION_1_0 , true ) ; } if ( ! out . containsKey ( OAuth . OAUTH_TOKEN ) ) { if ( token != null && ! token . equals ( \"\" ) || sendEmptyTokens ) { out . put ( OAuth . OAUTH_TOKEN , token , true ) ; } } }'", "label": "'<p > Helper method that adds any OAuth parameters to the given request parameters which are missing from the current request but required for signing . A good example is the oauth_nonce parameter which is typically not provided by the client in advance . < / p > <p > It s probably not a very good idea to override this method . If you want to generate different nonces or timestamps override { @link #generateNonce () } or { @link #generateTimestamp () } instead . < / p >'"}
{"text": "'protected void collectHeaderParameters ( HttpRequest request , HttpParameters out ) { HttpParameters headerParams = OAuth . oauthHeaderToParamsMap ( request . getHeader ( OAuth . HTTP_AUTHORIZATION_HEADER ) ) ; out . putAll ( headerParams , false ) ; }'", "label": "'Collects OAuth Authorization header parameters as per OAuth Core 1 . 0 spec section 9 . 1 . 1'"}
{"text": "'protected void collectBodyParameters ( HttpRequest request , HttpParameters out ) throws IOException { // collect x-www-form-urlencoded body params String contentType = request . getContentType ( ) ; if ( contentType != null && contentType . startsWith ( OAuth . FORM_ENCODED ) ) { InputStream payload = request . getMessagePayload ( ) ; out . putAll ( OAuth . decodeForm ( payload ) , true ) ; } }'", "label": "'Collects x - www - form - urlencoded body parameters as per OAuth Core 1 . 0 spec section 9 . 1 . 1'"}
{"text": "\"protected void collectQueryParameters ( HttpRequest request , HttpParameters out ) { String url = request . getRequestUrl ( ) ; int q = url . indexOf ( ' ' ) ; if ( q >= 0 ) { // Combine the URL query string with the other parameters: out . putAll ( OAuth . decodeForm ( url . substring ( q + 1 ) ) , true ) ; } }\"", "label": "'Collects HTTP GET query string parameters as per OAuth Core 1 . 0 spec section 9 . 1 . 1'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public < T > TypeAdapter < T > getAdapter ( TypeToken < T > type ) { TypeAdapter < ? > cached = typeTokenCache . get ( type ) ; if ( cached != null ) { return ( TypeAdapter < T > ) cached ; } Map < TypeToken < ? > , FutureTypeAdapter < ? > > threadCalls = calls . get ( ) ; // the key and value type parameters always agree FutureTypeAdapter < T > ongoingCall = ( FutureTypeAdapter < T > ) threadCalls . get ( type ) ; if ( ongoingCall != null ) { return ongoingCall ; } FutureTypeAdapter < T > call = new FutureTypeAdapter < T > ( ) ; threadCalls . put ( type , call ) ; try { for ( TypeAdapterFactory factory : factories ) { TypeAdapter < T > candidate = factory . create ( this , type ) ; if ( candidate != null ) { call . setDelegate ( candidate ) ; typeTokenCache . put ( type , candidate ) ; return candidate ; } } throw new IllegalArgumentException ( \"GSON cannot handle \" + type ) ; } finally { threadCalls . remove ( type ) ; } }'", "label": "'Returns the type adapter for { @code } type .'"}
{"text": "'public < T > TypeAdapter < T > getNextAdapter ( TypeAdapterFactory skipPast , TypeToken < T > type ) { boolean skipPastFound = false ; for ( TypeAdapterFactory factory : factories ) { if ( ! skipPastFound ) { if ( factory == skipPast ) { skipPastFound = true ; } continue ; } TypeAdapter < T > candidate = factory . create ( this , type ) ; if ( candidate != null ) { return candidate ; } } throw new IllegalArgumentException ( \"GSON cannot serialize \" + type ) ; }'", "label": "'TODO : needs documentation'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public void toJson ( Object src , Type typeOfSrc , JsonWriter writer ) throws JsonIOException { TypeAdapter < ? > adapter = getAdapter ( TypeToken . get ( typeOfSrc ) ) ; boolean oldLenient = writer . isLenient ( ) ; writer . setLenient ( true ) ; boolean oldHtmlSafe = writer . isHtmlSafe ( ) ; writer . setHtmlSafe ( htmlSafe ) ; boolean oldSerializeNulls = writer . getSerializeNulls ( ) ; writer . setSerializeNulls ( serializeNulls ) ; try { ( ( TypeAdapter < Object > ) adapter ) . write ( writer , src ) ; } catch ( IOException e ) { throw new JsonIOException ( e ) ; } finally { writer . setLenient ( oldLenient ) ; writer . setHtmlSafe ( oldHtmlSafe ) ; writer . setSerializeNulls ( oldSerializeNulls ) ; } }'", "label": "'Writes the JSON representation of {'"}
{"text": "'public void toJson ( JsonElement jsonElement , Appendable writer ) throws JsonIOException { try { JsonWriter jsonWriter = newJsonWriter ( Streams . writerForAppendable ( writer ) ) ; toJson ( jsonElement , jsonWriter ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }'", "label": "'Writes out the equivalent JSON for a tree of { @link JsonElement } s .'"}
{"text": "'private JsonWriter newJsonWriter ( Writer writer ) throws IOException { if ( generateNonExecutableJson ) { writer . write ( JSON_NON_EXECUTABLE_PREFIX ) ; } JsonWriter jsonWriter = new JsonWriter ( writer ) ; if ( prettyPrinting ) { jsonWriter . setIndent ( \"  \" ) ; } jsonWriter . setSerializeNulls ( serializeNulls ) ; return jsonWriter ; }'", "label": "'Returns a new JSON writer configured for this GSON and with the non - execute prefix if that is configured .'"}
{"text": "'public void toJson ( JsonElement jsonElement , JsonWriter writer ) throws JsonIOException { boolean oldLenient = writer . isLenient ( ) ; writer . setLenient ( true ) ; boolean oldHtmlSafe = writer . isHtmlSafe ( ) ; writer . setHtmlSafe ( htmlSafe ) ; boolean oldSerializeNulls = writer . getSerializeNulls ( ) ; writer . setSerializeNulls ( serializeNulls ) ; try { Streams . write ( jsonElement , writer ) ; } catch ( IOException e ) { throw new JsonIOException ( e ) ; } finally { writer . setLenient ( oldLenient ) ; writer . setHtmlSafe ( oldHtmlSafe ) ; writer . setSerializeNulls ( oldSerializeNulls ) ; } }'", "label": "'Writes the JSON for {'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public < T > T fromJson ( JsonReader reader , Type typeOfT ) throws JsonIOException , JsonSyntaxException { boolean isEmpty = true ; boolean oldLenient = reader . isLenient ( ) ; reader . setLenient ( true ) ; try { reader . peek ( ) ; isEmpty = false ; TypeAdapter < T > typeAdapter = ( TypeAdapter < T > ) getAdapter ( TypeToken . get ( typeOfT ) ) ; return typeAdapter . read ( reader ) ; } catch ( EOFException e ) { /*\\n       * For compatibility with JSON 1.5 and earlier, we return null for empty\\n       * documents instead of throwing.\\n       */ if ( isEmpty ) { return null ; } throw new JsonSyntaxException ( e ) ; } catch ( IllegalStateException e ) { throw new JsonSyntaxException ( e ) ; } catch ( IOException e ) { // TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException throw new JsonSyntaxException ( e ) ; } finally { reader . setLenient ( oldLenient ) ; } }'", "label": "'Reads the next JSON value from { @code reader } and convert it to an object of type { @code typeOfT } . Since Type is not parameterized by T this method is type unsafe and should be used carefully'"}
{"text": "'@ Override public void executeDemo ( final String text ) { TwitterUtils . link ( this , new SocializeAuthListener ( ) { @ Override public void onError ( SocializeException error ) { handleError ( TweetActivity . this , error ) ; } @ Override public void onCancel ( ) { handleCancel ( ) ; } @ Override public void onAuthSuccess ( SocializeSession session ) { Tweet tweet = new Tweet ( ) ; tweet . setText ( text ) ; tweet . setLocation ( LocationUtils . getLastKnownLocation ( TweetActivity . this ) ) ; tweet . setShareLocation ( true ) ; TwitterUtils . tweet ( TweetActivity . this , tweet , new SocialNetworkListener ( ) { @ Override public boolean onBeforePost ( Activity parent , SocialNetwork socialNetwork , PostData postData ) { // Nothing to see here.. move along. return false ; } @ Override public void onNetworkError ( Activity context , SocialNetwork network , Exception error ) { handleError ( TweetActivity . this , error ) ; } @ Override public void onCancel ( ) { handleCancel ( ) ; } @ Override public void onAfterPost ( Activity parent , SocialNetwork socialNetwork , JSONObject responseObject ) { handleResult ( responseObject . toString ( ) ) ; } } ) ; } @ Override public void onAuthFail ( SocializeException error ) { handleError ( TweetActivity . this , error ) ; } } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public final String toJson ( T value ) throws IOException { StringWriter stringWriter = new StringWriter ( ) ; toJson ( stringWriter , value ) ; return stringWriter . toString ( ) ; }'", "label": "'Converts { @code value } to a JSON document . Unlike Gson s similar { @link Gson#toJson ( Object ) toJson } method this write is strict . Create a { @link JsonWriter#setLenient ( boolean ) lenient } { @code JsonWriter } and call { @link #write ( com . socialize . google . gson . stream . JsonWriter Object ) } for lenient writing .'"}
{"text": "'public void onViewLoad ( IOCContainer container ) { // Create a menu if we have one. if ( menu != null ) { createOptionsMenuItem ( getActivity ( ) , menu ) ; } viewLoaded = true ; }'", "label": "'Subclasses override'"}
{"text": "'@ Override public void executeDemo ( String text ) { // We are going to list comments just so we can get the ID for a single comment // Usually you would NOT do this as you would usually already have an ID (e.g. from a click on a list view) CommentUtils . getCommentsByEntity ( this , entity . getKey ( ) , 0 , 1 , new CommentListListener ( ) { @ Override public void onList ( ListResult < Comment > comments ) { // Use the id from the first comment if ( comments . getTotalCount ( ) > 0 ) { CommentUtils . getComment ( GetCommentsByIDActivity . this , new CommentGetListener ( ) { @ Override public void onGet ( Comment comment ) { handleSocializeResult ( comment ) ; } @ Override public void onError ( SocializeException error ) { handleError ( GetCommentsByIDActivity . this , error ) ; } } , comments . getItems ( ) . get ( 0 ) . getId ( ) ) ; } } @ Override public void onError ( SocializeException error ) { handleError ( GetCommentsByIDActivity . this , error ) ; } } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'private void onFacebookBtnClicked ( ) { // defaults found in:   com.socialize.networks.facebook.BaseFacebookFacade String [ ] permissions = { \"email\" } ; FacebookUtils . linkForRead ( this , new SocializeAuthListener ( ) { @ Override public void onCancel ( ) { Toast . makeText ( GetEmailActivity . this , \"Facebook login cancelled\" , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onAuthSuccess ( SocializeSession session ) { getFaceBookUserEmailetc ( ) ; } @ Override public void onAuthFail ( SocializeException error ) { handleError ( GetEmailActivity . this , error ) ; } @ Override public void onError ( SocializeException error ) { handleError ( GetEmailActivity . this , error ) ; } } , permissions ) ; }'", "label": "'######################################################################'"}
{"text": "'private void getFaceBookUserEmailetc ( ) { String graphPath = \"/me\" ; // Execute a GET on facebook // The \"this\" argument refers to the current Activity FacebookUtils . get ( this , graphPath , null , new SocialNetworkPostListener ( ) { @ Override public void onCancel ( ) { Toast . makeText ( GetEmailActivity . this , \"Facebook get cancelled\" , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onNetworkError ( Activity context , SocialNetwork network , Exception error ) { handleError ( GetEmailActivity . this , error ) ; } @ Override public void onAfterPost ( Activity parent , SocialNetwork socialNetwork , JSONObject responseObject ) { if ( responseObject . has ( \"email\" ) && ! responseObject . isNull ( \"email\" ) ) { try { handleResult ( responseObject . getString ( \"email\" ) ) ; } catch ( JSONException e ) { handleError ( GetEmailActivity . this , e ) ; } } else { handleResult ( \"Unable to retrieve email address!\\\\n\\\\n\" + responseObject . toString ( ) ) ; } } } ) ; }'", "label": "'######################################################################'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) // use runtime checks to guarantee that \\'T\\' is what it is private < T > ObjectConstructor < T > newDefaultImplementationConstructor ( Class < ? super T > rawType ) { if ( Collection . class . isAssignableFrom ( rawType ) ) { if ( SortedSet . class . isAssignableFrom ( rawType ) ) { return new ObjectConstructor < T > ( ) { public T construct ( ) { return ( T ) new TreeSet < Object > ( ) ; } } ; } else if ( Set . class . isAssignableFrom ( rawType ) ) { return new ObjectConstructor < T > ( ) { public T construct ( ) { return ( T ) new LinkedHashSet < Object > ( ) ; } } ; } else if ( Queue . class . isAssignableFrom ( rawType ) ) { return new ObjectConstructor < T > ( ) { public T construct ( ) { return ( T ) new LinkedList < Object > ( ) ; } } ; } else { return new ObjectConstructor < T > ( ) { public T construct ( ) { return ( T ) new ArrayList < Object > ( ) ; } } ; } } if ( Map . class . isAssignableFrom ( rawType ) ) { return new ObjectConstructor < T > ( ) { public T construct ( ) { return ( T ) new LinkedHashMap < Object , Object > ( ) ; } } ; // TODO: SortedMap ? } return null ; }'", "label": "'Constructors for common interface types like Map and List and their subytpes .'"}
{"text": "'@ Override public SimpleNotificationMessage translate ( Context context , NotificationMessage message ) throws SocializeException { SimpleNotificationMessage msg = newSimpleNotificationMessage ( ) ; StringBuilder titleBuilder = newStringBuilder ( ) ; titleBuilder . append ( message . getUser ( ) ) ; switch ( message . getActionType ( ) ) { case COMMENT : titleBuilder . append ( \" commented on \" ) ; break ; case SHARE : titleBuilder . append ( \" shared \" ) ; break ; case LIKE : titleBuilder . append ( \" liked \" ) ; break ; case VIEW : titleBuilder . append ( \" viewed \" ) ; break ; } titleBuilder . append ( message . getEntity ( ) ) ; msg . setTitle ( titleBuilder . toString ( ) ) ; msg . setText ( message . getText ( ) ) ; return msg ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override protected void toJSON ( Propagation from , JSONObject to ) throws JSONException { // Make params Map < String , String > extraParams = from . getExtraParams ( ) ; if ( extraParams != null && extraParams . size ( ) > 0 ) { Set < Entry < String , String > > entrySet = extraParams . entrySet ( ) ; if ( entrySet != null && entrySet . size ( ) > 0 ) { int count = 0 ; StringBuilder builder = new StringBuilder ( ) ; for ( Entry < String , String > entry : entrySet ) { String key = entry . getKey ( ) ; String value = entry . getValue ( ) ; if ( ! StringUtils . isEmpty ( key ) && ! StringUtils . isEmpty ( value ) ) { if ( count > 0 ) { builder . append ( \"&\" ) ; } builder . append ( URLEncoder . encode ( key ) ) ; builder . append ( \"=\" ) ; builder . append ( URLEncoder . encode ( value ) ) ; count ++ ; } } to . put ( \"extra_params\" , builder . toString ( ) ) ; } } JSONArray networks = new JSONArray ( ) ; List < ShareType > thirdParties = from . getThirdParties ( ) ; if ( thirdParties != null && thirdParties . size ( ) > 0 ) { for ( ShareType socialNetwork : thirdParties ) { networks . put ( socialNetwork . name ( ) . toLowerCase ( ) ) ; } to . put ( \"third_parties\" , networks ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public static String replaceNewLines ( String src , int from , int to ) { if ( src != null && from > 0 && to < from ) { String strFrom = \"\" ; String strTo = \"\" ; for ( int i = 0 ; i < from ; i ++ ) { strFrom += \"\\\\n\" ; } for ( int i = 0 ; i < to ; i ++ ) { strTo += \"\\\\n\" ; } while ( src . contains ( strFrom ) ) { src = src . replaceAll ( strFrom , strTo ) ; } } return src ; }'", "label": "'Replaces successive new line characters .'"}
{"text": "'@ Override public void executeDemo ( String text ) { try { ShareUtils . getSharesByUser ( this , UserUtils . getCurrentUser ( this ) , 0 , PAGE_SIZE , new ShareListListener ( ) { @ Override public void onList ( ListResult < Share > shares ) { handleSocializeResult ( shares ) ; } @ Override public void onError ( SocializeException error ) { handleError ( GetSharesByUserActivity . this , error ) ; } } ) ; } catch ( SocializeException e ) { e . printStackTrace ( ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void addEvent ( SocializeSession session , SocializeEvent event , EventListener eventListener ) { postAsync ( session , ENDPOINT , event , false , eventListener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void show ( Context context , final AuthDialogListener listener , final boolean required ) { showDialog ( context , new BeanCreationListener < AuthPanelView > ( ) { @ Override public void onError ( String name , Exception e ) { } @ Override public void onCreate ( AuthPanelView bean ) { bean . setAuthDialogListener ( listener ) ; bean . setAuthRequired ( required ) ; } } , new AuthDialogListener ( ) { @ Override public void onShow ( Dialog dialog , AuthPanelView dialogView ) { recordEvent ( \"show\" ) ; if ( listener != null ) { listener . onShow ( dialog , dialogView ) ; } } @ Override public void onCancel ( Dialog dialog ) { recordEvent ( \"cancel\" ) ; if ( listener != null ) { listener . onCancel ( dialog ) ; } } @ Override public void onSkipAuth ( Activity context , Dialog dialog ) { recordEvent ( \"skip\" ) ; if ( listener != null ) { listener . onSkipAuth ( context , dialog ) ; } } @ Override public void onError ( Activity context , Dialog dialog , Exception error ) { recordEvent ( \"error\" ) ; if ( listener != null ) { listener . onError ( context , dialog , error ) ; } } @ Override public void onAuthenticate ( Activity context , Dialog dialog , SocialNetwork network ) { recordEvent ( \"auth\" , network . name ( ) ) ; if ( listener != null ) { listener . onAuthenticate ( context , dialog , network ) ; } } } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'void reload ( ) { //begin-snippet-1 // The in the Activity which renders the ActionBar Entity entity = Entity . newInstance ( \"http://getsocialize.com\" , \"Socialize\" ) ; // Setup a listener to retain a reference MyActionBarListener listener = new MyActionBarListener ( ) ; // Use the listener when you show the action bar // The \"this\" argument refers to the current Activity ActionBarUtils . showActionBar ( this , R . layout . actionbar , entity , null , listener ) ; // Later (After the action bar has loaded!), you can reference the view to refresh ActionBarView view = listener . getActionBarView ( ) ; if ( view != null ) { Entity newEntity = new Entity ( ) ; // This would be your new entity view . setEntity ( newEntity ) ; view . refresh ( ) ; } //end-snippet-1 }'", "label": "'end - snippet - 0'"}
{"text": "'@ Override public SimpleNotificationMessage translate ( Context context , Bundle data , NotificationMessage message ) throws SocializeException { SimpleNotificationMessage notify = new SimpleNotificationMessage ( ) ; notify . setTitle ( message . getText ( ) ) ; String url = message . getUrl ( ) ; if ( url != null ) { notify . setText ( url ) ; data . putString ( Socialize . DIRECT_URL , url ) ; } else { throw new SocializeException ( \"No url found in notification of type [\" + message . getNotificationType ( ) + \"]\" ) ; } return notify ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void executeDemo ( String text ) { try { LikeUtils . getLikesByUser ( this , UserUtils . getCurrentUser ( this ) , 0 , PAGE_SIZE , new LikeListListener ( ) { @ Override public void onList ( List < Like > items , int totalSize ) { handleSocializeResult ( items ) ; } @ Override public void onError ( SocializeException error ) { handleError ( GetLikesByUserActivity . this , error ) ; } } ) ; } catch ( SocializeException e ) { e . printStackTrace ( ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public String getSimpleLocation ( Address address ) { StringBuilder builder = new StringBuilder ( ) ; String locality = address . getLocality ( ) ; String countryName = address . getCountryName ( ) ; if ( ! StringUtils . isEmpty ( locality ) ) { builder . append ( locality ) ; } else if ( ! StringUtils . isEmpty ( countryName ) ) { builder . append ( countryName ) ; } return builder . toString ( ) ; }'", "label": "'Returns a simple one - line address based on city and country'"}
{"text": "'@ Override public void getUser ( SocializeSession session , long id , UserListener listener ) { getAsync ( session , ENDPOINT , String . valueOf ( id ) , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void saveUserSettings ( final Context context , final SocializeSession session , final UserSettings settingsToBeSaved , final UserListener listener ) { User sessionUser = session . getUser ( ) ; UserSettings sessionSettings = session . getUserSettings ( ) ; boolean wasNotificationsEnabled = sessionSettings . isNotificationsEnabled ( ) ; // Update the settings and the user in the session so they are saved sessionUser . setFirstName ( settingsToBeSaved . getFirstName ( ) ) ; sessionUser . setLastName ( settingsToBeSaved . getLastName ( ) ) ; sessionSettings . update ( settingsToBeSaved ) ; boolean isNotificationsEnabled = sessionSettings . isNotificationsEnabled ( ) ; if ( settingsToBeSaved . getImage ( ) != null ) { sessionUser . setProfilePicData ( bitmapUtils . encode ( settingsToBeSaved . getImage ( ) ) ) ; } // If notifications was not previously enabled, we may need to register. if ( isNotificationsEnabled && ! wasNotificationsEnabled && notificationRegistrationSystem != null ) { notificationRegistrationSystem . registerC2DMAsync ( context ) ; } saveUserAsync ( context , session , sessionUser , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'protected void login ( Activity context , boolean read , final AuthProviderListener listener ) { login ( context , config . getProperty ( SocializeConfig . FACEBOOK_APP_ID ) , ( read ) ? READ_PERMISSIONS : WRITE_PERMISSIONS , config . getBooleanProperty ( SocializeConfig . FACEBOOK_SSO_ENABLED , true ) , read , listener ) ; }'", "label": "'Protected so we can mock'"}
{"text": "'protected Session createNewSession ( Activity context , String appId ) { return new Session . Builder ( context ) . setApplicationId ( appId ) . build ( ) ; }'", "label": "'So we can mock'"}
{"text": "'protected void login ( Activity context , String appId , String [ ] permissions , boolean sso , boolean read , final AuthProviderListener listener ) { Session . OpenRequest auth = new Session . OpenRequest ( context ) ; if ( permissions != null ) { auth . setPermissions ( Arrays . asList ( permissions ) ) ; } if ( sso ) { auth . setLoginBehavior ( SessionLoginBehavior . SSO_WITH_FALLBACK ) ; } else { auth . setLoginBehavior ( SessionLoginBehavior . SUPPRESS_SSO ) ; } auth . setCallback ( createLoginCallback ( listener ) ) ; Session session = createNewSession ( context , appId ) ; Session . setActiveSession ( session ) ; if ( read ) { openSessionForRead ( session , auth ) ; } else { openSessionForPublish ( session , auth ) ; } }'", "label": "'Protected so we can mock'"}
{"text": "'protected Session . StatusCallback createLoginCallback ( final AuthProviderListener listener ) { return new Session . StatusCallback ( ) { // callback when session changes state @ Override public void call ( final Session session , SessionState state , Exception exception ) { if ( exception != null && exception instanceof FacebookOperationCanceledException ) { if ( logger != null ) { logger . error ( \"Facebook operation failed\" , exception ) ; } handleCancel ( listener ) ; return ; } switch ( state ) { case OPENED : if ( isSessionOpen ( session ) ) { // make request to the /me API getUser ( session , listener ) ; } break ; case CLOSED : if ( exception != null ) { handleError ( exception , listener ) ; } break ; case CLOSED_LOGIN_FAILED : if ( exception != null ) { handleAuthFail ( exception , listener ) ; } break ; } } } ; }'", "label": "'So we can mock'"}
{"text": "'protected void getUser ( final Session session , final AuthProviderListener listener ) { Request . executeMeRequestAsync ( session , new Request . GraphUserCallback ( ) { // callback after Graph API response with user object @ Override public void onCompleted ( GraphUser user , Response response ) { if ( response . getError ( ) != null ) { handleError ( response . getError ( ) . getException ( ) , listener ) ; } else if ( user != null ) { handleResult ( session , user , listener ) ; } } } ) ; }'", "label": "'so we can mock'"}
{"text": "'protected void handleError ( Exception exception , SocializeListener listener ) { if ( listener != null ) { listener . onError ( SocializeException . wrap ( exception ) ) ; } }'", "label": "'Protected so we can mock'"}
{"text": "'protected void handleAuthFail ( Exception exception , AuthProviderListener listener ) { if ( listener != null ) { listener . onAuthFail ( SocializeException . wrap ( exception ) ) ; } }'", "label": "'Protected so we can mock'"}
{"text": "'protected void handleResult ( Session session , GraphUser user , AuthProviderListener listener ) { if ( listener != null ) { AuthProviderResponse response = new AuthProviderResponse ( ) ; response . setUserId ( user . getId ( ) ) ; response . setToken ( session . getAccessToken ( ) ) ; listener . onAuthSuccess ( response ) ; } }'", "label": "'Protected so we can mock'"}
{"text": "'protected Session getActiveSession ( Context context ) { Session activeSession = Session . getActiveSession ( ) ; if ( activeSession == null ) { activeSession = new Session . Builder ( context ) . setApplicationId ( config . getProperty ( SocializeConfig . FACEBOOK_APP_ID ) ) . build ( ) ; Session . setActiveSession ( activeSession ) ; } return activeSession ; }'", "label": "'Protected so we can mock'"}
{"text": "'protected void handleFBResponse ( final Activity context , Response response , final SocialNetworkPostListener listener ) { FacebookRequestError error = response . getError ( ) ; if ( error != null ) { if ( listener != null ) { listener . onNetworkError ( context , SocialNetwork . FACEBOOK , error . getException ( ) ) ; } if ( logger != null ) { logger . error ( error . getErrorMessage ( ) , error . getException ( ) ) ; } else { Log . e ( \"Socialize\" , error . getErrorMessage ( ) , error . getException ( ) ) ; } switch ( error . getCategory ( ) ) { case AUTHENTICATION_REOPEN_SESSION : unlink ( context , null ) ; break ; case AUTHENTICATION_RETRY : unlink ( context , null ) ; break ; case PERMISSION : unlink ( context , null ) ; break ; } } else if ( listener != null ) { listener . onAfterPost ( context , SocialNetwork . FACEBOOK , response . getGraphObject ( ) . getInnerJSONObject ( ) ) ; } }'", "label": "'Protected so we can mock'"}
{"text": "'protected void handleNotSignedIn ( final Activity context , SocializeListener listener ) { String msg = \"Not signed into Facebook\" ; if ( listener != null ) { listener . onError ( new SocializeException ( msg ) ) ; } else { handleNonListenerError ( msg , new SocializeException ( msg ) ) ; } }'", "label": "'Protected so we can mock'"}
{"text": "'protected void handleNotSignedIn ( final Activity context , SocialNetworkPostListener listener ) { String msg = \"Not signed into Facebook\" ; if ( listener != null ) { listener . onNetworkError ( context , SocialNetwork . FACEBOOK , new SocializeException ( msg ) ) ; } else { handleNonListenerError ( msg , new SocializeException ( msg ) ) ; } }'", "label": "'Protected so we can mock'"}
{"text": "'protected void handleNonListenerError ( String msg , Exception error ) { if ( logger != null ) { logger . error ( msg , error ) ; } else { Log . e ( \"Socialize\" , msg , error ) ; } }'", "label": "'Protected so we can mock'"}
{"text": "'public static void getActionsByApplication ( Activity context , int start , int end , ActionListListener listener ) { proxy . getActionsByApplication ( context , start , end , listener ) ; }'", "label": "'Gets the application - wide actions .'"}
{"text": "'public static void getActionsByUser ( Activity context , long userId , int start , int end , ActionListListener listener ) { proxy . getActionsByUser ( context , userId , start , end , listener ) ; }'", "label": "'Gets the actions of a single user .'"}
{"text": "'public static void getActionsByEntity ( Activity context , String entityKey , int start , int end , ActionListListener listener ) { proxy . getActionsByEntity ( context , entityKey , start , end , listener ) ; }'", "label": "'Gets the actions for a given entity .'"}
{"text": "'public static void getActionsByUserAndEntity ( Activity context , long userId , String entityKey , int start , int end , ActionListListener listener ) { proxy . getActionsByUserAndEntity ( context , userId , entityKey , start , end , listener ) ; }'", "label": "'Gets the actions of a single user on a single entity .'"}
{"text": "'private JsonWriter close ( JsonScope empty , JsonScope nonempty , String closeBracket ) throws IOException { JsonScope context = peek ( ) ; if ( context != nonempty && context != empty ) { throw new IllegalStateException ( \"Nesting problem: \" + stack ) ; } if ( deferredName != null ) { throw new IllegalStateException ( \"Dangling name: \" + deferredName ) ; } stack . remove ( stack . size ( ) - 1 ) ; if ( context == nonempty ) { newline ( ) ; } out . write ( closeBracket ) ; return this ; }'", "label": "'Closes the current scope by appending any necessary whitespace and the given bracket .'"}
{"text": "'public JsonWriter name ( String name ) throws IOException { if ( name == null ) { throw new NullPointerException ( \"name == null\" ) ; } if ( deferredName != null ) { throw new IllegalStateException ( ) ; } deferredName = name ; return this ; }'", "label": "'Encodes the property name .'"}
{"text": "'public JsonWriter value ( Number value ) throws IOException { if ( value == null ) { return nullValue ( ) ; } writeDeferredName ( ) ; String string = value . toString ( ) ; if ( ! lenient && ( string . equals ( \"-Infinity\" ) || string . equals ( \"Infinity\" ) || string . equals ( \"NaN\" ) ) ) { throw new IllegalArgumentException ( \"Numeric values must be finite, but was \" + value ) ; } beforeValue ( false ) ; out . append ( string ) ; return this ; }'", "label": "'Encodes { @code value } .'"}
{"text": "'@ Override public T translate ( Context context , Bundle data , NotificationMessage message ) throws SocializeException { data . putString ( Socialize . ACTION_ID , String . valueOf ( message . getActionId ( ) ) ) ; data . putString ( Socialize . ACTION_TYPE , String . valueOf ( message . getActionType ( ) . name ( ) ) ) ; // The action detail view expects this, but will handle the -1 case. data . putString ( Socialize . USER_ID , \"-1\" ) ; return translate ( context , message ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public JsonElement parse ( Reader json ) throws JsonIOException , JsonSyntaxException { try { JsonReader jsonReader = new JsonReader ( json ) ; JsonElement element = parse ( jsonReader ) ; if ( ! element . isJsonNull ( ) && jsonReader . peek ( ) != JsonToken . END_DOCUMENT ) { throw new JsonSyntaxException ( \"Did not consume the entire document.\" ) ; } return element ; } catch ( MalformedJsonException e ) { throw new JsonSyntaxException ( e ) ; } catch ( IOException e ) { throw new JsonIOException ( e ) ; } catch ( NumberFormatException e ) { throw new JsonSyntaxException ( e ) ; } }'", "label": "'Parses the specified JSON string into a parse tree'"}
{"text": "'public JsonElement parse ( JsonReader json ) throws JsonIOException , JsonSyntaxException { boolean lenient = json . isLenient ( ) ; json . setLenient ( true ) ; try { return Streams . parse ( json ) ; } catch ( StackOverflowError e ) { throw new JsonParseException ( \"Failed parsing JSON source: \" + json + \" to Json\" , e ) ; } catch ( OutOfMemoryError e ) { throw new JsonParseException ( \"Failed parsing JSON source: \" + json + \" to Json\" , e ) ; } catch ( JsonParseException e ) { if ( e . getCause ( ) instanceof EOFException ) { return JsonNull . INSTANCE ; } throw e ; } finally { json . setLenient ( lenient ) ; } }'", "label": "'Returns the next value from the JSON stream as a parse tree .'"}
{"text": "'@ Override public boolean launch ( Activity context , Bundle data ) { if ( entityLoaderUtils != null ) { entityLoaderUtils . initEntityLoader ( ) ; } Class < ? > [ ] activityClasses = getActivityClasses ( ) ; Class < ? > activityClass = null ; for ( Class < ? > cls : activityClasses ) { if ( appUtils . isActivityAvailable ( context , cls ) ) { activityClass = cls ; break ; } } if ( activityClass != null ) { Intent intent = newIntent ( context , activityClass ) ; intent . putExtras ( data ) ; handleIntent ( context , intent , data ) ; context . startActivity ( intent ) ; return true ; } return false ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void executeDemo ( String text ) { // We need additional permissions for this String [ ] permissions = { \"user_tagged_places\" } ; FacebookUtils . linkForRead ( this , new SocializeAuthListener ( ) { @ Override public void onError ( SocializeException error ) { handleError ( ListCheckinsActivity . this , error ) ; } @ Override public void onCancel ( ) { handleCancel ( ) ; } @ Override public void onAuthSuccess ( SocializeSession session ) { FacebookUtils . get ( ListCheckinsActivity . this , \"me/tagged_places\" , null , new SocialNetworkPostListener ( ) { @ Override public void onNetworkError ( Activity context , SocialNetwork network , Exception error ) { handleError ( context , error ) ; } @ Override public void onCancel ( ) { handleCancel ( ) ; } @ Override public void onAfterPost ( Activity parent , SocialNetwork socialNetwork , JSONObject responseObject ) { try { handleResult ( responseObject . toString ( 4 ) ) ; } catch ( JSONException e ) { handleError ( parent , e ) ; } } } ) ; } @ Override public void onAuthFail ( SocializeException error ) { handleError ( ListCheckinsActivity . this , error ) ; } } , permissions ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override protected View getView ( Bundle bundle , Object ... bundleKeys ) { if ( bundleKeys != null ) { if ( actionLayoutView == null ) { actionLayoutView = container . getBean ( \"actionDetailLayoutView\" , bundleKeys ) ; LayoutParams scrollViewLayout = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . FILL_PARENT , LinearLayout . LayoutParams . FILL_PARENT ) ; LayoutParams childViewLayout = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . FILL_PARENT , LinearLayout . LayoutParams . FILL_PARENT ) ; ScrollView scrollView = new ScrollView ( getContext ( ) ) ; scrollView . setFillViewport ( true ) ; scrollView . setLayoutParams ( scrollViewLayout ) ; scrollView . addView ( actionLayoutView , childViewLayout ) ; LinearLayout layout = new LinearLayout ( getContext ( ) ) ; LayoutParams masterParams = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . FILL_PARENT , LinearLayout . LayoutParams . FILL_PARENT ) ; layout . setLayoutParams ( masterParams ) ; CompatUtils . setBackgroundDrawable ( layout , ( ( Drawables ) container . getBean ( \"drawables\" ) ) . getDrawable ( \"slate.png\" , true , true , true ) ) ; layout . addView ( scrollView ) ; view = layout ; } return view ; } else { SocializeLogger . e ( \"No user id specified for \" + getClass ( ) . getSimpleName ( ) ) ; return null ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void onError ( SocializeException error ) { if ( error instanceof SocializeApiError ) { SocializeApiError aError = ( SocializeApiError ) error ; if ( aError . getResultCode ( ) != 404 ) { SocializeLogger . e ( error . getMessage ( ) , error ) ; } } else { SocializeLogger . e ( error . getMessage ( ) , error ) ; } onNotLiked ( ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override protected void handle ( Activity context , SocializeAction action , String text , PropagationInfo info , SocialNetworkListener listener ) throws Exception { boolean shareCancelled = false ; Entity entity = action . getEntity ( ) ; PostData postData = sharePostDataFactory . create ( entity , info , text , isHtml ( ) , true ) ; if ( listener != null ) { shareCancelled = listener . onBeforePost ( context , null , postData ) ; } if ( ! shareCancelled ) { String title = String . valueOf ( postData . getPostValues ( ) . get ( ShareUtils . EXTRA_TITLE ) ) ; String body = String . valueOf ( postData . getPostValues ( ) . get ( ShareUtils . EXTRA_TEXT ) ) ; Intent msg = getIntent ( context ) ; msg . putExtra ( Intent . EXTRA_TITLE , title ) ; if ( isHtml ( ) ) { msg . putExtra ( Intent . EXTRA_TEXT , Html . fromHtml ( body ) ) ; } else { msg . putExtra ( Intent . EXTRA_TEXT , body ) ; } msg . putExtra ( Intent . EXTRA_SUBJECT , String . valueOf ( postData . getPostValues ( ) . get ( ShareUtils . EXTRA_SUBJECT ) ) ) ; startActivity ( context , msg , title ) ; } if ( listener != null ) { listener . onAfterPost ( context , null , null ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override protected void postToJSON ( DeviceRegistration from , JSONObject to ) throws JSONException { to . put ( \"gcm_registration_id\" , from . getRegistrationId ( ) ) ; to . put ( \"device_type\" , \"Android\" ) ; to . put ( \"service_type\" , \"ANDROID_GCM\" ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public static void link ( Activity context , String token , String secret , SocializeAuthListener listener ) { proxy . link ( context , token , secret , listener ) ; }'", "label": "'Links the current user to their Twitter account using an existing Twitter oAuth token and secret .'"}
{"text": "'public static void setCredentials ( Context context , String consumerKey , String consumerSecret ) { proxy . setCredentials ( context , consumerKey , consumerSecret ) ; }'", "label": "'Sets the Twitter App credentials for the application . This sets the same configuration properties as twitter . consumer . key and twitter . consumer . secret'"}
{"text": "'public static void tweetEntity ( final Activity context , final Entity entity , final String text , final SocialNetworkShareListener listener ) { if ( proxy . isLinked ( context ) ) { proxy . tweetEntity ( context , entity , text , listener ) ; } else { proxy . link ( context , new SocializeAuthListener ( ) { @ Override public void onError ( SocializeException error ) { if ( listener != null ) { listener . onNetworkError ( context , SocialNetwork . TWITTER , error ) ; } } @ Override public void onCancel ( ) { if ( listener != null ) { listener . onCancel ( ) ; } } @ Override public void onAuthSuccess ( SocializeSession session ) { proxy . tweetEntity ( context , entity , text , listener ) ; } @ Override public void onAuthFail ( SocializeException error ) { if ( listener != null ) { listener . onNetworkError ( context , SocialNetwork . TWITTER , error ) ; } } } ) ; } }'", "label": "'Tweets an entity . A share event will be recorded in Socialize and the entity URL generated by Socialize will be posted to the user s Twitter feed . If the user is not currently linked to a Twitter account they will be prompted to authenticate .'"}
{"text": "'public static void get ( final Activity context , final String resource , final Map < String , Object > params , final SocialNetworkPostListener listener ) { if ( proxy . isLinked ( context ) ) { proxy . get ( context , resource , params , listener ) ; } else { proxy . link ( context , new SocializeAuthListener ( ) { @ Override public void onError ( SocializeException error ) { if ( listener != null ) { listener . onNetworkError ( context , SocialNetwork . TWITTER , error ) ; } } @ Override public void onCancel ( ) { if ( listener != null ) { listener . onCancel ( ) ; } } @ Override public void onAuthSuccess ( SocializeSession session ) { proxy . get ( context , resource , params , listener ) ; } @ Override public void onAuthFail ( SocializeException error ) { if ( listener != null ) { listener . onNetworkError ( context , SocialNetwork . TWITTER , error ) ; } } } ) ; } }'", "label": "'Performs a simple HTTP GET to the Twitter resource endpoint specified . If the user is not currently linked to a Twitter account they will be prompted to authenticate .'"}
{"text": "'public static void tweet ( final Activity context , final Tweet tweet , final SocialNetworkListener listener ) { if ( proxy . isLinked ( context ) ) { proxy . tweet ( context , tweet , listener ) ; } else { proxy . link ( context , new SocializeAuthListener ( ) { @ Override public void onError ( SocializeException error ) { if ( listener != null ) { listener . onNetworkError ( context , SocialNetwork . TWITTER , error ) ; } } @ Override public void onCancel ( ) { if ( listener != null ) { listener . onCancel ( ) ; } } @ Override public void onAuthSuccess ( SocializeSession session ) { proxy . tweet ( context , tweet , listener ) ; } @ Override public void onAuthFail ( SocializeException error ) { if ( listener != null ) { listener . onNetworkError ( context , SocialNetwork . TWITTER , error ) ; } } } ) ; } }'", "label": "'Performs a simple tweet . If the user is not currently linked to a Twitter account they will be prompted to authenticate .'"}
{"text": "'public static void tweetPhoto ( final Activity context , final PhotoTweet photo , final SocialNetworkPostListener listener ) { if ( proxy . isLinked ( context ) ) { proxy . tweetPhoto ( context , photo , listener ) ; } else { proxy . link ( context , new SocializeAuthListener ( ) { @ Override public void onError ( SocializeException error ) { if ( listener != null ) { listener . onNetworkError ( context , SocialNetwork . TWITTER , error ) ; } } @ Override public void onCancel ( ) { if ( listener != null ) { listener . onCancel ( ) ; } } @ Override public void onAuthSuccess ( SocializeSession session ) { proxy . tweetPhoto ( context , photo , listener ) ; } @ Override public void onAuthFail ( SocializeException error ) { if ( listener != null ) { listener . onNetworkError ( context , SocialNetwork . TWITTER , error ) ; } } } ) ; } }'", "label": "'Publishes a photo to a user s Twitter feed . If the user is not currently linked to a Twitter account they will be prompted to authenticate .'"}
{"text": "'@ Override public synchronized void delete ( Context context , AuthProviderType type ) { SharedPreferences prefs = context . getSharedPreferences ( PREFERENCES , Context . MODE_PRIVATE ) ; String authData = prefs . getString ( USER_AUTH_DATA , null ) ; Editor editor = prefs . edit ( ) ; if ( ! StringUtils . isEmpty ( authData ) ) { UserProviderCredentialsMap map = jsonUtils . fromJSON ( authData , UserProviderCredentialsMap . class ) ; map . remove ( type ) ; editor . putString ( USER_AUTH_DATA , jsonUtils . toJSON ( map ) ) ; } else { editor . putString ( USER_AUTH_DATA , jsonUtils . toJSON ( makeDefaultUserProviderCredentials ( ) ) ) ; } editor . commit ( ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public synchronized void save ( Context context , SocializeSession session ) { SharedPreferences prefs = context . getSharedPreferences ( PREFERENCES , Context . MODE_PRIVATE ) ; Editor editor = prefs . edit ( ) ; editor . putString ( \"consumer_key\" , session . getConsumerKey ( ) ) ; editor . putString ( \"consumer_secret\" , session . getConsumerSecret ( ) ) ; editor . putString ( \"consumer_token\" , session . getConsumerToken ( ) ) ; editor . putString ( \"consumer_token_secret\" , session . getConsumerTokenSecret ( ) ) ; editor . putString ( SOCIALIZE_VERSION , Socialize . VERSION ) ; String userProviderCredentials = jsonUtils . toJSON ( session . getUserProviderCredentials ( ) ) ; editor . putString ( USER_AUTH_DATA , userProviderCredentials ) ; User user = session . getUser ( ) ; UserSettings settings = session . getUserSettings ( ) ; saveUser ( editor , user , settings ) ; editor . commit ( ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public synchronized WritableSession load ( Context context ) { SharedPreferences prefs = context . getSharedPreferences ( PREFERENCES , Context . MODE_PRIVATE ) ; String key = prefs . getString ( \"consumer_key\" , null ) ; String secret = prefs . getString ( \"consumer_secret\" , null ) ; UserProviderCredentialsMap userProviderCredentials = loadUserProviderCredentials ( prefs ) ; WritableSession session = sessionFactory . create ( key , secret , userProviderCredentials ) ; session . setRestored ( true ) ; String oauth_token = prefs . getString ( \"consumer_token\" , null ) ; String oauth_token_secret = prefs . getString ( \"consumer_token_secret\" , null ) ; if ( StringUtils . isEmpty ( oauth_token ) || StringUtils . isEmpty ( oauth_token_secret ) ) { return null ; } session . setConsumerToken ( oauth_token ) ; session . setConsumerTokenSecret ( oauth_token_secret ) ; String userJson = prefs . getString ( \"user\" , null ) ; User user = null ; if ( userJson != null ) { try { JSONObject json = new JSONObject ( userJson ) ; user = userFactory . fromJSON ( json ) ; session . setUser ( user ) ; } catch ( JSONException e ) { if ( logger != null ) { logger . error ( \"Failed to deserialize user object\" , e ) ; } else { SocializeLogger . e ( \"Failed to deserialize user object\" , e ) ; } } } String userSettingsJson = prefs . getString ( \"user-settings\" , null ) ; if ( userSettingsJson != null ) { try { JSONObject json = new JSONObject ( userSettingsJson ) ; UserSettings userSettings = userSettingsFactory . fromJSON ( json ) ; session . setUserSettings ( userSettings ) ; } catch ( JSONException e ) { if ( logger != null ) { logger . error ( \"Failed to deserialize user settings object\" , e ) ; } else { SocializeLogger . e ( \"Failed to deserialize user settings object\" , e ) ; } } } else if ( user != null ) { session . setUserSettings ( createSettingsLegacy ( user ) ) ; } return session ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public synchronized void delete ( Context context ) { SharedPreferences prefs = context . getSharedPreferences ( PREFERENCES , Context . MODE_PRIVATE ) ; prefs . edit ( ) . clear ( ) . commit ( ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getActionsByApplication ( Activity context , int start , int end , ActionListListener listener ) { activitySystem . getActivityByApplication ( Socialize . getSocialize ( ) . getSession ( ) , start , end , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getActionsByUser ( Activity context , long userId , int start , int end , ActionListListener listener ) { activitySystem . getActivityByUser ( Socialize . getSocialize ( ) . getSession ( ) , userId , start , end , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getActionsByEntity ( Activity context , String entityKey , int start , int end , ActionListListener listener ) { activitySystem . getActivityByEntity ( Socialize . getSocialize ( ) . getSession ( ) , entityKey , start , end , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getActionsByUserAndEntity ( Activity context , long userId , String entityKey , int start , int end , ActionListListener listener ) { activitySystem . getActivityByUserAndEntity ( Socialize . getSocialize ( ) . getSession ( ) , userId , entityKey , start , end , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public < T > T construct ( String className ) throws SocializeException { try { return builder . construct ( className ) ; } catch ( Exception e ) { throw new SocializeException ( e ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void executeDemo ( String text ) { CommentUtils . getCommentsByEntity ( this , entity . getKey ( ) , 0 , PAGE_SIZE , new CommentListListener ( ) { @ Override public void onList ( ListResult < Comment > comments ) { handleSocializeResult ( comments ) ; } @ Override public void onError ( SocializeException error ) { handleError ( GetCommentsByEntityActivity . this , error ) ; } } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public Bitmap getScaledBitmap ( Bitmap bitmap , int scaleToWidth , int scaleToHeight , boolean recycleOriginal , int density ) { bitmap . setDensity ( density ) ; Bitmap original = bitmap ; if ( scaleToWidth > 0 || scaleToHeight > 0 ) { int width = bitmap . getWidth ( ) ; int height = bitmap . getHeight ( ) ; // scale lowest and crop highes if ( height != scaleToHeight || width != scaleToWidth ) { float ratio = 1.0f ; // Scale to smallest if ( height > width ) { ratio = ( float ) scaleToWidth / ( float ) width ; width = scaleToWidth ; height = Math . round ( ( float ) height * ratio ) ; bitmap = bitmapBuilder . scale ( bitmap , width , height ) ; width = bitmap . getWidth ( ) ; height = bitmap . getHeight ( ) ; if ( height > scaleToHeight ) { // crop height int diff = height - scaleToHeight ; int half = Math . round ( ( float ) diff / 2.0f ) ; bitmap = bitmapBuilder . crop ( bitmap , 0 , half , width , scaleToHeight ) ; } } else { ratio = ( float ) scaleToHeight / ( float ) height ; height = scaleToHeight ; width = Math . round ( ( float ) width * ratio ) ; bitmap = bitmapBuilder . scale ( bitmap , width , height ) ; width = bitmap . getWidth ( ) ; height = bitmap . getHeight ( ) ; if ( width > scaleToWidth ) { // crop width int diff = width - scaleToWidth ; int half = Math . round ( ( float ) diff / 2.0f ) ; bitmap = bitmapBuilder . crop ( bitmap , half , 0 , scaleToWidth , height ) ; } } if ( recycleOriginal ) { original . recycle ( ) ; } } } return bitmap ; }'", "label": "'Returns a scaled bitmap cropped if necessary .'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public void putAsPostAsync ( SocializeSession session , String endpoint , T object , SocializeActionListener listener ) { AsyncPutter poster = new AsyncPutter ( session , listener ) ; SocializePutRequest < T > request = new SocializePutRequest < T > ( ) ; request . setRequestType ( RequestType . PUT_AS_POST ) ; request . setEndpoint ( endpoint ) ; request . setObject ( object ) ; poster . execute ( request ) ; }'", "label": "'Does a POST but expects a single object in return .'"}
{"text": "'@ Override protected View getView ( Bundle bundle , Object ... entityKeys ) { if ( actionBarLayoutView == null ) { actionBarLayoutView = container . getBean ( \"actionBarLayoutView\" , this , actionBarOptions ) ; if ( actionBarLayoutView == null ) { SocializeLogger . w ( \"Request for bean [actionBarLayoutView] returned null\" ) ; } } setListeners ( ) ; if ( actionBarListener != null ) { actionBarListener . onCreate ( this ) ; } return actionBarLayoutView ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void extendAccessToken ( final Activity context , final SocializeAuthListener listener ) { try { Facebook facebook = getFacebook ( context ) ; if ( isLinked ( context ) ) { if ( facebook != null && ! facebook . extendAccessTokenIfNeeded ( context , new ServiceListener ( ) { @ Override public void onFacebookError ( FacebookError e ) { if ( logger != null ) { logger . warn ( \"An error occurred while attempting to extend a Facebook access token.  The local Facebook account will be cleared.\" , e ) ; } // Clear the local session state unlink ( context , null ) ; } @ Override public void onError ( Error e ) { if ( logger != null ) { logger . warn ( \"An error occurred while attempting to extend a Facebook access token.  The local Facebook account will be cleared.\" , e ) ; } // Clear the local session state unlink ( context , null ) ; } @ Override public void onComplete ( Bundle values ) { // Update the local session state SocializeSession session = getSocialize ( ) . getSession ( ) ; if ( session != null ) { final String newAccessToken = values . getString ( Facebook . TOKEN ) ; if ( ! StringUtils . isEmpty ( newAccessToken ) ) { if ( logger != null && logger . isDebugEnabled ( ) ) { logger . debug ( \"Got new Facebook access token [\" + newAccessToken + \"]\" ) ; } // Link the user again link ( context , newAccessToken , false , new SocializeAuthListener ( ) { @ Override public void onError ( SocializeException error ) { if ( logger != null ) { logger . error ( \"An error occurred while attempting to update authentication details\" , error ) ; } if ( listener != null ) { listener . onError ( error ) ; } } @ Override public void onCancel ( ) { if ( listener != null ) { listener . onCancel ( ) ; } } @ Override public void onAuthSuccess ( SocializeSession session ) { UserProviderCredentialsMap map = session . getUserProviderCredentials ( ) ; UserProviderCredentials creds = map . get ( AuthProviderType . FACEBOOK ) ; DefaultUserProviderCredentials newCreds = new DefaultUserProviderCredentials ( ) ; if ( creds != null ) { newCreds . merge ( creds ) ; } newCreds . setAccessToken ( newAccessToken ) ; map . put ( AuthProviderType . FACEBOOK , newCreds ) ; getSocialize ( ) . setSession ( session ) ; getSocialize ( ) . saveSession ( context ) ; if ( listener != null ) { listener . onAuthSuccess ( session ) ; } } @ Override public void onAuthFail ( SocializeException error ) { if ( logger != null ) { logger . error ( \"An error occurred while attempting to update authentication details\" , error ) ; } if ( listener != null ) { listener . onAuthFail ( error ) ; } } } ) ; } else { if ( logger != null ) { logger . warn ( \"Access token returned from Facebook was empty during request to extend\" ) ; } } } } } ) ) { if ( logger != null ) { logger . warn ( \"Failed to bind to the Facebook RefreshToken Service\" ) ; } } } else if ( facebook != null ) { // Ensure the local fb session is cleared String accessToken = facebook . getAccessToken ( ) ; if ( ! StringUtils . isEmpty ( accessToken ) ) { new FacebookSessionStore ( ) . clear ( context ) ; } } } catch ( Exception e ) { if ( listener != null ) { listener . onError ( SocializeException . wrap ( e ) ) ; } if ( logger != null ) { logger . error ( \"Failure during Facebook Token Refresh\" , e ) ; } } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public void setTextSize ( int textSize ) { if ( textView != null ) { textView . setTextSize ( android . util . TypedValue . COMPLEX_UNIT_DIP , textSize ) ; } this . textSize = textSize ; }'", "label": "'Set the text size in DIP'"}
{"text": "'@ Override public void executeDemo ( String text ) { TwitterUtils . link ( this , new SocializeAuthListener ( ) { @ Override public void onError ( SocializeException error ) { handleError ( UserTimelineActivity . this , error ) ; } @ Override public void onCancel ( ) { handleCancel ( ) ; } @ Override public void onAuthSuccess ( SocializeSession session ) { TwitterUtils . get ( UserTimelineActivity . this , \"statuses/user_timeline.json\" , null , new SocialNetworkPostListener ( ) { @ Override public void onNetworkError ( Activity context , SocialNetwork network , Exception error ) { handleError ( context , error ) ; } @ Override public void onCancel ( ) { handleCancel ( ) ; } @ Override public void onAfterPost ( Activity parent , SocialNetwork socialNetwork , JSONObject responseObject ) { try { JSONArray jsonArray = responseObject . getJSONArray ( \"data\" ) ; StringBuilder builder = new StringBuilder ( ) ; int len = jsonArray . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( i > 0 ) { builder . append ( \"\\\\n\" ) ; } builder . append ( jsonArray . getString ( i ) ) ; } handleResult ( builder . toString ( ) ) ; } catch ( JSONException e ) { handleError ( parent , e ) ; } } } ) ; } @ Override public void onAuthFail ( SocializeException error ) { handleError ( UserTimelineActivity . this , error ) ; } } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public void onImageChange ( Bitmap bitmap , String localPath ) { if ( profileLayoutView != null ) { profileLayoutView . onImageChange ( bitmap ) ; } // Set the image in the user settings try { UserUtils . getUserSettings ( getContext ( ) ) . setLocalImagePath ( localPath ) ; } catch ( SocializeException e ) { Log . e ( SocializeLogger . LOG_TAG , \"Error getting user settings\" , e ) ; } }'", "label": "'Called when the user s profile image is changed .'"}
{"text": "'@ Override public void executeDemo ( String text ) { EntityUtils . getEntities ( this , 0 , PAGE_SIZE , SortOrder . TOTAL_ACTIVITY , new EntityListListener ( ) { @ Override public void onList ( ListResult < Entity > entities ) { List < Entity > items = entities . getItems ( ) ; Collection < String > strResults = new ArrayList < String > ( ) ; for ( Entity socializeAction : items ) { strResults . add ( socializeAction . toString ( ) + \" (Total Activity \" + socializeAction . getEntityStats ( ) . getTotalActivityCount ( ) + \")\" ) ; } handleResults ( strResults ) ; } @ Override public void onError ( SocializeException error ) { handleError ( GetPopularEntitiesActivity . this , error ) ; } } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void executeDemo ( String text ) { // usually the name parameter would be a human readable name (i.e. not the same as the key). Entity e = Entity . newInstance ( text , text ) ; EntityUtils . saveEntity ( this , e , new EntityAddListener ( ) { @ Override public void onError ( SocializeException error ) { handleError ( AddEntityActivity . this , error ) ; } @ Override public void onCreate ( Entity entity ) { handleBasicSocializeResult ( entity ) ; } } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'protected void retrieveToken ( OAuthConsumer consumer , String endpointUrl , OAuthTokenListener listener , String ... additionalParameters ) throws OAuthMessageSignerException , OAuthCommunicationException , OAuthNotAuthorizedException , OAuthExpectationFailedException { Map < String , String > defaultHeaders = getRequestHeaders ( ) ; if ( consumer . getConsumerKey ( ) == null || consumer . getConsumerSecret ( ) == null ) { throw new OAuthExpectationFailedException ( \"Consumer key or secret not set\" ) ; } HttpRequest request = null ; HttpResponse response = null ; try { request = createRequest ( endpointUrl ) ; for ( String header : defaultHeaders . keySet ( ) ) { request . setHeader ( header , defaultHeaders . get ( header ) ) ; } if ( additionalParameters != null ) { HttpParameters httpParams = new HttpParameters ( ) ; httpParams . putAll ( additionalParameters , true ) ; consumer . setAdditionalParameters ( httpParams ) ; } if ( this . listener != null ) { this . listener . prepareRequest ( request ) ; } consumer . sign ( request ) ; if ( this . listener != null ) { this . listener . prepareSubmission ( request ) ; } response = sendRequest ( request ) ; int statusCode = response . getStatusCode ( ) ; boolean requestHandled = false ; if ( this . listener != null ) { requestHandled = this . listener . onResponseReceived ( request , response ) ; } if ( requestHandled ) { return ; } if ( statusCode >= 300 ) { handleUnexpectedResponse ( statusCode , response ) ; } HttpParameters responseParams = OAuth . decodeForm ( response . getContent ( ) ) ; if ( listener != null ) { listener . onResponse ( responseParams ) ; } String token = responseParams . getFirst ( OAuth . OAUTH_TOKEN ) ; String secret = responseParams . getFirst ( OAuth . OAUTH_TOKEN_SECRET ) ; responseParams . remove ( OAuth . OAUTH_TOKEN ) ; responseParams . remove ( OAuth . OAUTH_TOKEN_SECRET ) ; setResponseParameters ( responseParams ) ; if ( token == null || secret == null ) { throw new OAuthExpectationFailedException ( \"Request token or token secret not set in server reply. \" + \"The service provider you use is probably buggy.\" ) ; } consumer . setTokenWithSecret ( token , secret ) ; } catch ( OAuthNotAuthorizedException e ) { throw e ; } catch ( OAuthExpectationFailedException e ) { throw e ; } catch ( Exception e ) { throw new OAuthCommunicationException ( e ) ; } finally { try { closeConnection ( request , response ) ; } catch ( Exception e ) { throw new OAuthCommunicationException ( e ) ; } } }'", "label": "'<p > Implemented by subclasses . The responsibility of this method is to contact the service provider at the given endpoint URL and fetch a request or access token . What kind of token is retrieved solely depends on the URL being used . < / p > <p > Correct implementations of this method must guarantee the following post - conditions : <ul > <li > the { @link OAuthConsumer } passed to this method must have a valid { @link OAuth#OAUTH_TOKEN } and { @link OAuth#OAUTH_TOKEN_SECRET } set by calling { @link OAuthConsumer#setTokenWithSecret ( String String ) } < / li > <li > { @link #getResponseParameters () } must return the set of query parameters served by the service provider in the token response with all OAuth specific parameters being removed< / li > < / ul > < / p >'"}
{"text": "'@ Override public void executeDemo ( String text ) { ActionUtils . getActionsByEntity ( this , entity . getKey ( ) , 0 , PAGE_SIZE , new ActionListListener ( ) { @ Override public void onList ( ListResult < SocializeAction > result ) { handleSocializeResult ( result ) ; } @ Override public void onError ( SocializeException error ) { handleError ( GetActionsByEntityActivity . this , error ) ; } } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void save ( Context context , UserSettings profile , UserSaveListener listener ) { UserUtils . saveUserSettings ( context , profile , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public SocializeEntityLoader initEntityLoader ( ) { SocializeEntityLoader entityLoader = Socialize . getSocialize ( ) . getEntityLoader ( ) ; if ( entityLoader == null ) { String entityLoaderClassName = config . getProperty ( SocializeConfig . SOCIALIZE_ENTITY_LOADER ) ; if ( ! StringUtils . isEmpty ( entityLoaderClassName ) ) { try { if ( logger != null && logger . isDebugEnabled ( ) ) { logger . debug ( \"Instantiating entity loader [\" + entityLoader + \"]\" ) ; } Object loader = objectUtils . construct ( entityLoaderClassName ) ; if ( loader instanceof SocializeEntityLoader ) { entityLoader = ( SocializeEntityLoader ) loader ; Socialize . getSocialize ( ) . setEntityLoader ( entityLoader ) ; } else { if ( logger != null ) { logger . error ( \"Entity loader [\" + entityLoader + \"] is not an instance of [\" + SocializeEntityLoader . class . getName ( ) + \"]\" ) ; } } } catch ( SocializeException e ) { if ( logger != null ) { logger . error ( \"Failed to instantiate entity loader [\" + entityLoader + \"]\" , e ) ; } } } else { if ( logger != null ) { logger . warn ( \"No entity loader specified in socialize.properties\" ) ; } } } return entityLoader ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override protected Void doInBackground ( Void ... args ) { switch ( type ) { case FACEBOOK : FacebookUtils . unlink ( context . get ( ) ) ; break ; case TWITTER : TwitterUtils . unlink ( context . get ( ) ) ; break ; } return null ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void execute ( Context context , Bundle extras ) throws SocializeException { if ( tasks != null ) { for ( LaunchTask task : tasks ) { try { task . execute ( context , extras ) ; } catch ( SocializeException e ) { if ( logger != null ) { logger . error ( \"Error executing launcher task\" , e ) ; } else { SocializeLogger . e ( e . getMessage ( ) , e ) ; } } } } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void executeDemo ( String text ) { FacebookUtils . linkForRead ( this , new SocializeAuthListener ( ) { @ Override public void onError ( SocializeException error ) { handleError ( GetTokenActivity . this , error ) ; } @ Override public void onCancel ( ) { handleCancel ( ) ; } @ Override public void onAuthSuccess ( SocializeSession session ) { UserProviderCredentials userProviderCredentials = session . getUserProviderCredentials ( AuthProviderType . FACEBOOK ) ; handleResult ( userProviderCredentials . getAccessToken ( ) ) ; } @ Override public void onAuthFail ( SocializeException error ) { handleError ( GetTokenActivity . this , error ) ; } } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public Activity getActivity ( ) { Context context = getContext ( ) ; if ( context instanceof Activity ) { return ( Activity ) context ; } return null ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void onAfterSetComment ( Comment comment , CommentListItem item ) { Linkify . addLinks ( item . getCommentText ( ) , mask ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void executeDemo ( String text ) { // usually the name parameter would be a human readable name (i.e. not the same as the key). ViewUtils . view ( this , entity , new ViewAddListener ( ) { @ Override public void onError ( SocializeException error ) { handleError ( AddViewActivity . this , error ) ; } @ Override public void onCreate ( View entity ) { handleSocializeResult ( entity ) ; } } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void init ( SocializeConfig config ) throws SocializeException { try { if ( logger != null && logger . isDebugEnabled ( ) ) { logger . debug ( \"Initializing \" + getClass ( ) . getSimpleName ( ) ) ; } params = new BasicHttpParams ( ) ; HttpProtocolParams . setVersion ( params , HttpVersion . HTTP_1_1 ) ; HttpProtocolParams . setContentCharset ( params , HTTP . UTF_8 ) ; HttpConnectionParams . setConnectionTimeout ( params , config . getIntProperty ( SocializeConfig . HTTP_CONNECTION_TIMEOUT , 10000 ) ) ; HttpConnectionParams . setSoTimeout ( params , config . getIntProperty ( SocializeConfig . HTTP_SOCKET_TIMEOUT , 10000 ) ) ; SchemeRegistry registry = new SchemeRegistry ( ) ; registry . register ( new Scheme ( \"http\" , PlainSocketFactory . getSocketFactory ( ) , 80 ) ) ; registry . register ( new Scheme ( \"https\" , SSLSocketFactory . getSocketFactory ( ) , 443 ) ) ; connectionManager = new ThreadSafeClientConnManager ( params , registry ) ; monitor = new IdleConnectionMonitorThread ( connectionManager ) ; monitor . setDaemon ( true ) ; monitor . start ( ) ; if ( logger != null && logger . isDebugEnabled ( ) ) { logger . debug ( \"Initialized \" + getClass ( ) . getSimpleName ( ) ) ; } destroyed = false ; } catch ( Exception e ) { throw new SocializeException ( e ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void destroy ( ) { if ( logger != null && logger . isDebugEnabled ( ) ) { logger . debug ( \"Destroying \" + getClass ( ) . getSimpleName ( ) ) ; } if ( monitor != null ) { monitor . shutdown ( ) ; } if ( connectionManager != null ) { connectionManager . shutdown ( ) ; } if ( logger != null && logger . isDebugEnabled ( ) ) { logger . debug ( \"Destroyed \" + getClass ( ) . getSimpleName ( ) ) ; } destroyed = true ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public synchronized HttpClient getClient ( ) { if ( client == null ) { if ( apacheHttpClientFactory != null ) { client = apacheHttpClientFactory . getBean ( connectionManager , params ) ; } else { client = new DefaultHttpClient ( connectionManager , params ) ; } } else { monitor . trigger ( ) ; } return client ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void addComment ( SocializeSession session , Entity entity , String comment , CommentOptions commentOptions , CommentListener listener , SocialNetwork ... networks ) { Comment c = new Comment ( ) ; c . setText ( comment ) ; c . setEntitySafe ( entity ) ; addComment ( session , c , commentOptions , listener , networks ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getCommentsByEntity ( SocializeSession session , String key , CommentListener listener ) { listAsync ( session , ENDPOINT , key , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getCommentsByEntity ( SocializeSession session , String key , int startIndex , int endIndex , CommentListener listener ) { listAsync ( session , ENDPOINT , key , null , null , startIndex , endIndex , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getCommentsByApplication ( SocializeSession session , int startIndex , int endIndex , CommentListener listener ) { listAsync ( session , ENDPOINT , null , null , null , startIndex , endIndex , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getCommentsByUser ( SocializeSession session , long userId , CommentListener listener ) { String endpoint = \"/user/\" + userId + ENDPOINT ; listAsync ( session , endpoint , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getCommentsById ( SocializeSession session , CommentListener listener , long ... ids ) { String [ ] strIds = new String [ ids . length ] ; for ( int i = 0 ; i < ids . length ; i ++ ) { strIds [ i ] = String . valueOf ( ids [ i ] ) ; } // No need for pagination here really listAsync ( session , ENDPOINT , null , 0 , SocializeConfig . MAX_LIST_RESULTS , listener , strIds ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getComment ( SocializeSession session , long id , CommentListener listener ) { getAsync ( session , ENDPOINT , String . valueOf ( id ) , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public boolean launch ( final Activity context , Bundle data ) { String url = data . getString ( Socialize . DIRECT_URL ) ; if ( ! StringUtils . isEmpty ( url ) ) { final DirectUrlWebView webView = directUrlWebViewFactory . getBean ( ) ; webView . setListener ( directUrlListener ) ; Dialog dialog = dialogFactory . build ( context , webView , true ) ; dialog . setOnCancelListener ( new OnCancelListener ( ) { @ Override public void onCancel ( DialogInterface dialog ) { handleCloseEvent ( webView , context ) ; } } ) ; dialog . setOnDismissListener ( new OnDismissListener ( ) { @ Override public void onDismiss ( DialogInterface dialog ) { handleCloseEvent ( webView , context ) ; } } ) ; dialog . setOnKeyListener ( new OnKeyListener ( ) { @ Override public boolean onKey ( DialogInterface dialog , int keyCode , KeyEvent event ) { if ( keyCode == KeyEvent . KEYCODE_BACK ) { if ( webView . canGoBack ( ) ) { webView . goBack ( ) ; return true ; } } return false ; } } ) ; boolean show = true ; if ( directUrlListener != null ) { show = directUrlListener . onBeforePageLoaded ( webView , url ) ; } if ( show ) { dialog . show ( ) ; webView . loadUrl ( url ) ; } return show ; } else { handleWarn ( \"No url found under key [\" + Socialize . DIRECT_URL + \"]\" ) ; } return false ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public static void saveUserAsync ( Context context , User user , UserSaveListener listener ) { proxy . saveUserAsync ( context , user , listener ) ; }'", "label": "'Saves the given user .'"}
{"text": "'public static void getUser ( Context context , long id , UserGetListener listener ) { proxy . getUser ( context , id , listener ) ; }'", "label": "'Retrieves a User based on the given ID .'"}
{"text": "'public static void showUserProfile ( Activity context , User user ) { proxy . showUserProfileView ( context , user , null , null ) ; }'", "label": "'Shows the user profile UI for the given user .'"}
{"text": "'public static void showUserProfileWithAction ( Activity context , User user , SocializeAction action ) { proxy . showUserProfileView ( context , user , action , null ) ; }'", "label": "'Shows the user profile UI for the given user .'"}
{"text": "'public static void showUserProfileWithAction ( Activity context , User user , SocializeAction action , OnActionDetailViewListener onActionDetailViewListener ) { proxy . showUserProfileView ( context , user , action , onActionDetailViewListener ) ; }'", "label": "'Shows the user profile UI for the given user .'"}
{"text": "'public static void showUserSettings ( Activity context ) { try { proxy . showUserSettingsView ( context , UserUtils . getCurrentUser ( context ) . getId ( ) ) ; } catch ( SocializeException e ) { SocializeLogger . e ( \"Error displaying user settings\" , e ) ; } }'", "label": "'Shows the settings UI for the current user .'"}
{"text": "'public static void showUserSettingsForResult ( Activity context , int requestCode ) { try { proxy . showUserSettingsViewForResult ( context , UserUtils . getCurrentUser ( context ) . getId ( ) , requestCode ) ; } catch ( SocializeException e ) { SocializeLogger . e ( \"Error displaying user settings\" , e ) ; } }'", "label": "'Shows the settings UI for the current user .'"}
{"text": "'public static void saveUserSettings ( Context context , UserSettings userSettings , UserSaveListener listener ) { proxy . saveUserSettings ( context , userSettings , listener ) ; }'", "label": "'Saves the profile for the given user .'"}
{"text": "'@ Override public boolean launch ( Activity context , Bundle data ) { return getLauncher ( context ) . launch ( context , data ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void onResult ( Activity context , int requestCode , int resultCode , Intent returnedIntent , Intent originalIntent ) { getLauncher ( context ) . onResult ( context , requestCode , resultCode , returnedIntent , originalIntent ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Deprecated public boolean setAutoPostPreferences ( SocialNetwork ... networks ) { boolean tw = isAutoPostToTwitter ( ) ; boolean fb = isAutoPostToFacebook ( ) ; setAutoPostToFacebook ( false ) ; setAutoPostToTwitter ( false ) ; if ( networks != null ) { for ( SocialNetwork network : networks ) { if ( network . equals ( SocialNetwork . FACEBOOK ) ) { setAutoPostToFacebook ( true ) ; } else if ( network . equals ( SocialNetwork . TWITTER ) ) { setAutoPostToTwitter ( true ) ; } } } return tw != isAutoPostToTwitter ( ) || fb != isAutoPostToFacebook ( ) ; }'", "label": "'Sets the auto post preferences for the user .'"}
{"text": "'@ Override public void validate ( ) throws SocializeException { if ( StringUtils . isEmpty ( consumerKey ) ) { throw new SocializeException ( \"No twitter consumer key found.\" ) ; } if ( StringUtils . isEmpty ( consumerSecret ) ) { throw new SocializeException ( \"No twitter consumer secret found.\" ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public boolean merge ( AuthProviderInfo info ) { if ( info instanceof TwitterAuthProviderInfo ) { TwitterAuthProviderInfo that = ( TwitterAuthProviderInfo ) info ; this . consumerKey = that . consumerKey ; this . consumerSecret = that . consumerSecret ; return true ; } return false ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void saveEntity ( Activity context , Entity e , EntityAddListener listener ) { entitySystem . addEntity ( Socialize . getSocialize ( ) . getSession ( ) , e , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getEntity ( Activity context , String key , EntityGetListener listener ) { entitySystem . getEntity ( Socialize . getSocialize ( ) . getSession ( ) , key , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getEntities ( Activity context , int start , int end , SortOrder sortOrder , EntityListListener listener ) { entitySystem . getEntities ( Socialize . getSocialize ( ) . getSession ( ) , start , end , sortOrder , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getEntities ( Activity context , SortOrder sortOrder , EntityListListener listener , String ... keys ) { entitySystem . getEntities ( Socialize . getSocialize ( ) . getSession ( ) , sortOrder , listener , keys ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void onReceive ( Context context , Intent intent ) { if ( ! SmartAlertUtils . handleBroadcastIntent ( context , intent ) ) { // Message was NOT handled by Socialize. } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Deprecated public void authenticate ( Activity context ) { authenticate ( context , FacebookFacade . DEFAULT_PERMISSIONS , true , false ) ; }'", "label": "'Authenticates with default permissions and Single Sign On .'"}
{"text": "'public void authenticateForRead ( Activity context , boolean sso , String [ ] permissions ) { authenticate ( context , permissions , sso , true ) ; }'", "label": "'Authenticates with Single Sign On .'"}
{"text": "'@ Override public void executeDemo ( String text ) { LikeUtils . getLikesByEntity ( this , entity . getKey ( ) , 0 , PAGE_SIZE , new LikeListListener ( ) { @ Override public void onList ( List < Like > items , int totalSize ) { handleSocializeResult ( items ) ; } @ Override public void onError ( SocializeException error ) { handleError ( GetLikesByEntityActivity . this , error ) ; } } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public static void onPause ( Activity context ) { instance . onPause ( context ) ; if ( socializeLifecycleListener != null ) { socializeLifecycleListener . onPause ( context ) ; } }'", "label": "'Called by containing Activities in their onPause () method .'"}
{"text": "'public static void onResume ( Activity context ) { instance . onResume ( context ) ; if ( socializeLifecycleListener != null ) { socializeLifecycleListener . onResume ( context ) ; } }'", "label": "'Called by containing Activities in their onResume () method .'"}
{"text": "'public static void onCreate ( Activity context , Bundle savedInstanceState ) { instance . onCreate ( context , savedInstanceState ) ; if ( socializeLifecycleListener != null ) { socializeLifecycleListener . onCreate ( context , savedInstanceState ) ; } }'", "label": "'Called by containing Activities in their onCreate () method .'"}
{"text": "'public static void onDestroy ( Activity context ) { instance . onDestroy ( context ) ; if ( socializeLifecycleListener != null ) { socializeLifecycleListener . onDestroy ( context ) ; } }'", "label": "'Called by containing Activities in their onDestroy () method .'"}
{"text": "'public static void onStart ( Activity context ) { instance . onStart ( context ) ; if ( socializeLifecycleListener != null ) { socializeLifecycleListener . onStart ( context ) ; } }'", "label": "'Called by containing Activities in their onStart () method .'"}
{"text": "'public static void onStop ( Activity context ) { instance . onStop ( context ) ; if ( socializeLifecycleListener != null ) { socializeLifecycleListener . onStop ( context ) ; } }'", "label": "'Called by containing Activities in their onStop () method .'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public static final < E extends Object > E getStaticField ( String fieldName , Class < ? > clazz ) throws Exception { try { Field field = clazz . getField ( fieldName ) ; if ( field != null ) { return ( E ) field . get ( null ) ; } } catch ( Exception e ) { throw e ; } return null ; }'", "label": "'Gets the value of the given static field from the given class .'"}
{"text": "'public static final String getStaticFieldName ( Object value , Class < ? > clazz ) throws Exception { Field [ ] fields = clazz . getFields ( ) ; for ( Field field : fields ) { Object fVal = field . get ( null ) ; if ( fVal != null && fVal . equals ( value ) ) { return field . getName ( ) ; } } return null ; }'", "label": "'Returns the name of the static field that corresponds to the given value'"}
{"text": "'@ Override public void executeDemo ( String text ) { // We are going to list shares just so we can get the ID for a single share // Usually you would NOT do this as you would usually already have an ID (e.g. from a click on a list view) ShareUtils . getSharesByEntity ( this , entity . getKey ( ) , 0 , 1 , new ShareListListener ( ) { @ Override public void onList ( ListResult < Share > shares ) { // Use the id from the first share if ( shares . getTotalCount ( ) > 0 ) { ShareUtils . getShare ( GetSharesByIDActivity . this , new ShareGetListener ( ) { @ Override public void onGet ( Share share ) { handleSocializeResult ( share ) ; } @ Override public void onError ( SocializeException error ) { handleError ( GetSharesByIDActivity . this , error ) ; } } , shares . getItems ( ) . get ( 0 ) . getId ( ) ) ; } } @ Override public void onError ( SocializeException error ) { handleError ( GetSharesByIDActivity . this , error ) ; } } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public String put ( String key , String value ) { return put ( key , value , false ) ; }'", "label": "'Convenience method to add a single value for the parameter specified by key .'"}
{"text": "'public String put ( String key , String value , boolean percentEncode ) { SortedSet < String > values = wrappedMap . get ( key ) ; if ( values == null ) { values = new TreeSet < String > ( ) ; wrappedMap . put ( percentEncode ? OAuth . percentEncode ( key ) : key , values ) ; } if ( value != null ) { value = percentEncode ? OAuth . percentEncode ( value ) : value ; values . add ( value ) ; } return value ; }'", "label": "'Convenience method to add a single value for the parameter specified by key .'"}
{"text": "'public void putMap ( Map < String , List < String > > m ) { for ( String key : m . keySet ( ) ) { SortedSet < String > vals = get ( key ) ; if ( vals == null ) { vals = new TreeSet < String > ( ) ; put ( key , vals ) ; } vals . addAll ( m . get ( key ) ) ; } }'", "label": "'Convenience method to merge a Map<String List<String >> .'"}
{"text": "'public String getFirst ( Object key , boolean percentDecode ) { SortedSet < String > values = wrappedMap . get ( key ) ; if ( values == null || values . isEmpty ( ) ) { return null ; } String value = values . first ( ) ; return percentDecode ? OAuth . percentDecode ( value ) : value ; }'", "label": "'Returns the first value from the set of all values for the given parameter name . If the key passed to this method contains special characters you MUST first percent encode it using { @link OAuth#percentEncode ( String ) } otherwise the lookup will fail ( that s because upon storing values in this map keys get percent - encoded ) .'"}
{"text": "'public String getAsQueryString ( Object key ) { StringBuilder sb = new StringBuilder ( ) ; key = OAuth . percentEncode ( ( String ) key ) ; Set < String > values = wrappedMap . get ( key ) ; if ( values == null ) { return key + \"=\" ; } Iterator < String > iter = values . iterator ( ) ; while ( iter . hasNext ( ) ) { sb . append ( key + \"=\" + iter . next ( ) ) ; if ( iter . hasNext ( ) ) { sb . append ( \"&\" ) ; } } return sb . toString ( ) ; }'", "label": "'Concatenates all values for the given key to a list of key / value pairs suitable for use in a URL query string .'"}
{"text": "'@ Override public void execute ( Context context , Bundle extras ) throws SocializeException { config . setEntityLoaderCheckEnabled ( false ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public int compareTo ( Key < K > o ) { if ( o != null ) { if ( o . time > time ) { return - 1 ; } else if ( o . time < time ) { return 1 ; } else if ( o . key != null ) { return o . key . compareTo ( key ) ; } else { return 0 ; } } return 0 ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void onClick ( View view ) { final ProgressDialog dialog = progressDialogFactory . show ( view . getContext ( ) , I18NConstants . DLG_SHARE , I18NConstants . DLG_SHARE_MESSAGE + \" \" + shareType . getDisplayName ( ) + \"...\" ) ; ShareOptions shareOptions = ShareUtils . getUserShareOptions ( context ) ; shareOptions . setText ( provider . getShareText ( ) ) ; ShareUtils . registerShare ( context , entity , shareOptions , new ShareAddListener ( ) { @ Override public void onError ( SocializeException error ) { dialog . dismiss ( ) ; alertDialogFactory . showToast ( context , \"Share failed.  Please try again\" ) ; } @ Override public void onCreate ( Share share ) { dialog . dismiss ( ) ; if ( onActionBarEventListener != null ) { onActionBarEventListener . onPostShare ( actionBarView , share ) ; } } } , SocialNetwork . valueOf ( shareType ) ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void executeDemo ( String text ) { try { ActionUtils . getActionsByUser ( this , UserUtils . getCurrentUser ( this ) . getId ( ) , 0 , PAGE_SIZE , new ActionListListener ( ) { @ Override public void onList ( ListResult < SocializeAction > result ) { handleSocializeResult ( result ) ; } @ Override public void onError ( SocializeException error ) { handleError ( GetActionsByUserActivity . this , error ) ; } } ) ; } catch ( SocializeException e ) { e . printStackTrace ( ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public String getString ( String key ) { if ( key == null ) return \"\" ; String str = strings . get ( key ) ; if ( StringUtils . isEmpty ( str ) ) { int resId = resources . getIdentifier ( key , \"string\" , packageName ) ; if ( resId > 0 ) { try { str = resources . getString ( resId ) ; } catch ( Exception e ) { // Shouldn\\'t happen e . printStackTrace ( ) ; } } if ( str == null ) { // Get default str = defaultLocalizationService . getString ( key ) ; } if ( str != null ) { strings . put ( key , str ) ; } else { str = key ; } } return str ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void executeDemo ( String text ) { try { CommentUtils . getCommentsByUser ( this , UserUtils . getCurrentUser ( this ) , 0 , PAGE_SIZE , new CommentListListener ( ) { @ Override public void onList ( ListResult < Comment > comments ) { handleSocializeResult ( comments ) ; } @ Override public void onError ( SocializeException error ) { handleError ( GetCommentsByUserActivity . this , error ) ; } } ) ; } catch ( SocializeException e ) { e . printStackTrace ( ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void onMessage ( final Context context , final Bundle data ) { // DON\\'T Use Socialize instance here, we are using a different container! try { // This should be synchronous.  We don\\'t want to launch an async task off the main UI thread. SocializeSession session = userSystem . authenticateSynchronous ( context , config . getProperty ( SocializeConfig . SOCIALIZE_CONSUMER_KEY ) , config . getProperty ( SocializeConfig . SOCIALIZE_CONSUMER_SECRET ) ) ; handleNotification ( context , data , session ) ; } catch ( SocializeException e ) { handleError ( \"Failed to authenticate user for notification receipt\" , e ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void executeDemo ( String text ) { String token = FacebookUtils . getAccessToken ( this ) ; if ( ! StringUtils . isEmpty ( token ) ) { FacebookUtils . getCurrentPermissions ( this , token , new OnPermissionResult ( ) { @ Override public void onError ( SocializeException error ) { handleError ( GetPermissionsActivity . this , error ) ; } @ Override public void onSuccess ( String [ ] permissions ) { handleResults ( Arrays . asList ( permissions ) ) ; } } ) ; } else { handleError ( this , new SocializeException ( \"Not signed into Facebook\" ) ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void like ( Activity context , final Entity entity , final LikeAddListener listener ) { like ( context , entity , getUserLikeOptions ( context ) , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void unlike ( Activity context , String entityKey , final LikeDeleteListener listener ) { final SocializeSession session = getSocialize ( ) . getSession ( ) ; // Get the like based on the key likeSystem . getLike ( session , entityKey , new LikeGetListener ( ) { @ Override public void onGet ( Like entity ) { if ( entity != null ) { likeSystem . deleteLike ( session , entity . getId ( ) , listener ) ; } else { if ( listener != null ) { listener . onDelete ( ) ; } } } @ Override public void onError ( SocializeException error ) { if ( error instanceof SocializeApiError ) { if ( ( ( SocializeApiError ) error ) . getResultCode ( ) == 404 ) { if ( listener != null ) { listener . onDelete ( ) ; } return ; } } if ( listener != null ) { listener . onError ( error ) ; } } } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getLike ( Activity context , String entityKey , LikeGetListener listener ) { final SocializeSession session = getSocialize ( ) . getSession ( ) ; likeSystem . getLike ( session , entityKey , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getLike ( Activity context , long id , LikeGetListener listener ) { final SocializeSession session = getSocialize ( ) . getSession ( ) ; likeSystem . getLike ( session , id , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getLikesByUser ( Activity context , User user , int start , int end , LikeListListener listener ) { final SocializeSession session = getSocialize ( ) . getSession ( ) ; likeSystem . getLikesByUser ( session , user . getId ( ) , start , end , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getLikesByEntity ( Activity context , String entityKey , int start , int end , LikeListListener listener ) { likeSystem . getLikesByEntity ( getSocialize ( ) . getSession ( ) , entityKey , start , end , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getLikesByApplication ( Activity context , int start , int end , LikeListListener listener ) { likeSystem . getLikesByApplication ( getSocialize ( ) . getSession ( ) , start , end , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override protected ImageView makeImage ( ) { if ( drawables != null ) { setImageOn ( drawables . getDrawable ( \"icon_facebook.png\" ) ) ; setImageOff ( drawables . getDrawable ( \"icon_facebook_disabled.png\" ) ) ; } return new ImageView ( getContext ( ) ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void executeDemo ( String text ) { CommentOptions options = CommentUtils . getUserCommentOptions ( this ) ; options . setShowAuthDialog ( false ) ; options . setShowShareDialog ( false ) ; CommentUtils . addComment ( this , entity , text , options , new CommentAddListener ( ) { @ Override public void onError ( SocializeException error ) { handleError ( AddCommentWithoutShareActivity . this , error ) ; } @ Override public void onCreate ( Comment comment ) { handleSocializeResult ( comment ) ; } @ Override public void onCancel ( ) { handleCancel ( ) ; } } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public static boolean onMessage ( Context context , Intent intent ) { assertInitialized ( context ) ; Bundle messageData = intent . getExtras ( ) ; if ( messageData != null ) { String source = messageData . getString ( C2DMCallback . SOURCE_KEY ) ; if ( source != null && source . trim ( ) . equalsIgnoreCase ( C2DMCallback . SOURCE_SOCIALIZE ) ) { handler . onMessage ( context , intent ) ; return true ; } } return false ; }'", "label": "'Handles a GCM message . Returns true ONLY if this message was intended for Socialize .'"}
{"text": "'public static boolean handleBroadcastIntent ( Context context , Intent intent ) { return Socialize . getSocialize ( ) . handleBroadcastIntent ( context , intent ) ; }'", "label": "'Handles a broadcast intent received by a Broadcast Receiver on Android . Call this method if you already have a broadcast receiver defined but want to also utilize Socialize SmartAlerts .'"}
{"text": "'@ Override public boolean launch ( final Activity context , Bundle data ) { if ( entityLoaderUtils != null ) { final SocializeEntityLoader entityLoader = entityLoaderUtils . initEntityLoader ( ) ; if ( entityLoader != null ) { Object idObj = data . get ( Socialize . ENTITY_ID ) ; if ( idObj != null ) { long id = Long . parseLong ( idObj . toString ( ) ) ; try { SocializeSession session = notificationAuthenticator . authenticate ( context ) ; Entity entity = entitySystem . getEntitySynchronous ( session , id ) ; return loadEntity ( context , entityLoader , entity ) ; } catch ( Exception e ) { handleError ( \"Failed to load entity\" , e ) ; } } else { handleWarn ( \"No entity id found.  Entity based notification cannot be handled\" ) ; } } else { handleWarn ( \"No entity loader found.  Entity based notification cannot be handled\" ) ; } } return false ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void execute ( Context context , Bundle extras ) throws SocializeException { try { if ( logger != null && logger . isDebugEnabled ( ) ) { logger . debug ( \"Recording notification open event...\" ) ; } final SocializeEvent event = new SocializeEvent ( ) ; event . setBucket ( \"NOTIFICATION_OPEN\" ) ; String json = extras . getString ( C2DMCallback . MESSAGE_KEY ) ; JSONObject obj = new JSONObject ( json ) ; event . setData ( obj ) ; notificationAuthenticator . authenticateAsync ( context , new SocializeAuthListener ( ) { @ Override public void onError ( SocializeException error ) { logError ( error ) ; } @ Override public void onCancel ( ) { } @ Override public void onAuthSuccess ( SocializeSession session ) { eventSystem . addEvent ( session , event , new EventListener ( ) { @ Override public void onError ( SocializeException error ) { logError ( error ) ; } @ Override public void onPost ( ) { if ( logger != null && logger . isDebugEnabled ( ) ) { logger . debug ( \"Notification open event recorded.\" ) ; } } } ) ; } @ Override public void onAuthFail ( SocializeException error ) { logError ( error ) ; } } ) ; } catch ( Exception e ) { throw SocializeException . wrap ( e ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public byte [ ] encode ( byte [ ] source , int off , int len , byte [ ] alphabet , int maxLineLength ) { int lenDiv3 = ( len + 2 ) / 3 ; // ceil(len / 3) int len43 = lenDiv3 * 4 ; byte [ ] outBuff = new byte [ len43 // Main 4:3 + ( len43 / maxLineLength ) ] ; // New lines int d = 0 ; int e = 0 ; int len2 = len - 2 ; int lineLength = 0 ; for ( ; d < len2 ; d += 3 , e += 4 ) { // The following block of code is the same as // encode3to4( source, d + off, 3, outBuff, e, alphabet ); // but inlined for faster encoding (~20% improvement) int inBuff = ( ( source [ d + off ] << 24 ) >>> 8 ) | ( ( source [ d + 1 + off ] << 24 ) >>> 16 ) | ( ( source [ d + 2 + off ] << 24 ) >>> 24 ) ; outBuff [ e ] = alphabet [ ( inBuff >>> 18 ) ] ; outBuff [ e + 1 ] = alphabet [ ( inBuff >>> 12 ) & 0x3f ] ; outBuff [ e + 2 ] = alphabet [ ( inBuff >>> 6 ) & 0x3f ] ; outBuff [ e + 3 ] = alphabet [ ( inBuff ) & 0x3f ] ; lineLength += 4 ; if ( lineLength == maxLineLength ) { outBuff [ e + 4 ] = NEW_LINE ; e ++ ; lineLength = 0 ; } // end if: end of line } // end for: each piece of array if ( d < len ) { encode3to4 ( source , d + off , len - d , outBuff , e , alphabet ) ; lineLength += 4 ; if ( lineLength == maxLineLength ) { // Add a last newline outBuff [ e + 4 ] = NEW_LINE ; e ++ ; } e += 4 ; } assert ( e == outBuff . length ) ; return outBuff ; }'", "label": "'Encodes a byte array into Base64 notation .'"}
{"text": "'private int decode4to3 ( byte [ ] source , int srcOffset , byte [ ] destination , int destOffset , byte [ ] decodabet ) { // Example: Dk== if ( source [ srcOffset + 2 ] == EQUALS_SIGN ) { int outBuff = ( ( decodabet [ source [ srcOffset ] ] << 24 ) >>> 6 ) | ( ( decodabet [ source [ srcOffset + 1 ] ] << 24 ) >>> 12 ) ; destination [ destOffset ] = ( byte ) ( outBuff >>> 16 ) ; return 1 ; } else if ( source [ srcOffset + 3 ] == EQUALS_SIGN ) { // Example: DkL= int outBuff = ( ( decodabet [ source [ srcOffset ] ] << 24 ) >>> 6 ) | ( ( decodabet [ source [ srcOffset + 1 ] ] << 24 ) >>> 12 ) | ( ( decodabet [ source [ srcOffset + 2 ] ] << 24 ) >>> 18 ) ; destination [ destOffset ] = ( byte ) ( outBuff >>> 16 ) ; destination [ destOffset + 1 ] = ( byte ) ( outBuff >>> 8 ) ; return 2 ; } else { // Example: DkLE int outBuff = ( ( decodabet [ source [ srcOffset ] ] << 24 ) >>> 6 ) | ( ( decodabet [ source [ srcOffset + 1 ] ] << 24 ) >>> 12 ) | ( ( decodabet [ source [ srcOffset + 2 ] ] << 24 ) >>> 18 ) | ( ( decodabet [ source [ srcOffset + 3 ] ] << 24 ) >>> 24 ) ; destination [ destOffset ] = ( byte ) ( outBuff >> 16 ) ; destination [ destOffset + 1 ] = ( byte ) ( outBuff >> 8 ) ; destination [ destOffset + 2 ] = ( byte ) ( outBuff ) ; return 3 ; } }'", "label": "'Decodes four bytes from array <var > source< / var > and writes the resulting bytes ( up to three of them ) to <var > destination< / var > . The source and destination arrays can be manipulated anywhere along their length by specifying <var > srcOffset< / var > and <var > destOffset< / var > . This method does not check to make sure your arrays are large enough to accommodate <var > srcOffset< / var > + 4 for the <var > source< / var > array or <var > destOffset< / var > + 3 for the <var > destination< / var > array . This method returns the actual number of bytes that were converted from the Base64 encoding .'"}
{"text": "'public byte [ ] decodeWebSafe ( String s ) throws Base64DecoderException { byte [ ] bytes = s . getBytes ( ) ; return decodeWebSafe ( bytes , 0 , bytes . length ) ; }'", "label": "'Decodes data from web safe Base64 notation . Web safe encoding uses - instead of + _ instead of /'"}
{"text": "'public byte [ ] decode ( byte [ ] source , int off , int len , byte [ ] decodabet ) throws Base64DecoderException { int len34 = len * 3 / 4 ; byte [ ] outBuff = new byte [ 2 + len34 ] ; // Upper limit on size of output int outBuffPosn = 0 ; byte [ ] b4 = new byte [ 4 ] ; int b4Posn = 0 ; int i = 0 ; byte sbiCrop = 0 ; byte sbiDecode = 0 ; for ( i = 0 ; i < len ; i ++ ) { sbiCrop = ( byte ) ( source [ i + off ] & 0x7f ) ; // Only the low seven bits sbiDecode = decodabet [ sbiCrop ] ; if ( sbiDecode >= WHITE_SPACE_ENC ) { // White space Equals sign or better if ( sbiDecode >= EQUALS_SIGN_ENC ) { // An equals sign (for padding) must not occur at position 0 or 1 // and must be the last byte[s] in the encoded value if ( sbiCrop == EQUALS_SIGN ) { int bytesLeft = len - i ; byte lastByte = ( byte ) ( source [ len - 1 + off ] & 0x7f ) ; if ( b4Posn == 0 || b4Posn == 1 ) { throw new Base64DecoderException ( \"invalid padding byte \\'=\\' at byte offset \" + i ) ; } else if ( ( b4Posn == 3 && bytesLeft > 2 ) || ( b4Posn == 4 && bytesLeft > 1 ) ) { throw new Base64DecoderException ( \"padding byte \\'=\\' falsely signals end of encoded value \" + \"at offset \" + i ) ; } else if ( lastByte != EQUALS_SIGN && lastByte != NEW_LINE ) { throw new Base64DecoderException ( \"encoded value has invalid trailing byte\" ) ; } break ; } b4 [ b4Posn ++ ] = sbiCrop ; if ( b4Posn == 4 ) { outBuffPosn += decode4to3 ( b4 , 0 , outBuff , outBuffPosn , decodabet ) ; b4Posn = 0 ; } } } else { throw new Base64DecoderException ( \"Bad Base64 input character at \" + i + \": \" + source [ i + off ] + \"(decimal)\" ) ; } } // Because web safe encoding allows non padding base64 encodes, we // need to pad the rest of the b4 buffer with equal signs when // b4Posn != 0.  There can be at most 2 equal signs at the end of // four characters, so the b4 buffer must have two or three // characters.  This also catches the case where the input is // padded with EQUALS_SIGN if ( b4Posn != 0 ) { if ( b4Posn == 1 ) { throw new Base64DecoderException ( \"single trailing character at offset \" + ( len - 1 ) ) ; } b4 [ b4Posn ++ ] = EQUALS_SIGN ; outBuffPosn += decode4to3 ( b4 , 0 , outBuff , outBuffPosn , decodabet ) ; } byte [ ] out = new byte [ outBuffPosn ] ; System . arraycopy ( outBuff , 0 , out , 0 , outBuffPosn ) ; return out ; }'", "label": "'Decodes Base64 content using the supplied decodabet and returns the decoded byte array .'"}
{"text": "'public static void view ( Activity context , Entity e , ViewAddListener listener ) { proxy . view ( context , e , listener ) ; }'", "label": "'Records a view against the given entity for the current user .'"}
{"text": "'@ Override public void executeDemo ( String text ) { ActionUtils . getActionsByApplication ( this , 0 , PAGE_SIZE , new ActionListListener ( ) { @ Override public void onList ( ListResult < SocializeAction > result ) { handleSocializeResult ( result ) ; } @ Override public void onError ( SocializeException error ) { handleError ( GetActionsByApplicationActivity . this , error ) ; } } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { try { if ( synchronous || method . isAnnotationPresent ( Synchronous . class ) || ! isVoidMethod ( method ) ) { Context context = findContext ( args ) ; if ( context != null ) { synchronized ( this ) { SocializeService socialize = Socialize . getSocialize ( ) ; if ( ! socialize . isInitialized ( context ) ) { socialize . init ( context ) ; if ( ! socialize . isAuthenticated ( ) && ! method . isAnnotationPresent ( NoAuth . class ) ) { socialize . authenticateSynchronous ( context ) ; } } } } return method . invoke ( getBean ( ) , args ) ; } else { Activity context = findActivity ( args ) ; if ( context != null ) { SocializeListener listener = findListener ( args ) ; // Always init to set the context invokeWithInit ( context , listener , method , args ) ; } else { throw new MethodNotSupportedException ( \"No activity found in method arguments for method [\" + method . getName ( ) + \"]\" ) ; } } // Always void return null ; } catch ( Throwable e ) { SocializeLogger . e ( e . getMessage ( ) , e ) ; throw e ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public void onProfileUpdate ( ) { commentAdapter . notifyDataSetChanged ( ) ; if ( commentEntrySlider != null ) { commentEntrySlider . updateContent ( ) ; } if ( notifyBox != null ) { try { UserSettings user = userUtils . getUserSettings ( getContext ( ) ) ; if ( user . isNotificationsEnabled ( ) ) { notifyBox . setVisibility ( View . VISIBLE ) ; } else { notifyBox . setVisibility ( View . GONE ) ; } } catch ( SocializeException e ) { if ( logger != null ) { logger . error ( \"Error getting user settings\" , e ) ; } else { e . printStackTrace ( ) ; } notifyBox . setVisibility ( View . GONE ) ; } } }'", "label": "'Called when the current logged in user updates their profile .'"}
{"text": "'@ Override public Launcher getLaucher ( String action ) { try { return getLaucher ( LaunchAction . valueOf ( action ) ) ; } catch ( Exception e ) { if ( logger != null ) { logger . error ( \"Launch action [\" + action + \"] provided is not a known action\" , e ) ; } else { SocializeLogger . e ( e . getMessage ( ) , e ) ; } return null ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public Launcher getLaucher ( LaunchAction action ) { if ( launchers != null ) { return launchers . get ( action . name ( ) ) ; } return null ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public boolean isActivityAvailable ( Context context , Class < ? > activity ) { Intent intent = new Intent ( context , activity ) ; return isIntentAvailable ( context , intent ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public boolean isIntentAvailable ( Context context , String action ) { Intent intent = new Intent ( action ) ; return isIntentAvailable ( context , intent ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public boolean isIntentAvailable ( Context context , Intent intent ) { PackageManager packageManager = context . getPackageManager ( ) ; return packageManager . queryIntentActivities ( intent , PackageManager . MATCH_DEFAULT_ONLY ) . size ( ) > 0 ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public boolean isServiceAvailable ( Context context , Class < ? > cls ) { final PackageManager packageManager = context . getPackageManager ( ) ; final Intent intent = new Intent ( context , cls ) ; return packageManager . queryIntentServices ( intent , PackageManager . MATCH_DEFAULT_ONLY ) . size ( ) > 0 ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public boolean isReceiverAvailable ( Context context , Class < ? > cls ) { final PackageManager packageManager = context . getPackageManager ( ) ; final Intent intent = new Intent ( context , cls ) ; return packageManager . queryBroadcastReceivers ( intent , PackageManager . MATCH_DEFAULT_ONLY ) . size ( ) > 0 ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public boolean isLocationAvailable ( Context context ) { if ( ! locationAssessed && config != null ) { locationAvailable = config . getBooleanProperty ( SocializeConfig . SOCIALIZE_LOCATION_ENABLED , true ) && ( hasPermission ( context , \"android.permission.ACCESS_FINE_LOCATION\" ) || hasPermission ( context , \"android.permission.ACCESS_COARSE_LOCATION\" ) ) ; locationAssessed = true ; } return locationAvailable ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public boolean isNotificationsAvailable ( Context context ) { if ( ! notificationsAssessed ) { String permissionString = context . getPackageName ( ) + \".permission.C2D_MESSAGE\" ; boolean ok = true ; if ( config . getBooleanProperty ( SocializeConfig . SOCIALIZE_NOTIFICATIONS_ENABLED , true ) ) { if ( ! hasPermission ( context , permissionString ) ) { lastNotificationWarning = \"Notifications not available, permission [\" + permissionString + \"] not specified in AndroidManifest.xml\" ; if ( logger . isInfoEnabled ( ) ) logger . info ( lastNotificationWarning ) ; ok = false ; } if ( ! hasPermission ( context , \"com.google.android.c2dm.permission.RECEIVE\" ) ) { lastNotificationWarning = \"Notifications not available, permission com.google.android.c2dm.permission.RECEIVE not specified in AndroidManifest.xml, or device does not include Google APIs\" ; if ( logger . isInfoEnabled ( ) ) logger . info ( lastNotificationWarning ) ; ok = false ; } if ( config . isEntityLoaderCheckEnabled ( ) && getSocialize ( ) . getEntityLoader ( ) == null ) { lastNotificationWarning = \"Notifications not available. Entity loader not found.\" ; if ( logger . isInfoEnabled ( ) ) logger . info ( lastNotificationWarning ) ; ok = false ; } } else { ok = false ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"SmartAlerts disabled in config\" ) ; } } notificationsAvailable = ok ; notificationsAssessed = true ; } else if ( ! notificationsAvailable ) { if ( lastNotificationWarning != null && logger . isInfoEnabled ( ) ) { logger . info ( lastNotificationWarning ) ; } } return notificationsAvailable ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public boolean hasPermission ( Context context , String permission ) { return context . getPackageManager ( ) . checkPermission ( permission , context . getPackageName ( ) ) == PackageManager . PERMISSION_GRANTED ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public SocializeAction getAction ( SocializeSession session , long id , ActionType type ) throws SocializeException { String endpoint = null ; switch ( type ) { case COMMENT : endpoint = CommentSystem . ENDPOINT ; break ; case LIKE : endpoint = LikeSystem . ENDPOINT ; break ; case SHARE : endpoint = ShareSystem . ENDPOINT ; break ; case VIEW : endpoint = ViewSystem . ENDPOINT ; break ; } return get ( session , endpoint , String . valueOf ( id ) , type ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getActivityByUser ( SocializeSession session , long id , ActionListener listener ) { String userId = String . valueOf ( id ) ; String endpoint = getEndpoint ( userId ) ; listAsync ( session , endpoint , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; // Define/obtain your entity Entity entity = Entity . newInstance ( \"http://getsocialize.com\" , \"Socialize\" ) ; // Get a reference to the button you want to transform // This can be any type of CompoundButton (CheckBox, RadioButton, Switch, ToggleButton) CheckBox btnCustomCheckBoxLike = ( CheckBox ) findViewById ( R . id . btnCustomCheckBoxLike ) ; // Make the button a socialize like button! LikeUtils . makeLikeButton ( this , btnCustomCheckBoxLike , entity , new LikeButtonListener ( ) { @ Override public void onClick ( CompoundButton button ) { // You can use this callback to set any loading text or display a progress dialog button . setText ( \"--\" ) ; } @ Override public void onCheckedChanged ( CompoundButton button , boolean isChecked ) { // The like was posted successfully, change the button to reflect the change if ( isChecked ) { button . setText ( \"Unlike\" ) ; } else { button . setText ( \"Like\" ) ; } } @ Override public void onError ( CompoundButton button , Exception error ) { // An error occurred posting the like, we need to return the button to its original state Log . e ( \"Socialize\" , \"Error on like button\" , error ) ; if ( button . isChecked ( ) ) { button . setText ( \"Unlike\" ) ; } else { button . setText ( \"Like\" ) ; } } } ) ; }'", "label": "'begin - snippet - 0'"}
{"text": "'@ Override public void executeDemo ( String text ) { EntityUtils . getEntities ( this , 0 , PAGE_SIZE , new EntityListListener ( ) { @ Override public void onList ( ListResult < Entity > entities ) { handleBasicSocializeResult ( entities ) ; } @ Override public void onError ( SocializeException error ) { handleError ( GetAllEntitiesActivity . this , error ) ; } } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "\"public static < T extends Map . Entry < String , String > > void formEncode ( Collection < T > parameters , OutputStream into ) throws IOException { if ( parameters != null ) { boolean first = true ; for ( Map . Entry < String , String > entry : parameters ) { if ( first ) { first = false ; } else { into . write ( ' ' ) ; } into . write ( percentEncode ( safeToString ( entry . getKey ( ) ) ) . getBytes ( ) ) ; into . write ( ' ' ) ; into . write ( percentEncode ( safeToString ( entry . getValue ( ) ) ) . getBytes ( ) ) ; } } }\"", "label": "'Construct a x - www - form - urlencoded document containing the given sequence of name / value pairs . Use OAuth percent encoding ( not exactly the encoding mandated by x - www - form - urlencoded ) .'"}
{"text": "'public static < T extends Map . Entry < String , String > > String formEncode ( Collection < T > parameters ) throws IOException { ByteArrayOutputStream b = new ByteArrayOutputStream ( ) ; formEncode ( parameters , b ) ; return new String ( b . toByteArray ( ) ) ; }'", "label": "'Construct a x - www - form - urlencoded document containing the given sequence of name / value pairs . Use OAuth percent encoding ( not exactly the encoding mandated by x - www - form - urlencoded ) .'"}
{"text": "'public static HttpParameters decodeForm ( String form ) { HttpParameters params = new HttpParameters ( ) ; if ( isEmpty ( form ) ) { return params ; } for ( String nvp : form . split ( \"\\\\\\\\&\" ) ) { int equals = nvp . indexOf ( \\' \\' ) ; String name ; String value ; if ( equals < 0 ) { name = percentDecode ( nvp ) ; value = null ; } else { name = percentDecode ( nvp . substring ( 0 , equals ) ) ; value = percentDecode ( nvp . substring ( equals + 1 ) ) ; } params . put ( name , value ) ; } return params ; }'", "label": "'Parse a form - urlencoded document .'"}
{"text": "'public static < T extends Map . Entry < String , String > > Map < String , String > toMap ( Collection < T > from ) { HashMap < String , String > map = new HashMap < String , String > ( ) ; if ( from != null ) { for ( Map . Entry < String , String > entry : from ) { String key = entry . getKey ( ) ; if ( ! map . containsKey ( key ) ) { map . put ( key , entry . getValue ( ) ) ; } } } return map ; }'", "label": "'Construct a Map containing a copy of the given parameters . If several parameters have the same name the Map will contain the first value only .'"}
{"text": "'public static String addQueryParameters ( String url , String ... kvPairs ) { String queryDelim = url . contains ( \"?\" ) ? \"&\" : \"?\" ; StringBuilder sb = new StringBuilder ( url + queryDelim ) ; for ( int i = 0 ; i < kvPairs . length ; i += 2 ) { if ( i > 0 ) { sb . append ( \"&\" ) ; } sb . append ( OAuth . percentEncode ( kvPairs [ i ] ) + \"=\" + OAuth . percentEncode ( kvPairs [ i + 1 ] ) ) ; } return sb . toString ( ) ; }'", "label": "'Appends a list of key / value pairs to the given URL e . g . :'"}
{"text": "'public static String prepareOAuthHeader ( String ... kvPairs ) { StringBuilder sb = new StringBuilder ( \"OAuth \" ) ; for ( int i = 0 ; i < kvPairs . length ; i += 2 ) { if ( i > 0 ) { sb . append ( \", \" ) ; } String value = kvPairs [ i ] . startsWith ( \"oauth_\" ) ? OAuth . percentEncode ( kvPairs [ i + 1 ] ) : kvPairs [ i + 1 ] ; sb . append ( OAuth . percentEncode ( kvPairs [ i ] ) + \"=\\\\\"\" + value + \"\\\\\"\" ) ; } return sb . toString ( ) ; }'", "label": "'Builds an OAuth header from the given list of header fields . All parameters starting in oauth_ * will be percent encoded .'"}
{"text": "'public static String toHeaderElement ( String name , String value ) { return OAuth . percentEncode ( name ) + \"=\\\\\"\" + OAuth . percentEncode ( value ) + \"\\\\\"\" ; }'", "label": "'Helper method to concatenate a parameter and its value to a pair that can be used in an HTTP header . This method percent encodes both parts before joining them .'"}
{"text": "'public static < T extends Iterable < ? > > T checkContentsNotNull ( T iterable ) { if ( containsOrIsNull ( iterable ) ) { throw new NullPointerException ( ) ; } return iterable ; }'", "label": "'Ensures that an { @code Iterable } object passed as a parameter to the calling method is not null and contains no null elements .'"}
{"text": "'public static < T extends Iterable < ? > > T checkContentsNotNull ( T iterable , Object errorMessage ) { if ( containsOrIsNull ( iterable ) ) { throw new NullPointerException ( String . valueOf ( errorMessage ) ) ; } return iterable ; }'", "label": "'Ensures that an { @code Iterable } object passed as a parameter to the calling method is not null and contains no null elements .'"}
{"text": "'public static < T extends Iterable < ? > > T checkContentsNotNull ( T iterable , String errorMessageTemplate , Object ... errorMessageArgs ) { if ( containsOrIsNull ( iterable ) ) { throw new NullPointerException ( format ( errorMessageTemplate , errorMessageArgs ) ) ; } return iterable ; }'", "label": "'Ensures that an { @code Iterable } object passed as a parameter to the calling method is not null and contains no null elements .'"}
{"text": "'public static void checkElementIndex ( int index , int size , String desc ) { checkArgument ( size >= 0 , \"negative size: %s\" , size ) ; if ( index < 0 ) { throw new IndexOutOfBoundsException ( format ( \"%s (%s) must not be negative\" , desc , index ) ) ; } if ( index >= size ) { throw new IndexOutOfBoundsException ( format ( \"%s (%s) must be less than size (%s)\" , desc , index , size ) ) ; } }'", "label": "'Ensures that { @code index } specifies a valid <i > element< / i > in an array list or string of size { @code size } . An element index may range from zero inclusive to { @code size } exclusive .'"}
{"text": "'public static void checkPositionIndex ( int index , int size , String desc ) { checkArgument ( size >= 0 , \"negative size: %s\" , size ) ; if ( index < 0 ) { throw new IndexOutOfBoundsException ( format ( \"%s (%s) must not be negative\" , desc , index ) ) ; } if ( index > size ) { throw new IndexOutOfBoundsException ( format ( \"%s (%s) must not be greater than size (%s)\" , desc , index , size ) ) ; } }'", "label": "'Ensures that { @code index } specifies a valid <i > position< / i > in an array list or string of size { @code size } . A position index may range from zero to { @code size } inclusive .'"}
{"text": "'public static void checkPositionIndexes ( int start , int end , int size ) { checkPositionIndex ( start , size , \"start index\" ) ; checkPositionIndex ( end , size , \"end index\" ) ; if ( end < start ) { throw new IndexOutOfBoundsException ( format ( \"end index (%s) must not be less than start index (%s)\" , end , start ) ) ; } }'", "label": "'Ensures that { @code start } and { @code end } specify a valid <i > positions< / i > in an array list or string of size { @code size } and are in order . A position index may range from zero to { @code size } inclusive .'"}
{"text": "'@ Override public void executeDemo ( String text ) { try { ActionUtils . getActionsByUserAndEntity ( this , UserUtils . getCurrentUser ( this ) . getId ( ) , entity . getKey ( ) , 0 , PAGE_SIZE , new ActionListListener ( ) { @ Override public void onList ( ListResult < SocializeAction > result ) { handleSocializeResult ( result ) ; } @ Override public void onError ( SocializeException error ) { handleError ( GetActionsByUserEntityActivity . this , error ) ; } } ) ; } catch ( SocializeException e ) { e . printStackTrace ( ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override protected void postFromJSON ( JSONObject from , Subscription to ) throws JSONException { try { if ( from . has ( \"user\" ) && ! from . isNull ( \"user\" ) ) { JSONObject user = from . getJSONObject ( \"user\" ) ; if ( user != null ) { to . setUser ( userFactory . fromJSON ( user ) ) ; } } if ( from . has ( \"entity\" ) && ! from . isNull ( \"entity\" ) ) { JSONObject entity = from . getJSONObject ( \"entity\" ) ; if ( entity != null ) { to . setEntity ( entityFactory . fromJSON ( entity ) ) ; } } if ( from . has ( \"subscribed\" ) && ! from . isNull ( \"subscribed\" ) ) { to . setSubscribed ( from . getBoolean ( \"subscribed\" ) ) ; } if ( from . has ( \"date\" ) && ! from . isNull ( \"date\" ) ) { try { to . setDate ( DATE_FORMAT . parse ( from . getString ( \"date\" ) ) . getTime ( ) ) ; } catch ( ParseException e ) { if ( logger != null && logger . isWarnEnabled ( ) ) { logger . warn ( \"Could not parse date [\" + from . getString ( \"date\" ) + \"] using format [\" + DATE_FORMAT_STRING + \"]\" ) ; } } } if ( from . has ( \"type\" ) && ! from . isNull ( \"type\" ) ) { try { to . setNotificationType ( NotificationType . valueOf ( from . getString ( \"type\" ) . toUpperCase ( ) ) ) ; } catch ( Exception e ) { if ( logger != null && logger . isWarnEnabled ( ) ) { logger . warn ( \"Could not parse type [\" + from . getString ( \"type\" ) + \"] into \" + NotificationType . class . getName ( ) ) ; } } } } catch ( Throwable e ) { throw new JSONException ( e . getMessage ( ) ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override protected void postToJSON ( Subscription from , JSONObject to ) throws JSONException { try { Entity entityObject = from . getEntity ( ) ; User userObject = from . getUser ( ) ; Long date = from . getDate ( ) ; if ( entityObject != null ) { if ( ! StringUtils . isEmpty ( entityObject . getName ( ) ) && ! StringUtils . isEmpty ( entityObject . getKey ( ) ) ) { JSONObject entity = entityFactory . toJSON ( entityObject ) ; to . put ( \"entity\" , entity ) ; } else if ( ! StringUtils . isEmpty ( entityObject . getKey ( ) ) ) { to . put ( \"entity_key\" , entityObject . getKey ( ) ) ; } } if ( userObject != null ) { JSONObject user = userFactory . toJSON ( userObject ) ; to . put ( \"user\" , user ) ; } if ( date != null ) { to . put ( \"date\" , DATE_FORMAT . format ( date ) ) ; } to . put ( \"subscribed\" , from . isSubscribed ( ) ) ; to . put ( \"type\" , from . getNotificationType ( ) . name ( ) . toLowerCase ( ) ) ; } catch ( Exception e ) { throw new JSONException ( e . getMessage ( ) ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void registerDevice ( SocializeSession session , DeviceRegistration registration , DeviceRegistrationListener listener ) { List < DeviceRegistration > registrations = new ArrayList < DeviceRegistration > ( 1 ) ; registrations . add ( registration ) ; postAsync ( session , ENDPOINT , registrations , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void authenticate ( Context context , TwitterAuthProviderInfo info , final AuthProviderListener listener ) { twitterAuthUtils . showAuthDialog ( context , info , newTwitterAuthListener ( listener ) ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public boolean put ( K strKey , E object , long ttl ) { return put ( strKey , object , ttl , false ) ; }'", "label": "'Adds an object to cache with the given time - to - live'"}
{"text": "'public boolean put ( K strKey , E object , boolean eternal ) { return put ( strKey , object , defaultTTL , eternal ) ; }'", "label": "'Adds an object to cache that optionally lives forever .'"}
{"text": "'protected synchronized boolean put ( K k , E object , long ttl , boolean eternal ) { // Check the key map first\\r if ( exists ( k ) ) { TTLObject < K , E > ttlObject = getTTLObject ( k ) ; Key < K > key = keys . get ( k ) ; key . setTime ( System . currentTimeMillis ( ) ) ; ttlObject . setEternal ( eternal ) ; ttlObject . extendLife ( ttl ) ; ttlObject . setObject ( object ) ; if ( eventListener != null ) { eventListener . onPut ( object ) ; } return true ; } else { TTLObject < K , E > t = new TTLObject < K , E > ( object , k , ttl ) ; t . setEternal ( eternal ) ; long addedSize = object . getSizeInBytes ( ) ; long newSize = currentSizeInBytes + addedSize ; boolean oversize = false ; oversize = ( hardByteLimit && maxCapacityBytes > 0 && newSize > maxCapacityBytes ) ; if ( ! oversize ) { Key < K > key = new Key < K > ( k , System . currentTimeMillis ( ) ) ; keys . put ( k , key ) ; objects . put ( key , t ) ; t . getObject ( ) . onPut ( k ) ; // Increment size\\r currentSizeInBytes = newSize ; if ( eventListener != null ) { eventListener . onPut ( object ) ; } return true ; } } return false ; }'", "label": "'Adds an object to cache with the given Time To Live in milliseconds'"}
{"text": "'public synchronized E getRaw ( K strKey ) { TTLObject < K , E > obj = getTTLObject ( strKey ) ; if ( obj != null && ! isExpired ( obj ) ) { return obj . getObject ( ) ; } return null ; }'", "label": "'Ignores proxy and always returns raw object'"}
{"text": "'public synchronized E get ( K key ) { TTLObject < K , E > obj = getTTLObject ( key ) ; if ( obj != null && ! isExpired ( obj ) ) { if ( extendOnGet ) { extendTTL ( key ) ; } if ( eventListener != null ) { eventListener . onGet ( obj . getObject ( ) ) ; } obj . getObject ( ) . onGet ( ) ; return obj . getObject ( ) ; } else if ( obj != null ) { // Expired\\r destroy ( obj . getKey ( ) ) ; obj = null ; } if ( obj == null ) { if ( objectFactory != null ) { E object = objectFactory . create ( key ) ; if ( object != null ) { if ( ! put ( key , object ) && logger != null ) { // We couldn\\'t put this record.. just log a warning\\r logger . warn ( \"Failed to put object into cache. Cache size exceeded\" ) ; } } return object ; } } return null ; }'", "label": "'Gets an object from cache . Returns null if the object does not exist or has expired .'"}
{"text": "'public Collection < E > values ( ) { Collection < E > values = null ; Collection < TTLObject < K , E > > ttls = objects . values ( ) ; if ( ttls != null ) { values = new ArrayList < E > ( ttls . size ( ) ) ; for ( TTLObject < K , E > t : ttls ) { if ( ! isExpired ( t ) ) { values . add ( t . getObject ( ) ) ; } } } return values ; }'", "label": "'Returns the internal values of the cache . <br / > Proxy objects are returned if gets are proxied within the cache .'"}
{"text": "'public boolean exists ( K k ) { Key < K > key = keys . get ( k ) ; if ( key != null ) { return objects . get ( key ) != null ; } return false ; }'", "label": "'Returns true if the object with the given key resides in the cache .'"}
{"text": "'public synchronized void extendTTL ( K strKey ) { TTLObject < K , E > object = getTTLObject ( strKey ) ; if ( object != null ) { object . setLifeExpectancy ( System . currentTimeMillis ( ) + object . getTtl ( ) ) ; } }'", "label": "'Extends the ttl of the object with the given key with the current system time .'"}
{"text": "'public void loadImageByData ( final String name , final String encodedData , int width , int height , final ImageLoadListener listener ) { ImageLoadRequest request = makeRequest ( ) ; request . setUrl ( name ) ; request . setEncodedImageData ( encodedData ) ; request . setType ( ImageLoadType . ENCODED ) ; loadImage ( request , listener ) ; }'", "label": "'Loads an image based on Base64 encoded bytes .'"}
{"text": "'public void loadImageByUrl ( final String url , int width , int height , final ImageLoadListener listener ) { ImageLoadRequest request = makeRequest ( ) ; request . setUrl ( url ) ; request . setType ( ImageLoadType . URL ) ; request . setScaleWidth ( width ) ; request . setScaleHeight ( height ) ; loadImage ( request , listener ) ; }'", "label": "'Asynchronously loads the image at the given url and calls the listener when it is loaded .'"}
{"text": "'@ Override public void addLike ( SocializeSession session , Entity entity , LikeOptions shareOptions , LikeListener listener , SocialNetwork ... networks ) { Like c = new Like ( ) ; c . setEntitySafe ( entity ) ; setPropagationData ( c , shareOptions , networks ) ; setLocation ( c ) ; List < Like > list = new ArrayList < Like > ( 1 ) ; list . add ( c ) ; postAsync ( session , ENDPOINT , list , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void deleteLike ( SocializeSession session , long id , LikeListener listener ) { deleteAsync ( session , ENDPOINT , String . valueOf ( id ) , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getLikesByEntity ( SocializeSession session , String key , LikeListener listener ) { listAsync ( session , ENDPOINT , key , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getLikesByEntity ( SocializeSession session , String key , int startIndex , int endIndex , LikeListener listener ) { listAsync ( session , ENDPOINT , key , null , null , startIndex , endIndex , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getLikesByApplication ( SocializeSession session , int startIndex , int endIndex , LikeListener listener ) { listAsync ( session , ENDPOINT , null , null , null , startIndex , endIndex , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getLike ( SocializeSession session , final String entityUrl , final LikeListener listener ) { final User user = session . getUser ( ) ; if ( user != null ) { final Long userId = user . getId ( ) ; String endpoint = \"/user/\" + userId . toString ( ) + ENDPOINT ; listAsync ( session , endpoint , entityUrl , null , null , 0 , 1 , new LikeListListener ( ) { @ Override public void onList ( List < Like > items , int totalSize ) { boolean is404 = false ; if ( items != null ) { if ( items != null && items . size ( ) > 0 ) { Like like = items . get ( 0 ) ; if ( like != null ) { listener . onGet ( like ) ; } else { is404 = true ; } } else { is404 = true ; } } else { is404 = true ; } if ( is404 ) { onError ( new SocializeApiError ( 404 , \"No likes found for entity with key [\" + entityUrl + \"] for user [\" + userId + \"]\" ) ) ; } } @ Override public void onError ( SocializeException error ) { listener . onError ( error ) ; } } ) ; } else { if ( listener != null ) { listener . onError ( new SocializeException ( \"No user found in current session\" ) ) ; } } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void getLike ( SocializeSession session , long id , LikeListener listener ) { getAsync ( session , ENDPOINT , String . valueOf ( id ) , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public long getTotalLength ( ) { long contentLen = 0 ; for ( FormBodyPart part : this . parts ) { ContentBody body = part . getBody ( ) ; long len = body . getContentLength ( ) ; if ( len >= 0 ) { contentLen += len ; } else { return - 1 ; } } ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; try { doWriteTo ( this . mode , out , false ) ; byte [ ] extra = out . toByteArray ( ) ; return contentLen + extra . length ; } catch ( IOException ex ) { // Should never happen\\r return - 1 ; } }'", "label": "'Determines the total length of the multipart content ( content length of individual parts plus that of extra elements required to delimit the parts from one another ) . If any of the @ { link BodyPart } s contained in this object is of a streaming entity of unknown length the total length is also unknown . <p / > This method buffers only a small amount of data in order to determine the total length of the entire entity . The content of individual parts is not buffered .'"}
{"text": "'@ Override public void addView ( SocializeSession session , Entity entity , Location location , ViewListener listener ) { View c = new View ( ) ; c . setEntitySafe ( entity ) ; setLocation ( c ) ; List < View > list = new ArrayList < View > ( 1 ) ; list . add ( c ) ; postAsync ( session , ENDPOINT , list , listener ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void send ( Set < OpenTsdbMetric > metrics ) { if ( metrics . isEmpty ( ) ) return ; Writer writer = null ; try { writer = this . writerFactory . getWriter ( ) ; write ( metrics , writer ) ; } catch ( Exception e ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Error writing codahale metrics\" , e ) ; } else { logger . warn ( \"Error writing codahale metrics: {}\" , e . getMessage ( ) ) ; } } finally { if ( writer != null ) { try { writer . close ( ) ; } catch ( IOException e ) { logger . error ( \"Error while closing writer:\" , e ) ; } } } }'", "label": "'send a set of metrics to opentsdb'"}
{"text": "'public void send ( Set < OpenTsdbMetric > metrics ) { // we set the patch size because of existing issue in opentsdb where large batch of metrics failed // see at https://groups.google.com/forum/#!topic/opentsdb/U-0ak_v8qu0 // we recommend batch size of 5 - 10 will be safer // alternatively you can enable chunked request if ( batchSizeLimit > 0 && metrics . size ( ) > batchSizeLimit ) { final Set < OpenTsdbMetric > smallMetrics = new HashSet < OpenTsdbMetric > ( ) ; for ( final OpenTsdbMetric metric : metrics ) { smallMetrics . add ( metric ) ; if ( smallMetrics . size ( ) >= batchSizeLimit ) { sendHelper ( smallMetrics ) ; smallMetrics . clear ( ) ; } } sendHelper ( smallMetrics ) ; } else { sendHelper ( metrics ) ; } }'", "label": "'send a set of metrics to opentsdb'"}
{"text": "'public static Map < String , String > parseTags ( final String tagString ) throws IllegalArgumentException { // delimit by whitespace or \\'=\\' Scanner scanner = new Scanner ( tagString ) . useDelimiter ( \"\\\\\\\\s+|=\" ) ; Map < String , String > tagMap = new HashMap < String , String > ( ) ; try { while ( scanner . hasNext ( ) ) { String tagName = scanner . next ( ) ; String tagValue = scanner . next ( ) ; tagMap . put ( tagName , tagValue ) ; } } catch ( NoSuchElementException e ) { // The tag string is corrupted. throw new IllegalArgumentException ( \"Invalid tag string \\'\" + tagString + \"\\'\" ) ; } finally { scanner . close ( ) ; } return tagMap ; }'", "label": "'Convert a tag string into a tag map .'"}
{"text": "'public static String formatTags ( final Map < String , String > tagMap ) { StringBuilder stringBuilder = new StringBuilder ( ) ; String delimeter = \"\" ; for ( Map . Entry < String , String > tag : tagMap . entrySet ( ) ) { stringBuilder . append ( delimeter ) . append ( sanitize ( tag . getKey ( ) ) ) . append ( \"=\" ) . append ( sanitize ( tag . getValue ( ) ) ) ; delimeter = \" \" ; } return stringBuilder . toString ( ) ; }'", "label": "'Convert a tag map into a space - delimited string .'"}
{"text": "'public static String encodeTagsInName ( final String name , final String tags ) throws IllegalArgumentException { return encodeTagsInName ( name , parseTags ( tags ) ) ; }'", "label": "'Add TSDB tags to a CodaHale metric name .'"}
{"text": "'public static String encodeTagsInName ( final String name , final Map < String , String > tags ) { return String . format ( \"TAG(%s)%s\" , formatTags ( tags ) , sanitize ( name ) ) ; }'", "label": "'Add TSDB tags to a CodaHale metric name .'"}
{"text": "'public static String fixEncodedTagsInNameAfterPrefix ( final String name ) { if ( name == null ) return name ; int tagStart = name . indexOf ( \"TAG(\" ) ; if ( tagStart == - 1 ) return name ; // no tags in this name if ( tagStart == 0 ) return name ; // tag string is already correct // extract the \"TAG(...)\" string from the middle of the name and put it at the front. int tagEnd = name . lastIndexOf ( \\' \\' ) ; if ( tagEnd == - 1 ) { throw new IllegalArgumentException ( \"Tag definition missing closing parenthesis for metric \\'\" + name + \"\\'\" ) ; } String tagString = name . substring ( tagStart , tagEnd + 1 ) ; return tagString + name . substring ( 0 , tagStart ) + name . substring ( tagEnd + 1 ) ; }'", "label": "'Call this function whenever a potentially tag - encoded name is prefixed .'"}
{"text": "'public static Builder named ( String name ) { /*\\n\\t\\tA name can contain either a pure metric name, or a string returned by encodeTagsInName().\\n\\t\\tIf it\\'s the latter, it looks like \"TAG(tag1=value1 tag2=value2)metricname\".\\n\\t\\t */ if ( ! hasEncodedTagInName ( name ) ) { return new Builder ( name ) ; } // parse out the tags int tagEnd = name . lastIndexOf ( \\' \\' ) ; if ( tagEnd == - 1 ) { throw new IllegalArgumentException ( \"Tag definition missing closing parenthesis for metric \\'\" + name + \"\\'\" ) ; } String tagString = name . substring ( 4 , tagEnd ) ; name = name . substring ( tagEnd + 1 ) ; return new Builder ( name ) . withTags ( parseTags ( tagString ) ) ; }'", "label": "'Creates a Builder for a metric name .'"}
{"text": "'public String toTelnetPutString ( ) { String tagString = formatTags ( tags ) ; return String . format ( \"put %s %d %s %s%n\" , metric , timestamp , value , tagString ) ; }'", "label": "'Returns a put string version of this metric compatible with the telnet - style reporter .'"}
{"text": "'@ Override public String toHumanString ( ) { if ( unicode ) { return domain ; } final IDNA . Info idnaInfo = new IDNA . Info ( ) ; final StringBuilder idnaOutput = new StringBuilder ( ) ; IDNA . getUTS46Instance ( IDNA . DEFAULT ) . nameToUnicode ( domain , idnaOutput , idnaInfo ) ; return idnaOutput . toString ( ) ; }'", "label": "'Converts the domain to a Unicode representation suitable for human interpretation . It does IDNA conversion .'"}
{"text": "'private static String serialize ( final byte [ ] bytes , final int offset , final int length ) { if ( bytes == null ) { throw new NullPointerException ( \"bytes\" ) ; } final StringBuilder sb = new StringBuilder ( length ) ; for ( int i = offset ; i < offset + length ; i ++ ) { final byte b = bytes [ i ] ; if ( 0x20 == b ) { sb . append ( ( char ) 0x20 ) ; } else if ( 0x2A == b || 0x2D == b || 0x2E == b || ( 0x30 <= b && b <= 0x39 ) || ( 0x41 <= b && b <= 0x5A ) || 0x5F == b || ( 0x61 <= b && b <= 0x7A ) ) { sb . appendCodePoint ( b ) ; } else { URLUtils . percentEncode ( b , sb ) ; } } return sb . toString ( ) ; }'", "label": "'Implements the application / x - www - form - urlencoded byte serializer .'"}
{"text": "'public static String encode ( final String input , final Charset charset ) { return encode ( parse ( input ) , charset ) ; }'", "label": "'Replacement for { @link java . net . URLEncoder#encode ( String String ) } .'"}
{"text": "'public static String encode ( final List < NameValue > input , final Charset charset ) { if ( input == null ) { throw new NullPointerException ( \"input\" ) ; } if ( charset == null ) { throw new NullPointerException ( \"charset\" ) ; } // 2. Let output be the empty string. final StringBuilder sb = new StringBuilder ( ) ; // 3. For each pair in pairs, run these substeps: for ( int i = 0 ; i < input . size ( ) ; i ++ ) { final NameValue pair = input . get ( i ) ; // 1. Let outputPair be a copy of pair. // N/A // 2. Replace outputPair\\'s name and value with the result of running encode on them using //    encoding override, respectively. // 3. Replace outputPair\\'s name and value with their serialization. final String outputName = serialize ( charset . encode ( pair . name ( ) ) ) ; final String outputValue = serialize ( charset . encode ( pair . value ( ) ) ) ; // 4. If pair is not the first pair in pairs, append \"&\" to output. if ( i != 0 ) { sb . append ( \\' \\' ) ; } // 5. Append outputPair\\'s name, followed by \"=\", followed by outputPair\\'s value to output. sb . append ( outputName ) . append ( \\' \\' ) . append ( outputValue ) ; } // 4. Return output. return sb . toString ( ) ; }'", "label": "'Implements the application / x - www - form - urlencoded serializer .'"}
{"text": "\"public static String percentDecode ( final String input ) { if ( input . isEmpty ( ) ) { return input ; } try { final ByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; int idx = 0 ; while ( idx < input . length ( ) ) { boolean isEOF = idx >= input . length ( ) ; int c = ( isEOF ) ? 0x00 : input . codePointAt ( idx ) ; while ( ! isEOF && c != ' ' ) { if ( c <= 0x7F ) { // String.getBytes is slow, so do not perform encoding // if not needed bytes . write ( ( byte ) c ) ; idx ++ ; } else { bytes . write ( new String ( Character . toChars ( c ) ) . getBytes ( UTF_8 ) ) ; idx += Character . charCount ( c ) ; } isEOF = idx >= input . length ( ) ; c = ( isEOF ) ? 0x00 : input . codePointAt ( idx ) ; } if ( c == ' ' && ( input . length ( ) <= idx + 2 || ! isASCIIHexDigit ( input . charAt ( idx + 1 ) ) || ! isASCIIHexDigit ( input . charAt ( idx + 2 ) ) ) ) { if ( c <= 0x7F ) { // String.getBytes is slow, so do not perform encoding // if not needed bytes . write ( ( byte ) c ) ; idx ++ ; } else { bytes . write ( new String ( Character . toChars ( c ) ) . getBytes ( UTF_8 ) ) ; idx += Character . charCount ( c ) ; } } else { while ( c == ' ' && input . length ( ) > idx + 2 && isASCIIHexDigit ( input . charAt ( idx + 1 ) ) && isASCIIHexDigit ( input . charAt ( idx + 2 ) ) ) { bytes . write ( hexToInt ( input . charAt ( idx + 1 ) , input . charAt ( idx + 2 ) ) ) ; idx += 3 ; c = ( input . length ( ) <= idx ) ? 0x00 : input . codePointAt ( idx ) ; } } } return new String ( bytes . toByteArray ( ) , UTF_8 ) ; } catch ( IOException ex ) { throw new RuntimeException ( ex ) ; } }\"", "label": "'Percent - decodes a string .'"}
{"text": "'public static String getDefaultPortForScheme ( final String scheme ) { if ( \"ftp\" . equals ( scheme ) ) { return \"21\" ; } if ( \"file\" . equals ( scheme ) ) { return null ; } if ( \"gopher\" . equals ( scheme ) ) { return \"70\" ; } if ( \"http\" . equals ( scheme ) ) { return \"80\" ; } if ( \"https\" . equals ( scheme ) ) { return \"443\" ; } if ( \"ws\" . equals ( scheme ) ) { return \"80\" ; } if ( \"wss\" . equals ( scheme ) ) { return \"443\" ; } return null ; }'", "label": "'Gets the default port for a given schema . That is :'"}
{"text": "'public InetAddress toInetAddress ( ) { final byte [ ] bytes = new byte [ 16 ] ; for ( int i = 0 ; i < pieces . length ; i ++ ) { bytes [ i * 2 ] = ( byte ) ( ( pieces [ i ] >> 8 ) & 0xFF ) ; bytes [ i * 2 + 1 ] = ( byte ) ( pieces [ i ] & 0xFF ) ; } try { return InetAddress . getByAddress ( bytes ) ; } catch ( UnknownHostException e ) { // Can\\'t happen if we pass the right amount of bytes throw new RuntimeException ( \"BUG\" , e ) ; } }'", "label": "'Convert to @ { java . net . InetAddress } .'"}
{"text": "'public static IPv6Address fromInet6Address ( final Inet6Address inet6Address ) { final byte [ ] bytes = inet6Address . getAddress ( ) ; final short [ ] pieces = new short [ 8 ] ; for ( int i = 0 ; i < pieces . length ; i ++ ) { pieces [ i ] = ( short ) ( ( ( bytes [ i * 2 ] & 0xFF ) << 8 ) | ( bytes [ i * 2 + 1 ] & 0x00FF ) ) ; } return new IPv6Address ( pieces ) ; }'", "label": "'Convert from @ { java . net . Inet6Address } .'"}
{"text": "'public static Host parseHost ( final String input ) throws GalimatiasParseException { if ( input == null ) { throw new NullPointerException ( \"null host\" ) ; } if ( input . isEmpty ( ) ) { throw new GalimatiasParseException ( \"empty host\" , - 1 ) ; } if ( input . charAt ( 0 ) == \\' \\' ) { if ( input . charAt ( input . length ( ) - 1 ) != \\' \\' ) { throw new GalimatiasParseException ( \"Unmatched \\'[\\'\" , - 1 ) ; } return IPv6Address . parseIPv6Address ( input . substring ( 1 , input . length ( ) - 1 ) ) ; } final Domain domain = Domain . parseDomain ( input ) ; try { return IPv4Address . parseIPv4Address ( domain . toString ( ) ) ; } catch ( GalimatiasParseException e ) { return domain ; } }'", "label": "'Parses a host as found in URLs . IPv6 literals are expected enclosed in square brackets ( i . e . [ ipv6 - literal ] ) .'"}
{"text": "'public String queryParameter ( final String name ) { if ( name == null ) { throw new NullPointerException ( \"name is null\" ) ; } if ( query == null || query . isEmpty ( ) ) { return null ; } int start = 0 ; do { final int nextAmpersand = query . indexOf ( \\' \\' , start ) ; final int end = ( nextAmpersand == - 1 ) ? query . length ( ) : nextAmpersand ; int nextEquals = query . indexOf ( \\' \\' , start ) ; if ( nextEquals == - 1 || nextEquals > end ) { nextEquals = end ; } final int thisNameLength = nextEquals - start ; final int thisValueLength = end - nextEquals ; if ( thisNameLength == name . length ( ) && query . regionMatches ( start , name , 0 , name . length ( ) ) ) { if ( thisValueLength == 0 ) { return \"\" ; } return query . substring ( nextEquals + 1 , end ) ; } if ( nextAmpersand == - 1 ) { break ; } start = nextAmpersand + 1 ; } while ( true ) ; return null ; }'", "label": "'Gets the first query parameter value for a given name .'"}
{"text": "'public List < String > queryParameters ( final String name ) { if ( name == null ) { throw new NullPointerException ( \"name is null\" ) ; } if ( query == null || query . isEmpty ( ) ) { return null ; } int start = 0 ; final List < String > result = new ArrayList < String > ( ) ; do { final int nextAmpersand = query . indexOf ( \\' \\' , start ) ; final int end = ( nextAmpersand == - 1 ) ? query . length ( ) : nextAmpersand ; int nextEquals = query . indexOf ( \\' \\' , start ) ; if ( nextEquals == - 1 || nextEquals > end ) { nextEquals = end ; } final int thisNameLength = nextEquals - start ; final int thisValueLength = end - nextEquals ; if ( thisNameLength == name . length ( ) && query . regionMatches ( start , name , 0 , name . length ( ) ) ) { if ( thisValueLength == 0 ) { result . add ( \"\" ) ; } else { result . add ( query . substring ( nextEquals + 1 , end ) ) ; } } if ( nextAmpersand == - 1 ) { break ; } start = nextAmpersand + 1 ; } while ( true ) ; return result ; }'", "label": "'Gets all query parameter values for a given name .'"}
{"text": "'public String relativize ( final URL url ) { if ( this . isOpaque ( ) || url . isOpaque ( ) ) { return url . toString ( ) ; } if ( ! this . scheme ( ) . equals ( url . scheme ( ) ) ) { return url . toString ( ) ; } if ( this . authority ( ) == null ^ url . authority ( ) == null ) { return url . toString ( ) ; } if ( this . authority ( ) != null && ! this . authority ( ) . equals ( url . authority ( ) ) ) { return url . toString ( ) ; } String prefixPath = ( this . path ( ) . endsWith ( \"/\" ) ) ? this . path : this . path ( ) + \"/\" ; if ( ! url . path ( ) . startsWith ( prefixPath ) && ! this . path ( ) . equals ( url . path ( ) ) ) { return url . toString ( ) ; } StringBuilder output = new StringBuilder ( ) ; if ( ! this . path ( ) . equals ( url . path ( ) ) ) { output . append ( url . path ( ) . replaceFirst ( prefixPath , \"\" ) ) ; } if ( url . query ( ) != null ) { output . append ( \\' \\' ) . append ( url . query ( ) ) ; } if ( url . fragment ( ) != null ) { output . append ( \\' \\' ) . append ( url . fragment ( ) ) ; } return output . toString ( ) ; }'", "label": "'Returns a relative URL reference for the given URL .'"}
{"text": "'public static URL buildHierarchical ( final String scheme , final String host ) throws GalimatiasParseException { if ( ! URLUtils . isRelativeScheme ( scheme ) ) { throw new GalimatiasParseException ( \"Scheme is not relative: \" + scheme ) ; } return new URLParser ( scheme + \"://\" + host ) . parse ( ) ; }'", "label": "'Gets a URL object from a relative scheme and a host .'"}
{"text": "'public static URL buildOpaque ( final String scheme ) throws GalimatiasParseException { if ( URLUtils . isRelativeScheme ( scheme ) ) { throw new GalimatiasParseException ( \"Scheme is relative: \" + scheme ) ; } return new URLParser ( scheme + \":\" ) . parse ( ) ; }'", "label": "'Gets a URL object from a non - relative scheme .'"}
{"text": "'public java . net . URI toJavaURI ( ) throws URISyntaxException { if ( isHierarchical ) { return new URI ( scheme ( ) , ( ! \"\" . equals ( userInfo ( ) ) ) ? URLUtils . percentDecode ( userInfo ( ) ) : null , ( host ( ) != null ) ? host ( ) . toString ( ) : null , port , ( path ( ) != null ) ? URLUtils . percentDecode ( path ( ) ) : null , ( query ( ) != null ) ? URLUtils . percentDecode ( query ( ) ) : null , ( fragment ( ) != null ) ? URLUtils . percentDecode ( fragment ( ) ) : null ) ; } return new URI ( scheme ( ) , URLUtils . percentDecode ( schemeData ( ) ) + ( ( query ( ) == null ) ? \"\" : \"?\" + URLUtils . percentDecode ( query ( ) ) ) , ( fragment ( ) != null ) ? URLUtils . percentDecode ( fragment ( ) ) : null ) ; }'", "label": "'Converts to { @link java . net . URI } .'"}
{"text": "'public static URL fromJavaURI ( java . net . URI uri ) { //TODO: Let\\'s do this more efficient. try { return new URLParser ( uri . toString ( ) ) . parse ( ) ; } catch ( GalimatiasParseException e ) { // This should not happen. throw new RuntimeException ( \"BUG\" , e ) ; } }'", "label": "'Construct a URL from a { @link java . net . URI } .'"}
{"text": "'public static URL fromJavaURL ( java . net . URL url ) { //TODO: Let\\'s do this more efficient. try { return new URLParser ( url . toString ( ) ) . parse ( ) ; } catch ( GalimatiasParseException e ) { // This should not happen. throw new RuntimeException ( \"BUG\" , e ) ; } }'", "label": "'Construct a URL from a { @link java . net . URL } .'"}
{"text": "'public String toHumanString ( ) { final StringBuilder output = new StringBuilder ( ) ; output . append ( scheme ) . append ( \\' \\' ) ; if ( isHierarchical ) { output . append ( \"//\" ) ; final String userInfo = userInfo ( ) ; if ( ! userInfo . isEmpty ( ) ) { output . append ( URLUtils . percentDecode ( userInfo ) ) . append ( \\' \\' ) ; } if ( host != null ) { if ( host instanceof IPv6Address ) { output . append ( host . toHostString ( ) ) ; } else { output . append ( host . toHumanString ( ) ) ; } } if ( port != - 1 ) { output . append ( \\' \\' ) . append ( port ) ; } if ( path != null ) { output . append ( URLUtils . percentDecode ( path ) ) ; } } else { output . append ( URLUtils . percentDecode ( schemeData ) ) ; } if ( query != null ) { output . append ( \\' \\' ) . append ( URLUtils . percentDecode ( query ) ) ; } if ( fragment != null ) { output . append ( \\' \\' ) . append ( URLUtils . percentDecode ( fragment ) ) ; } return output . toString ( ) ; }'", "label": "'Serializes the URL to a human - readable representation . That is percent - decoded and with IDN domains in its Unicode representation .'"}
{"text": "'public < T , U > U forStream ( String fileName , Class < T > clazz , Function < ? super Stream < T > , U > handleStream ) { String sql = getTemplate ( fileName , EMPTY_ARGS ) ; PreparedStatementSetter pss = paramBuilder . byArgs ( new Object [ 0 ] ) ; RowMapper < T > mapper = mapperBuilder . mapper ( clazz ) ; return queryStreamWithOrdinalParams ( sql , pss , mapper , handleStream ) ; }'", "label": "'Executes a query passing the row objects to { @code handleStream } as a stream .'"}
{"text": "'public < T , U > U forStream ( String fileName , Class < T > clazz , Map < String , Object > params , Function < ? super Stream < T > , U > handleStream ) { String sql = getTemplate ( fileName , params ) ; SqlParameterSource sps = paramBuilder . byMap ( params ) ; RowMapper < T > mapper = mapperBuilder . mapper ( clazz ) ; return queryStreamWithNamedParams ( sql , sps , mapper , handleStream ) ; }'", "label": "'Executes a query using { @code params } as the named parameters passing the row objects to { @code handleStream } as a stream .'"}
{"text": "'public < T , U > U forStream ( String fileName , Class < T > clazz , Object entity , Function < ? super Stream < T > , U > handleStream ) { String sql = getTemplate ( fileName , entity ) ; RowMapper < T > mapper = mapperBuilder . mapper ( clazz ) ; SQLExceptionTranslator excTranslator = jdbcTemplate . getExceptionTranslator ( ) ; if ( TypeUtils . isSimpleValueType ( entity . getClass ( ) ) ) { PreparedStatementSetter pss = paramBuilder . byArgs ( entity ) ; return queryStreamWithOrdinalParams ( sql , pss , mapper , handleStream ) ; } else { SqlParameterSource sps = paramBuilder . byBean ( entity ) ; return queryStreamWithNamedParams ( sql , sps , mapper , handleStream ) ; } }'", "label": "'Executes a query passing the row objects to { @code handleStream } as a stream .'"}
{"text": "'public < U > U forStream ( String fileName , Function < ? super Stream < Map < String , Object > > , U > handleStream ) { String sql = getTemplate ( fileName , EMPTY_ARGS ) ; PreparedStatementSetter pss = paramBuilder . byArgs ( new Object [ 0 ] ) ; RowMapper < Map < String , Object > > mapper = new ColumnMapRowMapper ( ) ; return queryStreamWithOrdinalParams ( sql , pss , mapper , handleStream ) ; }'", "label": "'Executes a query passing the column maps to { @code handleStream } as a stream .'"}
{"text": "'public < U > U forStream ( String fileName , Map < String , Object > params , Function < ? super Stream < Map < String , Object > > , U > handleStream ) { String sql = getTemplate ( fileName , params ) ; SqlParameterSource sps = paramBuilder . byMap ( params ) ; RowMapper < Map < String , Object > > mapper = new ColumnMapRowMapper ( ) ; return queryStreamWithNamedParams ( sql , sps , mapper , handleStream ) ; }'", "label": "'Executes a query using { @code params } as the named parameters passing the column maps to { @code handleStream } as a stream .'"}
{"text": "'public < U > U forStream ( String fileName , Object entity , Function < ? super Stream < Map < String , Object > > , U > handleStream ) { String sql = getTemplate ( fileName , entity ) ; RowMapper < Map < String , Object > > mapper = new ColumnMapRowMapper ( ) ; if ( TypeUtils . isSimpleValueType ( entity . getClass ( ) ) ) { PreparedStatementSetter pss = paramBuilder . byArgs ( entity ) ; return queryStreamWithOrdinalParams ( sql , pss , mapper , handleStream ) ; } else { SqlParameterSource sps = paramBuilder . byBean ( entity ) ; return queryStreamWithNamedParams ( sql , sps , mapper , handleStream ) ; } }'", "label": "'Executes a query passing the column maps to { @code handleStream } as a stream .'"}
{"text": "'private < T , U > U queryStreamWithOrdinalParams ( String sql , PreparedStatementSetter pss , RowMapper < T > mapper , Function < ? super Stream < T > , U > handleStream ) { SQLExceptionTranslator excTranslator = jdbcTemplate . getExceptionTranslator ( ) ; ResultSetExtractor < U > extractor = new StreamResultSetExtractor ( sql , mapper , handleStream , excTranslator ) ; return jdbcTemplate . query ( sql , pss , extractor ) ; }'", "label": "'Executes a quey for stream with ordinal parameters .'"}
{"text": "'private < T , U > U queryStreamWithNamedParams ( String sql , SqlParameterSource sps , RowMapper < T > mapper , Function < ? super Stream < T > , U > handleStream ) { SQLExceptionTranslator excTranslator = jdbcTemplate . getExceptionTranslator ( ) ; ResultSetExtractor < U > extractor = new StreamResultSetExtractor ( sql , mapper , handleStream , excTranslator ) ; return namedJdbcTemplate . query ( sql , sps , extractor ) ; }'", "label": "'Executes a query for stream with named parameters .'"}
{"text": "'public static Field [ ] get ( Class < ? > clazz ) { Field [ ] fields = CACHED_FIELDS . get ( clazz ) ; if ( fields == null ) { fields = clazz . getFields ( ) ; CACHED_FIELDS . putIfAbsent ( clazz , fields ) ; } return fields ; }'", "label": "'Get fields of the given class .'"}
{"text": "'public static boolean isSimpleValueType ( Class < ? > clazz ) { return ClassUtils . isPrimitiveOrWrapper ( clazz ) || clazz . isEnum ( ) || CharSequence . class . isAssignableFrom ( clazz ) || Number . class . isAssignableFrom ( clazz ) || Date . class . isAssignableFrom ( clazz ) || Temporal . class . isAssignableFrom ( clazz ) || clazz . equals ( URI . class ) || clazz . equals ( URL . class ) || clazz . equals ( Locale . class ) || clazz . equals ( Class . class ) ; }'", "label": "'Check if the given type represents a simple value type : a primitive a String or other CharSequence a Number a Date a URI a URL a Locale or a Class .'"}
{"text": "'@ Override public Object getValue ( String paramName ) { Object value = values . get ( paramName ) ; if ( value == null ) { return null ; } return Jsr310JdbcUtils . convertIfNecessary ( value , zoneId ) ; }'", "label": "'{'"}
{"text": "'private Optional < T > fetchRow ( ) { if ( this . row != null ) { // already fetched return Optional . of ( this . row ) ; } this . hasReachedEos = hasReachedEos || ! wrapSqlException ( ( ) -> rs . next ( ) ) ; if ( this . hasReachedEos ) { return Optional . empty ( ) ; } this . row = wrapSqlException ( ( ) -> mapper . mapRow ( rs , 1 ) ) ; return Optional . ofNullable ( this . row ) ; }'", "label": "'Fetches a row if not fetched yet .'"}
{"text": "'< R > R wrapSqlException ( SqlAction < R > action ) { try { return action . perform ( ) ; } catch ( SQLException sqlException ) { throw excTranslator . translate ( \"StreamResultSetExtractor\" , sql , sqlException ) ; } }'", "label": "'Performs an action which may throw an {'"}
{"text": "'protected static LocalDateTime getAsLocalDateTime ( ResultSet rs , int index ) throws SQLException { Timestamp timestamp = rs . getTimestamp ( index ) ; if ( timestamp != null ) { return timestamp . toLocalDateTime ( ) ; } return null ; }'", "label": "'Get the column value as LocalDateTime .'"}
{"text": "'protected static LocalDate getAsLocalDate ( ResultSet rs , int index ) throws SQLException { Date date = rs . getDate ( index ) ; if ( date != null ) { return date . toLocalDate ( ) ; } return null ; }'", "label": "'Get the column value as LocalDate .'"}
{"text": "'protected static LocalTime getAsLocalTime ( ResultSet rs , int index ) throws SQLException { Time time = rs . getTime ( index ) ; if ( time != null ) { return time . toLocalTime ( ) ; } return null ; }'", "label": "'Get the column value as LocalTime .'"}
{"text": "'protected static ZonedDateTime getAsZonedDateTime ( ResultSet rs , int index , ZoneId zoneId ) throws SQLException { Timestamp timestamp = rs . getTimestamp ( index ) ; if ( timestamp != null ) { return timestamp . toLocalDateTime ( ) . atZone ( zoneId ) ; } return null ; }'", "label": "'Get the column value as ZonedDateTime .'"}
{"text": "'protected static OffsetDateTime getAsOffsetDateTime ( ResultSet rs , int index , ZoneId zoneId ) throws SQLException { Timestamp timestamp = rs . getTimestamp ( index ) ; if ( timestamp != null ) { return timestamp . toLocalDateTime ( ) . atZone ( zoneId ) . toOffsetDateTime ( ) ; } return null ; }'", "label": "'Get the column value as OffsetDateTime .'"}
{"text": "'protected static OffsetTime getAsOffsetTime ( ResultSet rs , int index , ZoneId zoneId ) throws SQLException { Time time = rs . getTime ( index ) ; if ( time != null ) { return time . toLocalTime ( ) . atOffset ( zoneId . getRules ( ) . getOffset ( Instant . now ( ) ) ) ; } return null ; }'", "label": "'Get the column value as OffsetTime .'"}
{"text": "'@ Override public boolean hasValue ( String paramName ) { return privateFields . contains ( paramName ) || publicFeilds . containsKey ( paramName ) ; }'", "label": "'{'"}
{"text": "'@ Override public Object getValue ( String paramName ) { Object value = null ; if ( privateFields . contains ( paramName ) ) { value = beanWrapper . getPropertyValue ( paramName ) ; } else if ( publicFeilds . containsKey ( paramName ) ) { Field field = publicFeilds . get ( paramName ) ; try { value = field . get ( entity ) ; } catch ( IllegalAccessException e ) { throw new IllegalArgumentException ( e ) ; } } if ( value == null ) { return null ; } return Jsr310JdbcUtils . convertIfNecessary ( value , zoneId ) ; }'", "label": "'{'"}
{"text": "'private String underscoreName ( String name ) { if ( ! StringUtils . hasLength ( name ) ) { return \"\" ; } StringBuilder result = new StringBuilder ( ) ; result . append ( name . substring ( 0 , 1 ) . toLowerCase ( ) ) ; for ( int i = 1 ; i < name . length ( ) ; i ++ ) { String s = name . substring ( i , i + 1 ) ; String slc = s . toLowerCase ( ) ; if ( ! s . equals ( slc ) ) { result . append ( \"_\" ) . append ( slc ) ; } else { result . append ( s ) ; } } return result . toString ( ) ; }'", "label": "'{ @see org . springframework . jdbc . core . BeanPropertyRowMapper#un } Convert a name in camelCase to an underscored name in lower case . Any upper case letters are converted to lower case with a preceding underscore .'"}
{"text": "'@ Override public T mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Assert . state ( this . mappedClass != null , \"Mapped class was not specified\" ) ; T mappedObject = BeanUtils . instantiate ( this . mappedClass ) ; BeanWrapper bw = PropertyAccessorFactory . forBeanPropertyAccess ( mappedObject ) ; ResultSetMetaData metaData = rs . getMetaData ( ) ; int columnCount = metaData . getColumnCount ( ) ; for ( int index = 1 ; index <= columnCount ; index ++ ) { String column = JdbcUtils . lookupColumnName ( metaData , index ) ; String name = column . replaceAll ( \" \" , \"\" ) . toLowerCase ( ) ; Object value = null ; if ( privateFields . containsKey ( name ) ) { PropertyDescriptor pd = privateFields . get ( name ) ; value = getColumnValue ( rs , index , pd . getPropertyType ( ) ) ; if ( logger . isDebugEnabled ( ) && rowNumber == 0 ) { logger . debug ( \"Mapping column \\'\" + column + \"\\' to property \\'\" + pd . getName ( ) + \"\\' of type \" + pd . getPropertyType ( ) ) ; } // TODO: care about assign null to primitive field. See BeanPropertyRowMapper bw . setPropertyValue ( pd . getName ( ) , value ) ; } else if ( publicFields . containsKey ( name ) ) { Field field = this . publicFields . get ( name ) ; value = getColumnValue ( rs , index , field . getType ( ) ) ; if ( logger . isDebugEnabled ( ) && rowNumber == 0 ) { logger . debug ( \"Mapping column \\'\" + column + \"\\' to property \\'\" + field . getName ( ) + \"\\' of type \" + field . getType ( ) ) ; } try { field . set ( mappedObject , value ) ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( e ) ; } } } return mappedObject ; }'", "label": "'{'"}
{"text": "'protected Object getColumnValue ( ResultSet rs , int index , Class < ? > requiredType ) throws SQLException { return Jsr310JdbcUtils . getResultSetValue ( rs , index , requiredType , zoneId ) ; }'", "label": "'Get the column value .'"}
{"text": "'protected void doSetValue ( PreparedStatement ps , int parameterPosition , Object argValue ) throws SQLException { super . doSetValue ( ps , parameterPosition , Jsr310JdbcUtils . convertIfNecessary ( argValue , zoneId ) ) ; }'", "label": "'{'"}
{"text": "'@ Override public U extractData ( ResultSet rs ) { Iterable < T > iterable = ( ) -> new ResultSetIterator ( sql , rs , mapper , excTranslator ) ; Stream < T > stream = StreamSupport . stream ( iterable . spliterator ( ) , false ) ; return handleStream . apply ( stream ) ; }'", "label": "'Applies { @code handleStream } to the row stream converted from the ResultSet to extract a result .'"}
{"text": "'public File upload ( int pollingInterval ) throws UploadFailureException { RequestHelper requestHelper = client . getRequestHelper ( ) ; URI uploadUrl = Urls . uploadFromUrl ( sourceUrl , client . getPublicKey ( ) , store ) ; String token = requestHelper . executeQuery ( new HttpGet ( uploadUrl ) , false , UploadFromUrlData . class ) . token ; URI statusUrl = Urls . uploadFromUrlStatus ( token ) ; while ( true ) { sleep ( pollingInterval ) ; HttpGet request = new HttpGet ( statusUrl ) ; UploadFromUrlStatusData data = requestHelper . executeQuery ( request , false , UploadFromUrlStatusData . class ) ; if ( data . status . equals ( \"success\" ) ) { return client . getFile ( data . fileId ) ; } else if ( data . status . equals ( \"error\" ) || data . status . equals ( \"failed\" ) ) { throw new UploadFailureException ( ) ; } } }'", "label": "'Synchronously uploads the file to Uploadcare .'"}
{"text": "'public CdnPathBuilder crop ( int width , int height ) { dimensionsGuard ( width , height ) ; sb . append ( \"/-/crop/\" ) . append ( width ) . append ( \"x\" ) . append ( height ) ; return this ; }'", "label": "'Adds top - left - aligned crop .'"}
{"text": "'public CdnPathBuilder cropCenter ( int width , int height ) { dimensionsGuard ( width , height ) ; sb . append ( \"/-/crop/\" ) . append ( width ) . append ( \"x\" ) . append ( height ) . append ( \"/center\" ) ; return this ; }'", "label": "'Adds center - aligned crop .'"}
{"text": "'public CdnPathBuilder cropColor ( int width , int height , Color color ) { dimensionsGuard ( width , height ) ; sb . append ( \"/-/crop/\" ) . append ( width ) . append ( \"x\" ) . append ( height ) . append ( \"/\" ) . append ( colorToHex ( color ) ) ; return this ; }'", "label": "'Adds top - left - aligned crop with a filled background .'"}
{"text": "'public CdnPathBuilder resizeWidth ( int width ) { dimensionGuard ( width ) ; sb . append ( \"/-/resize/\" ) . append ( width ) . append ( \"x\" ) ; return this ; }'", "label": "'Resizes width keeping the aspect ratio .'"}
{"text": "'public CdnPathBuilder resize ( int width , int height ) { dimensionsGuard ( width , height ) ; sb . append ( \"/-/resize/\" ) . append ( width ) . append ( \"x\" ) . append ( height ) ; return this ; }'", "label": "'Resizes width and height'"}
{"text": "'public CdnPathBuilder scaleCrop ( int width , int height ) { dimensionsGuard ( width , height ) ; sb . append ( \"/-/scale_crop/\" ) . append ( width ) . append ( \"x\" ) . append ( height ) ; return this ; }'", "label": "'Scales the image until one of the dimensions fits then crops the bottom or right side .'"}
{"text": "'public CdnPathBuilder scaleCropCenter ( int width , int height ) { dimensionsGuard ( width , height ) ; sb . append ( \"/-/scale_crop/\" ) . append ( width ) . append ( \"x\" ) . append ( height ) . append ( \"/center\" ) ; return this ; }'", "label": "'Scales the image until one of the dimensions fits centers it then crops the rest .'"}
{"text": "'public CdnPathBuilder blur ( int strength ) { if ( strength < 0 || strength > 5000 ) { strength = 10 ; } sb . append ( \"/-/blur/\" ) . append ( strength ) ; return this ; }'", "label": "'Performs Gaussian blur on result image .'"}
{"text": "'public CdnPathBuilder sharp ( int strength ) { if ( strength < 0 || strength > 20 ) { strength = 5 ; } sb . append ( \"/-/sharp/\" ) . append ( strength ) ; return this ; }'", "label": "'Performs sharpening on result image . This can be useful after scaling down .'"}
{"text": "'public CdnPathBuilder preview ( int width , int height ) { dimensionsGuard ( width , height ) ; sb . append ( \"/-/preview/\" ) . append ( width ) . append ( \"x\" ) . append ( height ) ; return this ; }'", "label": "'Reduces an image proportionally in order to fit it into given dimensions .'"}
{"text": "'public Project getProject ( ) { URI url = Urls . apiProject ( ) ; RequestHelper requestHelper = getRequestHelper ( ) ; ProjectData projectData = requestHelper . executeQuery ( new HttpGet ( url ) , true , ProjectData . class ) ; return new Project ( this , projectData ) ; }'", "label": "'Requests project info from the API .'"}
{"text": "'public File getFile ( String fileId ) { URI url = Urls . apiFile ( fileId ) ; RequestHelper requestHelper = getRequestHelper ( ) ; FileData fileData = requestHelper . executeQuery ( new HttpGet ( url ) , true , FileData . class ) ; return new File ( this , fileData ) ; }'", "label": "'Requests file data .'"}
{"text": "'public void deleteFile ( String fileId ) { URI url = Urls . apiFile ( fileId ) ; RequestHelper requestHelper = getRequestHelper ( ) ; requestHelper . executeCommand ( new HttpDelete ( url ) , true ) ; }'", "label": "'Marks a file as deleted .'"}
{"text": "'public void saveFile ( String fileId ) { URI url = Urls . apiFileStorage ( fileId ) ; RequestHelper requestHelper = getRequestHelper ( ) ; requestHelper . executeCommand ( new HttpPost ( url ) , true ) ; }'", "label": "'Marks a file as saved .'"}
{"text": "'public File upload ( ) throws UploadFailureException { URI uploadUrl = Urls . uploadBase ( ) ; HttpPost request = new HttpPost ( uploadUrl ) ; MultipartEntityBuilder entityBuilder = MultipartEntityBuilder . create ( ) ; entityBuilder . addTextBody ( \"UPLOADCARE_PUB_KEY\" , client . getPublicKey ( ) ) ; entityBuilder . addTextBody ( \"UPLOADCARE_STORE\" , store ) ; if ( file != null ) { entityBuilder . addPart ( \"file\" , new FileBody ( file ) ) ; } else if ( stream != null ) { entityBuilder . addBinaryBody ( \"file\" , stream ) ; } else { entityBuilder . addPart ( \"file\" , new ByteArrayBody ( bytes , filename ) ) ; } request . setEntity ( entityBuilder . build ( ) ) ; String fileId = client . getRequestHelper ( ) . executeQuery ( request , false , UploadBaseData . class ) . file ; return client . getFile ( fileId ) ; }'", "label": "'Synchronously uploads the file to Uploadcare .'"}
{"text": "'public HttpResponse executeCommand ( HttpUriRequest request , boolean apiHeaders ) { if ( apiHeaders ) { setApiHeaders ( request ) ; } try { CloseableHttpResponse response = client . getHttpClient ( ) . execute ( request ) ; try { checkResponseStatus ( response ) ; return response ; } finally { response . close ( ) ; } } catch ( IOException e ) { throw new UploadcareNetworkException ( e ) ; } }'", "label": "'Executes the request et the Uploadcare API and return the HTTP Response object .'"}
{"text": "'private void checkResponseStatus ( HttpResponse response ) throws IOException { int statusCode = response . getStatusLine ( ) . getStatusCode ( ) ; if ( statusCode >= 200 && statusCode < 300 ) { return ; } else if ( statusCode == 401 || statusCode == 403 ) { throw new UploadcareAuthenticationException ( streamToString ( response . getEntity ( ) . getContent ( ) ) ) ; } else if ( statusCode == 400 || statusCode == 404 ) { throw new UploadcareInvalidRequestException ( streamToString ( response . getEntity ( ) . getContent ( ) ) ) ; } else { throw new UploadcareApiException ( \"Unknown exception during an API call, response:\" + streamToString ( response . getEntity ( ) . getContent ( ) ) ) ; } }'", "label": "'Verifies that the response status codes are within acceptable boundaries and throws corresponding exceptions otherwise .'"}
{"text": "'private static String streamToString ( InputStream is ) { java . util . Scanner s = new java . util . Scanner ( is , \"UTF-8\" ) . useDelimiter ( \"\\\\\\\\A\" ) ; return s . hasNext ( ) ? s . next ( ) : \"\" ; }'", "label": "'Convert an InputStream into a String object . Method taken from http : // stackoverflow . com / a / 5445161 / 521535'"}
{"text": "'public static URI uploadFromUrl ( String sourceUrl , String pubKey , String store ) { URIBuilder builder = new URIBuilder ( URI . create ( UPLOAD_BASE ) ) ; builder . setPath ( \"/from_url/\" ) . setParameter ( \"source_url\" , sourceUrl ) . setParameter ( \"pub_key\" , pubKey ) . setParameter ( \"store\" , store ) ; return trustedBuild ( builder ) ; }'", "label": "'Creates a URL for URL upload .'"}
{"text": "'public static URI uploadFromUrlStatus ( String token ) { URIBuilder builder = new URIBuilder ( URI . create ( UPLOAD_BASE ) ) ; builder . setPath ( \"/from_url/status/\" ) . setParameter ( \"token\" , token ) ; return trustedBuild ( builder ) ; }'", "label": "'Creates a URL for URL upload status ( e . g . progress ) .'"}
{"text": "'@ Override public void inject ( Object target ) { checkState ( mObjectGraph != null , \"object graph must be assigned prior to calling inject\" ) ; mObjectGraph . inject ( target ) ; }'", "label": "'Injects a target object using this ActionBarActivity s object graph .'"}
{"text": "'@ Override protected void onCreate ( android . os . Bundle savedInstanceState ) { // expand the application graph with the activity-specific module(s) ObjectGraph appGraph = ( ( Injector ) getApplication ( ) ) . getObjectGraph ( ) ; List < Object > activityModules = getModules ( ) ; mObjectGraph = appGraph . plus ( activityModules . toArray ( ) ) ; // now we can inject ourselves inject ( this ) ; // note: we do the graph setup and injection before calling super.onCreate so that InjectingFragments // associated with this InjectingActivity can do their graph setup and injection in their // onAttach override. super . onCreate ( savedInstanceState ) ; }'", "label": "'Creates an object graph for this ActionBarActivity by extending the application - scope object graph with the modules returned by {'"}
{"text": "'protected List < Object > getModules ( ) { List < Object > result = new ArrayList < Object > ( ) ; result . add ( new InjectingActivityModule ( this , this ) ) ; return result ; }'", "label": "'Returns the list of dagger modules to be included in this ActionBarActivity s object graph . Subclasses that override this method should add to the list returned by super . getModules () .'"}
{"text": "'protected List < Object > getModules ( ) { List < Object > result = new ArrayList < Object > ( ) ; result . add ( new InjectingBroadcastReceiverModule ( mContext , this , this ) ) ; return result ; }'", "label": "'Returns the list of dagger modules to be included in this BroadcastReceiver s object graph . Subclasses that override this method should add to the list returned by super . getModules () .'"}
{"text": "'@ Override public void onCreate ( ) { super . onCreate ( ) ; // extend the application-scope object graph with the modules for this service mObjectGraph = ( ( Injector ) getApplication ( ) ) . getObjectGraph ( ) . plus ( getModules ( ) . toArray ( ) ) ; // then inject ourselves mObjectGraph . inject ( this ) ; }'", "label": "'Creates an object graph for this Service by extending the application - scope object graph with the modules returned by {'"}
{"text": "'@ Override protected void onCreate ( android . os . Bundle savedInstanceState ) { // extend the application-scope object graph with the modules for this activity mObjectGraph = ( ( Injector ) getApplication ( ) ) . getObjectGraph ( ) . plus ( getModules ( ) . toArray ( ) ) ; // now we can inject ourselves inject ( this ) ; // note: we do the graph setup and injection before calling super.onCreate so that InjectingFragments // associated with this InjectingActivity can do their graph setup and injection in their // onAttach override. super . onCreate ( savedInstanceState ) ; }'", "label": "'Creates an object graph for this Activity by extending the application - scope object graph with the modules returned by {'"}
{"text": "'protected List < Object > getModules ( ) { List < Object > result = new ArrayList < Object > ( ) ; result . add ( new InjectingFragmentModule ( this , this ) ) ; return result ; }'", "label": "'Returns the list of dagger modules to be included in this ListFragment s object graph . Subclasses that override this method should add to the list returned by super . getModules () .'"}
{"text": "\"@ Override public void onCreate ( ) { super . onCreate ( ) ; // initialize object graph and inject this mObjectGraph = ObjectGraph . create ( getModules ( ) . toArray ( ) ) ; mObjectGraph . inject ( this ) ; // debug mode stuff if ( ( getApplicationInfo ( ) . flags & ApplicationInfo . FLAG_DEBUGGABLE ) == 1 ) { mObjectGraph . validate ( ) ; // validate dagger's object graph } }\"", "label": "'Creates an object graph for this Application using the modules returned by {'"}
{"text": "'protected List < Object > getModules ( ) { List < Object > result = new ArrayList < Object > ( ) ; result . addAll ( mSeedModules ) ; result . add ( new InjectingApplicationModule ( this , this ) ) ; return result ; }'", "label": "'Returns the list of dagger modules to be included in this Application s object graph . Subclasses that override this method should add to the list returned by super . getModules () .'"}
{"text": "\"@ Override public void onAttach ( Activity activity ) { super . onAttach ( activity ) ; // expand the activity graph with the fragment-specific module(s) ObjectGraph appGraph = ( ( Injector ) activity ) . getObjectGraph ( ) ; List < Object > fragmentModules = getModules ( ) ; mObjectGraph = appGraph . plus ( fragmentModules . toArray ( ) ) ; // make sure it's the first time through; we don't want to re-inject a retained fragment that is going // through a detach/attach sequence. if ( mFirstAttach ) { inject ( this ) ; mFirstAttach = false ; } }\"", "label": "'Creates an object graph for this Fragment by extending the hosting Activity s object graph with the modules returned by {'"}
{"text": "'@ Override public void onReceive ( Context context , Intent intent ) { mContext = context ; // extend the application-scope object graph with the modules for this AppWidgetProvider mObjectGraph = ( ( Injector ) context . getApplicationContext ( ) ) . getObjectGraph ( ) . plus ( getModules ( ) . toArray ( ) ) ; // then inject ourselves mObjectGraph . inject ( this ) ; super . onReceive ( context , intent ) ; }'", "label": "'Creates an object graph for this AppWidgetProvider by extending the application - scope object graph with the modules returned by {'"}
{"text": "'protected List < Object > getModules ( ) { List < Object > result = new ArrayList < Object > ( ) ; result . add ( new InjectingAppWidgetProviderModule ( mContext , this , this ) ) ; return result ; }'", "label": "'Returns the list of dagger modules to be included in this AppWidgetProvider s object graph . Subclasses that override this method should add to the list returned by super . getModules () .'"}
{"text": "'public static Builder newBuilder ( Context context , int themeResId ) { if ( Build . VERSION . SDK_INT >= 21 ) { return new APi21Builder ( context , themeResId ) ; } return new Api20Builder ( context , themeResId ) ; }'", "label": "'Create new Builder .'"}
{"text": "'private void onCommonClick ( ) { AlertDialog . build ( this ) . setTitle ( \"\u6807\u9898\")  . setMessage ( \"\u63d0\u793a\u4fe1\u606f\")  . setNeutralButton ( \"\u5ffd\u7565\", (d i l og, wh i h) ->     Toast . makeText ( MainActivity . this , \"\u70b9\u51fb\u4e86\u5ffd\u7565\", Toast.LE N TH_SH O RT).show();       } ) . setNegativeButton ( \"\u53d6\u6d88\", (d i l og, wh i h) ->     Toast . makeText ( MainActivity . this , \"\u70b9\u51fb\u4e86\u53d6\u6d88\", Toast.LE N TH_SH O RT).show();       } ) . setPositiveButton ( \"\u597d\u7684\", (d i l og, wh i h) ->     Toast . makeText ( MainActivity . this , \"\u70b9\u51fb\u4e86\u786e\u5b9a\", Toast.LE N TH_SH O RT).show();       } ) . show ( ) ; //  Button\u88ab\u70b9\u51fb\u540e\uff0c\u4e0d\u8c03\u7528dialog.dismiss()\uff0c\u56e0\u4e3aAlertDialog\u4f1a\u81ea\u52a8\u8c03\u7528\u3002 }'", "label": "'\u663e\u793a\u6b63\u5e38\u7528\u6cd5\u7684\u6309\u94ae\u3002'"}
{"text": "'private void onSpecialClick ( ) { AlertDialog alertDialog = AlertDialog . build ( this ) . setTitle ( \"\u6807\u9898\")  . setMessage ( \"\u63d0\u793a\u4fe1\u606f\")  // Listener \u5199null\uff0cButton\u88ab\u70b9\u51fb\u65f6\uff0cAlertdialog\u5c31\u4e0d\u4f1a\u81ea\u52a8dismiss\u4e86\u3002 . setNeutralButton ( \"\u5ffd\u7565\", nu l )  . setNegativeButton ( \"\u53d6\u6d88\", nu l )  . setPositiveButton ( \"\u597d\u7684\", nu l )  . show ( ) ; // \u8fd9\u91cc\u662f\u76f4\u63a5show()\uff0c\u4e0d\u662fcreate()\uff0c\u5426\u5219\u4e0d\u80fdgetButton()\u3002 // \u83b7\u53d6\u4e2d\u6027\u6309\u94ae\u3002 Button btnNeutral = alertDialog . getButton ( DialogInterface . BUTTON_NEUTRAL ) ; btnNeutral . setOnClickListener ( v -> { Toast . makeText ( MainActivity . this , \"\u6211\u4eec\u62e6\u622a\u4e86\u5ffd\u7565\u70b9\u51fb\u5173\u95eddialog\u64cd\u4f5c\",  Toast . LENGTH_SHORT ) . show ( ) ; } ) ; // \u83b7\u53d6\u53d6\u6d88\u6309\u94ae\u3002 Button btnNegative = alertDialog . getButton ( DialogInterface . BUTTON_NEGATIVE ) ; btnNegative . setOnClickListener ( v -> { alertDialog . dismiss ( ) ; // \u62e6\u622a\u4e86btn\u7684\u9ed8\u8ba4\u64cd\u4f5c\uff0c\u9700\u8981\u8c03\u7528dialog.dismiss()\u3002 Toast . makeText ( MainActivity . this , \"\u70b9\u51fb\u4e86\u53d6\u6d88\",  Toast . LENGTH_SHORT ) . show ( ) ; } ) ; // \u83b7\u53d6\u786e\u5b9a\u6309\u94ae\u3002 Button btnPositive = alertDialog . getButton ( DialogInterface . BUTTON_POSITIVE ) ; btnPositive . setOnClickListener ( v -> { alertDialog . dismiss ( ) ; // \u62e6\u622a\u4e86btn\u7684\u9ed8\u8ba4\u64cd\u4f5c\uff0c\u9700\u8981\u8c03\u7528dialog.dismiss()\u3002 Toast . makeText ( MainActivity . this , \"\u70b9\u51fb\u4e86\u786e\u5b9a\",  Toast . LENGTH_SHORT ) . show ( ) ; } ) ; }'", "label": "'\u7279\u6b8a\u7528\u6cd5\u88ab\u70b9\u51fb\u3002'"}
{"text": "'private void generateCacheHitReturn ( final CodeBlock block ) { generateGetFromCache ( block ) ; final LabelNode cacheMiss = new LabelNode ( ) ; block . dup ( ) . ifnull ( cacheMiss ) . areturn ( ) . label ( cacheMiss ) . pop ( ) ; }'", "label": "'if ( <cache > ! = null ) return <cache > ;'"}
{"text": "'private void generateStoreNewProxyMatcher ( final CodeBlock block ) { block . newobj ( CodegenUtils . p ( ProxyMatcher . class ) ) . dup ( ) . invokespecial ( CodegenUtils . p ( ProxyMatcher . class ) , \"<init>\" , CodegenUtils . sig ( void . class ) ) ; generateStoreInCache ( block ) ; }'", "label": "'<cache > = new ProxyMatcher () ;'"}
{"text": "'private static void generateArmProxyMatcher ( final CodeBlock block ) { block . dup_x1 ( ) . checkcast ( CodegenUtils . p ( Matcher . class ) ) . invokevirtual ( CodegenUtils . p ( ProxyMatcher . class ) , \"arm\" , CodegenUtils . sig ( void . class , Matcher . class ) ) ; }'", "label": "'<proxyMatcher > . arm ( <rule > )'"}
{"text": "'@ Nullable public Class < ? > findClass ( final String className ) { Objects . requireNonNull ( className ) ; try { return ( Class < ? > ) findClass . invoke ( loader , className ) ; } catch ( IllegalAccessException | InvocationTargetException e ) { throw new ParserTransformException ( \"unable to find class by name (\" + className + \\' \\' , e ) ; } }'", "label": "'Returns the class with the given name if it has already been loaded by the given class loader'"}
{"text": "'public Class < ? > loadClass ( final String className , final byte [ ] bytecode ) { Objects . requireNonNull ( className ) ; Objects . requireNonNull ( bytecode ) ; try { return ( Class < ? > ) loadClass . invoke ( loader , className , bytecode , 0 , bytecode . length ) ; } catch ( InvocationTargetException | IllegalAccessException e ) { throw new ParserTransformException ( \"unable to load class by name\" , e ) ; } }'", "label": "'Loads the class defined with the given name and bytecode using the given class loader'"}
{"text": "'private int doSearch ( final CharBuffer buffer , final int matchedLength , final int currentLength , final boolean ignoreCase ) { /*\\n         * Try and see if there is a possible match here; there is if \"fullword\"\\n         * is true, in this case the next \"matchedLength\" argument to a possible\\n         * child call will be the current length.\\n         */ final int nextLength = fullWord ? currentLength : matchedLength ; /*\\n         * If there is nothing left in the buffer, we have a match.\\n         */ if ( ! buffer . hasRemaining ( ) ) return nextLength ; /*\\n         * OK, there is at least one character remaining, so pick it up and see\\n         * whether it is in the list of our children...\\n         */ char c = buffer . get ( ) ; int index = Arrays . binarySearch ( nextChars , c ) ; if ( index < 0 && ignoreCase ) { final boolean isUpper = Character . isUpperCase ( c ) ; final boolean isLower = Character . isLowerCase ( c ) ; if ( isUpper != isLower ) { c = isUpper ? Character . toLowerCase ( c ) : Character . toUpperCase ( c ) ; index = Arrays . binarySearch ( nextChars , c ) ; } } /*\\n         * If not, we return the last good match; if yes, we call this same\\n         * method on the matching child node with the (possibly new) matched\\n         * length as an argument and a depth increased by 1.\\n         */ if ( index < 0 ) return nextLength ; return nextNodes [ index ] . doSearch ( buffer , nextLength , currentLength + 1 , ignoreCase ) ; }'", "label": "'Core search method'"}
{"text": "'public TrieBuilder addWord ( @ Nonnull final String word ) { Objects . requireNonNull ( word ) ; final int length = word . length ( ) ; if ( length == 0 ) throw new IllegalArgumentException ( \"a trie cannot have empty \" + \"strings (use EMPTY instead)\" ) ; nrWords ++ ; maxLength = Math . max ( maxLength , length ) ; nodeBuilder . addWord ( word ) ; return this ; }'", "label": "'Add one word to the trie'"}
{"text": "\"private static void runMethodTransformers ( final ParserClassNode classNode ) throws Exception { // TODO: comment above may be right, but it's still dangerous // iterate through all rule methods // since the ruleMethods map on the classnode is a treemap we get the // methods sorted by name which puts all super methods first (since they // are prefixed with one or more '$') for ( final RuleMethod ruleMethod : classNode . getRuleMethods ( ) . values ( ) ) { if ( ruleMethod . hasDontExtend ( ) ) continue ; for ( final RuleMethodProcessor methodProcessor : PROCESSORS ) if ( methodProcessor . appliesTo ( classNode , ruleMethod ) ) methodProcessor . process ( classNode , ruleMethod ) ; } for ( final RuleMethod ruleMethod : classNode . getRuleMethods ( ) . values ( ) ) if ( ! ruleMethod . isGenerationSkipped ( ) ) classNode . methods . add ( ruleMethod ) ; }\"", "label": "'TODO : poor exception handling again'"}
{"text": "'public boolean append ( final char c ) { if ( get ( ) == null ) return set ( new StringBuilder ( ) . append ( c ) ) ; get ( ) . append ( c ) ; return true ; }'", "label": "'Appends the given char . If this instance is currently uninitialized the given char is used for initialization .'"}
{"text": "'public final T getAndSet ( final T value ) { final T ret = this . value ; this . value = value ; return ret ; }'", "label": "'Replaces this references value with the given one .'"}
{"text": "'public static Class < ? > getClassForType ( final Type type ) { Objects . requireNonNull ( type , \"type\" ) ; switch ( type . getSort ( ) ) { case Type . BOOLEAN : return boolean . class ; case Type . BYTE : return byte . class ; case Type . CHAR : return char . class ; case Type . DOUBLE : return double . class ; case Type . FLOAT : return float . class ; case Type . INT : return int . class ; case Type . LONG : return long . class ; case Type . SHORT : return short . class ; case Type . VOID : return void . class ; case Type . OBJECT : case Type . ARRAY : return CACHE . loadClass ( type . getInternalName ( ) ) ; //return getClassForInternalName(type.getInternalName()); } throw new IllegalStateException ( ) ; // should be unreachable }'", "label": "'Get the class equivalent to an ASM { @link Type }'"}
{"text": "'public static boolean isAssignableTo ( final String classInternalName , final Class < ? > type ) { Objects . requireNonNull ( classInternalName , \"classInternalName\" ) ; Objects . requireNonNull ( type , \"type\" ) ; final Class < ? > c = CACHE . loadClass ( classInternalName ) ; //final Class<?> c = getClassForInternalName(classInternalName); return type . isAssignableFrom ( c ) ; }'", "label": "'Determines whether the class with the given descriptor is assignable to the given type .'"}
{"text": "'public static byte [ ] getByteCode ( final Class < ? > parserClass ) throws Exception { final ParserClassNode node = extendParserClass ( parserClass ) ; return node . getClassCode ( ) ; }'", "label": "'TODO : poor exception specification'"}
{"text": "\"private void copyParseInfo ( final FileSystem zipfs ) throws IOException { final Path path = zipfs . getPath ( INFO_PATH ) ; try ( final BufferedWriter writer = Files . newBufferedWriter ( path , UTF_8 ) ; ) { sb . setLength ( 0 ) ; sb . append ( startTime ) . append ( ' ' ) . append ( prematchIndices . size ( ) ) . append ( ' ' ) . append ( nextMatcherId ) . append ( ' ' ) . append ( nrLines ) . append ( ' ' ) . append ( nrChars ) . append ( ' ' ) . append ( nrCodePoints ) . append ( ' ' ) . append ( nextNodeId ) . append ( ' ' ) ; writer . append ( sb ) ; writer . flush ( ) ; } }\"", "label": "'MUST be called after copyInputText!'"}
{"text": "'public static void hash ( @ Nonnull final InstructionGroup group , @ Nonnull final String className ) { final InstructionGroupHasher groupHasher = new InstructionGroupHasher ( group , className ) ; final String name = groupHasher . hashAndGetName ( ) ; group . setName ( name ) ; }'", "label": "'Generate a hash of the group use it to name it'"}
{"text": "'private String hashAndGetName ( ) { group . getInstructions ( ) . accept ( this ) ; for ( final FieldNode node : group . getFields ( ) ) hasher . putObject ( node , FieldNodeFunnel . INSTANCE ) ; final byte [ ] hash = new byte [ 10 ] ; hasher . hash ( ) . writeBytesTo ( hash , 0 , 10 ) ; final String prefix = group . getRoot ( ) . isActionRoot ( ) ? \"Action$\" : \"VarInit$\" ; return prefix + BASE_ENCODING . encode ( hash ) ; }'", "label": "'TODO : not very nice : /'"}
{"text": "'@ Override public Rule label ( final String label ) { return new VarFramingMatcher ( inner . label ( label ) , variables ) ; }'", "label": "'Rule'"}
{"text": "'@ Cached @ DontLabel public Rule ignoreCase ( final char c ) { return Character . isLowerCase ( c ) == Character . isUpperCase ( c ) ? ch ( c ) : new CharIgnoreCaseMatcher ( c ) ; }'", "label": "'Match a given character in a case - insensitive manner'"}
{"text": "'@ Cached @ DontLabel public Rule unicodeChar ( final int codePoint ) { if ( ! Character . isValidCodePoint ( codePoint ) ) throw new InvalidGrammarException ( \"invalid code point \" + codePoint ) ; return new CodePointMatcher ( codePoint ) ; }'", "label": "'Match one Unicode character'"}
{"text": "'@ Cached @ DontLabel public Rule unicodeRange ( final int low , final int high ) { if ( ! Character . isValidCodePoint ( low ) ) throw new InvalidGrammarException ( \"invalid code point \" + low ) ; if ( ! Character . isValidCodePoint ( high ) ) throw new InvalidGrammarException ( \"invalid code point \" + high ) ; if ( low > high ) throw new InvalidGrammarException ( \"invalid code point range: \" + low + \" > \" + high ) ; return low == high ? new CodePointMatcher ( low ) : new CodePointRangeMatcher ( low , high ) ; }'", "label": "'Match a Unicode character range'"}
{"text": "'@ Cached @ DontLabel public Rule charRange ( final char cLow , final char cHigh ) { return cLow == cHigh ? ch ( cLow ) : new CharRangeMatcher ( cLow , cHigh ) ; }'", "label": "'Match an inclusive range of { @code char } s'"}
{"text": "'@ DontLabel public Rule anyOf ( final String characters ) { Objects . requireNonNull ( characters ) ; // TODO: see in this Characters class whether it is possible to wrap return anyOf ( characters . toCharArray ( ) ) ; }'", "label": "'Match any of the characters in the given string'"}
{"text": "'@ DontLabel public Rule anyOf ( final char [ ] characters ) { Objects . requireNonNull ( characters ) ; switch ( characters . length ) { case 0 : throw new IllegalArgumentException ( \"empty character array\" ) ; case 1 : return ch ( characters [ 0 ] ) ; default : return anyOf ( Characters . of ( characters ) ) ; } }'", "label": "'Match any character in the given { @code char } array'"}
{"text": "'@ Cached @ DontLabel public Rule anyOf ( final Characters characters ) { Objects . requireNonNull ( characters ) ; if ( ! characters . isSubtractive ( ) && characters . getChars ( ) . length == 1 ) return ch ( characters . getChars ( ) [ 0 ] ) ; if ( characters . equals ( Characters . NONE ) ) return NOTHING ; return new AnyOfMatcher ( characters ) ; }'", "label": "'Match any given character among a set of characters'"}
{"text": "'@ DontLabel public Rule noneOf ( final String characters ) { Objects . requireNonNull ( characters ) ; return noneOf ( characters . toCharArray ( ) ) ; }'", "label": "'Match any characters <em > except< / em > the ones contained in the strings'"}
{"text": "'@ DontLabel public Rule noneOf ( final char [ ] characters ) { Objects . requireNonNull ( characters ) ; Preconditions . checkArgument ( characters . length > 0 ) ; return anyOf ( Characters . allBut ( characters ) ) ; }'", "label": "'Match all characters <em > except< / em > the ones in the { @code char } array given as an argument'"}
{"text": "'@ DontLabel public Rule string ( final String string ) { Objects . requireNonNull ( string ) ; return string ( string . toCharArray ( ) ) ; }'", "label": "'Match a string literal'"}
{"text": "'@ Cached @ DontLabel public Rule string ( final char ... characters ) { if ( characters . length == 1 ) return ch ( characters [ 0 ] ) ; // optimize one-char strings return new StringMatcher ( new String ( characters ) ) ; }'", "label": "'Match a given set of characters as a string literal'"}
{"text": "'@ DontLabel public Rule ignoreCase ( final String string ) { Objects . requireNonNull ( string ) ; return ignoreCase ( string . toCharArray ( ) ) ; }'", "label": "'Match a string literal in a case insensitive manner'"}
{"text": "'@ Cached @ DontLabel public Rule ignoreCase ( final char ... characters ) { if ( characters . length == 1 ) return ignoreCase ( characters [ 0 ] ) ; // optimize one-char strings return new StringIgnoreCaseMatcher ( new String ( characters ) ) ; }'", "label": "'Match a sequence of characters as a string literal ( case insensitive )'"}
{"text": "'public Rule longestString ( final String first , final String second , final String ... others ) { return trie ( first , second , others ) ; }'", "label": "'Match the longest possible string among a series of strings ( case sensitive )'"}
{"text": "'public Rule longestStringIgnoreCase ( final String first , final String second , final String ... others ) { return trieIgnoreCase ( first , second , others ) ; }'", "label": "'Match the longest possible string among a series of strings ( case insensitive )'"}
{"text": "'public Rule trie ( final String first , final String second , final String ... others ) { final List < String > words = ImmutableList . < String > builder ( ) . add ( first ) . add ( second ) . add ( others ) . build ( ) ; return trie ( words ) ; }'", "label": "'Match one string among many using a <a href = http : // en . wikipedia . org / wiki / Trie target = _blank > trie< / a >'"}
{"text": "'@ Cached public Rule trieIgnoreCase ( final Collection < String > strings ) { final List < String > list = ImmutableList . copyOf ( strings ) ; final TrieBuilder builder = Trie . newBuilder ( ) ; list . forEach ( builder :: addWord ) ; return new CaseInsensitiveTrieMatcher ( builder . build ( ) ) ; }'", "label": "'Match one string among many using a <a href = http : // en . wikipedia . org / wiki / Trie target = _blank > trie< / a > case insensitive version'"}
{"text": "'@ DontLabel public Rule firstOf ( final Object rule , final Object rule2 , final Object ... moreRules ) { Objects . requireNonNull ( moreRules ) ; final Object [ ] rules = ImmutableList . builder ( ) . add ( rule ) . add ( rule2 ) . add ( moreRules ) . build ( ) . toArray ( ) ; return firstOf ( rules ) ; }'", "label": "'Match the first rule of a series of rules'"}
{"text": "'@ Cached @ DontLabel public Rule firstOf ( final Object [ ] rules ) { Objects . requireNonNull ( rules , \"rules\" ) ; if ( rules . length == 1 ) return toRule ( rules [ 0 ] ) ; final Collection < String > strings = new ArrayList <> ( ) ; for ( final Object object : rules ) { if ( ! ( object instanceof String ) ) return new FirstOfMatcher ( toRules ( rules ) ) ; strings . add ( ( String ) object ) ; } return trie ( strings ) ; }'", "label": "'Match the first rule of a series of rules'"}
{"text": "'@ Cached @ DontLabel public Rule optional ( final Object rule ) { Objects . requireNonNull ( rule ) ; return new OptionalMatcher ( toRule ( rule ) ) ; }'", "label": "'Try and match a rule zero or one time'"}
{"text": "'@ DontLabel public Rule optional ( final Object rule , final Object rule2 , final Object ... moreRules ) { Objects . requireNonNull ( moreRules ) ; return optional ( sequence ( rule , rule2 , moreRules ) ) ; }'", "label": "'Try and match a given set of rules once'"}
{"text": "'@ DontLabel public Rule sequence ( final Object rule , final Object rule2 , final Object ... moreRules ) { final Object [ ] rules = ImmutableList . builder ( ) . add ( rule ) . add ( rule2 ) . add ( moreRules ) . build ( ) . toArray ( ) ; return sequence ( rules ) ; }'", "label": "'Match a given set of rules exactly once'"}
{"text": "'@ Cached @ DontLabel public Rule sequence ( final Object [ ] rules ) { Objects . requireNonNull ( rules ) ; return rules . length == 1 ? toRule ( rules [ 0 ] ) : new SequenceMatcher ( toRules ( rules ) ) ; }'", "label": "'Match a given set of rules exactly once'"}
{"text": "'@ DontLabel public final JoinMatcherBootstrap < V , BaseParser < V > > join ( final Object rule ) { final Rule matcher = toRule ( rule ) ; return new JoinMatcherBootstrap <> ( this , matcher ) ; }'", "label": "'Kickstart a { @code join } rule'"}
{"text": "'@ DontLabel public final JoinMatcherBootstrap < V , BaseParser < V > > join ( final Object rule , final Object rule2 , final Object ... moreRules ) { Objects . requireNonNull ( moreRules ) ; return join ( sequence ( rule , rule2 , moreRules ) ) ; }'", "label": "'Kickstart a { @code join } rule'"}
{"text": "'@ DontLabel public final RepeatMatcherBuilder < V > repeat ( final Object rule , final Object rule2 , final Object ... moreRules ) { Objects . requireNonNull ( moreRules ) ; return repeat ( sequence ( rule , rule2 , moreRules ) ) ; }'", "label": "'Kickstart a repeat rule'"}
{"text": "'@ DontLabel public Rule zeroOrMore ( final Object rule , final Object rule2 , final Object ... moreRules ) { return repeat ( rule , rule2 , moreRules ) . min ( 0 ) ; }'", "label": "'Try and match a set of rules zero or more times'"}
{"text": "'@ DontExtend protected Rule fromStringLiteral ( final String string ) { Objects . requireNonNull ( string ) ; return fromCharArray ( string . toCharArray ( ) ) ; }'", "label": "'Convert a string literal to a parser rule'"}
{"text": "'@ DontExtend public Rule [ ] toRules ( final Object ... objects ) { return Arrays . stream ( objects ) . map ( this :: toRule ) . toArray ( Rule [ ] :: new ) ; }'", "label": "'Convert the given object array to an array of rules'"}
{"text": "'@ DontExtend public Rule toRule ( final Object obj ) { Objects . requireNonNull ( obj ) ; if ( obj instanceof Rule ) return ( Rule ) obj ; if ( obj instanceof Character ) return fromCharLiteral ( ( Character ) obj ) ; if ( obj instanceof String ) return fromStringLiteral ( ( String ) obj ) ; if ( obj instanceof char [ ] ) return fromCharArray ( ( char [ ] ) obj ) ; if ( obj instanceof Action ) { final Action < ? > action = ( Action < ? > ) obj ; return new ActionMatcher ( action ) ; } final String errmsg = obj instanceof Boolean ? \"unwrapped Boolean value in rule (wrap it with ACTION())\" : \"\\'\" + obj + \"\\' cannot be automatically converted to a rule\" ; throw new InvalidGrammarException ( errmsg ) ; }'", "label": "'Converts the given object to a rule'"}
{"text": "'public boolean push ( final int down , final V value ) { check ( ) ; context . getValueStack ( ) . push ( down , value ) ; return true ; }'", "label": "'Inserts the given value a given number of elements below the current top of the value stack'"}
{"text": "'public < E extends V > E popAs ( @ Nonnull final Class < E > c ) { return c . cast ( pop ( ) ) ; }'", "label": "'Removes the value at the top of the value stack and casts it before returning it'"}
{"text": "'public < E extends V > E popAs ( final Class < E > c , final int down ) { return c . cast ( pop ( down ) ) ; }'", "label": "'Removes the value the given number of elements below the top of the value stack and casts it before returning it'"}
{"text": "'public < E extends V > E peekAs ( final Class < E > c ) { return c . cast ( peek ( ) ) ; }'", "label": "'Returns and casts the value at the top of the value stack without removing it'"}
{"text": "'public boolean poke ( final int down , final V value ) { check ( ) ; context . getValueStack ( ) . poke ( down , value ) ; return true ; }'", "label": "'Replaces the element the given number of elements below the current top of the value stack'"}
{"text": "'@ Override public < T > boolean match ( final MatcherContext < T > context ) { final Matcher matcher = context . getMatcher ( ) ; final PreMatchEvent < T > preMatchEvent = new PreMatchEvent <> ( context ) ; bus . post ( preMatchEvent ) ; if ( throwable != null ) throw new GrappaException ( \"parsing listener error (before match)\" , throwable ) ; // FIXME: is there any case at all where context.getMatcher() is null? @ SuppressWarnings ( \"ConstantConditions\" ) final boolean match = matcher . match ( context ) ; final MatchContextEvent < T > postMatchEvent = match ? new MatchSuccessEvent <> ( context ) : new MatchFailureEvent <> ( context ) ; bus . post ( postMatchEvent ) ; if ( throwable != null ) throw new GrappaException ( \"parsing listener error (after match)\" , throwable ) ; return match ; }'", "label": "'Internal method . DO NOT USE!'"}
{"text": "'public boolean overlapsWith ( final IndexRange other ) { Objects . requireNonNull ( other , \"other\" ) ; return end > other . start && other . end > start ; }'", "label": "'Determines whether this range overlaps with the given other one .'"}
{"text": "'public boolean touches ( final IndexRange other ) { Objects . requireNonNull ( other , \"other\" ) ; return other . end == start || end == other . start ; }'", "label": "'Determines whether this range immediated follows or precedes the given other one .'"}
{"text": "'public IndexRange mergedWith ( final IndexRange other ) { Objects . requireNonNull ( other , \"other\" ) ; return new IndexRange ( Math . min ( start , other . start ) , Math . max ( end , other . end ) ) ; }'", "label": "'Created a new IndexRange that spans all characters between the smallest and the highest index of the two ranges .'"}
{"text": "\"@ Override public final < V > boolean match ( final MatcherContext < V > context ) { /*\\n         * TODO! Check logic\\n         *\\n         * At this point, if we have enough cycles, we can't determined whether\\n         * our joining rule would match empty... Which is illegal.\\n         */ int cycles = 0 ; if ( ! joined . getSubContext ( context ) . runMatcher ( ) ) return enoughCycles ( cycles ) ; cycles ++ ; Object snapshot = context . getValueStack ( ) . takeSnapshot ( ) ; int beforeCycle = context . getCurrentIndex ( ) ; while ( runAgain ( cycles ) && matchCycle ( context , beforeCycle ) ) { beforeCycle = context . getCurrentIndex ( ) ; snapshot = context . getValueStack ( ) . takeSnapshot ( ) ; cycles ++ ; } context . getValueStack ( ) . restoreSnapshot ( snapshot ) ; context . setCurrentIndex ( beforeCycle ) ; return enoughCycles ( cycles ) ; }\"", "label": "'Tries a match on the given MatcherContext .'"}
{"text": "'public static < P extends BaseParser < V > , V > P createParser ( @ Nonnull final Class < P > parserClass , final Object ... constructorArgs ) { Objects . requireNonNull ( parserClass , \"parserClass\" ) ; try { final Class < ? > extendedClass = ParserTransformer . transformParser ( parserClass ) ; final Constructor < ? > constructor = findConstructor ( extendedClass , constructorArgs ) ; @ SuppressWarnings ( \"unchecked\" ) final P ret = ( P ) constructor . newInstance ( constructorArgs ) ; return ret ; } catch ( Exception e ) { // TODO: catch better than Exception throw new RuntimeException ( \"Error creating extended parser class: \" + e . getMessage ( ) , e ) ; } }'", "label": "'<p > Creates a parser object whose rule creation methods can then be used with one of the { @link ParseRunner } implementations . < / p > <p > Since parboiled needs to extend your parser with certain extra logic ( e . g . to prevent infinite recursions in recursive rule definitions ) you cannot create your parser object yourself but have to go through this method . Also your parser class has to be derived from { @link BaseParser } . If you want to use a non - default constructor you can provide its arguments to this method . Make sure your non - default constructor does not use primitive type parameters ( like int ) but rather their boxed counterparts ( like Integer ) otherwise the constructor will not be found . < / p > <p > Performing the rule analysis and extending the parser class is an expensive process ( time - wise ) and can take up to several hundred milliseconds for large grammars . However this cost is only incurred once per parser class and class loader . Subsequent calls to this method are therefore fast once the initial extension has been performed . < / p >'"}
{"text": "'public static < P extends BaseParser < V > , V > byte [ ] getByteCode ( final Class < P > parserClass ) { try { return ParserTransformer . getByteCode ( parserClass ) ; } catch ( Exception e ) { throw new RuntimeException ( \"failed to generate byte code\" , e ) ; } }'", "label": "'Generate the byte code of a transformed parser class'"}
{"text": "'private void doAddWord ( final CharBuffer buffer ) { if ( ! buffer . hasRemaining ( ) ) { fullWord = true ; return ; } final char c = buffer . get ( ) ; TrieNodeBuilder builder = subnodes . get ( c ) ; if ( builder == null ) { builder = new TrieNodeBuilder ( ) ; subnodes . put ( c , builder ) ; } builder . doAddWord ( buffer ) ; }'", "label": "'Add a word'"}
{"text": "'public static Matcher unwrap ( final Matcher matcher ) { if ( matcher instanceof ProxyMatcher ) { final ProxyMatcher proxyMatcher = ( ProxyMatcher ) matcher ; if ( proxyMatcher . dirty ) proxyMatcher . apply ( ) ; return proxyMatcher . target == null ? proxyMatcher : proxyMatcher . target ; } return matcher ; }'", "label": "'Retrieves the innermost Matcher that is not a ProxyMatcher .'"}
{"text": "'@ Override public < V > boolean match ( final MatcherContext < V > context ) { /*\\n         * Since the trie knows about the length of its possible longest match,\\n         * extract that many characters from the buffer. Remind that .extract()\\n         * will adjust illegal indices automatically.\\n         */ final int maxLength = trie . getMaxLength ( ) ; final int index = context . getCurrentIndex ( ) ; final String input = context . getInputBuffer ( ) . extract ( index , index + maxLength ) ; /*\\n         * We now just have to trie and search... (pun intended)\\n         */ final int ret = trie . search ( input , false ) ; if ( ret == - 1 ) return false ; /*\\n         * and since the result, when positive, is the length of the match,\\n         * advance the index in the buffer by that many positions.\\n         */ context . advanceIndex ( ret ) ; return true ; }'", "label": "'Tries a match on the given MatcherContext .'"}
{"text": "'public final boolean register ( @ Nonnull final Object listener ) { bus . register ( Objects . requireNonNull ( listener ) ) ; return true ; }'", "label": "'Register a listener to the event bus'"}
{"text": "'public final boolean post ( @ Nonnull final Object object ) { Objects . requireNonNull ( object ) ; bus . post ( object ) ; return true ; }'", "label": "'Post an arbitrary non null object on the bus'"}
{"text": "'public JoinMatcherBuilder < V > using ( @ Nonnull final Object joining ) { return new JoinMatcherBuilder <> ( joined , parser , parser . toRule ( joining ) ) ; }'", "label": "'Define the joining rule'"}
{"text": "'public JoinMatcherBuilder < V > using ( final Object rule , final Object rule2 , final Object ... moreRules ) { return using ( parser . sequence ( rule , rule2 , moreRules ) ) ; }'", "label": "'Define the joining rule'"}
{"text": "'@ Override public < V > MatcherContext < V > getSubContext ( final MatcherContext < V > context ) { return context . getSubContext ( this ) ; }'", "label": "'default implementation is to simply delegate to the context'"}
{"text": "'public Rule min ( final int nrCycles ) { Preconditions . checkArgument ( nrCycles >= 0 , \"illegal repetition number specified (\" + nrCycles + \"), must be 0 or greater\" ) ; return range ( Range . atLeast ( nrCycles ) ) ; }'", "label": "'Return a rule with a minimum number of cycles to run'"}
{"text": "'public Rule max ( final int nrCycles ) { Preconditions . checkArgument ( nrCycles >= 0 , \"illegal repetition number specified (\" + nrCycles + \"), must be 0 or greater\" ) ; return range ( Range . atMost ( nrCycles ) ) ; }'", "label": "'Return a rule with a maximum number of cycles to run'"}
{"text": "'public Rule times ( final int nrCycles ) { Preconditions . checkArgument ( nrCycles >= 0 , \"illegal repetition number specified (\" + nrCycles + \"), must be 0 or greater\" ) ; return range ( Range . singleton ( nrCycles ) ) ; }'", "label": "'Return a rule with an exact number of cycles to run'"}
{"text": "'public Rule times ( final int minCycles , final int maxCycles ) { Preconditions . checkArgument ( minCycles >= 0 , \"illegal repetition number specified (\" + minCycles + \"), must be 0 or greater\" ) ; Preconditions . checkArgument ( maxCycles >= minCycles , \"illegal range specified (\" + minCycles + \", \" + maxCycles + \"): maximum must be greater than minimum\" ) ; return range ( Range . closed ( minCycles , maxCycles ) ) ; }'", "label": "'Return a rule with both lower and upper bounds on the number of cycles'"}
{"text": "'@ Cached @ DontLabel public Rule range ( final Range < Integer > range ) { Objects . requireNonNull ( range , \"range must not be null\" ) ; final Range < Integer > realRange = normalizeRange ( range ) ; /*\\n         * We always have a lower bound\\n         */ final int lowerBound = realRange . lowerEndpoint ( ) ; /*\\n         * Handle the case where there is no upper bound\\n         */ if ( ! realRange . hasUpperBound ( ) ) return boundedDown ( lowerBound ) ; /*\\n         * There is an upper bound. Handle the case where it is 0 or 1. Since\\n         * the range is legal, we know that if it is 0, so is the lowerbound;\\n         * and if it is one, the lower bound is either 0 or 1.\\n         */ final int upperBound = realRange . upperEndpoint ( ) ; if ( upperBound == 0 ) return parser . empty ( ) ; if ( upperBound == 1 ) return lowerBound == 0 ? parser . optional ( rule ) : rule ; /*\\n         * So, upper bound is 2 or greater; return the appropriate matcher\\n         * according to what the lower bound is.\\n         *\\n         * Also, if the lower and upper bounds are equal, return a matcher doing\\n         * a fixed number of matches.\\n         */ if ( lowerBound == 0 ) return boundedUp ( upperBound ) ; return lowerBound == upperBound ? exactly ( lowerBound ) : boundedBoth ( lowerBound , upperBound ) ; }'", "label": "'Core method for building a repeating matcher'"}
{"text": "'public static Characters of ( final char ... chars ) { final int length = chars . length ; if ( length == 0 ) return NONE ; final char [ ] array = Arrays . copyOf ( chars , length ) ; Arrays . sort ( array ) ; return new Characters ( false , array ) ; }'", "label": "'Creates a new Characters instance containing only the given chars .'"}
{"text": "'public static Characters of ( final String chars ) { return chars . isEmpty ( ) ? NONE : of ( chars . toCharArray ( ) ) ; }'", "label": "'Creates a new Characters instance containing only the given chars .'"}
{"text": "'public static Characters allBut ( final char ... chars ) { final int length = chars . length ; if ( length == 0 ) return ALL ; final char [ ] array = Arrays . copyOf ( chars , length ) ; Arrays . sort ( array ) ; return new Characters ( true , array ) ; }'", "label": "'Creates a new Characters instance containing all characters minus the given ones .'"}
{"text": "'public List < JAXBElement < ? extends DeploymentDescriptorType > > getDeploymentDescriptor ( ) { if ( deploymentDescriptor == null ) { deploymentDescriptor = new ArrayList < JAXBElement < ? extends DeploymentDescriptorType > > ( ) ; } return this . deploymentDescriptor ; }'", "label": "'Gets the value of the deploymentDescriptor property .'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/authentication\" , name = \"CookieAuthenticationConfiguration\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/authentication\" , substitutionHeadName = \"AuthenticationConfiguration\" ) public JAXBElement < CookieAuthenticationConfiguration > createCookieAuthenticationConfiguration ( CookieAuthenticationConfiguration value ) { return new JAXBElement < CookieAuthenticationConfiguration > ( _CookieAuthenticationConfiguration_QNAME , CookieAuthenticationConfiguration . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link CookieAuthenticationConfiguration } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/authentication\" , name = \"URLAuthenticationConfiguration\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/authentication\" , substitutionHeadName = \"AuthenticationConfiguration\" ) public JAXBElement < URLAuthenticationConfiguration > createURLAuthenticationConfiguration ( URLAuthenticationConfiguration value ) { return new JAXBElement < URLAuthenticationConfiguration > ( _URLAuthenticationConfiguration_QNAME , URLAuthenticationConfiguration . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link URLAuthenticationConfiguration } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/authentication\" , name = \"RequiresAuthentication\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/dd\" , substitutionHeadName = \"DeploymentDescriptor\" ) public JAXBElement < RequiresAuthentication > createRequiresAuthentication ( RequiresAuthentication value ) { return new JAXBElement < RequiresAuthentication > ( _RequiresAuthentication_QNAME , RequiresAuthentication . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link RequiresAuthentication } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/authentication\" , name = \"WebServerAuthenticationConfiguration\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/authentication\" , substitutionHeadName = \"AuthenticationConfiguration\" ) public JAXBElement < WebServerAuthenticationConfiguration > createWebServerAuthenticationConfiguration ( WebServerAuthenticationConfiguration value ) { return new JAXBElement < WebServerAuthenticationConfiguration > ( _WebServerAuthenticationConfiguration_QNAME , WebServerAuthenticationConfiguration . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link WebServerAuthenticationConfiguration } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/authentication\" , name = \"HttpSessionAuthenticationConfiguration\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/authentication\" , substitutionHeadName = \"AuthenticationConfiguration\" ) public JAXBElement < HttpSessionAuthenticationConfiguration > createHttpSessionAuthenticationConfiguration ( HttpSessionAuthenticationConfiguration value ) { return new JAXBElement < HttpSessionAuthenticationConfiguration > ( _HttpSessionAuthenticationConfiguration_QNAME , HttpSessionAuthenticationConfiguration . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link HttpSessionAuthenticationConfiguration } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/authentication\" , name = \"CustomAuthenticationConfiguration\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/authentication\" , substitutionHeadName = \"AuthenticationConfiguration\" ) public JAXBElement < CustomAuthenticationConfiguration > createCustomAuthenticationConfiguration ( CustomAuthenticationConfiguration value ) { return new JAXBElement < CustomAuthenticationConfiguration > ( _CustomAuthenticationConfiguration_QNAME , CustomAuthenticationConfiguration . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link CustomAuthenticationConfiguration } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/authentication\" , name = \"AuthenticationConfiguration\" ) public JAXBElement < AuthenticationConfigurationType > createAuthenticationConfiguration ( AuthenticationConfigurationType value ) { return new JAXBElement < AuthenticationConfigurationType > ( _AuthenticationConfiguration_QNAME , AuthenticationConfigurationType . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link AuthenticationConfigurationType } { @code > }}'"}
{"text": "'public List < JAXBElement < ? extends AuthenticationConfigurationType > > getAuthenticationConfiguration ( ) { if ( authenticationConfiguration == null ) { authenticationConfiguration = new ArrayList < JAXBElement < ? extends AuthenticationConfigurationType > > ( ) ; } return this . authenticationConfiguration ; }'", "label": "'Gets the value of the authenticationConfiguration property .'"}
{"text": "'protected String getDescription ( File f ) throws JAXBException { ProcessModel pm = new ProcessModel ( f ) ; String description = pm . getProcess ( ) . getDescription ( ) ; return description ; }'", "label": "'@throws JAXBException'"}
{"text": "'private void initApplication ( ) throws JAXBException { jaxbContext = JAXBContext . newInstance ( com . tibco . xmlns . applicationmanagement . ObjectFactory . class , com . tibco . xmlns . applicationmanagement . bw . ObjectFactory . class , com . tibco . xmlns . dd . ObjectFactory . class ) ; Unmarshaller jaxbUnmarshaller = jaxbContext . createUnmarshaller ( ) ; Object o = jaxbUnmarshaller . unmarshal ( xmlFile ) ; try { this . application = ( ApplicationType ) o ; } catch ( ClassCastException e ) { // strange workaround: sometimes we get an ApplicationType object, // sometimes a JAXBElement<ApplicationType> object @ SuppressWarnings ( \"unchecked\" ) JAXBElement < ApplicationType > j = ( JAXBElement < ApplicationType > ) o ; this . application = j . getValue ( ) ; } }'", "label": "'<p > This will initialize the { @link ApplicationType } object which is a JAXB representation of the application root - element of TIBCO XML Deployment Descriptor files using the schema with http : // www . tibco . com / xmlns / ApplicationManagement namespace . < / p >'"}
{"text": "'private List < Bw > getBWServices ( ) { List < Bw > result = new ArrayList < Bw > ( ) ; for ( JAXBElement < ? extends ServiceType > jaxbElement : application . getServices ( ) . getBaseService ( ) ) { if ( jaxbElement . getName ( ) . getLocalPart ( ) . equals ( \"bw\" ) ) { result . add ( ( Bw ) jaxbElement . getValue ( ) ) ; } } return result ; }'", "label": "'This method retrieves the list of objects of type BWServiceType .'"}
{"text": "'private Bwprocesses getBWProcesses ( Bw bwService ) { for ( Object o : bwService . getRest ( ) ) { if ( o . getClass ( ) . equals ( Bwprocesses . class ) ) { return ( Bwprocesses ) o ; } } return null ; }'", "label": "'This method retrieves {'"}
{"text": "'private Checkpoints getBWCheckpoints ( Bw bwService ) { for ( Object o : bwService . getRest ( ) ) { if ( o . getClass ( ) . equals ( Checkpoints . class ) ) { return ( Checkpoints ) o ; } } return null ; }'", "label": "'This method retrieves {'"}
{"text": "'private FaultTolerant getBWFaultTolerant ( Bw bwService ) { for ( Object o : bwService . getRest ( ) ) { if ( o . getClass ( ) . equals ( FaultTolerant . class ) ) { return ( FaultTolerant ) o ; } } return null ; }'", "label": "'This method retrieves {'"}
{"text": "'private Boolean isIsFt ( Bw bw ) { Boolean value = false ; // default to false (?) for ( Object o : bw . getRest ( ) ) { if ( o . getClass ( ) . equals ( JAXBElement . class ) ) { //  should never be other than Boolean according to // com.tibco.xmlns.applicationmanagement.BWServiceType @ SuppressWarnings ( \"unchecked\" ) JAXBElement < Boolean > e = ( JAXBElement < Boolean > ) o ; value = e . getValue ( ) ; } } return value ; }'", "label": "'This method retrieves isFt property from Bw . getRest () objects'"}
{"text": "'private void setIsFt ( Bw bw , Boolean value ) { for ( Object o : bw . getRest ( ) ) { if ( o . getClass ( ) . equals ( JAXBElement . class ) ) { //  should never be other than Boolean according to // com.tibco.xmlns.applicationmanagement.BWServiceType @ SuppressWarnings ( \"unchecked\" ) JAXBElement < Boolean > e = ( JAXBElement < Boolean > ) o ; e . setValue ( value ) ; } } }'", "label": "'This method sets isFt property in Bw . getRest () objects'"}
{"text": "'public Properties getGlobalVariables ( ) { SortedProperties result = new SortedProperties ( ) ; NVPairs globalVariablesPairs = getGlobalVariablesPairs ( ) ; if ( globalVariablesPairs != null ) { for ( JAXBElement < ? extends NVPairType > nvPair : globalVariablesPairs . getNVPair ( ) ) { String key = nvPair . getValue ( ) . getName ( ) ; String value = nvPair . getValue ( ) . getValue ( ) ; result . setProperty ( key , value ) ; } } return result ; }'", "label": "'<p > The Global Variables are inside the NVPairs element with @name attribute equals to Global Variables at the root level . < / p >'"}
{"text": "'protected Properties getProcessArchives ( ) { SortedProperties result = new SortedProperties ( ) ; List < Bw > bwServices = getBWServices ( ) ; String key ; for ( Bw bwService : bwServices ) { String serviceKey = \"bw[\" + bwService . getName ( ) + \"]\" ; /// \"ServiceType\" complexType // enabled key = serviceKey + \"/enabled\" ; result . setProperty ( key , bwService . isEnabled ( ) ) ; // bindings result . putAll ( getBindings ( bwService ) ) ; // NVPairs result . putAll ( getNVPairs ( bwService ) ) ; // failureCount key = serviceKey + \"/failureCount\" ; result . setProperty ( key , bwService . getFailureCount ( ) ) ; // failureInterval key = serviceKey + \"/failureInterval\" ; result . setProperty ( key , bwService . getFailureInterval ( ) ) ; // monitor /// \"BWServiceType\" complexType // bwprocesses result . putAll ( getProcesses ( bwService ) ) ; // checkpoints result . putAll ( getCheckpoints ( bwService ) ) ; // isFt key = serviceKey + \"/isFt\" ; result . setProperty ( key , isIsFt ( bwService ) ) ; // faultTolerant result . putAll ( getFaultTolerant ( bwService ) ) ; // plugins // not supported (too complex) } return result ; }'", "label": "'<p > This method focuses on all child elements of <bw name = par > . These elements are defined in the ServiceType & BWServiceType complexTypes of the XSD schema . < / p >'"}
{"text": "'protected Properties getAdapterArchives ( ) { SortedProperties result = new SortedProperties ( ) ; List < Adapter > adapters = getAdapterServices ( ) ; String key ; for ( Adapter adapter : adapters ) { String serviceKey = \"adapter[\" + adapter . getName ( ) + \"]\" ; /// \"ServiceType\" complexType // enabled key = serviceKey + \"/enabled\" ; result . setProperty ( key , adapter . isEnabled ( ) ) ; // bindings result . putAll ( getBindings ( adapter ) ) ; // NVPairs result . putAll ( getNVPairs ( adapter ) ) ; // failureCount key = serviceKey + \"/failureCount\" ; result . setProperty ( key , adapter . getFailureCount ( ) ) ; // failureInterval key = serviceKey + \"/failureInterval\" ; result . setProperty ( key , adapter . getFailureInterval ( ) ) ; // monitor // plugins // not supported (too complex) } return result ; }'", "label": "'<p > This method focuses on all child elements of <adapter name = aar > . These elements are defined in the ServiceType complexType of the XSD schema . < / p >'"}
{"text": "'protected < T extends ServiceType > Properties getBindings ( T service ) { SortedProperties result = new SortedProperties ( ) ; String serviceKey = getElementKey ( service ) + \"[\" + service . getName ( ) + \"]\" ; Bindings bindings = service . getBindings ( ) ; if ( bindings != null ) { for ( Binding binding : bindings . getBinding ( ) ) { String processKey = serviceKey + \"/bindings/binding[\" + binding . getName ( ) + \"]\" ; String key ; // machine key = processKey + \"/machine\" ; result . setProperty ( key , binding . getMachine ( ) ) ; // product if ( binding . getProduct ( ) != null ) { key = processKey + \"/product/type\" ; result . setProperty ( key , binding . getProduct ( ) . getType ( ) ) ; key = processKey + \"/product/version\" ; result . setProperty ( key , binding . getProduct ( ) . getVersion ( ) ) ; key = processKey + \"/product/location\" ; result . setProperty ( key , binding . getProduct ( ) . getLocation ( ) ) ; } // container key = processKey + \"/container\" ; result . setProperty ( key , binding . getContainer ( ) ) ; // description key = processKey + \"/description\" ; result . setProperty ( key , binding . getDescription ( ) ) ; // contact key = processKey + \"/contact\" ; result . setProperty ( key , binding . getContact ( ) ) ; // setting Setting setting = binding . getSetting ( ) ; if ( setting != null ) { key = processKey + \"/setting/startOnBoot\" ; result . setProperty ( key , setting . isStartOnBoot ( ) ) ; key = processKey + \"/setting/enableVerbose\" ; result . setProperty ( key , setting . isEnableVerbose ( ) ) ; key = processKey + \"/setting/maxLogFileSize\" ; result . setProperty ( key , setting . getMaxLogFileSize ( ) ) ; key = processKey + \"/setting/maxLogFileCount\" ; result . setProperty ( key , setting . getMaxLogFileCount ( ) ) ; key = processKey + \"/setting/threadCount\" ; result . setProperty ( key , setting . getThreadCount ( ) ) ; NTService ntService = setting . getNTService ( ) ; if ( ntService != null ) { key = processKey + \"/setting/NTService/runAsNT\" ; result . setProperty ( key , ntService . isRunAsNT ( ) ) ; key = processKey + \"/setting/NTService/startupType\" ; result . setProperty ( key , ntService . getStartupType ( ) ) ; key = processKey + \"/setting/NTService/loginAs\" ; result . setProperty ( key , ntService . getLoginAs ( ) ) ; key = processKey + \"/setting/NTService/password\" ; result . setProperty ( key , ntService . getPassword ( ) ) ; } Java java = setting . getJava ( ) ; if ( java != null ) { key = processKey + \"/setting/java/prepandClassPath\" ; result . setProperty ( key , java . getPrepandClassPath ( ) ) ; key = processKey + \"/setting/java/appendClassPath\" ; result . setProperty ( key , java . getAppendClassPath ( ) ) ; key = processKey + \"/setting/java/initHeapSize\" ; result . setProperty ( key , java . getInitHeapSize ( ) ) ; key = processKey + \"/setting/java/maxHeapSize\" ; result . setProperty ( key , java . getMaxHeapSize ( ) ) ; key = processKey + \"/setting/java/threadStackSize\" ; result . setProperty ( key , java . getThreadStackSize ( ) ) ; } } // ftWeight key = processKey + \"/ftWeight\" ; result . setProperty ( key , binding . getFtWeight ( ) ) ; // shutdown Shutdown shutdown = binding . getShutdown ( ) ; if ( shutdown != null ) { key = processKey + \"/shutdown/checkpoint\" ; result . setProperty ( key , shutdown . isCheckpoint ( ) ) ; key = processKey + \"/shutdown/timeout\" ; result . setProperty ( key , shutdown . getTimeout ( ) ) ; } // plugins // not supported (too complex) // NVPairs if ( binding . getNVPairs ( ) != null ) { for ( JAXBElement < ? extends NVPairType > nvPair : binding . getNVPairs ( ) . getNVPair ( ) ) { key = processKey + \"/variables/variable[\" + nvPair . getValue ( ) . getName ( ) + \"]\" ; result . setProperty ( key , nvPair . getValue ( ) . getValue ( ) ) ; } } } } return result ; }'", "label": "'<p > This method focuses on bindings found in these paths : / application / services / bw / bindings / binding / application / services / adapter / bindings / binding < / p >'"}
{"text": "'private < T extends ServiceType > Properties getNVPairs ( T service ) { SortedProperties result = new SortedProperties ( ) ; String serviceKey = getElementKey ( service ) + \"[\" + service . getName ( ) + \"]\" ; List < NVPairs > nvPairsList = new ArrayList < NVPairs > ( ) ; nvPairsList = service . getNVPairs ( ) ; String variablesKey ; for ( NVPairs nvPairs : nvPairsList ) { variablesKey = serviceKey + \"/variables[\" + nvPairs . getName ( ) + \"]\" ; String key ; for ( JAXBElement < ? extends NVPairType > nvPair : nvPairs . getNVPair ( ) ) { key = variablesKey + \"/variable[\" + nvPair . getValue ( ) . getName ( ) + \"]\" ; result . setProperty ( key , nvPair . getValue ( ) . getValue ( ) ) ; } } return result ; }'", "label": "'<p > This method focuses on Global Variables found in this path : / application / services / bw / NVPairs / application / services / adapter / NVPairs < / p >'"}
{"text": "'protected Properties getProcesses ( Bw bwService ) { SortedProperties result = new SortedProperties ( ) ; String serviceKey = \"bw[\" + bwService . getName ( ) + \"]\" ; Bwprocesses bwProcesses = getBWProcesses ( bwService ) ; if ( bwProcesses != null ) { for ( Bwprocess process : bwProcesses . getBwprocess ( ) ) { String processKey = serviceKey + \"/bwprocesses/bwprocess[\" + process . getName ( ) + \"]\" ; String key ; // starter key = processKey + \"/starter\" ; result . setProperty ( key , process . getStarter ( ) ) ; // enabled key = processKey + \"/enabled\" ; result . setProperty ( key , process . isEnabled ( ) ) ; // maxJob key = processKey + \"/maxJob\" ; result . setProperty ( key , process . getMaxJob ( ) ) ; // activation key = processKey + \"/activation\" ; result . setProperty ( key , process . isActivation ( ) ) ; // flowLimit key = processKey + \"/flowLimit\" ; result . setProperty ( key , process . getFlowLimit ( ) ) ; } } return result ; }'", "label": "'<p > This method focuses on processes found in this path : / application / services / bw / bwprocesses / bwprocess < / p >'"}
{"text": "'protected Properties getCheckpoints ( Bw bwService ) { SortedProperties result = new SortedProperties ( ) ; String serviceKey = \"bw[\" + bwService . getName ( ) + \"]\" ; Checkpoints checkpoints = getBWCheckpoints ( bwService ) ; if ( checkpoints != null ) { String key ; // tablePrefix key = serviceKey + \"/checkpoints/tablePrefix\" ; result . setProperty ( key , checkpoints . getTablePrefix ( ) ) ; for ( String checkpoint : checkpoints . getCheckpoint ( ) ) { if ( checkpoint == null ) continue ; // checkpoint key = serviceKey + \"/checkpoints/checkpoint[\" + checkpoint + \"]\" ; result . setProperty ( key , checkpoint . equals ( checkpoints . getSelected ( ) ) ) ; } } return result ; }'", "label": "'<p > This method focuses on checkpoints found in this path : / application / services / bw / checkpoints / checkpoint < / p >'"}
{"text": "'protected Properties getFaultTolerant ( Bw bwService ) { SortedProperties result = new SortedProperties ( ) ; String serviceKey = \"bw[\" + bwService . getName ( ) + \"]\" ; FaultTolerant faultTolerant = getBWFaultTolerant ( bwService ) ; if ( faultTolerant != null ) { String key ; // hbInterval key = serviceKey + \"/faultTolerant/hbInterval\" ; result . setProperty ( key , faultTolerant . getHbInterval ( ) ) ; // activationInterval key = serviceKey + \"/faultTolerant/activationInterval\" ; result . setProperty ( key , faultTolerant . getActivationInterval ( ) ) ; // preparationDelay key = serviceKey + \"/faultTolerant/preparationDelay\" ; result . setProperty ( key , faultTolerant . getPreparationDelay ( ) ) ; } return result ; }'", "label": "'<p > This method focuses on faultTolerant object found in this path : / application / services / bw / faultTolerant < / p >'"}
{"text": "'private Bw getBw ( String name ) { List < Bw > services = getBWServices ( ) ; if ( services != null ) { for ( Bw service : services ) { if ( service . getName ( ) . equals ( name ) ) { return service ; } } } Bw result = new Bw ( ) ; result . setName ( name ) ; services . add ( result ) ; QName qName = new QName ( APPLICATION_MANAGEMENT_NAMESPACE , \"bw\" ) ; JAXBElement < Bw > j = new JAXBElement < Bw > ( qName , Bw . class , result ) ; application . getServices ( ) . getBaseService ( ) . add ( j ) ; return result ; }'", "label": "'/ application / services / bw'"}
{"text": "'private Adapter getAdapter ( String name ) { List < Adapter > services = getAdapterServices ( ) ; if ( services != null ) { for ( Adapter service : services ) { if ( service . getName ( ) . equals ( name ) ) { return service ; } } } Adapter result = new Adapter ( ) ; result . setName ( name ) ; services . add ( result ) ; QName qName = new QName ( APPLICATION_MANAGEMENT_NAMESPACE , \"adapter\" ) ; JAXBElement < Adapter > j = new JAXBElement < Adapter > ( qName , Adapter . class , result ) ; application . getServices ( ) . getBaseService ( ) . add ( j ) ; return result ; }'", "label": "'/ application / services / adapter'"}
{"text": "'private < T extends ServiceType > Binding getBinding ( String nameAttribute , T parent ) { Bindings bindings = parent . getBindings ( ) ; if ( bindings != null ) { for ( Binding binding : bindings . getBinding ( ) ) { if ( binding . getName ( ) . equals ( nameAttribute ) ) { return binding ; } } } else { bindings = new Bindings ( ) ; parent . setBindings ( bindings ) ; } // create new Binding Binding binding = new Binding ( ) ; binding . setName ( nameAttribute ) ; Product p = new Product ( ) ; p . setType ( \"bwengine\" ) ; p . setLocation ( \"\" ) ; p . setVersion ( \"\" ) ; binding . setProduct ( p ) ; binding . setDescription ( \"\" ) ; binding . setContact ( \"\" ) ; Shutdown s = new Shutdown ( ) ; s . setCheckpoint ( false ) ; s . setTimeout ( new BigInteger ( \"0\" ) ) ; binding . setShutdown ( s ) ; bindings . getBinding ( ) . add ( binding ) ; return binding ; }'", "label": "'/ application / services / bw / bindings / binding / application / services / adapter / bindings / binding'"}
{"text": "'private Object addBindingParameter ( Binding binding , String key , String value ) { if ( \"machine\" . equals ( key ) ) { binding . setMachine ( value ) ; } else if ( \"product\" . equals ( key ) ) { if ( binding . getProduct ( ) == null ) { binding . setProduct ( new Product ( ) ) ; } return binding . getProduct ( ) ; } else if ( \"container\" . equals ( key ) ) { binding . setContainer ( value ) ; } else if ( \"description\" . equals ( key ) ) { binding . setDescription ( value ) ; } else if ( \"contact\" . equals ( key ) ) { binding . setContact ( value ) ; } else if ( \"setting\" . equals ( key ) ) { if ( binding . getSetting ( ) == null ) { binding . setSetting ( new Setting ( ) ) ; } return binding . getSetting ( ) ; } else if ( \"ftWeight\" . equals ( key ) ) { binding . setFtWeight ( BigInteger . valueOf ( Long . parseLong ( value ) ) ) ; } else if ( \"shutdown\" . equals ( key ) ) { if ( binding . getShutdown ( ) == null ) { binding . setShutdown ( new Shutdown ( ) ) ; } return binding . getShutdown ( ) ; } return binding ; }'", "label": "'/ application / services / bw / bindings / binding / *'"}
{"text": "'private Object addProductParameter ( Product product , String key , String value ) { if ( \"type\" . equals ( key ) ) { product . setType ( value ) ; } else if ( \"version\" . equals ( key ) ) { product . setVersion ( value ) ; } else if ( \"location\" . equals ( key ) ) { product . setLocation ( value ) ; } return product ; }'", "label": "'/ application / services / bw / bindings / binding / product / *'"}
{"text": "'private Object addSettingParameter ( Setting setting , String key , String value ) { if ( \"startOnBoot\" . equals ( key ) ) { setting . setStartOnBoot ( Boolean . parseBoolean ( value ) ) ; } else if ( \"enableVerbose\" . equals ( key ) ) { setting . setEnableVerbose ( Boolean . parseBoolean ( value ) ) ; } else if ( \"maxLogFileSize\" . equals ( key ) ) { setting . setMaxLogFileSize ( BigInteger . valueOf ( Long . parseLong ( value ) ) ) ; } else if ( \"maxLogFileCount\" . equals ( key ) ) { setting . setMaxLogFileCount ( BigInteger . valueOf ( Long . parseLong ( value ) ) ) ; } else if ( \"threadCount\" . equals ( key ) ) { setting . setThreadCount ( BigInteger . valueOf ( Long . parseLong ( value ) ) ) ; } else if ( \"NTService\" . equals ( key ) ) { if ( setting . getNTService ( ) == null ) { setting . setNTService ( new NTService ( ) ) ; } return setting . getNTService ( ) ; } else if ( \"java\" . equals ( key ) ) { if ( setting . getJava ( ) == null ) { setting . setJava ( new Java ( ) ) ; } return setting . getJava ( ) ; } return setting ; }'", "label": "'/ application / services / bw / bindings / binding / setting / *'"}
{"text": "'private Object addNTServiceParameter ( NTService ntService , String key , String value ) { if ( \"runAsNT\" . equals ( key ) ) { ntService . setRunAsNT ( Boolean . parseBoolean ( value ) ) ; } else if ( \"startupType\" . equals ( key ) ) { ntService . setStartupType ( value ) ; } else if ( \"loginAs\" . equals ( key ) ) { ntService . setLoginAs ( value ) ; } else if ( \"password\" . equals ( key ) ) { ntService . setPassword ( value ) ; } return ntService ; }'", "label": "'/ application / services / bw / bindings / binding / setting / NTService / *'"}
{"text": "'private Object addJavaParameter ( Java java , String key , String value ) { if ( \"prepandClassPath\" . equals ( key ) ) { java . setPrepandClassPath ( value ) ; } else if ( \"appendClassPath\" . equals ( key ) ) { java . setAppendClassPath ( value ) ; } else if ( \"initHeapSize\" . equals ( key ) ) { java . setInitHeapSize ( BigInteger . valueOf ( Long . parseLong ( value ) ) ) ; } else if ( \"maxHeapSize\" . equals ( key ) ) { java . setMaxHeapSize ( BigInteger . valueOf ( Long . parseLong ( value ) ) ) ; } else if ( \"threadStackSize\" . equals ( key ) ) { java . setThreadStackSize ( BigInteger . valueOf ( Long . parseLong ( value ) ) ) ; } return java ; }'", "label": "'/ application / services / bw / bindings / binding / setting / java / *'"}
{"text": "'private Object addShutdownParameter ( Shutdown shutdown , String key , String value ) { if ( \"checkpoint\" . equals ( key ) ) { shutdown . setCheckpoint ( Boolean . parseBoolean ( value ) ) ; } else if ( \"timeout\" . equals ( key ) ) { shutdown . setTimeout ( BigInteger . valueOf ( Long . parseLong ( value ) ) ) ; } return shutdown ; }'", "label": "'/ application / services / bw / bindings / binding / shutdown / *'"}
{"text": "'private Bwprocess getBWProcess ( String nameAttribute , Bw parent ) { Bwprocesses bwProcesses = getBWProcesses ( parent ) ; if ( bwProcesses != null ) { for ( Bwprocess bwProcess : bwProcesses . getBwprocess ( ) ) { if ( bwProcess . getName ( ) . equals ( nameAttribute ) ) { return bwProcess ; } } } else { bwProcesses = new Bwprocesses ( ) ; parent . getRest ( ) . add ( bwProcesses ) ; } Bwprocess bwProcess = new Bwprocess ( ) ; bwProcess . setName ( nameAttribute ) ; bwProcesses . getBwprocess ( ) . add ( bwProcess ) ; return bwProcess ; }'", "label": "'/ application / services / bw / bwprocesses / bwprocess'"}
{"text": "'private void addBWProcessParameter ( Bwprocess bwProcess , String key , String value ) { if ( \"starter\" . equals ( key ) ) { bwProcess . setStarter ( value ) ; } else if ( \"enabled\" . equals ( key ) ) { bwProcess . setEnabled ( Boolean . parseBoolean ( value ) ) ; } else if ( \"maxJob\" . equals ( key ) ) { bwProcess . setMaxJob ( BigInteger . valueOf ( Long . parseLong ( value ) ) ) ; } else if ( \"activation\" . equals ( key ) ) { bwProcess . setActivation ( Boolean . parseBoolean ( value ) ) ; } else if ( \"flowLimit\" . equals ( key ) ) { bwProcess . setFlowLimit ( BigInteger . valueOf ( Long . parseLong ( value ) ) ) ; } }'", "label": "'/ application / services / bw / bwprocesses / bwprocess / *'"}
{"text": "'private void addFaultTolerantParameter ( FaultTolerant faultTolerant , String key , String value ) { if ( \"activationInterval\" . equals ( key ) ) { faultTolerant . setActivationInterval ( BigInteger . valueOf ( Long . parseLong ( value ) ) ) ; } else if ( \"hbInterval\" . equals ( key ) ) { faultTolerant . setHbInterval ( BigInteger . valueOf ( Long . parseLong ( value ) ) ) ; } else if ( \"preparationDelay\" . equals ( key ) ) { faultTolerant . setPreparationDelay ( BigInteger . valueOf ( Long . parseLong ( value ) ) ) ; } }'", "label": "'/ application / services / bw / faultTolerant / *'"}
{"text": "'private Object addBwParameter ( Bw bw , String key , String value ) { if ( \"enabled\" . equals ( key ) ) { bw . setEnabled ( Boolean . parseBoolean ( value ) ) ; } else if ( \"failureCount\" . equals ( key ) ) { bw . setFailureCount ( BigInteger . valueOf ( Long . parseLong ( value ) ) ) ; } else if ( \"failureInterval\" . equals ( key ) ) { bw . setFailureInterval ( BigInteger . valueOf ( Long . parseLong ( value ) ) ) ; } else if ( \"isFt\" . equals ( key ) ) { setIsFt ( bw , Boolean . parseBoolean ( value ) ) ; } else if ( \"faultTolerant\" . equals ( key ) ) { return getBWFaultTolerant ( bw ) ; } return bw ; }'", "label": "'/ application / services / bw / *'"}
{"text": "'private Object addAdapterParameter ( Adapter adapter , String key , String value ) { if ( \"enabled\" . equals ( key ) ) { adapter . setEnabled ( Boolean . parseBoolean ( value ) ) ; } else if ( \"failureCount\" . equals ( key ) ) { adapter . setFailureCount ( BigInteger . valueOf ( Long . parseLong ( value ) ) ) ; } else if ( \"failureInterval\" . equals ( key ) ) { adapter . setFailureInterval ( BigInteger . valueOf ( Long . parseLong ( value ) ) ) ; } return adapter ; }'", "label": "'/ application / services / adapter / *'"}
{"text": "'public Object getElement ( String path , String element , String value , Object parent ) { if ( map . containsKey ( path ) ) { return map . get ( path ) ; } else { Matcher matcherElement = patternElement . matcher ( element ) ; if ( matcherElement . matches ( ) ) { String elementName = matcherElement . group ( 1 ) ; String nameAttribute = matcherElement . group ( 3 ) ; if ( nameAttribute != null ) { if ( elementName . equals ( \"variables\" ) ) { NVPairs gvs = null ; if ( parent . getClass ( ) . equals ( Bw . class ) || parent . getClass ( ) . equals ( Adapter . class ) ) { ServiceType service = ( ServiceType ) parent ; for ( NVPairs nvPairs : service . getNVPairs ( ) ) { if ( nvPairs . getName ( ) . equals ( nameAttribute ) ) { gvs = nvPairs ; break ; } } if ( gvs == null ) { gvs = new NVPairs ( ) ; service . getNVPairs ( ) . add ( gvs ) ; } } else if ( parent . getClass ( ) . equals ( Binding . class ) ) { gvs = new NVPairs ( ) ; gvs . setName ( nameAttribute ) ; ( ( Binding ) parent ) . setNVPairs ( gvs ) ; } map . put ( path , gvs ) ; return gvs ; } else if ( elementName . equals ( \"variable\" ) ) { NameValuePair simpleGV = new NameValuePair ( ) ; simpleGV . setName ( nameAttribute ) ; simpleGV . setValue ( value ) ; QName name = new QName ( APPLICATION_MANAGEMENT_NAMESPACE , \"NameValuePair\" ) ; JAXBElement < NameValuePair > _simpleGV = new JAXBElement < NameValuePair > ( name , NameValuePair . class , simpleGV ) ; boolean found = false ; for ( JAXBElement < ? extends NVPairType > nvPair : ( ( NVPairs ) parent ) . getNVPair ( ) ) { if ( nameAttribute . equals ( nvPair . getValue ( ) . getName ( ) ) ) { nvPair . getValue ( ) . setValue ( value ) ; found = true ; } } if ( ! found ) { ( ( NVPairs ) parent ) . getNVPair ( ) . add ( _simpleGV ) ; } return simpleGV ; } else if ( elementName . equals ( \"bw\" ) ) { Bw service = this . getBw ( nameAttribute ) ; map . put ( path , service ) ; return service ; } else if ( elementName . equals ( \"adapter\" ) ) { Adapter service = this . getAdapter ( nameAttribute ) ; map . put ( path , service ) ; return service ; } else if ( elementName . equals ( \"binding\" ) ) { Binding binding = null ; if ( parent . getClass ( ) . equals ( Bw . class ) ) { binding = this . getBinding ( nameAttribute , ( Bw ) parent ) ; } else if ( parent . getClass ( ) . equals ( Adapter . class ) ) { binding = this . getBinding ( nameAttribute , ( Adapter ) parent ) ; } else { // throw ? } map . put ( path , binding ) ; return binding ; } else if ( elementName . equals ( \"bwprocess\" ) ) { Bwprocess bwProcess = this . getBWProcess ( nameAttribute , ( Bw ) parent ) ; map . put ( path , bwProcess ) ; return bwProcess ; } else if ( elementName . equals ( \"checkpoint\" ) ) { Checkpoints checkpoints = ( Checkpoints ) parent ; if ( ! checkpoints . getCheckpoint ( ) . contains ( nameAttribute ) ) { checkpoints . getCheckpoint ( ) . add ( nameAttribute ) ; } if ( \"true\" . equals ( value ) ) { checkpoints . setSelected ( nameAttribute ) ; } } } else { if ( elementName . equals ( \"variables\" ) ) { NVPairs gvs = null ; if ( parent . getClass ( ) . equals ( Bw . class ) || parent . getClass ( ) . equals ( Adapter . class ) ) { ServiceType service = ( ServiceType ) parent ; for ( NVPairs nvPairs : service . getNVPairs ( ) ) { if ( nvPairs . getName ( ) . equals ( \"Runtime Variables\" ) ) { gvs = nvPairs ; break ; } } if ( gvs == null ) { gvs = new NVPairs ( ) ; service . getNVPairs ( ) . add ( gvs ) ; } } else if ( parent . getClass ( ) . equals ( Binding . class ) ) { gvs = new NVPairs ( ) ; gvs . setName ( \"Runtime Variables\" ) ; ( ( Binding ) parent ) . setNVPairs ( gvs ) ; } map . put ( path , gvs ) ; return gvs ; } else if ( elementName . equals ( \"checkpoints\" ) ) { Checkpoints checkpoints = this . getBWCheckpoints ( ( Bw ) parent ) ; map . put ( path , checkpoints ) ; return checkpoints ; } else if ( elementName . equals ( \"tablePrefix\" ) ) { Checkpoints checkpoints = ( Checkpoints ) parent ; checkpoints . setTablePrefix ( value ) ; // Binding children } else if ( parent . getClass ( ) . equals ( Binding . class ) ) { return addBindingParameter ( ( Binding ) parent , elementName , value ) ; } else if ( parent . getClass ( ) . equals ( Product . class ) ) { return addProductParameter ( ( Product ) parent , elementName , value ) ; } else if ( parent . getClass ( ) . equals ( Setting . class ) ) { return addSettingParameter ( ( Setting ) parent , elementName , value ) ; } else if ( parent . getClass ( ) . equals ( NTService . class ) ) { return addNTServiceParameter ( ( NTService ) parent , elementName , value ) ; } else if ( parent . getClass ( ) . equals ( Java . class ) ) { return addJavaParameter ( ( Java ) parent , elementName , value ) ; } else if ( parent . getClass ( ) . equals ( Shutdown . class ) ) { return addShutdownParameter ( ( Shutdown ) parent , elementName , value ) ; // // Bwprocess children } else if ( parent . getClass ( ) . equals ( Bwprocess . class ) ) { addBWProcessParameter ( ( Bwprocess ) parent , elementName , value ) ; } else if ( parent . getClass ( ) . equals ( FaultTolerant . class ) ) { addFaultTolerantParameter ( ( FaultTolerant ) parent , elementName , value ) ; } else if ( parent . getClass ( ) . equals ( Checkpoints . class ) ) { addCheckpointsParameter ( ( Checkpoints ) parent , elementName , value ) ; // Bw chidren (direct children) } else if ( parent . getClass ( ) . equals ( Bw . class ) ) { return addBwParameter ( ( Bw ) parent , elementName , value ) ; } else if ( parent . getClass ( ) . equals ( Adapter . class ) ) { return addAdapterParameter ( ( Adapter ) parent , elementName , value ) ; } } } return parent ; } }'", "label": "'<p > This method will create JAXB objects from Properties through recursive calls . Each property has a path . The last part of a path ( after last / ) is the element . < / p >'"}
{"text": "'public void removeDuplicateBinding ( ) { List < Bw > bwServices = this . getBWServices ( ) ; for ( Bw bw : bwServices ) { boolean first = true ; List < Binding > bindings = bw . getBindings ( ) . getBinding ( ) ; for ( Iterator < Binding > iterator = bindings . iterator ( ) ; iterator . hasNext ( ) ; ) { Binding binding = ( Binding ) iterator . next ( ) ; if ( ! first && binding . getName ( ) . equals ( \"\" ) ) { iterator . remove ( ) ; } first = false ; } } List < Adapter > adapterServices = this . getAdapterServices ( ) ; for ( Adapter adapter : adapterServices ) { boolean first = true ; List < Binding > bindings = adapter . getBindings ( ) . getBinding ( ) ; for ( Iterator < Binding > iterator = bindings . iterator ( ) ; iterator . hasNext ( ) ; ) { Binding binding = ( Binding ) iterator . next ( ) ; if ( ! first && binding . getName ( ) . equals ( \"\" ) ) { iterator . remove ( ) ; } first = false ; } } }'", "label": "'<p > This will remove from the XML the second duplicate default binding ( with empty name attribute ) to keep only the first one . This is is because AppManage - export - max exports two empty bindings to prepare fault tolerance configuration . < / p >'"}
{"text": "'public void removeDefaultBindingIfNotExists ( Properties properties ) { List < Bw > bwServices = this . getBWServices ( ) ; for ( Bw bw : bwServices ) { String path = \"bw[\" + bw . getName ( ) + \"]/bindings/binding[]/machine\" ; List < Binding > bindings = bw . getBindings ( ) . getBinding ( ) ; for ( Iterator < Binding > iterator = bindings . iterator ( ) ; iterator . hasNext ( ) ; ) { Binding binding = ( Binding ) iterator . next ( ) ; //\\t\\t\\t\\tif (binding.getName().equals(\"\") && properties.getString(path) == null) { if ( binding . getName ( ) . equals ( \"\" ) && ! properties . containsKey ( path ) ) { iterator . remove ( ) ; } } } List < Adapter > adapterServices = this . getAdapterServices ( ) ; for ( Adapter adapter : adapterServices ) { String path = \"adapter[\" + adapter . getName ( ) + \"]/bindings/binding[]/machine\" ; List < Binding > bindings = adapter . getBindings ( ) . getBinding ( ) ; for ( Iterator < Binding > iterator = bindings . iterator ( ) ; iterator . hasNext ( ) ; ) { Binding binding = ( Binding ) iterator . next ( ) ; //\\t\\t\\t\\tif (binding.getName().equals(\"\") && properties.getString(path) == null) { if ( binding . getName ( ) . equals ( \"\" ) && ! properties . containsKey ( path ) ) { iterator . remove ( ) ; } } } }'", "label": "'<p > This will remove from the XML the default binding ( with empty name attribute ) if it is not found in the properties . < / p >'"}
{"text": "'public void addMonitoringEventsToAllServices ( Events events ) { List < JAXBElement < ? extends EventType > > events_ = events . getEvent ( ) ; if ( events_ != null && ! events_ . isEmpty ( ) ) { for ( Bw service : this . getBWServices ( ) ) { Monitor monitor = service . getMonitor ( ) ; if ( monitor != null ) { monitor . setEvents ( events ) ; } } } }'", "label": "'Add &lt ; events > in &lt ; monitor > element of all &lt ; bw > elements .'"}
{"text": "'public List < GlobalVariables . GlobalVariable > getGlobalVariable ( ) { if ( globalVariable == null ) { globalVariable = new ArrayList < GlobalVariables . GlobalVariable > ( ) ; } return this . globalVariable ; }'", "label": "'Gets the value of the globalVariable property .'"}
{"text": "'public List < JAXBElement < ? extends ServiceType > > getBaseService ( ) { if ( baseService == null ) { baseService = new ArrayList < JAXBElement < ? extends ServiceType > > ( ) ; } return this . baseService ; }'", "label": "'Gets the value of the baseService property .'"}
{"text": "'public List < JAXBElement < ? extends EventType > > getEvent ( ) { if ( event == null ) { event = new ArrayList < JAXBElement < ? extends EventType > > ( ) ; } return this . event ; }'", "label": "'Gets the value of the event property .'"}
{"text": "'public static AbstractBWMojo propertiesManager ( MavenSession session , MavenProject mavenProject ) { AbstractBWMojo mojo = new AbstractBWMojo ( ) ; mojo . setProject ( mavenProject ) ; mojo . setSession ( session ) ; mojo . setSettings ( session . getSettings ( ) ) ; return mojo ; }'", "label": "'<p > Instantiate a minimalistic { @link AbstractCommonMojo } to use properties management as a standalone object . < / p >'"}
{"text": "'private void checkBWProject ( ) throws MojoExecutionException { if ( projectDirectory == null ) { projectNotFound ( ) ; } else if ( ! projectDirectory . exists ( ) || ! projectDirectory . isDirectory ( ) ) { projectNotFound ( ) ; } }'", "label": "'This will check that the BW project specified in the POM project exists .'"}
{"text": "'protected List < Dependency > readDependenciesFromFile ( String resolvedFileName , String dependencyType ) throws IOException { List < Dependency > dependencies = new ArrayList < Dependency > ( ) ; File resolvedFile = new File ( resolvedFileName ) ; if ( ! resolvedFile . exists ( ) ) { return dependencies ; } FileInputStream fstream = new FileInputStream ( resolvedFile ) ; DataInputStream ds = new DataInputStream ( fstream ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( ds ) ) ; Pattern p = Pattern . compile ( \"   (.*):(.*):\" + dependencyType + \":(.*):(.*)\" ) ; // keep only selected type (projlib or jar or bw-ear) dependencies String strLine ; while ( ( strLine = br . readLine ( ) ) != null ) { Matcher m = p . matcher ( strLine ) ; if ( m . matches ( ) ) { getLog ( ) . debug ( m . group ( 0 ) ) ; String groupId = m . group ( 1 ) ; String artifactId = m . group ( 2 ) ; String version = m . group ( 3 ) ; String scope = m . group ( 4 ) ; // create the dependency Dependency dependency = new Dependency ( ) ; dependency . setGroupId ( groupId ) ; dependency . setArtifactId ( artifactId ) ; dependency . setVersion ( version ) ; dependency . setType ( dependencyType ) ; dependency . setScope ( scope ) ; dependencies . add ( dependency ) ; } } br . close ( ) ; return dependencies ; }'", "label": "'This will read the dependencies from the resolved file found in the build directory . This file was created earlier in the build by the resolve - bw - dependencies execution of the process - resources phase .'"}
{"text": "'protected List < Dependency > getDependencies ( String dependencyType , boolean doIgnoreDependencies ) throws IOException { ArrayList < Dependency > result = new ArrayList < Dependency > ( ) ; List < Dependency > dependencies = readDependenciesFromFile ( directory + \"/resolved\" , dependencyType ) ; for ( Dependency dependency : dependencies ) { if ( doIgnoreDependencies ) { if ( dependenciesIgnored . indexOf ( dependency . getGroupId ( ) + \\' \\' + dependency . getArtifactId ( ) ) >= 0 ) { continue ; } } if ( dependency . getType ( ) . equals ( dependencyType ) ) { result . add ( dependency ) ; } } return result ; }'", "label": "'This will retrieve only the dependencies of type dependencyType defined in POM project as / dependencies / dependency / type = dependencyType .'"}
{"text": "'private void copyAliasesFile ( ) throws IOException { // Create the aliases.properties in the target folder File aliasesFile = getAliasesFile ( ) ; FileWriter file = null ; BufferedWriter buffer = null ; PrintWriter aliasesFileOut = null ; try { file = new FileWriter ( aliasesFile ) ; buffer = new BufferedWriter ( file ) ; aliasesFileOut = new PrintWriter ( buffer ) ; // Copy all of the required aliases for the project, and map them with their path in Designer5.prefs for ( Dependency dependency : getJarDependencies ( ) ) { String jarName = getJarName ( dependency , false ) ; String jarAlias = formatAlias ( getJarAlias ( dependency , false ) ) ; String jarPath = getDependencyPath ( jarName ) ; if ( new File ( jarPath ) . exists ( ) ) { aliasesFileOut . println ( TIBCO_ALIAS_PREFIX + jarAlias + \"=\" + jarPath ) ; } } for ( Dependency dependency : getProjlibsDependencies ( ) ) { String projlibName = getProjlibName ( dependency ) ; String projlibAlias = formatAlias ( getProjlibAlias ( dependency ) ) ; String projlibPath = getDependencyPath ( projlibName ) ; aliasesFileOut . println ( TIBCO_ALIAS_PREFIX + projlibAlias + \"=\" + projlibPath ) ; } } finally { aliasesFileOut . close ( ) ; buffer . close ( ) ; file . close ( ) ; } }'", "label": "'This will create an aliases file ( aliases . properties ) that can be provided to buildear for instance to specify the JAR aliases . It seems that the JAR aliases are not recognized by buildear from Designer5 . prefs whereas they are by TIBCO Designer .'"}
{"text": "'private void copyDesigner5Prefs ( ) throws IOException { File designer5Prefs = getDesigner5Prefs ( ) ; // copy system \\'Designer5.prefs\\' to this \".TIBCO\" directory File systemDesigner5Prefs = new File ( System . getProperty ( \"user.home\" ) + \"/\" + TIBCO_HOME_DIR + \"/\" + DESIGNER5_PREFS ) ; getLog ( ) . debug ( DESIGNER5_PREFS + \" : \" + systemDesigner5Prefs . getAbsolutePath ( ) ) ; if ( systemDesigner5Prefs . exists ( ) ) { copyFile ( systemDesigner5Prefs , designer5Prefs ) ; } else { designer5Prefs . createNewFile ( ) ; } // remove file aliases ReplaceRegExp replaceRegExp = new ReplaceRegExp ( ) ; replaceRegExp . setFile ( designer5Prefs ) ; replaceRegExp . setMatch ( FILE_ALIAS_PREFIX_ESCAPED + \"([0-9]*)=(.*)\" ) ; replaceRegExp . setReplace ( \"\" ) ; replaceRegExp . setByLine ( true ) ; replaceRegExp . execute ( ) ; // replace with actual file aliases (which are Maven artifacts) FileWriter file = null ; BufferedWriter buffer = null ; PrintWriter designer5PrefsOut = null ; try { file = new FileWriter ( designer5Prefs , true ) ; buffer = new BufferedWriter ( file ) ; designer5PrefsOut = new PrintWriter ( buffer ) ; designer5PrefsOut . println ( \"\" ) ; // first the Projlibs aliases int i = 0 ; if ( ! hideLibraryResources ) { // implements the \"Hide Library Resources\" of TIBCO Designer for ( Dependency dependency : getProjlibsDependencies ( ) ) { String projlibName = getProjlibName ( dependency ) ; String projlibAlias = getProjlibAlias ( dependency ) ; String projlibPath = getDependencyPath ( projlibName ) ; designer5PrefsOut . println ( FILE_ALIAS_PREFIX + ( i ++ ) + \"=\" + projlibAlias + \"\\\\\\\\=\" + projlibPath ) ; } } // then the Jar aliases for ( Dependency dependency : getJarDependencies ( ) ) { String jarName = getJarName ( dependency , false ) ; String jarAlias = getJarAlias ( dependency , false ) ; String jarPath = getDependencyPath ( jarName ) ; // String jarNameUnderscored = getJarName(dependency, true); designer5PrefsOut . println ( FILE_ALIAS_PREFIX + ( i ++ ) + \"=\" + jarAlias + \"\\\\\\\\=\" + jarPath ) ; } } finally { designer5PrefsOut . close ( ) ; buffer . close ( ) ; file . close ( ) ; } }'", "label": "'This will create the Designer5 . prefs file in target / . TIBCO which will override the platform TIBCO_HOME directory .'"}
{"text": "'private void copyDesignTimeLibs ( ) throws IOException { File designTimeLibs = new File ( buildSrcDirectory + \"/\" + DTL_FILE_NAME ) ; getLog ( ) . debug ( DTL_FILE_NAME + \" : \" + buildSrcDirectory + \"/\" + DTL_FILE_NAME ) ; if ( ! designTimeLibs . exists ( ) ) { if ( buildSrcDirectory . exists ( ) ) { designTimeLibs . createNewFile ( ) ; } else { return ; } } FileWriter file = null ; BufferedWriter buffer = null ; PrintWriter designTimeLibsOut = null ; try { file = new FileWriter ( designTimeLibs , false ) ; buffer = new BufferedWriter ( file ) ; designTimeLibsOut = new PrintWriter ( buffer ) ; int i = getProjlibsDependencies ( ) . size ( ) ; if ( ! hideLibraryResources ) { for ( Dependency dependency : getProjlibsDependencies ( ) ) { //String projlibName = getProjlibName(dependency); String projlibAlias = getProjlibAlias ( dependency ) ; designTimeLibsOut . println ( ( -- i ) + \"=\" + projlibAlias + \"\\\\\\\\=\" ) ; } } } finally { designTimeLibsOut . close ( ) ; buffer . close ( ) ; file . close ( ) ; } }'", "label": "'This will create the . designtimelibs file in { @link buildSrcDirectory } which is basically the path to the temporary BusinessWorks project being built .'"}
{"text": "'protected int launchTIBCOBinary ( File binary , List < File > tras , ArrayList < String > arguments , File workingDir , String errorMsg , boolean fork , boolean synchronous ) throws IOException , MojoExecutionException { Integer result = 0 ; if ( tras == null ) { // no value specified as Mojo parameter, we use the .tra in the same directory as the binary String traPathFileName = binary . getAbsolutePath ( ) ; traPathFileName = FilenameUtils . removeExtension ( traPathFileName ) ; traPathFileName += \".tra\" ; tras = new ArrayList < File > ( ) ; tras . add ( new File ( traPathFileName ) ) ; } HashMap < File , File > trasMap = new HashMap < File , File > ( ) ; for ( File tra : tras ) { // copy of \".tra\" file in the working directory File tmpTRAFile = new File ( directory , tra . getName ( ) ) ; trasMap . put ( tra , tmpTRAFile ) ; copyFile ( tra , tmpTRAFile ) ; } for ( File tra : trasMap . keySet ( ) ) { if ( trasMap . containsKey ( tibcoDesignerTRAPath ) && ( ( tibcoBuildEARUseDesignerTRA && tra == tibcoBuildEARTRAPath ) || ( tibcoBuildLibraryUseDesignerTRA && tra == tibcoBuildLibraryTRAPath ) ) ) { if ( tras . size ( ) > 1 ) { ReplaceRegExp replaceRegExp = new ReplaceRegExp ( ) ; replaceRegExp . setFile ( trasMap . get ( tra ) ) ; replaceRegExp . setMatch ( \"tibco.include.tra (.*/designer.tra)\" ) ; replaceRegExp . setReplace ( \"tibco.include.tra \" + trasMap . get ( tibcoDesignerTRAPath ) . toString ( ) . replace ( \\' \\' , \\' \\' ) ) ; replaceRegExp . setByLine ( true ) ; replaceRegExp . execute ( ) ; } } if ( tra == tibcoBuildEARTRAPath || tra == tibcoDesignerTRAPath || tra == tibcoBWEngineTRAPath ) { // FIXME: should check more properly // append user.home at the end to force the use of custom Designer5.prefs PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( trasMap . get ( tra ) , true ) ) ) ; out . println ( \"\" ) ; out . println ( \"java.property.user.home=\" + directory . getAbsolutePath ( ) . replace ( \"\\\\\\\\\" , \"/\" ) ) ; out . close ( ) ; } } CommandLine cmdLine = new CommandLine ( binary ) ; for ( String argument : arguments ) { cmdLine . addArgument ( argument ) ; } getLog ( ) . debug ( \"launchTIBCOBinary command line : \" + cmdLine . toString ( ) ) ; getLog ( ) . debug ( \"working dir : \" + workingDir ) ; DefaultExecutor executor = new DefaultExecutor ( ) ; executor . setWorkingDirectory ( workingDir ) ; if ( timeOut > 0 ) { ExecuteWatchdog watchdog = new ExecuteWatchdog ( timeOut * 1000 ) ; executor . setWatchdog ( watchdog ) ; } executor . setProcessDestroyer ( new ShutdownHookProcessDestroyer ( ) ) ; ByteArrayOutputStream stdOutAndErr = new ByteArrayOutputStream ( ) ; executor . setStreamHandler ( new PumpStreamHandler ( stdOutAndErr ) ) ; if ( fork ) { CommandLauncher commandLauncher = CommandLauncherFactory . createVMLauncher ( ) ; commandLauncher . exec ( cmdLine , null , workingDir ) ; } else { try { if ( synchronous ) { result = executor . execute ( cmdLine ) ; } else { executor . execute ( cmdLine , new DefaultExecuteResultHandler ( ) ) ; } } catch ( ExecuteException e ) { // TODO : g\u00e9rer erreurs des ex\u00e9cutables (\u00e9ventuellement parser les erreurs classiques) getLog ( ) . info ( cmdLine . toString ( ) ) ; getLog ( ) . info ( stdOutAndErr . toString ( ) ) ; getLog ( ) . info ( result . toString ( ) ) ; throw new MojoExecutionException ( errorMsg , e ) ; } catch ( IOException e ) { throw new MojoExecutionException ( e . getMessage ( ) , e ) ; } } return result ; }'", "label": "'This calls a TIBCO binary .'"}
{"text": "'protected void launchTIBCOBinary ( File binary , List < File > tras , ArrayList < String > arguments , File workingDir , String errorMsg ) throws IOException , MojoExecutionException { launchTIBCOBinary ( binary , tras , arguments , workingDir , errorMsg , false , true ) ; }'", "label": "'Same as launchTIBCOBinary with fork = false and synchronous = true'"}
{"text": "'public void execute ( ) throws MojoExecutionException { if ( dependenciesIgnored == null ) { dependenciesIgnored = new ArrayList < String > ( ) ; } if ( ! directory . exists ( ) ) { directory . mkdirs ( ) ; } checkBWProject ( ) ; try { copyAliasesFile ( ) ; copyDesigner5Prefs ( ) ; copyDesignTimeLibs ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; // FIXME : remove printStackTrace() } }'", "label": "'<p > The execute method of this Mojo will : <ul > <li > check that the BusinessWorks project exists< / li > <li > copy the Designer5 . prefs file< / li > <li > copy the . designtimelibs file useful for setting a TIBCO environment for the project being built . < / li > < / ul > < / p >'"}
{"text": "'public List < JAXBElement < ? extends ActionType > > getAction ( ) { if ( action == null ) { action = new ArrayList < JAXBElement < ? extends ActionType > > ( ) ; } return this . action ; }'", "label": "'Gets the value of the action property .'"}
{"text": "'private void buildEAR ( File outputFile ) throws MojoExecutionException , IOException { checkBuildEAR ( ) ; // assert (outputFile != null); ArrayList < String > arguments = new ArrayList < String > ( ) ; arguments . add ( \"-ear\" ) ; // path of the Enterprise Archive \"builder\" relative to the BW project path arguments . add ( archiveFile ) ; arguments . add ( \"-p\" ) ; // BW project path arguments . add ( buildSrcDirectory . getAbsolutePath ( ) ) ; arguments . add ( \"-o\" ) ; // output file arguments . add ( outputFile . getAbsolutePath ( ) ) ; arguments . add ( \"-x\" ) ; // overwrite the output if ( tibcoBuildEARValidation ) { arguments . add ( \"-v\" ) ; // validate the project } File aliasesFile = new File ( directory , ALIASES_FILE ) ; if ( aliasesFile . exists ( ) ) { arguments . add ( \"-a\" ) ; arguments . add ( aliasesFile . getAbsolutePath ( ) ) ; } getLog ( ) . info ( BUILDING_EAR ) ; ArrayList < File > tras = new ArrayList < File > ( ) ; tras . add ( tibcoBuildEARTRAPath ) ; if ( tibcoBuildEARUseDesignerTRA ) { tras . add ( tibcoDesignerTRAPath ) ; } launchTIBCOBinary ( tibcoBuildEARPath , tras , arguments , directory , BUILD_EAR_FAILED ) ; }'", "label": "'This calls the buildear binary found in TIBCO TRA to build an EAR for the { @link AbstractBWMojo#project } defined by the { @link CompileEARMojo#archiveFile } .'"}
{"text": "'protected boolean cleanDirectory ( File directory ) { if ( directory . isDirectory ( ) && directory . listFiles ( ) . length != 0 ) { for ( File file : directory . listFiles ( ) ) { if ( file . isFile ( ) ) { file . delete ( ) ; } } } return directory . delete ( ) ; }'", "label": "'Delete all file of a directory and then delete this directory'"}
{"text": "'public java . util . List < String > getFinal ( ) { if ( _final == null ) { _final = new ArrayList < String > ( ) ; } return this . _final ; }'", "label": "'Gets the value of the final property .'"}
{"text": "'private void initProcessModel ( ) throws JAXBException { jaxbContext = JAXBContext . newInstance ( ObjectFactory . class ) ; Unmarshaller jaxbUnmarshaller = jaxbContext . createUnmarshaller ( ) ; Object o = jaxbUnmarshaller . unmarshal ( xmlFile ) ; this . process = ( ProcessDefinition ) o ; }'", "label": "'<p > This will initialize the { @link ProcessDefinition } object which is a JAXB representation of the ProcessDefinition root - element of TIBCO processes files using the schema with http : // xmlns . tibco . com / bw / process / 2003 namespace . < / p >'"}
{"text": "'public void save ( ) throws JAXBException { Marshaller m = jaxbContext . createMarshaller ( ) ; m . setProperty ( Marshaller . JAXB_FORMATTED_OUTPUT , true ) ; m . marshal ( process , xmlFile ) ; }'", "label": "'<p > This will marshall the object back to the XML file . < / p >'"}
{"text": "'public List < Rulebases . Rulebase > getRulebase ( ) { if ( rulebase == null ) { rulebase = new ArrayList < Rulebases . Rulebase > ( ) ; } return this . rulebase ; }'", "label": "'Gets the value of the rulebase property .'"}
{"text": "'private List < MethodSubscriber > monitorInstances ( List < ImmutablePair < String , String > > instances ) throws ConsoleInitializationException , MicroAgentException { List < MethodSubscriber > result = new ArrayList < MethodSubscriber > ( ) ; microAgent = new MicroAgent ( hawkDomain , hawkRvService , hawkRvNetwork , hawkRvDaemon , \"COM.TIBCO.admin.TRA\" ) ; getLog ( ) . info ( \"\" ) ; getLog ( ) . info ( SUBSCRIBING_TO_HAWK_METHODS ) ; for ( ImmutablePair < String , String > instance : instances ) { MethodSubscriber ms = new MethodSubscriber ( microAgent ) ; ms . setMethodName ( \"getComponentInstanceStatus\" ) ; ms . setArguments ( instance . left , instance . right ) ; ms . setInterval ( hawkSubscribeInterval ) ; ms . setNumberOfRetry ( hawkSubscribeNumberOfRetry ) ; ms . subscribe ( new RunningInstanceSubscriptionHandler ( getLog ( ) , ms , numberOfRunningStatuses ) ) ; result . add ( ms ) ; } return result ; }'", "label": "'This methods subscribe to the Hawk method COM . TIBCO . admin . TRA : getComponentInstanceStatus for all { @code instances } being started .'"}
{"text": "'private void initRepositoryModel ( ) throws JAXBException { jaxbContext = JAXBContext . newInstance ( ObjectFactory . class ) ; Unmarshaller jaxbUnmarshaller = jaxbContext . createUnmarshaller ( ) ; Object o = jaxbUnmarshaller . unmarshal ( xmlFile ) ; this . repository = ( Repository ) o ; }'", "label": "'<p > This will initialize the { @link Repository } object which is a JAXB representation of the Repository root - element of TIBCO . aliaslib files using the schema with http : // www . tibco . com / xmlns / repo / types / 2002 namespace . < / p >'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/dd\" , name = \"NameValuePairInteger\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/dd\" , substitutionHeadName = \"NVPair\" ) public JAXBElement < NameValuePairInteger > createNameValuePairInteger ( NameValuePairInteger value ) { return new JAXBElement < NameValuePairInteger > ( _NameValuePairInteger_QNAME , NameValuePairInteger . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link NameValuePairInteger } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/dd\" , name = \"DiffExcludeFilter\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/dd\" , substitutionHeadName = \"DeploymentDescriptor\" ) public JAXBElement < DiffExcludeFilter > createDiffExcludeFilter ( DiffExcludeFilter value ) { return new JAXBElement < DiffExcludeFilter > ( _DiffExcludeFilter_QNAME , DiffExcludeFilter . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link DiffExcludeFilter } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/dd\" , name = \"NameValuePairs\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/dd\" , substitutionHeadName = \"DeploymentDescriptor\" ) public JAXBElement < NameValuePairs > createNameValuePairs ( NameValuePairs value ) { return new JAXBElement < NameValuePairs > ( _NameValuePairs_QNAME , NameValuePairs . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link NameValuePairs } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/dd\" , name = \"ClassLoaderExtension\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/dd\" , substitutionHeadName = \"DeploymentDescriptor\" ) public JAXBElement < ClassLoaderExtension > createClassLoaderExtension ( ClassLoaderExtension value ) { return new JAXBElement < ClassLoaderExtension > ( _ClassLoaderExtension_QNAME , ClassLoaderExtension . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link ClassLoaderExtension } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/dd\" , name = \"DeploymentDescriptor\" ) public JAXBElement < DeploymentDescriptorType > createDeploymentDescriptor ( DeploymentDescriptorType value ) { return new JAXBElement < DeploymentDescriptorType > ( _DeploymentDescriptor_QNAME , DeploymentDescriptorType . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link DeploymentDescriptorType } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/dd\" , name = \"CustomTSMPlugInConfiguration\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/dd\" , substitutionHeadName = \"DeploymentDescriptor\" ) public JAXBElement < CustomTSMPlugInConfiguration > createCustomTSMPlugInConfiguration ( CustomTSMPlugInConfiguration value ) { return new JAXBElement < CustomTSMPlugInConfiguration > ( _CustomTSMPlugInConfiguration_QNAME , CustomTSMPlugInConfiguration . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link CustomTSMPlugInConfiguration } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/dd\" , name = \"NameValuePairBoolean\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/dd\" , substitutionHeadName = \"NVPair\" ) public JAXBElement < NameValuePairBoolean > createNameValuePairBoolean ( NameValuePairBoolean value ) { return new JAXBElement < NameValuePairBoolean > ( _NameValuePairBoolean_QNAME , NameValuePairBoolean . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link NameValuePairBoolean } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/dd\" , name = \"StartAsOneOf\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/dd\" , substitutionHeadName = \"DeploymentDescriptor\" ) public JAXBElement < StartAsOneOf > createStartAsOneOf ( StartAsOneOf value ) { return new JAXBElement < StartAsOneOf > ( _StartAsOneOf_QNAME , StartAsOneOf . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link StartAsOneOf } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/dd\" , name = \"Modules\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/dd\" , substitutionHeadName = \"DeploymentDescriptor\" ) public JAXBElement < Modules > createModules ( Modules value ) { return new JAXBElement < Modules > ( _Modules_QNAME , Modules . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link Modules } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/dd\" , name = \"DeploymentDescriptorFactory\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/dd\" , substitutionHeadName = \"DeploymentDescriptor\" ) public JAXBElement < DeploymentDescriptorFactory > createDeploymentDescriptorFactory ( DeploymentDescriptorFactory value ) { return new JAXBElement < DeploymentDescriptorFactory > ( _DeploymentDescriptorFactory_QNAME , DeploymentDescriptorFactory . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link DeploymentDescriptorFactory } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/dd\" , name = \"SupportsFaultTolerance\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/dd\" , substitutionHeadName = \"DeploymentDescriptor\" ) public JAXBElement < SupportsFaultTolerance > createSupportsFaultTolerance ( SupportsFaultTolerance value ) { return new JAXBElement < SupportsFaultTolerance > ( _SupportsFaultTolerance_QNAME , SupportsFaultTolerance . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link SupportsFaultTolerance } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/dd\" , name = \"RequiredComponents\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/dd\" , substitutionHeadName = \"DeploymentDescriptor\" ) public JAXBElement < RequiredComponents > createRequiredComponents ( RequiredComponents value ) { return new JAXBElement < RequiredComponents > ( _RequiredComponents_QNAME , RequiredComponents . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link RequiredComponents } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.w3.org/2001/XMLSchema\" , name = \"minInclusive\" ) public JAXBElement < Facet > createMinInclusive ( Facet value ) { return new JAXBElement < Facet > ( _MinInclusive_QNAME , Facet . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link Facet } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.w3.org/2001/XMLSchema\" , name = \"maxLength\" ) public JAXBElement < NumFacet > createMaxLength ( NumFacet value ) { return new JAXBElement < NumFacet > ( _MaxLength_QNAME , NumFacet . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link NumFacet } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.w3.org/2001/XMLSchema\" , name = \"sequence\" ) public JAXBElement < ExplicitGroup > createSequence ( ExplicitGroup value ) { return new JAXBElement < ExplicitGroup > ( _Sequence_QNAME , ExplicitGroup . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link ExplicitGroup } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.w3.org/2001/XMLSchema\" , name = \"minLength\" ) public JAXBElement < NumFacet > createMinLength ( NumFacet value ) { return new JAXBElement < NumFacet > ( _MinLength_QNAME , NumFacet . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link NumFacet } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.w3.org/2001/XMLSchema\" , name = \"group\" ) public JAXBElement < NamedGroup > createGroup ( NamedGroup value ) { return new JAXBElement < NamedGroup > ( _Group_QNAME , NamedGroup . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link NamedGroup } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.w3.org/2001/XMLSchema\" , name = \"attributeGroup\" ) public JAXBElement < NamedAttributeGroup > createAttributeGroup ( NamedAttributeGroup value ) { return new JAXBElement < NamedAttributeGroup > ( _AttributeGroup_QNAME , NamedAttributeGroup . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link NamedAttributeGroup } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.w3.org/2001/XMLSchema\" , name = \"key\" ) public JAXBElement < Keybase > createKey ( Keybase value ) { return new JAXBElement < Keybase > ( _Key_QNAME , Keybase . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link Keybase } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.w3.org/2001/XMLSchema\" , name = \"all\" ) public JAXBElement < All > createAll ( All value ) { return new JAXBElement < All > ( _All_QNAME , All . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link All } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.w3.org/2001/XMLSchema\" , name = \"length\" ) public JAXBElement < NumFacet > createLength ( NumFacet value ) { return new JAXBElement < NumFacet > ( _Length_QNAME , NumFacet . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link NumFacet } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.w3.org/2001/XMLSchema\" , name = \"simpleType\" ) public JAXBElement < TopLevelSimpleType > createSimpleType ( TopLevelSimpleType value ) { return new JAXBElement < TopLevelSimpleType > ( _SimpleType_QNAME , TopLevelSimpleType . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link TopLevelSimpleType } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.w3.org/2001/XMLSchema\" , name = \"enumeration\" ) public JAXBElement < NoFixedFacet > createEnumeration ( NoFixedFacet value ) { return new JAXBElement < NoFixedFacet > ( _Enumeration_QNAME , NoFixedFacet . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link NoFixedFacet } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.w3.org/2001/XMLSchema\" , name = \"choice\" ) public JAXBElement < ExplicitGroup > createChoice ( ExplicitGroup value ) { return new JAXBElement < ExplicitGroup > ( _Choice_QNAME , ExplicitGroup . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link ExplicitGroup } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.w3.org/2001/XMLSchema\" , name = \"fractionDigits\" ) public JAXBElement < NumFacet > createFractionDigits ( NumFacet value ) { return new JAXBElement < NumFacet > ( _FractionDigits_QNAME , NumFacet . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link NumFacet } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.w3.org/2001/XMLSchema\" , name = \"minExclusive\" ) public JAXBElement < Facet > createMinExclusive ( Facet value ) { return new JAXBElement < Facet > ( _MinExclusive_QNAME , Facet . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link Facet } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.w3.org/2001/XMLSchema\" , name = \"maxExclusive\" ) public JAXBElement < Facet > createMaxExclusive ( Facet value ) { return new JAXBElement < Facet > ( _MaxExclusive_QNAME , Facet . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link Facet } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.w3.org/2001/XMLSchema\" , name = \"element\" ) public JAXBElement < TopLevelElement > createElement ( TopLevelElement value ) { return new JAXBElement < TopLevelElement > ( _Element_QNAME , TopLevelElement . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link TopLevelElement } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.w3.org/2001/XMLSchema\" , name = \"unique\" ) public JAXBElement < Keybase > createUnique ( Keybase value ) { return new JAXBElement < Keybase > ( _Unique_QNAME , Keybase . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link Keybase } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.w3.org/2001/XMLSchema\" , name = \"complexType\" ) public JAXBElement < TopLevelComplexType > createComplexType ( TopLevelComplexType value ) { return new JAXBElement < TopLevelComplexType > ( _ComplexType_QNAME , TopLevelComplexType . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link TopLevelComplexType } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.w3.org/2001/XMLSchema\" , name = \"maxInclusive\" ) public JAXBElement < Facet > createMaxInclusive ( Facet value ) { return new JAXBElement < Facet > ( _MaxInclusive_QNAME , Facet . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link Facet } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.w3.org/2001/XMLSchema\" , name = \"attribute\" ) public JAXBElement < TopLevelAttribute > createAttribute ( TopLevelAttribute value ) { return new JAXBElement < TopLevelAttribute > ( _Attribute_QNAME , TopLevelAttribute . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link TopLevelAttribute } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.w3.org/2001/XMLSchema\" , name = \"anyAttribute\" ) public JAXBElement < Wildcard > createAnyAttribute ( Wildcard value ) { return new JAXBElement < Wildcard > ( _AnyAttribute_QNAME , Wildcard . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link Wildcard } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.w3.org/2001/XMLSchema\" , name = \"element\" , scope = Group . class ) public JAXBElement < LocalElement > createGroupElement ( LocalElement value ) { return new JAXBElement < LocalElement > ( _Element_QNAME , LocalElement . class , Group . class , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link LocalElement } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.w3.org/2001/XMLSchema\" , name = \"group\" , scope = Group . class ) public JAXBElement < GroupRef > createGroupGroup ( GroupRef value ) { return new JAXBElement < GroupRef > ( _Group_QNAME , GroupRef . class , Group . class , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link GroupRef } { @code > }}'"}
{"text": "'private List < File > initFiles ( ) throws IOException { FileSet restriction = new FileSet ( ) ; File directory = buildSrcDirectory ; if ( directory == null ) { directory = new File ( \".\" ) ; getLog ( ) . warn ( SRC_NOT_SET ) ; } getLog ( ) . debug ( directory . getAbsolutePath ( ) ) ; restriction . setDirectory ( directory . getAbsolutePath ( ) ) ; restriction . addInclude ( \"**/*.aliaslib\" ) ; List < File > result = AbstractProjectsListMojo . toFileList ( restriction ) ; if ( customAliasLibDirectories != null && ! customAliasLibDirectories . isEmpty ( ) ) { for ( File customDirectory : customAliasLibDirectories ) { getLog ( ) . debug ( \"Looking for \\'.aliaslib\\' files in custom directory: \" + customDirectory ) ; FileSet customRestriction = new FileSet ( ) ; customRestriction . setDirectory ( customDirectory . getAbsolutePath ( ) ) ; customRestriction . addInclude ( \"**/*.aliaslib\" ) ; result . addAll ( AbstractProjectsListMojo . toFileList ( customRestriction ) ) ; } } getLog ( ) . debug ( \"List of \\'.aliaslib\\' files to update: \" + result ) ; return result ; }'", "label": "'This method retrieves a list of . aliaslib files to process in the source directory ( usually target / src ) which is a copy of the actual source directory used to compile the TIBCO BusinessWorks EAR .'"}
{"text": "'private void addAlias ( ArrayList < HashMap < String , Object > > list , String aliasName ) { for ( HashMap < String , Object > h : list ) { String name = ( String ) h . get ( \"name\" ) ; if ( name != null && name . equals ( aliasName ) ) { return ; // avoid duplicates } } HashMap < String , Object > h = new HashMap < String , Object > ( ) ; h . put ( \"isClasspathFile\" , Boolean . TRUE ) ; h . put ( \"name\" , aliasName ) ; h . put ( \"includeInDeployment\" , Boolean . TRUE ) ; list . add ( h ) ; }'", "label": "'This method add an alias in the object used internally by TIBCO BusinessWorks .'"}
{"text": "'public void processFile ( File f ) throws MojoExecutionException { try { RepositoryModel repositoryModel = new RepositoryModel ( f ) ; ArrayList < HashMap < String , Object > > aliases = readXMLBean ( repositoryModel , f ) ; // reset old references if ( ! keepOriginalAliasLib ) { aliases . clear ( ) ; } // adding the JAR dependencies for ( Dependency dependency : jarDependencies ) { addAlias ( aliases , getJarAlias ( dependency , false ) ) ; } writeXMLBean ( repositoryModel , f , aliases ) ; } catch ( Exception e ) { throw new MojoExecutionException ( e . getMessage ( ) , e ) ; } }'", "label": "'This method adds the JAR aliases to a . aliaslib file'"}
{"text": "'private void buildProjlib ( File outputFile ) throws MojoExecutionException , IOException { checkDesignerBuildLibrary ( ) ; assert ( outputFile != null ) ; ArrayList < String > arguments = new ArrayList < String > ( ) ; arguments . add ( \"-lib\" ) ; // path of the libbuilder relative to the BW project path arguments . add ( libBuilder ) ; arguments . add ( \"-p\" ) ; // BW project path arguments . add ( buildSrcDirectory . getAbsolutePath ( ) ) ; arguments . add ( \"-o\" ) ; // output file arguments . add ( outputFile . getAbsolutePath ( ) ) ; arguments . add ( \"-x\" ) ; // overwrite the output if ( ! hideLibraryResources ) { arguments . add ( \"-v\" ) ; // validate the project } getLog ( ) . info ( BUILDING_PROJLIB ) ; ArrayList < File > tras = new ArrayList < File > ( ) ; tras . add ( tibcoBuildLibraryTRAPath ) ; if ( tibcoBuildLibraryUseDesignerTRA ) { tras . add ( tibcoDesignerTRAPath ) ; } launchTIBCOBinary ( tibcoBuildLibraryPath , tras , arguments , directory , BUILD_PROJLIB_FAILED ) ; }'", "label": "'This calls the buildlibrary binary found in TIBCO Designer to build a Projlib for the { @link AbstractBWMojo#project } defined by the { @link CompileProjlibMojo#libBuilder } .'"}
{"text": "'public List < JAXBElement < ? extends TExtensibleAttributesDocumented > > getRest ( ) { if ( rest == null ) { rest = new ArrayList < JAXBElement < ? extends TExtensibleAttributesDocumented > > ( ) ; } return this . rest ; }'", "label": "'Gets the rest of the content model .'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://schemas.xmlsoap.org/wsdl/\" , name = \"definitions\" ) public JAXBElement < TDefinitions > createDefinitions ( TDefinitions value ) { return new JAXBElement < TDefinitions > ( _Definitions_QNAME , TDefinitions . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link TDefinitions } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://schemas.xmlsoap.org/wsdl/\" , name = \"fault\" , scope = TOperation . class ) public JAXBElement < TFault > createTOperationFault ( TFault value ) { return new JAXBElement < TFault > ( _TOperationFault_QNAME , TFault . class , TOperation . class , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link TFault } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://schemas.xmlsoap.org/wsdl/\" , name = \"output\" , scope = TOperation . class ) public JAXBElement < TParam > createTOperationOutput ( TParam value ) { return new JAXBElement < TParam > ( _TOperationOutput_QNAME , TParam . class , TOperation . class , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link TParam } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://schemas.xmlsoap.org/wsdl/\" , name = \"input\" , scope = TOperation . class ) public JAXBElement < TParam > createTOperationInput ( TParam value ) { return new JAXBElement < TParam > ( _TOperationInput_QNAME , TParam . class , TOperation . class , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link TParam } { @code > }}'"}
{"text": "'public static void main ( String [ ] args ) { MethodInvocator ca = null ; if ( args . length != 4 ) { System . err . println ( \"Usage: java ConsoleApp <hawkDomain> <rvService> <rvNetwork> <rvDaemon>\" ) ; return ; } if ( args . length == 4 ) { try { ca = new MethodInvocator ( args [ 0 ] , args [ 1 ] , args [ 2 ] , args [ 3 ] , \"COM.TIBCO.admin.TRA\" ) ; ca . setMethodName ( \"getComponentInstanceStatus\" ) ; ca . setArguments ( \"TEC-JMS\" , \"TEC-JMS-IN\" ) ; //\\t\\t\\t\\tca.setMethodName(\"getFileStatusForComponentFile\"); //\\t\\t\\t\\tca.setArguments(\"TEC-JMS\", \"TEC-JMS-IN\", \"C:/tibco/tra/domain/LOCAL/application/logs/TEC-JMS-TEC-JMS-IN.log\"); ca . invocate ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { System . exit ( 0 ) ; } } }'", "label": "'Main - Usage : java ConsoleApp <hawkDomain > <rvService > <rvNetwork > <rvDaemon >'"}
{"text": "'private List < String > getActiveModules ( List < Profile > activeProfiles , Model model ) { List < String > modules = model . getModules ( ) ; for ( Profile profile : model . getProfiles ( ) ) { Boolean found = false ; for ( Profile p : activeProfiles ) { if ( p . getId ( ) . equals ( profile . getId ( ) ) ) { found = true ; break ; } } if ( ! found ) continue ; for ( String module : profile . getModules ( ) ) { if ( modules . indexOf ( module ) < 0 ) { modules . add ( module ) ; } } } return modules ; }'", "label": "'/ * modules'"}
{"text": "'public List < JAXBElement < ? extends NVPairType > > getNVPair ( ) { if ( nvPair == null ) { nvPair = new ArrayList < JAXBElement < ? extends NVPairType > > ( ) ; } return this . nvPair ; }'", "label": "'Gets the value of the nvPair property .'"}
{"text": "'public static Model getModelFromPOM ( File pom , Log logger ) throws IOException , XmlPullParserException { Model model = null ; FileInputStream fis = null ; InputStreamReader isr = null ; try { fis = new FileInputStream ( pom ) ; isr = new InputStreamReader ( fis , \"utf-8\" ) ; // FIXME MavenXpp3Reader reader = new MavenXpp3Reader ( ) ; model = reader . read ( isr ) ; } finally { try { isr . close ( ) ; fis . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return model ; }'", "label": "'Load a Maven { @link Model } object from a POM file .'"}
{"text": "'public static Model mergeModelFromPOM ( File pom , Model existingModel , Log logger ) throws IOException , XmlPullParserException { if ( pom == null || ! pom . exists ( ) || existingModel == null || logger == null ) return null ; Model model = null ; FileInputStream fis = null ; InputStreamReader isr = null ; try { fis = new FileInputStream ( pom ) ; isr = new InputStreamReader ( fis , \"utf-8\" ) ; // FIXME MavenXpp3Reader reader = new MavenXpp3Reader ( ) ; model = reader . read ( isr ) ; DefaultInheritanceAssembler assembler = new DefaultInheritanceAssembler ( ) ; assembler . assembleModelInheritance ( model , existingModel , null , null ) ; } finally { try { isr . close ( ) ; fis . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return model ; }'", "label": "'Merge a Maven { @link Model } object from a POM file to an existing Maven { @link Model } object .'"}
{"text": "'public static void writeModelToPOM ( Model model , File pom , Log logger ) throws IOException { FileOutputStream fos = new FileOutputStream ( pom ) ; new MavenXpp3Writer ( ) . write ( fos , model ) ; try { fos . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }'", "label": "'Write a Maven { @link Model } object to a POM file .'"}
{"text": "'public static void addDependency ( File pom , Dependency dependency , Log logger ) throws IOException , XmlPullParserException { Model model = getModelFromPOM ( pom , logger ) ; model . addDependency ( dependency ) ; writeModelToPOM ( model , pom , logger ) ; }'", "label": "'Add the Maven dependency to a POM file .'"}
{"text": "'public static void addDependencyManagement ( File pom , Dependency dependency , Log logger ) throws IOException , XmlPullParserException { Model model = getModelFromPOM ( pom , logger ) ; DependencyManagement dMgmt = model . getDependencyManagement ( ) ; if ( dMgmt == null ) { model . setDependencyManagement ( new DependencyManagement ( ) ) ; dMgmt = model . getDependencyManagement ( ) ; } dMgmt . addDependency ( dependency ) ; writeModelToPOM ( model , pom , logger ) ; }'", "label": "'Add the Maven dependency to a POM file ( in management section ) .'"}
{"text": "'public static void removeDependency ( File pom , Dependency dependency , Log logger ) throws IOException , XmlPullParserException { Model model = getModelFromPOM ( pom , logger ) ; for ( Iterator < Dependency > it = model . getDependencies ( ) . iterator ( ) ; it . hasNext ( ) ; ) { if ( dependenciesEqual ( it . next ( ) , dependency ) ) { it . remove ( ) ; } } writeModelToPOM ( model , pom , logger ) ; }'", "label": "'Remove the Maven dependency from a POM file .'"}
{"text": "'public static void removeDependencyManagement ( File pom , Dependency dependency , Log logger ) throws IOException , XmlPullParserException { Model model = getModelFromPOM ( pom , logger ) ; DependencyManagement dMgmt = model . getDependencyManagement ( ) ; if ( dMgmt == null ) { model . setDependencyManagement ( new DependencyManagement ( ) ) ; dMgmt = model . getDependencyManagement ( ) ; } for ( Iterator < Dependency > it = dMgmt . getDependencies ( ) . iterator ( ) ; it . hasNext ( ) ; ) { if ( dependenciesEqual ( it . next ( ) , dependency ) ) { it . remove ( ) ; } } writeModelToPOM ( model , pom , logger ) ; }'", "label": "'Remove the Maven dependency from a POM file ( in management section ) .'"}
{"text": "'private static boolean dependencyExists ( Dependency dependency , List < Dependency > dependencies ) { for ( Dependency d : dependencies ) { if ( dependenciesEqual ( dependency , d ) ) { return true ; } } return false ; }'", "label": "'Check whether a dependency exists in a list of dependencies .'"}
{"text": "'public static boolean dependencyExists ( File pom , Dependency dependency , Log logger ) throws IOException , XmlPullParserException { Model model = getModelFromPOM ( pom , logger ) ; return dependencyExists ( dependency , model . getDependencies ( ) ) ; }'", "label": "'Check whether a dependency exists in a POM .'"}
{"text": "'public static boolean dependencyExistsManagement ( File pom , Dependency dependency , Log logger ) throws IOException , XmlPullParserException { Model model = getModelFromPOM ( pom , logger ) ; DependencyManagement dMgmt = model . getDependencyManagement ( ) ; if ( dMgmt == null ) { model . setDependencyManagement ( new DependencyManagement ( ) ) ; dMgmt = model . getDependencyManagement ( ) ; } return dependencyExists ( dependency , dMgmt . getDependencies ( ) ) ; }'", "label": "'Check whether a dependency exists in a POM ( in management section ) .'"}
{"text": "'public static void addProjectAsModule ( File pom , String relativePath , String profileId , Log logger ) throws IOException , XmlPullParserException { if ( relativePath == null ) return ; Model model = getModelFromPOM ( pom , logger ) ; relativePath = relativePath . replace ( \"\\\\\\\\\" , \"/\" ) ; if ( profileId != null && ! profileId . isEmpty ( ) ) { Profile p = getProfile ( model , profileId ) ; if ( p != null ) { p . addModule ( relativePath ) ; } } else { model . addModule ( relativePath ) ; } writeModelToPOM ( model , pom , logger ) ; }'", "label": "'Add a project as a module .'"}
{"text": "'public static boolean moduleExists ( File pom , String relativePath , String profileId , Log logger ) throws IOException , XmlPullParserException { if ( relativePath == null ) return false ; Model model = getModelFromPOM ( pom , logger ) ; relativePath = relativePath . replace ( \"\\\\\\\\\" , \"/\" ) ; if ( profileId != null && ! profileId . isEmpty ( ) ) { Profile p = getProfile ( model , profileId ) ; if ( p != null ) { return p . getModules ( ) . indexOf ( relativePath ) >= 0 ; } } else { return model . getModules ( ) . indexOf ( relativePath ) >= 0 ; } return false ; }'", "label": "'Check whether a module exists in a POM .'"}
{"text": "'protected Properties loadPropertiesFile ( File propertiesFile ) throws ConfigurationException , IOException { Properties properties = new Properties ( ) { // sorted properties private static final long serialVersionUID = 7793482336210629858L ; @ Override public synchronized Enumeration < Object > keys ( ) { return Collections . enumeration ( new TreeSet < Object > ( super . keySet ( ) ) ) ; } } ; FileInputStream fileInputStream = new FileInputStream ( propertiesFile ) ; properties . load ( fileInputStream ) ; return properties ; }'", "label": "'<p > This loads a properties file into a java . util . Properties object with sorted keys . <br / > <br / >'"}
{"text": "'protected void savePropertiesToFile ( File outputFile , Properties properties , String propertiesComment , String success , String failure ) throws MojoExecutionException { OutputStream outputStream = null ; try { outputFile . getParentFile ( ) . mkdirs ( ) ; outputStream = new FileOutputStream ( outputFile ) ; properties . store ( outputStream , propertiesComment ) ; if ( filterProperties ) { getLog ( ) . debug ( \"Filtering properties files\" ) ; File tmpDir = new File ( outputFile . getParentFile ( ) , \"tmp\" ) ; tmpDir . mkdir ( ) ; List < Resource > resources = new ArrayList < Resource > ( ) ; Resource r = new Resource ( ) ; r . setDirectory ( outputFile . getParentFile ( ) . getAbsolutePath ( ) ) ; r . addInclude ( \"*.properties\" ) ; r . setFiltering ( true ) ; resources . add ( r ) ; ArrayList < Object > filters = new ArrayList < Object > ( ) ; List < String > nonFilteredFileExtensions = new ArrayList < String > ( ) ; MavenResourcesExecution mre = new MavenResourcesExecution ( resources , tmpDir , this . getProject ( ) , this . sourceEncoding , filters , nonFilteredFileExtensions , session ) ; mavenResourcesFiltering . filterResources ( mre ) ; FileUtils . copyDirectory ( tmpDir , outputFile . getParentFile ( ) ) ; FileUtils . deleteDirectory ( tmpDir ) ; } getLog ( ) . info ( success + \" \\'\" + outputFile + \"\\'\" ) ; } catch ( Exception e ) { throw new MojoExecutionException ( failure + \" \\'\" + outputFile + \"\\'\" , e ) ; } finally { try { outputStream . close ( ) ; } catch ( Exception e ) { } } }'", "label": "'<p > This saves a java . util . Properties to a file . <br / >'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"performPolicy\" ) public JAXBElement < String > createPerformPolicy ( String value ) { return new JAXBElement < String > ( _PerformPolicy_QNAME , String . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link String } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"container\" ) public JAXBElement < String > createContainer ( String value ) { return new JAXBElement < String > ( _Container_QNAME , String . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link String } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"machine\" ) public JAXBElement < String > createMachine ( String value ) { return new JAXBElement < String > ( _Machine_QNAME , String . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link String } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"formFlow\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , substitutionHeadName = \"baseService\" ) public JAXBElement < FormFlow > createFormFlow ( FormFlow value ) { return new JAXBElement < FormFlow > ( _FormFlow_QNAME , FormFlow . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link FormFlow } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"httpRepoInstance\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , substitutionHeadName = \"remoteRepoInstance\" ) public JAXBElement < HttpRepoInstance > createHttpRepoInstance ( HttpRepoInstance value ) { return new JAXBElement < HttpRepoInstance > ( _HttpRepoInstance_QNAME , HttpRepoInstance . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link HttpRepoInstance } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"emailAction\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , substitutionHeadName = \"action\" ) public JAXBElement < EmailAction > createEmailAction ( EmailAction value ) { return new JAXBElement < EmailAction > ( _EmailAction_QNAME , EmailAction . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link EmailAction } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"remoteRepoInstance\" ) public JAXBElement < RemoteRepoInstanceType > createRemoteRepoInstance ( RemoteRepoInstanceType value ) { return new JAXBElement < RemoteRepoInstanceType > ( _RemoteRepoInstance_QNAME , RemoteRepoInstanceType . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link RemoteRepoInstanceType } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"level\" ) public JAXBElement < String > createLevel ( String value ) { return new JAXBElement < String > ( _Level_QNAME , String . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link String } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"event\" ) public JAXBElement < EventType > createEvent ( EventType value ) { return new JAXBElement < EventType > ( _Event_QNAME , EventType . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link EventType } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"bw\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , substitutionHeadName = \"baseService\" ) public JAXBElement < Bw > createBw ( Bw value ) { return new JAXBElement < Bw > ( _Bw_QNAME , Bw . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link Bw } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"NVPair\" ) public JAXBElement < NVPairType > createNVPair ( NVPairType value ) { return new JAXBElement < NVPairType > ( _NVPair_QNAME , NVPairType . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link NVPairType } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"failureEvent\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , substitutionHeadName = \"event\" ) public JAXBElement < FailureEvent > createFailureEvent ( FailureEvent value ) { return new JAXBElement < FailureEvent > ( _FailureEvent_QNAME , FailureEvent . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link FailureEvent } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"suspendProcessEvent\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , substitutionHeadName = \"event\" ) public JAXBElement < SuspendProcessEvent > createSuspendProcessEvent ( SuspendProcessEvent value ) { return new JAXBElement < SuspendProcessEvent > ( _SuspendProcessEvent_QNAME , SuspendProcessEvent . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link SuspendProcessEvent } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"customAction\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , substitutionHeadName = \"action\" ) public JAXBElement < CustomAction > createCustomAction ( CustomAction value ) { return new JAXBElement < CustomAction > ( _CustomAction_QNAME , CustomAction . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link CustomAction } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"service\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , substitutionHeadName = \"baseService\" ) public JAXBElement < Service > createService ( Service value ) { return new JAXBElement < Service > ( _Service_QNAME , Service . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link Service } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"checkPointRecoveryStorage\" , defaultValue = \"false\" ) public JAXBElement < Boolean > createCheckPointRecoveryStorage ( Boolean value ) { return new JAXBElement < Boolean > ( _CheckPointRecoveryStorage_QNAME , Boolean . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link Boolean } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"logEvent\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , substitutionHeadName = \"event\" ) public JAXBElement < LogEvent > createLogEvent ( LogEvent value ) { return new JAXBElement < LogEvent > ( _LogEvent_QNAME , LogEvent . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link LogEvent } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"checkpoint\" ) public JAXBElement < String > createCheckpoint ( String value ) { return new JAXBElement < String > ( _Checkpoint_QNAME , String . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link String } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"im\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , substitutionHeadName = \"baseService\" ) public JAXBElement < Im > createIm ( Im value ) { return new JAXBElement < Im > ( _Im_QNAME , Im . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link Im } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"adapter\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , substitutionHeadName = \"baseService\" ) public JAXBElement < Adapter > createAdapter ( Adapter value ) { return new JAXBElement < Adapter > ( _Adapter_QNAME , Adapter . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link Adapter } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"NameValuePair\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , substitutionHeadName = \"NVPair\" ) public JAXBElement < NameValuePair > createNameValuePair ( NameValuePair value ) { return new JAXBElement < NameValuePair > ( _NameValuePair_QNAME , NameValuePair . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link NameValuePair } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"baseService\" ) public JAXBElement < ServiceType > createBaseService ( ServiceType value ) { return new JAXBElement < ServiceType > ( _BaseService_QNAME , ServiceType . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link ServiceType } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"rvRepoInstance\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , substitutionHeadName = \"remoteRepoInstance\" ) public JAXBElement < RvRepoInstance > createRvRepoInstance ( RvRepoInstance value ) { return new JAXBElement < RvRepoInstance > ( _RvRepoInstance_QNAME , RvRepoInstance . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link RvRepoInstance } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"application\" ) public JAXBElement < ApplicationType > createApplication ( ApplicationType value ) { return new JAXBElement < ApplicationType > ( _Application_QNAME , ApplicationType . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link ApplicationType } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"isFt\" ) public JAXBElement < Boolean > createIsFt ( Boolean value ) { return new JAXBElement < Boolean > ( _IsFt_QNAME , Boolean . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link Boolean } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"NameValuePairPassword\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , substitutionHeadName = \"NVPair\" ) public JAXBElement < NameValuePairPassword > createNameValuePairPassword ( NameValuePairPassword value ) { return new JAXBElement < NameValuePairPassword > ( _NameValuePairPassword_QNAME , NameValuePairPassword . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link NameValuePairPassword } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"localRepoInstance\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , substitutionHeadName = \"repoInstance\" ) public JAXBElement < LocalRepoInstance > createLocalRepoInstance ( LocalRepoInstance value ) { return new JAXBElement < LocalRepoInstance > ( _LocalRepoInstance_QNAME , LocalRepoInstance . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link LocalRepoInstance } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"repoInstance\" ) public JAXBElement < RepoInstanceType > createRepoInstance ( RepoInstanceType value ) { return new JAXBElement < RepoInstanceType > ( _RepoInstance_QNAME , RepoInstanceType . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link RepoInstanceType } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"startupType\" , defaultValue = \"automatic\" ) public JAXBElement < String > createStartupType ( String value ) { return new JAXBElement < String > ( _StartupType_QNAME , String . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link String } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"alertAction\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , substitutionHeadName = \"action\" ) public JAXBElement < AlertAction > createAlertAction ( AlertAction value ) { return new JAXBElement < AlertAction > ( _AlertAction_QNAME , AlertAction . class , null , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link AlertAction } { @code > }}'"}
{"text": "'@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"extends\" , scope = Plugins . class ) public JAXBElement < AnyObject > createPluginsExtends ( AnyObject value ) { return new JAXBElement < AnyObject > ( _PluginsExtends_QNAME , AnyObject . class , Plugins . class , value ) ; }'", "label": "'Create an instance of { @link JAXBElement } { @code < } { @link AnyObject } { @code > }}'"}
{"text": "'private Artifact extractArtifact ( Artifact a , String type , String classifier ) { if ( a == null ) { return a ; } Artifact result = new DefaultArtifact ( a . getGroupId ( ) , a . getArtifactId ( ) , a . getVersionRange ( ) , a . getScope ( ) , type , classifier , new DefaultArtifactHandler ( type ) ) ; return result ; }'", "label": "'This returns a { @link DefaultArtifact } object with the same groupId artifactId version and scope as the main artifact of the project ( for instance bw - ear or projlib ) .'"}
{"text": "'protected File getArtifactFile ( File basedir , String finalName , String classifier ) { if ( classifier == null ) { classifier = \"\" ; } else if ( classifier . trim ( ) . length ( ) > 0 && ! classifier . startsWith ( \"-\" ) ) { classifier = \"-\" + classifier ; } return new File ( basedir , finalName + classifier + getArtifactFileExtension ( ) ) ; }'", "label": "'Retrieves the full path of the artifact that will be created .'"}
{"text": "'public void execute ( ) throws MojoExecutionException { if ( this . resources . size ( ) == 0 ) { throw new MojoExecutionException ( \"No resources configured\" ) ; } // Prefered to count error instead of failing on the first one. int errCount = 0 ; // Iterate on all configured resources. for ( final XPathResource r : this . resources ) { try { classBytesToBWJavaXPath ( r ) ; } catch ( Exception e ) { super . getLog ( ) . error ( e ) ; errCount ++ ; } } if ( errCount > 0 ) { throw new MojoExecutionException ( \"There was \" + errCount + \" error(s) during goal execution, check above.\" ) ; } }'", "label": "'MOJO execution method .'"}
{"text": "'protected String extractFileContent ( final String filename ) throws IOException { final StringBuilder sb = new StringBuilder ( ) ; String temp = \"\" ; final BufferedReader bufferedReader = new BufferedReader ( new FileReader ( filename ) ) ; try { while ( temp != null ) { temp = bufferedReader . readLine ( ) ; if ( temp != null ) { sb . append ( temp ) ; } } return sb . toString ( ) ; } finally { bufferedReader . close ( ) ; } }'", "label": "'Reads the complete content of the javaxpath file .'"}
{"text": "'protected byte [ ] getBytesForClass ( final String className ) throws RuntimeException { try { ClassLoader classLoader = this . getClass ( ) . getClassLoader ( ) ; InputStream stream = classLoader . getResourceAsStream ( className . replace ( \".\" , \"/\" ) + \".class\" ) ; if ( stream == null ) { throw new NullPointerException ( \"Class \" + className + \" could not be loaded. Check plugin dependencies.\" ) ; } byte [ ] byteArray = new byte [ 1024000 ] ; int readBytes = 0 ; int currentOffset = 0 ; while ( ( readBytes = stream . read ( byteArray , currentOffset , 1024 ) ) >= 0 ) { currentOffset += readBytes ; } return Arrays . copyOf ( byteArray , currentOffset ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }'", "label": "'Reads a class byte code from current { @link ClassLoader }'"}
{"text": "'public ArrayList < String > commonArguments ( ) { ArrayList < String > arguments = new ArrayList < String > ( ) ; arguments . add ( \"-app\" ) ; arguments . add ( deployedProjectName ) ; arguments . add ( \"-domain\" ) ; arguments . add ( domainName ) ; arguments . add ( \"-user\" ) ; arguments . add ( domainUsername ) ; arguments . add ( \"-pw\" ) ; arguments . add ( domainPassword ) ; return arguments ; }'", "label": "'<p > For each AppManage command a common set of arguments is required ( domain project name ... ) < / p >'"}
{"text": "'private void init ( ) throws MojoExecutionException { try { FileUtils . copyFile ( deploymentDescriptor , deploymentDescriptorFinal ) ; } catch ( IOException e ) { throw new MojoExecutionException ( APPLICATION_MANAGEMENT_COPY_FAILURE + \" \\'\" + deploymentDescriptor + \"\\' to \\'\" + deploymentDescriptorFinal + \"\\'\" , e ) ; } try { application = new ApplicationManagement ( deploymentDescriptorFinal ) ; } catch ( JAXBException e ) { throw new MojoExecutionException ( APPLICATION_MANAGEMENT_LOAD_FAILURE + \" \\'\" + deploymentDescriptorFinal + \"\\'\" , e ) ; } }'", "label": "'<p > First we will copy the XML file extracted from the EAR to the final file to be produced after merging all the properties files . < / p >'"}
{"text": "'private void mergeGlobalVariables ( ) throws MojoExecutionException { Properties propertiesGlobalVariables ; try { propertiesGlobalVariables = loadPropertiesFile ( deploymentGlobalVariables ) ; } catch ( Exception e ) { throw new MojoExecutionException ( PROPERTIES_GLOBAL_VARIABLES_LOAD_FAILURE + \" \\'\" + deploymentGlobalVariables + \"\\'\" , e ) ; } Enumeration < Object > e = propertiesGlobalVariables . keys ( ) ; while ( e . hasMoreElements ( ) ) { String key = ( String ) e . nextElement ( ) ; String value = propertiesGlobalVariables . getProperty ( key ) ; application . setGlobalVariable ( key , value ) ; } }'", "label": "'<p > This will merge the Global Variables properties file into the { @link ApplicationType } object . < / p >'"}
{"text": "'private void updateRepoInstances ( ) { RepoInstances repoInstances = application . getRepoInstances ( ) ; RvRepoInstance rvRepoInstance = repoInstances . getRvRepoInstance ( ) ; rvRepoInstance . setDiscoveryTimout ( BigInteger . valueOf ( repoRvDiscoveryTimeout ) ) ; rvRepoInstance . setTimeout ( BigInteger . valueOf ( repoRvTimeout ) ) ; rvRepoInstance . setDaemon ( repoRvDaemon ) ; rvRepoInstance . setService ( repoRvService ) ; rvRepoInstance . setNetwork ( repoRvNetwork ) ; rvRepoInstance . setRegionalSubject ( repoRvRegionalSubject ) ; rvRepoInstance . setOperationRetry ( BigInteger . valueOf ( repoRvOperationRetry ) ) ; rvRepoInstance . setExtraPropertyFile ( repoRvExtraPropertyFile ) ; rvRepoInstance . setServer ( repoRvServer ) ; rvRepoInstance . setUser ( repoRvUser ) ; rvRepoInstance . setPassword ( repoRvPassword ) ; HttpRepoInstance httpRepoInstance = repoInstances . getHttpRepoInstance ( ) ; httpRepoInstance . setTimeout ( BigInteger . valueOf ( repoHttpTimeout ) ) ; httpRepoInstance . setUrl ( repoHttpUrl ) ; httpRepoInstance . setServer ( repoHttpServer ) ; httpRepoInstance . setUser ( repoHttpUser ) ; httpRepoInstance . setPassword ( repoHttpPassword ) ; httpRepoInstance . setExtraPropertyFile ( repoHttpExtraPropertyFile ) ; LocalRepoInstance localRepoInstance = repoInstances . getLocalRepoInstance ( ) ; EncodingType encoding ; try { encoding = EncodingType . valueOf ( repoLocalEncoding ) ; } catch ( IllegalArgumentException e ) { encoding = EncodingType . UTF_8 ; } localRepoInstance . setEncoding ( encoding ) ; repoInstances . setRvRepoInstance ( rvRepoInstance ) ; repoInstances . setHttpRepoInstance ( httpRepoInstance ) ; repoInstances . setLocalRepoInstance ( localRepoInstance ) ; RepoType repoType ; try { repoType = RepoType . valueOf ( repoSelectInstance . toUpperCase ( ) ) ; } catch ( IllegalArgumentException e ) { repoType = RepoType . LOCAL ; } repoInstances . setSelected ( repoType ) ; }'", "label": "'This will update the &lt ; repoInstances > element .'"}
{"text": "'private void copyRuntimeJARsInEAR ( File ear ) throws IOException , JDOMException { Fileset fileSet = new Fileset ( ) ; fileSet . setDirectory ( buildLibDirectory . getAbsolutePath ( ) ) ; for ( Dependency dependency : this . getJarDependencies ( ) ) { String jarName = getJarName ( dependency , false ) ; fileSet . addInclude ( jarName ) ; // using jarName because files are all in buildLibDirectory } String ouptutDirectory = ear . getAbsolutePath ( ) + File . separator + \"lib.zip\" + File . separator + \"WEB-INF\" + File . separator + \"lib\" ; fileSet . setOutputDirectory ( ouptutDirectory ) ; if ( fileSet . getIncludes ( ) != null && ! fileSet . getIncludes ( ) . isEmpty ( ) ) { truezip . copy ( fileSet ) ; } truezip . sync ( ) ; if ( removeVersionFromFileNames ) { removeVersionFromFileNames ( ouptutDirectory , ear ) ; truezip . sync ( ) ; } }'", "label": "'<p > This methods copies the transitive JAR dependencies of the project inside the WEB - INF / lib folder of the lib . zip subarchive of the TIBCO BusinessWorks EAR archive . < / p >'"}
{"text": "'public static String getRelativePath ( String targetPath , String basePath , String pathSeparator ) { // Normalize the paths String normalizedTargetPath = FilenameUtils . normalizeNoEndSeparator ( targetPath ) ; String normalizedBasePath = FilenameUtils . normalizeNoEndSeparator ( basePath ) ; // Undo the changes to the separators made by normalization if ( pathSeparator . equals ( \"/\" ) ) { normalizedTargetPath = FilenameUtils . separatorsToUnix ( normalizedTargetPath ) ; normalizedBasePath = FilenameUtils . separatorsToUnix ( normalizedBasePath ) ; } else if ( pathSeparator . equals ( \"\\\\\\\\\" ) ) { normalizedTargetPath = FilenameUtils . separatorsToWindows ( normalizedTargetPath ) ; normalizedBasePath = FilenameUtils . separatorsToWindows ( normalizedBasePath ) ; } else { throw new IllegalArgumentException ( \"Unrecognised dir separator \\'\" + pathSeparator + \"\\'\" ) ; } String [ ] base = normalizedBasePath . split ( Pattern . quote ( pathSeparator ) ) ; String [ ] target = normalizedTargetPath . split ( Pattern . quote ( pathSeparator ) ) ; // First get all the common elements. Store them as a string, // and also count how many of them there are. StringBuffer common = new StringBuffer ( ) ; int commonIndex = 0 ; while ( commonIndex < target . length && commonIndex < base . length && target [ commonIndex ] . equals ( base [ commonIndex ] ) ) { common . append ( target [ commonIndex ] + pathSeparator ) ; commonIndex ++ ; } if ( commonIndex == 0 ) { // No single common path element. This most // likely indicates differing drive letters, like C: and D:. // These paths cannot be relativized. throw new PathResolutionException ( \"No common path element found for \\'\" + normalizedTargetPath + \"\\' and \\'\" + normalizedBasePath + \"\\'\" ) ; } // The number of directories we have to backtrack depends on whether the base is a file or a dir // For example, the relative path from // // /foo/bar/baz/gg/ff to /foo/bar/baz //  // \"..\" if ff is a file // \"../..\" if ff is a directory // // The following is a heuristic to figure out if the base refers to a file or dir. It\\'s not perfect, because // the resource referred to by this path may not actually exist, but it\\'s the best I can do boolean baseIsFile = true ; File baseResource = new File ( normalizedBasePath ) ; if ( baseResource . exists ( ) ) { baseIsFile = baseResource . isFile ( ) ; } else if ( basePath . endsWith ( pathSeparator ) ) { baseIsFile = false ; } StringBuffer relative = new StringBuffer ( ) ; if ( base . length != commonIndex ) { int numDirsUp = baseIsFile ? base . length - commonIndex - 1 : base . length - commonIndex ; for ( int i = 0 ; i < numDirsUp ; i ++ ) { relative . append ( \"..\" + pathSeparator ) ; } } relative . append ( normalizedTargetPath . substring ( common . length ( ) ) ) ; return relative . toString ( ) ; }'", "label": "'<p > Get the relative path from one file to another specifying the directory separator . If one of the provided resources does not exist it is assumed to be a file unless it ends with / or \\\\ . < / p >'"}
{"text": "'protected Properties expandWildCards ( Properties properties ) { Properties propertiesWithWildCards = new Properties ( ) { // sorted properties private static final long serialVersionUID = 7793482336210629858L ; @ Override public synchronized Enumeration < Object > keys ( ) { return Collections . enumeration ( new TreeSet < Object > ( super . keySet ( ) ) ) ; } } ; String key ; // retrieve the keys with WildCards Enumeration < Object > e = properties . keys ( ) ; while ( e . hasMoreElements ( ) ) { key = ( String ) e . nextElement ( ) ; if ( isAWildCard ( key ) ) { propertiesWithWildCards . setProperty ( key , properties . getProperty ( key ) ) ; properties . remove ( key ) ; } } // try to replace the values of other keys matching the keys with WildCards Enumeration < Object > w = propertiesWithWildCards . keys ( ) ; while ( w . hasMoreElements ( ) ) { String keyWithWildCards = ( String ) w . nextElement ( ) ; String regex = wildcardToRegex ( keyWithWildCards ) ; String ignoreWildcardInVariablesPattern = \"(.*)variables\\\\\\\\\\\\\\\\\\\\\\\\[(.*)\\\\\\\\\\\\\\\\\\\\\\\\]\\\\\\\\/variable\\\\\\\\\\\\\\\\\\\\\\\\[(.*)\\\\\\\\\\\\\\\\\\\\\\\\](.*)\" ; Pattern p = Pattern . compile ( ignoreWildcardInVariablesPattern ) ; Matcher m = p . matcher ( regex ) ; if ( m . matches ( ) ) { String variables = m . group ( 2 ) ; String variable = m . group ( 3 ) ; variables = variables . replace ( \".*\" , \"\\\\\\\\*\" ) ; variable = variable . replace ( \".*\" , \"\\\\\\\\*\" ) ; regex = m . group ( 1 ) + \"variables\\\\\\\\[\" + variables + \"\\\\\\\\]/variable\\\\\\\\[\" + variable + \"\\\\\\\\]\" + m . group ( 4 ) ; } Boolean found = false ; e = properties . keys ( ) ; while ( e . hasMoreElements ( ) ) { key = ( String ) e . nextElement ( ) ; if ( Pattern . matches ( regex , key ) ) { found = true ; String value = ( String ) propertiesWithWildCards . getProperty ( keyWithWildCards ) ; properties . setProperty ( key , value ) ; } } // not found, we put back the expression with wild cards in the original list (false positive) // this way the wildcard can still be used in a next pass and will be removed at the end by AbstractPackagingMojo.removeWildCards  if ( ! found ) { properties . setProperty ( keyWithWildCards , propertiesWithWildCards . getProperty ( keyWithWildCards ) ) ; } } return properties ; }'", "label": "'<p > This expands wild cards properties . <br / > <br / > Both wildcard expressions and expressions to expand are present in the same properties object . <br / > <br / > <i > Example< / i > <ul > <li > <b > property with wildcard< / b > : / root / element [ * ] / key = new_value< / li > <li > <b > property matching< / b > : / root / element [ my_name ] / key = old_value< / li > < / ul > will expand to : <br / > <ul > <li > <b > property after expansion< / b > : / root / element [ my_name ] / key = new_value< / li > < / ul > < / p >'"}
{"text": "'public void execute ( ) throws MojoExecutionException { executeMojo ( plugin ( groupId ( getGroupId ( ) ) , artifactId ( getArtifactId ( ) ) , version ( getVersion ( ) ) ) , goal ( getGoal ( ) ) , configuration ( generateConfiguration ( getConfiguration ( ) ) . toArray ( new Element [ 0 ] ) ) , getEnvironment ( ) ) ; }'", "label": "'This method will call the actual builtin goal from the Mojo specified in Plexus components . xml . <br / >'"}
{"text": "'public List < java . lang . Object > getAny ( ) { if ( any == null ) { any = new ArrayList < java . lang . Object > ( ) ; } return this . any ; }'", "label": "'Gets the value of the any property .'"}
{"text": "'private Statement createStatement ( MethodInvocation < Connection > methodInvocation ) throws Throwable { Statement result = ( Statement ) methodInvocation . proceed ( ) ; result = proxyFactory . wrapStatement ( result ) ; return result ; }'", "label": "'Wrap Statement during {'"}
{"text": "'private PreparedStatement prepareStatement ( MethodInvocation < Connection > methodInvocation ) throws Throwable { String sql = methodInvocation . getArgAt ( 0 , String . class ) ; PreparedStatement result = ( PreparedStatement ) methodInvocation . proceed ( ) ; result = proxyFactory . wrapPreparedStatement ( result , sql ) ; return result ; }'", "label": "'Wrap Statement during {'"}
{"text": "'private CallableStatement prepareCall ( MethodInvocation < Connection > methodInvocation ) throws Throwable { String sql = methodInvocation . getArgAt ( 0 , String . class ) ; CallableStatement result = ( CallableStatement ) methodInvocation . proceed ( ) ; result = proxyFactory . wrapCallableStatement ( result , sql ) ; return result ; }'", "label": "'Wrap Statement during {'"}
{"text": "'private static < T > T newInstance ( Class < T > clazz , Object ... params ) throws SQLException { try { if ( params == null || params . length == 0 ) { return clazz . newInstance ( ) ; } else { for ( Constructor < ? > ctor : clazz . getConstructors ( ) ) { if ( ctor . getParameterTypes ( ) . length != params . length ) { continue ; } int paramIndex = 0 ; for ( Class < ? > paramType : ctor . getParameterTypes ( ) ) { if ( ! paramType . isInstance ( params [ paramIndex ] ) ) { break ; } paramIndex ++ ; } if ( paramIndex != params . length ) { continue ; } @ SuppressWarnings ( \"unchecked\" ) Constructor < T > theCtor = ( Constructor < T > ) ctor ; return theCtor . newInstance ( params ) ; } throw new SQLException ( \"Constructor not found for \" + clazz ) ; } } catch ( ReflectiveOperationException reflectiveOperationException ) { throw new SQLException ( reflectiveOperationException ) ; } }'", "label": "'Instantiate a new object of type T'"}
{"text": "'@ Override public < T > T newProxy ( ProxyHandler < T > proxyHandler , ProxyClass proxyClass ) { return ( T ) Proxy . newProxyInstance ( proxyClass . getClassLoader ( ) , proxyClass . getInterfaces ( ) , proxyHandler ) ; }'", "label": "'{'"}
{"text": "'public < T > Class < T > createClass ( ) { return ( Class < T > ) Proxy . getProxyClass ( getClassLoader ( ) , getInterfaces ( ) ) ; }'", "label": "'Create proxy class'"}
{"text": "'public < T > Constructor < T > createConstructor ( ) { try { return this . < T > createClass ( ) . getConstructor ( InvocationHandler . class ) ; } catch ( NoSuchMethodException noSuchMethodException ) { throw new ProxyException ( noSuchMethodException ) ; } }'", "label": "'Create proxy constructor'"}
{"text": "'public Timer . Context startStatementExecuteTimer ( Query query ) { ensureSqlId ( query ) ; String name = metricNamingStrategy . getStatementExecuteTimer ( query . getSql ( ) , query . getSqlId ( ) ) ; return startTimer ( name ) ; }'", "label": "'Start Timer when statement is executed'"}
{"text": "'public Timer . Context startPreparedStatementLifeTimer ( Query query ) { ensureSqlId ( query ) ; String name = metricNamingStrategy . getPreparedStatementLifeTimer ( query . getSql ( ) , query . getSqlId ( ) ) ; return startTimer ( name ) ; }'", "label": "'Start Timer when prepared statement is created'"}
{"text": "'public Timer . Context startPreparedStatementExecuteTimer ( Query query ) { ensureSqlId ( query ) ; String name = metricNamingStrategy . getPreparedStatementExecuteTimer ( query . getSql ( ) , query . getSqlId ( ) ) ; return startTimer ( name ) ; }'", "label": "'Start Timer when prepared statement is created'"}
{"text": "'public Timer . Context startCallableStatementLifeTimer ( Query query ) { ensureSqlId ( query ) ; String name = metricNamingStrategy . getCallableStatementLifeTimer ( query . getSql ( ) , query . getSqlId ( ) ) ; return startTimer ( name ) ; }'", "label": "'Start Timer when callable statement is created'"}
{"text": "'public Timer . Context startCallableStatementExecuteTimer ( Query query ) { ensureSqlId ( query ) ; String name = metricNamingStrategy . getCallableStatementExecuteTimer ( query . getSql ( ) , query . getSqlId ( ) ) ; return startTimer ( name ) ; }'", "label": "'Start Timer when prepared statement is created'"}
{"text": "'public Timer . Context startResultSetLifeTimer ( Query query ) { ensureSqlId ( query ) ; String name = metricNamingStrategy . getResultSetLifeTimer ( query . getSql ( ) , query . getSqlId ( ) ) ; return startTimer ( name ) ; }'", "label": "'Start Timer when result set is created'"}
{"text": "'public void markResultSetRowMeter ( Query query ) { ensureSqlId ( query ) ; String name = metricNamingStrategy . getResultSetRowMeter ( query . getSql ( ) , query . getSqlId ( ) ) ; markMeter ( name ) ; }'", "label": "'Increment when result set row is read'"}
{"text": "'private < T > T newProxy ( JdbcProxyHandler < T > proxyHandler ) { return proxyFactory . newProxy ( proxyHandler , proxyHandler . getProxyClass ( ) ) ; }'", "label": "'Create a proxy for given JDBC proxy handler'"}
{"text": "'public Connection wrapConnection ( Connection wrappedConnection ) { Timer . Context lifeTimerContext = metricHelper . startConnectionLifeTimer ( ) ; return newProxy ( new ConnectionProxyHandler ( wrappedConnection , this , lifeTimerContext ) ) ; }'", "label": "'Wrap a connection to monitor it .'"}
{"text": "'public Statement wrapStatement ( Statement statement ) { Timer . Context lifeTimerContext = getMetricHelper ( ) . startStatementLifeTimer ( ) ; return newProxy ( new StatementProxyHandler ( statement , this , lifeTimerContext ) ) ; }'", "label": "'Wrap a simple statement to monitor it .'"}
{"text": "'public PreparedStatement wrapPreparedStatement ( PreparedStatement preparedStatement , String sql ) { Query query = new Query ( sql ) ; Timer . Context lifeTimerContext = getMetricHelper ( ) . startPreparedStatementLifeTimer ( query ) ; return newProxy ( new PreparedStatementProxyHandler ( preparedStatement , this , query , lifeTimerContext ) ) ; }'", "label": "'Wrap a prepared statement to monitor it .'"}
{"text": "'public CallableStatement wrapCallableStatement ( CallableStatement callableStatement , String sql ) { Query query = new Query ( sql ) ; Timer . Context lifeTimerContext = getMetricHelper ( ) . startCallableStatementLifeTimer ( query ) ; return newProxy ( new CallableStatementProxyHandler ( callableStatement , this , query , lifeTimerContext ) ) ; }'", "label": "'Wrap a callable statement to monitor it .'"}
{"text": "'public ResultSet wrapResultSet ( ResultSet resultSet , String sql ) { Query query = new Query ( sql ) ; Timer . Context lifeTimerContext = metricHelper . startResultSetLifeTimer ( query ) ; return ( ResultSet ) newProxy ( new ResultSetProxyHandler ( resultSet , getResultSetType ( resultSet ) , this , query , lifeTimerContext ) ) ; }'", "label": "'Wrap a result set to monitor it .'"}
{"text": "'public ResultSet wrapResultSet ( ResultSet resultSet , Query query , Timer . Context lifeTimerContext ) { return ( ResultSet ) newProxy ( new ResultSetProxyHandler ( resultSet , getResultSetType ( resultSet ) , this , query , lifeTimerContext ) ) ; }'", "label": "'Wrap a result set to monitor it .'"}
{"text": "'private Class < ? extends ResultSet > getResultSetType ( ResultSet resultSet ) { Class < ? extends ResultSet > resultSetType ; if ( resultSet instanceof RowSet ) { if ( resultSet instanceof CachedRowSet ) { if ( resultSet instanceof WebRowSet ) { if ( resultSet instanceof FilteredRowSet ) { resultSetType = FilteredRowSet . class ; } else if ( resultSet instanceof JoinRowSet ) { resultSetType = JoinRowSet . class ; } else { resultSetType = WebRowSet . class ; } } else { resultSetType = CachedRowSet . class ; } } else if ( resultSet instanceof JdbcRowSet ) { resultSetType = JdbcRowSet . class ; } else { resultSetType = RowSet . class ; } } else { resultSetType = ResultSet . class ; } return resultSetType ; }'", "label": "'Determine the interface implemented by this result set'"}
{"text": "'@ Override public ObjectName createName ( String type , String domain , String name ) { Matcher matcher = PATTERN . matcher ( name ) ; ObjectName objectName = null ; if ( matcher . matches ( ) ) { String className = matcher . group ( 1 ) ; String database = matcher . group ( 2 ) ; String sql = matcher . group ( 3 ) ; String event = matcher . group ( 4 ) ; Hashtable < String , String > props = new Hashtable <> ( ) ; props . put ( \"class\" , className ) ; props . put ( \"database\" , database ) ; if ( sql != null ) { // , and \\\\ are not allowed props . put ( \"sql\" , sql . replaceAll ( \"[:=*?,\\\\\\\\n\\\\\\\\\\\\\\\\]\" , \" \" ) . replaceAll ( \"[\\\\\\\\s]+\" , \" \" ) ) ; } if ( event != null ) { props . put ( \"event\" , event ) ; } if ( type != null ) { props . put ( \"metricType\" , type ) ; } try { objectName = new ObjectName ( domain , props ) ; } catch ( MalformedObjectNameException malformedObjectNameException ) { } } if ( objectName == null ) { objectName = defaultObjectFactory . createName ( type , domain , name ) ; } return objectName ; }'", "label": "'Event'"}
{"text": "'public String getStatementExecuteTimer ( String sql , String sqlId ) { return getStatementExecuteTimer ( Statement . class , sql , sqlId ) ; }'", "label": "'{'"}
{"text": "'public String getPreparedStatementLifeTimer ( String sql , String sqlId ) { return getStatementTimer ( PreparedStatement . class , sql , sqlId ) ; }'", "label": "'{'"}
{"text": "'public String getPreparedStatementExecuteTimer ( String sql , String sqlId ) { return getStatementExecuteTimer ( PreparedStatement . class , sql , sqlId ) ; }'", "label": "'{'"}
{"text": "'public String getCallableStatementLifeTimer ( String sql , String sqlId ) { return getStatementTimer ( CallableStatement . class , sql , sqlId ) ; }'", "label": "'{'"}
{"text": "'public String getCallableStatementExecuteTimer ( String sql , String sqlId ) { return getStatementExecuteTimer ( CallableStatement . class , sql , sqlId ) ; }'", "label": "'{'"}
{"text": "'public String getResultSetLifeTimer ( String sql , String sqlId ) { return MetricRegistry . name ( ResultSet . class , databaseName , sqlId ) ; }'", "label": "'{'"}
{"text": "'@ Override public String getResultSetRowMeter ( String sql , String sqlId ) { return MetricRegistry . name ( ResultSet . class , databaseName , sqlId , \"rows\" ) ; }'", "label": "'{'"}
{"text": "'protected String [ ] buildArgs ( ) { String result [ ] = new String [ 0 ] ; List < String > args = new ArrayList < String > ( ) ; if ( lang != null && lang . length ( ) > 0 ) { args . add ( flagify ( CowsayCli . Opt . LANG . toString ( ) ) ) ; args . add ( lang ) ; } if ( html ) { args . add ( flagify ( CowsayCli . Opt . HTML . toString ( ) ) ) ; } if ( alt != null && alt . length ( ) > 0 ) { args . add ( flagify ( CowsayCli . Opt . ALT . toString ( ) ) ) ; args . add ( alt ) ; } if ( wrap != null ) { args . add ( flagify ( CowsayCli . Opt . WRAP_AT . toString ( ) ) ) ; args . add ( wrap ) ; } buildFaceArgs ( args ) ; args . add ( message ) ; return args . toArray ( result ) ; }'", "label": "'Build an args array that can be passed to cowsay .'"}
{"text": "'private void buildFaceArgs ( final List < String > args ) { if ( mode != null && CowFace . isKnownMode ( mode ) ) { args . add ( flagify ( mode ) ) ; } else { if ( eyes != null ) { args . add ( flagify ( CowsayCli . Opt . EYES . toString ( ) ) ) ; args . add ( eyes ) ; } if ( tongue != null ) { args . add ( flagify ( CowsayCli . Opt . TONGUE . toString ( ) ) ) ; args . add ( tongue ) ; } if ( cowfile != null ) { args . add ( flagify ( CowsayCli . Opt . COWFILE . toString ( ) ) ) ; args . add ( cowfile ) ; } } }'", "label": "'Face specific flags either a face mode or face customizations .'"}
{"text": "'public String execute ( ) throws IllegalStateException { validate ( ) ; String [ ] args = buildArgs ( ) ; String result ; if ( think ) { result = Cowsay . think ( args ) ; } else { result = Cowsay . say ( args ) ; } return result ; }'", "label": "'Run cowsay with the provided properties .'"}
{"text": "'@ Override public void execute ( ) throws BuildException { try { String moo = executor . execute ( ) ; if ( this . property != null && this . property . length ( ) > 0 ) { getProject ( ) . setProperty ( this . property , moo ) ; } else { System . out . println ( moo ) ; } } catch ( IllegalStateException ex ) { throw new BuildException ( ex . getMessage ( ) , ex ) ; } }'", "label": "'Run cowsay with the provided attributes .'"}
{"text": "'public static void setLanguage ( final String language ) { currentLocale = new Locale ( language ) ; messages = ResourceBundle . getBundle ( \"MessagesBundle\" , currentLocale ) ; }'", "label": "'Set the language .'"}
{"text": "'protected static String getMessage ( final String key ) { if ( messages == null ) { setLanguage ( DEFAULT_LANG ) ; } return messages . getString ( key ) ; }'", "label": "'Get a message in the correct language .'"}
{"text": "'private static String sayOrThink ( final String [ ] args , final boolean think ) { try { boolean isThought = think ; String wordwrap = null ; CommandLine commandLine = CowsayCli . parseCmdArgs ( args ) ; if ( commandLine != null ) { if ( commandLine . hasOption ( CowsayCli . Opt . HELP . toString ( ) ) ) { CowsayCli . showCmdLineHelp ( ) ; } else if ( commandLine . hasOption ( CowsayCli . Opt . LIST_COWS . toString ( ) ) ) { String [ ] files = Cowloader . listAllCowfiles ( ) ; if ( files != null ) { return StringUtils . join ( files , System . getProperty ( \"line.separator\" ) ) ; } } else { String cowfileSpec = null ; CowFace cowFace = null ; if ( commandLine . hasOption ( CowsayCli . Opt . WRAP_AT . toString ( ) ) ) { wordwrap = commandLine . getOptionValue ( CowsayCli . Opt . WRAP_AT . toString ( ) ) ; } else if ( commandLine . hasOption ( CowsayCli . Opt . NOWRAP . toString ( ) ) ) { wordwrap = \"0\" ; } cowFace = getCowFaceByMode ( commandLine ) ; if ( cowFace == null ) { // if we are in here no modes were set if ( commandLine . hasOption ( CowsayCli . Opt . COWFILE . toString ( ) ) ) { cowfileSpec = commandLine . getOptionValue ( CowsayCli . Opt . COWFILE . toString ( ) ) ; } cowFace = getCowFace ( commandLine ) ; } if ( commandLine . hasOption ( CowsayCli . Opt . THINK . toString ( ) ) ) { isThought = true ; } if ( cowfileSpec == null ) { cowfileSpec = Cowloader . DEFAULT_COW ; } String cowTemplate = Cowloader . load ( cowfileSpec ) ; if ( cowTemplate != null ) { String moosages [ ] = commandLine . getArgs ( ) ; String moosage = StringUtils . join ( moosages , \" \" ) ; if ( moosage != null && moosage . length ( ) > 0 ) { Message message = new Message ( moosage , isThought ) ; if ( wordwrap != null ) { message . setWordwrap ( wordwrap ) ; } String cow = CowFormatter . formatCow ( cowTemplate , cowFace , message ) ; cow = formatHtml ( commandLine , cow , moosage , isThought ) ; return cow ; } } } } } catch ( CowParseException ex ) { Logger . getLogger ( Cowsay . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return \"\" ; }'", "label": "'Do some cowsaying or cowthinking .'"}
{"text": "'private static String formatHtml ( final CommandLine commandLine , final String plainCow , final String moosage , final boolean isThought ) { String cow = plainCow ; if ( commandLine . hasOption ( CowsayCli . Opt . HTML . toString ( ) ) ) { cow = StringEscapeUtils . escapeHtml4 ( cow ) ; cow = \"<figure><pre>\" + cow + \"</pre><figcaption style=\\\\\"left:-999px; position:absolute\\\\\">\" ; String alt ; if ( commandLine . hasOption ( CowsayCli . Opt . ALT . toString ( ) ) ) { alt = commandLine . getOptionValue ( CowsayCli . Opt . ALT . toString ( ) ) ; } else { alt = isThought ? I18n . getMessage ( \"altthink\" ) : I18n . getMessage ( \"altsay\" ) ; } String escaped = StringEscapeUtils . escapeHtml4 ( moosage ) ; cow += String . format ( alt , escaped ) ; cow += \"</figcaption></figure>\" ; } return cow ; }'", "label": "'May apply HTML markup to the cow if requested in the command line .'"}
{"text": "'private static CowFace getCowFaceByMode ( final CommandLine commandLine ) { CowFace cowFace = null ; Set < String > modes = CowFace . COW_MODES . keySet ( ) ; for ( String mode : modes ) { if ( commandLine . hasOption ( mode ) ) { cowFace = CowFace . getByMode ( mode ) ; break ; } } return cowFace ; }'", "label": "'If a pre - defined cow mode has been set on the command line then use that face .'"}
{"text": "'private static CowFace getCowFace ( final CommandLine commandLine ) { CowFace cowFace ; cowFace = new CowFace ( ) ; if ( commandLine . hasOption ( CowsayCli . Opt . EYES . toString ( ) ) ) { cowFace . setEyes ( commandLine . getOptionValue ( CowsayCli . Opt . EYES . toString ( ) ) ) ; } if ( commandLine . hasOption ( CowsayCli . Opt . TONGUE . toString ( ) ) ) { cowFace . setTongue ( commandLine . getOptionValue ( CowsayCli . Opt . TONGUE . toString ( ) ) ) ; } return cowFace ; }'", "label": "'Get a regular cow face optionally formatted with custom eyes and tongue from the command line .'"}
{"text": "'public static void main ( final String [ ] args ) { CowsayCli . addCowthinkOption ( ) ; String cowsay = say ( args ) ; if ( cowsay != null && cowsay . length ( ) > 0 ) { System . out . println ( cowsay ) ; } }'", "label": "'Will cowsay ( or cowthink if the -- cowthink flag is set )'"}
{"text": "'private static String extractCowTemplate ( final String cow ) throws CowParseException { Matcher matcher = COWSTART_RE . matcher ( cow ) ; if ( matcher . find ( 0 ) ) { String result = matcher . replaceFirst ( \"\" ) ; return result ; } else { throw new CowParseException ( \"Could not parse cow \" + cow ) ; } }'", "label": "'Extracts the ascii art part of the cowfile removing any before or after PERL comments variable assignments weird EOC markers etc .'"}
{"text": "'public static String formatCow ( final String cow , final CowFace face , final Message message ) throws CowParseException { String result = extractCowTemplate ( cow ) ; String tongue = face . getTongue ( ) ; String eyes = face . getEyes ( ) ; result = result . replaceAll ( \"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" , \"\\\\\\\\\\\\\\\\\" ) ; // do this first result = result . replace ( \"\\\\\\\\@\" , \"@\" ) ; result = result . replace ( \"\\\\\\\\$\" , \"$\" ) ; result = result . replace ( \"${tongue}\" , tongue ) ; result = result . replace ( \"$tongue\" , tongue ) ; result = result . replace ( \"$thoughts\" , message . getThoughts ( ) ) ; result = result . replace ( \"${eyes}\" , eyes ) ; // sheep - doesn\\'t help that i know zero perl result = result . replace ( \"$eyes\" , eyes ) ; result = result . replaceAll ( \"EOC\\\\\\\\s*$\" , \"\" ) ; result = message . getMessage ( ) + result ; return result ; }'", "label": "'Processes the cow template ( the raw content of a cowfile ) inserting face and message as appropriate .'"}
{"text": "'public static String load ( final String cowfileSpec ) { String effectiveCowfileSpec = ( cowfileSpec != null ) ? cowfileSpec . trim ( ) : DEFAULT_COW ; if ( effectiveCowfileSpec . length ( ) > 0 ) { if ( ! effectiveCowfileSpec . endsWith ( COWFILE_EXT ) ) { effectiveCowfileSpec += COWFILE_EXT ; } InputStream cowInputStream ; if ( effectiveCowfileSpec . indexOf ( File . separatorChar ) >= 0 ) { cowInputStream = getCowFromPath ( effectiveCowfileSpec ) ; } else { cowInputStream = getCowFromCowPath ( effectiveCowfileSpec ) ; } if ( cowInputStream == null ) { // Maybe there should be a verbose mode where we log this sort of error instead of silently failing? cowInputStream = getCowFromResources ( DEFAULT_COW + COWFILE_EXT ) ; } if ( cowInputStream != null ) { String cow = cowInputStreamToString ( cowInputStream ) ; return cow ; } } return null ; // should never happen }'", "label": "'Call this with the provided cowfileSpec - that is the value passed to - f on the commandline .'"}
{"text": "'private static String cowInputStreamToString ( final InputStream cowInputStream ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( cowInputStream ) ) ; StringBuilder sb = new StringBuilder ( ) ; String line ; try { String newLine = System . getProperty ( \"line.separator\" ) ; while ( ( line = reader . readLine ( ) ) != null ) { sb . append ( line ) ; sb . append ( newLine ) ; } reader . close ( ) ; } catch ( IOException ex ) { Logger . getLogger ( Cowloader . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } finally { if ( cowInputStream != null ) { try { cowInputStream . close ( ) ; } catch ( IOException ex ) { Logger . getLogger ( Cowloader . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } return sb . toString ( ) ; }'", "label": "'Reads a cowfile from an InputStream and returns a string .'"}
{"text": "'private static InputStream getCowFromPath ( final String path ) { String cwd = System . getProperty ( \"user.dir\" ) ; // TODO is this really CWD? if ( cwd != null ) { File cowfile = new File ( cwd , path ) ; if ( isCowfile ( cowfile ) ) { return cowfileToCowInputStream ( cowfile ) ; } } // maybe it\\'s an absolute path? File cowfile = new File ( path ) ; if ( isCowfile ( cowfile ) ) { return cowfileToCowInputStream ( cowfile ) ; } return null ; }'", "label": "'In the case that the cowfileSpec is a filesystem path call this method to attempt to load the cowfile . It will attempt to load the cowfile relative to CWD and if that fails it will try as an absolute path .'"}
{"text": "'private static InputStream getCowFromCowPath ( final String cowName ) { String cowPath = System . getenv ( \"COWPATH\" ) ; if ( cowPath != null ) { String [ ] paths = cowPath . split ( File . pathSeparator ) ; if ( paths != null ) { for ( String path : paths ) { File cowfile = getCowfile ( path , cowName ) ; if ( cowfile != null ) { return cowfileToCowInputStream ( cowfile ) ; } } } } return getCowFromResources ( cowName ) ; }'", "label": "'This will attempt to load a cowfile by name from the COWPATH environment variable or bundled cowfiles . Note that bundled cowfiles are considered part of the COWPATH since this is how to original cowsay worked . COWPATH takes precedence and bundled cowfiles are only considered after searching the COWPATH .'"}
{"text": "'public static String [ ] listAllCowfiles ( ) { String [ ] resultAsArray ; String [ ] bundled = null ; String cowfileExtRe = \"\\\\\\\\\" + COWFILE_EXT + \"$\" ; InputStream bundleStream = Cowloader . class . getResourceAsStream ( \"/cowfile-list.csv\" ) ; if ( bundleStream != null ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( bundleStream ) ) ; StringBuilder sb = new StringBuilder ( ) ; try { String line ; while ( ( line = reader . readLine ( ) ) != null ) { sb . append ( line ) ; } reader . close ( ) ; String bundleList = sb . toString ( ) ; bundled = bundleList . split ( \",\" ) ; } catch ( IOException ex ) { Logger . getLogger ( Cowloader . class . getName ( ) ) . log ( Level . WARNING , null , ex ) ; } finally { try { bundleStream . close ( ) ; } catch ( IOException ex ) { Logger . getLogger ( Cowloader . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } Set < String > result = new HashSet < String > ( ) ; if ( bundled != null ) { for ( String cowfile : bundled ) { if ( cowfile . endsWith ( COWFILE_EXT ) ) { // mech-and-cow for example is not a cowfile and should be excluded result . add ( cowfile . replaceAll ( cowfileExtRe , \"\" ) ) ; } } } String cowPath = System . getenv ( \"COWPATH\" ) ; if ( cowPath != null ) { String [ ] paths = cowPath . split ( File . pathSeparator ) ; if ( paths != null ) { for ( String path : paths ) { File [ ] cowfiles = getCowFiles ( path ) ; if ( cowfiles != null ) { for ( File cowfile : cowfiles ) { result . add ( cowfile . getName ( ) . replaceAll ( cowfileExtRe , \"\" ) ) ; } } } } } resultAsArray = result . toArray ( new String [ result . size ( ) ] ) ; Arrays . sort ( resultAsArray ) ; return resultAsArray ; }'", "label": "'List the names of all cowfiles found when searching COWPATH ( including bundled cowfiles ) . Primarily useful for the - l commandline flag and also handy for unit testing .'"}
{"text": "'private static boolean isCowfile ( final File cowfile ) { if ( cowfile != null && cowfile . exists ( ) ) { return cowfile . getName ( ) . endsWith ( COWFILE_EXT ) ; } return false ; }'", "label": "'Determine if this File appears to be a genuine cowfile . This is not a deep check more rigor will be applied later .'"}
{"text": "'private static InputStream cowfileToCowInputStream ( final File cowfile ) { InputStream cowInputStream = null ; try { cowInputStream = new FileInputStream ( cowfile ) ; } catch ( FileNotFoundException ex ) { Logger . getLogger ( Cowloader . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return cowInputStream ; }'", "label": "'Reads a File to an InputStream . Not sure why I thought this should be a separate method I guess it made sense at the time .'"}
{"text": "'private static File getCowfile ( final String folder , final String cowName ) { File [ ] cowfiles = getCowFiles ( folder ) ; for ( File cowfile : cowfiles ) { if ( cowfile . getName ( ) . equals ( cowName ) ) { return cowfile ; } } return null ; }'", "label": "'Get a cowfile by name from the given directory .'"}
{"text": "'private static File [ ] getCowFiles ( final String folder ) { File dir = new File ( folder ) ; File [ ] files ; files = dir . listFiles ( new FilenameFilter ( ) { @ Override public boolean accept ( final File dir , final String name ) { return name . endsWith ( \".cow\" ) ; } } ) ; return files ; }'", "label": "'Gets all cowfiles found in the given directory .'"}
{"text": "'protected static CowFace getByMode ( final String mode ) { if ( mode != null ) { return COW_MODES . get ( mode ) ; } return null ; }'", "label": "'Get cow args by mode .'"}
{"text": "'public final void setEyes ( final String eyes ) { if ( eyes != null && eyes . length ( ) > 0 ) { if ( eyes . length ( ) > 2 ) { this . eyes = eyes . substring ( 0 , 2 ) ; } else { this . eyes = eyes ; } } }'", "label": "'Set custom cow eyes .'"}
{"text": "'public final void setTongue ( final String tongue ) { if ( tongue != null && tongue . length ( ) > 0 ) { if ( tongue . length ( ) > 2 ) { this . tongue = tongue . substring ( 0 , 2 ) ; } else { this . tongue = tongue ; } } }'", "label": "'Set custom cow tongue .'"}
{"text": "'public static final boolean isKnownMode ( final String mode ) { Set < String > modes = COW_MODES . keySet ( ) ; return modes . contains ( mode ) ; }'", "label": "'Determine if the given mode flag is known and mapped to a particular cow face .'"}
{"text": "'protected static void addCowthinkOption ( ) { if ( ! options . hasOption ( null ) ) { options . addOption ( null , Opt . THINK . text , false , \"\" ) ; } }'", "label": "'Calling this method results in adding the non - standard -- cowthink option to the accepted commandline flags . This is useful if calling cowsay as an executable JAR where there is no other way to determine a cowsay or a cowthink invocation .'"}
{"text": "'public static CommandLine parseCmdArgs ( final String [ ] argv ) { final CommandLineParser cmdLineParser = new DefaultParser ( ) ; try { CommandLine parsed = cmdLineParser . parse ( options , argv , true ) ; if ( parsed . hasOption ( Opt . LANG . text ) ) { String language = parsed . getOptionValue ( Opt . LANG . text ) ; if ( language != null ) { I18n . setLanguage ( language ) ; } } return parsed ; } catch ( MissingArgumentException ex ) { Option option = ex . getOption ( ) ; String flag = option . getOpt ( ) ; if ( flag == null ) { flag = option . getLongOpt ( ) ; } Logger . getLogger ( CowsayCli . class . getName ( ) ) . log ( Level . INFO , I18n . getMessage ( \"missingarg\" ) , flag ) ; } catch ( ParseException ex ) { Logger . getLogger ( CowsayCli . class . getName ( ) ) . log ( Level . FINEST , null , ex ) ; } return null ; }'", "label": "'Parses an array of arguments .'"}
{"text": "'private static void updateOptionDescriptions ( ) { Collection < Option > allOptions = options . getOptions ( ) ; for ( Option option : allOptions ) { String key = option . getOpt ( ) ; if ( key == null ) { key = option . getLongOpt ( ) ; } if ( key != null ) { String description = I18n . getMessage ( key ) ; if ( description != null ) { if ( key . equals ( Opt . COWFILE . text ) ) { description = String . format ( description , File . separatorChar ) ; } option . setDescription ( description ) ; } } } }'", "label": "'Call to add options descriptions to the command line options . This is deferred so that language / locale changes will be reflected .'"}
{"text": "'public static void showCmdLineHelp ( ) { HelpFormatter formatter = new HelpFormatter ( ) ; updateOptionDescriptions ( ) ; formatter . printHelp ( I18n . getMessage ( \"usage\" ) , options ) ; }'", "label": "'Displays help message to user .'"}
{"text": "'private static String formatBubble ( final BubbleWrap bubble , final String message , final int longestLine ) { String newLine = System . getProperty ( \"line.separator\" ) ; String [ ] lines = message . split ( newLine ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( bubble . buildTop ( longestLine ) ) ; if ( lines . length > 1 ) { sb . append ( bubble . formatMultiOpen ( lines [ 0 ] , longestLine ) ) ; for ( int i = 1 ; i < ( lines . length - 1 ) ; i ++ ) { sb . append ( bubble . formatMultiMid ( lines [ i ] , longestLine ) ) ; } sb . append ( bubble . formatMultiEnd ( lines [ ( lines . length - 1 ) ] , longestLine ) ) ; } else { sb . append ( bubble . formatSingle ( lines [ 0 ] ) ) ; } sb . append ( bubble . buildBottom ( longestLine ) ) ; return sb . toString ( ) ; }'", "label": "'Draws a complete bubble around a line - wrapped message .'"}
{"text": "'private String wrapMessage ( final String message ) { // Note that the original cowsay wraps lines mid-word. // This version differs in that it wraps between words if possible. int wrap = getWordwrap ( ) ; if ( wrap <= 0 ) { return message ; } final List < String > result = new ArrayList < String > ( ) ; String newLine = System . getProperty ( \"line.separator\" ) ; String [ ] lines = message . split ( newLine ) ; for ( String line : lines ) { result . add ( WordUtils . wrap ( line , wrap , null , true ) ) ; } return StringUtils . join ( result , newLine ) ; }'", "label": "'Applies word wrapping to the message to handle long lines .'"}
{"text": "'private String formatMessage ( final String message ) { String result ; if ( message != null ) { result = wrapMessage ( message ) ; int longestLine = getLongestLineLen ( result ) ; if ( ! isThought ) { result = Bubble . formatSpeech ( result , longestLine ) ; } else { result = Bubble . formatThought ( result , longestLine ) ; } return result ; } return \"\" ; }'", "label": "'Builds the bubble around the message .'"}
{"text": "'public void setWordwrap ( final String wordwrap ) { try { int ww = Integer . parseInt ( wordwrap ) ; if ( ww >= 0 ) { this . wordwrap = ww ; } } catch ( Throwable ignore ) { // ignore } }'", "label": "'Set the length of the wordwrap default is 40 zero disables line - wrap .'"}
{"text": "'private static int getLongestLineLen ( final String message ) { String newLine = System . getProperty ( \"line.separator\" ) ; String [ ] lines = message . split ( newLine ) ; int maxLen = 0 ; for ( String line : lines ) { maxLen = Math . max ( maxLen , line . length ( ) ) ; } return maxLen ; }'", "label": "'For a given multiline message determines the character count of the longest line .'"}
{"text": "'public void setTags ( String ... tags ) { StringBuilder builder = new StringBuilder ( ) ; boolean first = true ; for ( String s : tags ) { for ( String t : s . split ( \",\" ) ) { t = t . trim ( ) ; if ( ! t . isEmpty ( ) ) { if ( ! first ) { builder . append ( \",\" ) ; } builder . append ( t ) ; } first = false ; } } // \"tags\" field must be null for Retrofit to exclude Loggly tags header. // Empty header string is not acceptable. this . tags = builder . length ( ) > 0 ? builder . toString ( ) : null ; }'", "label": "'Sets the tags to use for Loggly messages . The list of strings are converted into a single CSV ( trailing / leading spaces stripped from each entry ) .'"}
{"text": "'public boolean log ( String message ) { if ( message == null ) return false ; boolean ok ; try { ok = loggly . log ( token , tags , message ) . isExecuted ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; ok = false ; } return ok ; }'", "label": "'Posts a log message to Loggly'"}
{"text": "'public void log ( String message , final Callback callback ) { if ( message == null ) return ; loggly . log ( token , tags , message , new retrofit2 . Callback < LogglyResponse > ( ) { @ Override public void onResponse ( Call < LogglyResponse > call , Response < LogglyResponse > response ) { callback . success ( ) ; } @ Override public void onFailure ( Call < LogglyResponse > call , Throwable throwable ) { callback . failure ( throwable . getMessage ( ) ) ; } } ) ; }'", "label": "'Posts a log message asynchronously to Loggly'"}
{"text": "'public boolean logBulk ( String ... messages ) { if ( messages == null ) return false ; return logBulk ( Arrays . asList ( messages ) ) ; }'", "label": "'Posts several log messages in bulk to Loggly'"}
{"text": "'public boolean logBulk ( Collection < String > messages ) { if ( messages == null ) return false ; String parcel = joinStrings ( messages ) ; if ( parcel . isEmpty ( ) ) return false ; boolean ok ; try { ok = loggly . logBulk ( token , tags , parcel ) . isExecuted ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; ok = false ; } return ok ; }'", "label": "'Posts several log messages in bulk to Loggly'"}
{"text": "'public void logBulk ( Collection < String > messages , final Callback callback ) { if ( messages == null ) return ; String parcel = joinStrings ( messages ) ; if ( parcel . isEmpty ( ) ) return ; loggly . logBulk ( token , tags , parcel , new retrofit2 . Callback < LogglyResponse > ( ) { @ Override public void onResponse ( Call < LogglyResponse > call , Response < LogglyResponse > response ) { callback . success ( ) ; } @ Override public void onFailure ( Call < LogglyResponse > call , Throwable throwable ) { callback . failure ( throwable . getMessage ( ) ) ; } } ) ; }'", "label": "'Posts several log messages in bulk to Loggly asynchronously'"}
{"text": "'private String joinStrings ( Collection < String > messages ) { StringBuilder b = new StringBuilder ( ) ; for ( String s : messages ) { if ( s == null || s . isEmpty ( ) ) { continue ; } // Preserve new-lines in this event by replacing them // with \"\\\\r\". Otherwise, they\\'re processed as event // delimiters, resulting in unintentional multiple events. b . append ( s . replaceAll ( \"[\\\\r\\\\n]\" , \"\\\\r\" ) ) . append ( \\' \\' ) ; } return b . toString ( ) ; }'", "label": "'Combines a collection of messages to be sent to Loggly . In order to preserve event boundaries the new lines in each message are replaced with \\\\ r which get stripped by Loggly .'"}
{"text": "'public static void main ( String ... args ) { if ( args . length == 0 || args [ 0 ] . trim ( ) . isEmpty ( ) ) { System . err . println ( \"missing argument: loggly token\\\\nsee http://loggly.com/docs/customer-token-authentication-token/\" ) ; System . exit ( 1 ) ; } final String TOKEN = args [ 0 ] ; final ILogglyClient loggly = new LogglyClient ( TOKEN ) ; System . out . println ( \"posting single event to Loggly asynchronously...\" ) ; loggly . log ( \"Hello!\\\\nThis is a\\\\nmulti-line event!\\\\n\" , new LogglyClient . Callback ( ) { public void success ( ) { System . out . println ( \"callback succeeded\" ) ; } public void failure ( String error ) { System . err . println ( \"callback failed: \" + error ) ; } } ) ; System . out . println ( \"posting bulk events to Loggly asynchronously...\" ) ; loggly . logBulk ( Arrays . asList ( \"E1\" , \"E2\" ) , new LogglyClient . Callback ( ) { public void success ( ) { System . out . println ( \"bulk callback succeeded\" ) ; } public void failure ( String error ) { System . err . println ( \"bulk callback failed: \" + error ) ; } } ) ; System . out . println ( \"posting single event to Loggly...\" ) ; boolean ok = loggly . log ( \"Hello!\\\\nThis is a\\\\nmulti-line event!\\\\n\" ) ; System . out . println ( ok ? \"ok\" : \"err\" ) ; System . out . println ( \"posting single JSON event to Loggly...\" ) ; final String json = \"{ \\\\\"timestamp\\\\\": \\\\\"2015-01-01T12:34:00Z\\\\\", \\\\\"message\\\\\": \\\\\"Event 100\\\\\", \\\\\"count\\\\\": 100 }\" ; ok = loggly . log ( json ) ; System . out . println ( ok ? \"ok\" : \"err\" ) ; System . out . println ( \"posting bulk events to Loggly...\" ) ; ok = loggly . logBulk ( \"This is a\\\\nmulti-line event 1\" , \"Event 2\" , \"Event 3\" ) ; System . out . println ( ok ? \"ok\" : \"err\" ) ; System . out . println ( \"setting log tags to \\'foo\\', \\'bar\\', and \\'baz\\'...\" ) ; loggly . setTags ( \"foo\" , \"bar,baz\" ) ; ok = loggly . log ( \"This should be tagged with \\'foo\\', \\'bar\\', and \\'baz\\'\" ) ; System . out . println ( ok ? \"ok\" : \"err\" ) ; }'", "label": "'Runs a demo of the Loggly client'"}
{"text": "'public SortedMap < String , Schema > getSchemas ( ) throws SQLException { synchronized ( getSchemasLock ) { if ( getSchemasCache == null ) { SortedMap < String , Schema > newSchemas = new TreeMap <> ( DatabaseMetaData . getCollator ( ) ) ; try ( ResultSet results = metaData . getMetaData ( ) . getSchemas ( ) ) { ResultSetMetaData resultsMeta = results . getMetaData ( ) ; while ( results . next ( ) ) { int colCount = resultsMeta . getColumnCount ( ) ; //System.err.println(\"DEBUG: Catalog: getSchemas(): colCount=\" + colCount); //for(int i=1; i<=colCount; i++) { //\\tresultsMeta.getColumnName(i); //\\tSystem.err.println(\"DEBUG: Catalog: getSchemas(): resultsMeta.getColumnName(\"+i+\")=\" + resultsMeta.getColumnName(i)); //} //System.err.println(\"DEBUG: Catalog: getSchemas(): results.getString(\\\\\"table_catalog\\\\\")=\" + results.getString(\"table_catalog\")); //System.err.println(\"DEBUG: Catalog: getSchemas(): results.getString(\\\\\"TABLE_CATALOG\\\\\")=\" + results.getString(\"TABLE_CATALOG\")); if ( colCount == 1 // PostgreSQL 8.3 only returns one column || results . getString ( \"TABLE_CATALOG\" ) == null // PostgreSQL 9.4 driver returns null || name . equals ( results . getString ( \"TABLE_CATALOG\" ) ) // Other driver ) { Schema newSchema = new Schema ( this , results . getString ( \"TABLE_SCHEM\" ) ) ; if ( newSchemas . put ( newSchema . getName ( ) , newSchema ) != null ) throw new AssertionError ( \"Duplicate schema: \" + newSchema ) ; } } } getSchemasCache = AoCollections . optimalUnmodifiableSortedMap ( newSchemas ) ; } return getSchemasCache ; } }'", "label": "'Gets all schemas for this catalog keyed by unique name .'"}
{"text": "'public Schema getSchema ( String name ) throws NoRowException , SQLException { Schema schema = getSchemas ( ) . get ( name ) ; if ( schema == null ) throw new NoRowException ( \"name=\" + name ) ; return schema ; }'", "label": "'Gets the schema of the provided name .'"}
{"text": "'public SymmetricGraph < Table , Edge < Table > , SQLException > getForeignKeyGraph ( final Set < String > tableTypes ) { return new SymmetricGraph < Table , Edge < Table > , SQLException > ( ) { @ Override public Set < Table > getVertices ( ) throws SQLException { Set < Table > vertices = new LinkedHashSet <> ( ) ; for ( Schema schema : getSchemas ( ) . values ( ) ) { for ( Table table : schema . getTables ( ) . values ( ) ) { if ( tableTypes == null || tableTypes . contains ( table . getTableType ( ) ) ) vertices . add ( table ) ; } } return AoCollections . optimalUnmodifiableSet ( vertices ) ; } @ Override public Set < Edge < Table > > getEdgesFrom ( Table from ) throws SQLException { Set < ? extends Table > tos = from . getImportedTables ( ) ; Set < Edge < Table > > edges = new LinkedHashSet <> ( tos . size ( ) * 4 / 3 + 1 ) ; for ( Table to : tos ) { if ( tableTypes == null || tableTypes . contains ( from . getTableType ( ) ) || tableTypes . contains ( to . getTableType ( ) ) ) edges . add ( new Edge <> ( from , to ) ) ; } return AoCollections . optimalUnmodifiableSet ( edges ) ; } @ Override public Set < Edge < Table > > getEdgesTo ( Table to ) throws SQLException { Set < ? extends Table > froms = to . getExportedTables ( ) ; Set < Edge < Table > > edges = new LinkedHashSet <> ( froms . size ( ) * 4 / 3 + 1 ) ; for ( Table from : froms ) { if ( tableTypes == null || tableTypes . contains ( from . getTableType ( ) ) || tableTypes . contains ( to . getTableType ( ) ) ) edges . add ( new Edge <> ( from , to ) ) ; } return AoCollections . optimalUnmodifiableSet ( edges ) ; } } ; }'", "label": "'Gets a graph view of the imported / exported table relationships within this catalog .'"}
{"text": "'@ Override public void contextInitialized ( ServletContextEvent sce ) { try { ServletContext sc ; synchronized ( servletContextLock ) { servletContext = sce . getServletContext ( ) ; sc = servletContext ; } // Find the top level directory String gitToplevelPath = sc . getInitParameter ( GIT_TOPLEVEL_CONTEXT_PARAM ) ; File gitToplevelRaw ; if ( gitToplevelPath == null || gitToplevelPath . isEmpty ( ) ) { // Default to web root String rootRealPath = sc . getRealPath ( \"/\" ) ; if ( rootRealPath == null ) throw new IllegalStateException ( \"Unable to find web root and \" + GIT_TOPLEVEL_CONTEXT_PARAM + \" context parameter not provided\" ) ; gitToplevelRaw = new File ( rootRealPath ) ; } else { if ( gitToplevelPath . startsWith ( \"~/\" ) ) { gitToplevelRaw = new File ( System . getProperty ( \"user.home\" ) , gitToplevelPath . substring ( 2 ) ) ; } else { gitToplevelRaw = new File ( gitToplevelPath ) ; } } if ( DEBUG ) sc . log ( \"gitToplevelRaw: \" + gitToplevelRaw ) ; Path gtl ; synchronized ( gitToplevelLock ) { gitToplevel = gitToplevelRaw . getCanonicalFile ( ) . toPath ( ) ; gtl = gitToplevel ; } if ( DEBUG ) sc . log ( \"gitToplevel: \" + gtl ) ; // Make sure root exists and is readable if ( ! Files . isDirectory ( gtl , LinkOption . NOFOLLOW_LINKS ) ) throw new IOException ( \"Git toplevel is not a directory: \" + gtl ) ; if ( ! Files . isReadable ( gtl ) ) throw new IOException ( \"Unable to read Git toplevel directory: \" + gtl ) ; // Recursively watch for any changes in the directory if ( DEBUG ) sc . log ( \"Starting watcher\" ) ; WatchService w ; synchronized ( watcherLock ) { watcher = gtl . getFileSystem ( ) . newWatchService ( ) ; w = watcher ; } resync ( ) ; if ( DEBUG ) sc . log ( \"Starting watchThread\" ) ; synchronized ( watcherThreadLock ) { watcherThread = new Thread ( watcherRunnable ) ; watcherThread . start ( ) ; } if ( DEBUG ) sc . log ( \"Starting changeThread\" ) ; synchronized ( changedThreadLock ) { changedThread = new Thread ( changedRunnable ) ; changedThread . start ( ) ; } sc . setAttribute ( APPLICATION_SCOPE_KEY , this ) ; } catch ( IOException e ) { throw new WrappedException ( e ) ; } }'", "label": "'Set to null when context shutdown'"}
{"text": "'private void resync ( ) throws IOException { Path gtl ; synchronized ( gitToplevelLock ) { gtl = gitToplevel ; } WatchService w ; synchronized ( watcherLock ) { w = watcher ; } if ( gtl != null && w != null ) { synchronized ( registered ) { Set < Path > extraKeys = new HashSet <> ( registered . keySet ( ) ) ; resync ( w , gtl , extraKeys ) ; for ( Path extraKey : extraKeys ) { if ( DEBUG ) log ( \"Canceling watch key: \" + extraKey ) ; registered . remove ( extraKey ) . cancel ( ) ; } } } }'", "label": "'Resyncs the entire directory recursively registering and canceling any discrepancies found .'"}
{"text": "'private void updateGitStatus ( ) throws IOException , ParseException { long now = System . currentTimeMillis ( ) ; Path gtl ; synchronized ( gitToplevelLock ) { gtl = gitToplevel ; } GitStatus newStatus ; if ( gtl == null ) { // Java 1.8: Inline this List < UncommittedChange > emptyList = Collections . emptyList ( ) ; newStatus = new GitStatus ( now , State . DISABLED , emptyList ) ; } else { // Get a list of modules including \"\" for main module List < String > modules ; { if ( DEBUG ) log ( \"Finding modules\" ) ; ProcessBuilder pb = new ProcessBuilder ( \"git\" , \"submodule\" , \"--quiet\" , \"foreach\" , \"--recursive\" , \"echo \\\\\"$path\\\\\"\" ) . directory ( gtl . toFile ( ) ) ; Process p = pb . start ( ) ; ProcessResult result = ProcessResult . getProcessResult ( p ) ; if ( result . getExitVal ( ) != 0 ) throw new IOException ( \"Unable to find submodules: \" + result . getStderr ( ) ) ; List < String > submodules = StringUtility . splitLines ( result . getStdout ( ) ) ; if ( DEBUG ) { for ( String submodule : submodules ) log ( \"Got submodule: \" + submodule ) ; } // Add the empty module list modules = new ArrayList <> ( submodules . size ( ) + 1 ) ; modules . addAll ( submodules ) ; modules . add ( \"\" ) ; } // Get the status of each module State state = State . SYNCHRONIZED ; List < UncommittedChange > uncommittedChanges = new ArrayList <> ( ) ; for ( String module : modules ) { if ( DEBUG ) log ( \"Getting status of module \\\\\"\" + module + \"\\\\\"\" ) ; File workingDir ; if ( module . isEmpty ( ) ) { // Main module workingDir = gtl . toFile ( ) ; } else { // Submodule workingDir = new File ( gtl . toFile ( ) , module ) ; } ProcessBuilder pb = new ProcessBuilder ( \"git\" , \"status\" , \"--porcelain\" , \"-z\" ) . directory ( workingDir ) ; Process p = pb . start ( ) ; ProcessResult result = ProcessResult . getProcessResult ( p ) ; if ( result . getExitVal ( ) != 0 ) throw new IOException ( \"Unable to get status: \" + result . getStderr ( ) ) ; // Split on NUL (ASCII 0) List < String > split = new ArrayList <> ( StringUtility . splitString ( result . getStdout ( ) , ( char ) 0 ) ) ; if ( ! split . isEmpty ( ) ) { // Remove last empty part of split String last = split . remove ( split . size ( ) - 1 ) ; if ( ! last . isEmpty ( ) ) throw new ParseException ( \"Last element of split is not empty: \" + last , 0 ) ; } //if((split.size() % 2) != 0) throw new ParseException(\"Unexpected split size: \" + split.size(), 0); int i = 0 ; while ( i < split . size ( ) ) { char x ; char y ; String from ; String to ; { String first = split . get ( i ++ ) ; if ( first . length ( ) < 3 ) throw new ParseException ( \"split1 length too short: \" + first . length ( ) , 0 ) ; x = first . charAt ( 0 ) ; y = first . charAt ( 1 ) ; if ( first . charAt ( 2 ) != \\' \\' ) throw new ParseException ( \"Third character of split1 is not a space: \" + first . charAt ( 2 ) , 0 ) ; if ( x == \\' \\' ) { // Is rename, will have both to and from to = first . substring ( 3 ) ; from = split . get ( i ++ ) ; } else { // Will have from only from to = null ; from = first . substring ( 3 ) ; } } if ( DEBUG ) { log ( \"x = \\\\\"\" + x + \"\\\\\"\" ) ; log ( \"y = \\\\\"\" + y + \"\\\\\"\" ) ; log ( \"from = \\\\\"\" + from + \"\\\\\"\" ) ; log ( \"to = \\\\\"\" + to + \"\\\\\"\" ) ; } UncommittedChange uncommittedChange = new UncommittedChange ( x , y , module , from , to ) ; uncommittedChanges . add ( uncommittedChange ) ; // Keep the highest state State meaningState = uncommittedChange . getMeaning ( ) . getState ( ) ; if ( meaningState . compareTo ( state ) > 0 ) state = meaningState ; } } if ( DEBUG ) log ( \"state = \" + state ) ; // TODO: auto-commit any modified tasklogs // TODO: git pull all modules always to stay in sync // TODO: git push all modules if state is synchronized newStatus = new GitStatus ( now , state , Collections . unmodifiableList ( uncommittedChanges ) ) ; } synchronized ( statusLock ) { status = newStatus ; } } /**\\n\\t * Gets the current Git status, will not block.\\n\\t */ public GitStatus getGitStatus  ( ) { long now = System . currentTimeMillis ( ) ; synchronized ( statusLock ) { // Timeout when status not updated recently enough long statusTime = status . getStatusTime ( ) ; long millisSince = now - statusTime ; if ( millisSince >= TIMEOUT_MILLIS || millisSince <= - TIMEOUT_MILLIS // Can happen when system time reset ) { // Java 1.8: Inline this List < UncommittedChange > emptyList = Collections . emptyList ( ) ; return new GitStatus ( statusTime , State . TIMEOUT , emptyList ) ; } // Return most recently determined status return status ; } } public static AutoGitContextListener getInstance  ( ServletContext sc ) { return ( AutoGitContextListener ) sc . getAttribute ( APPLICATION_SCOPE_KEY ) ; } private static final String GIT_STATUS_REQUEST_CACHE_KEY = AutoGitContextListener . class . getName ( ) + \".getGitStatus.cache\" ; public static GitStatus getGitStatus  ( ServletContext servletContext , ServletRequest request ) { // Look for cached value GitStatus gitStatus = ( GitStatus ) request . getAttribute ( GIT_STATUS_REQUEST_CACHE_KEY ) ; if ( gitStatus == null ) { AutoGitContextListener gitContext = AutoGitContextListener . getInstance ( servletContext ) ; if ( gitContext == null ) { // Java 1.8: Inline this List < UncommittedChange > emptyList = Collections . emptyList ( ) ; gitStatus = new GitStatus ( System . currentTimeMillis ( ) , State . DISABLED , emptyList ) ; } else { gitStatus = gitContext . getGitStatus ( ) ; } request . setAttribute ( GIT_STATUS_REQUEST_CACHE_KEY , gitStatus ) ; } return gitStatus ; } }'", "label": "'Updates the current Git status will block on I / O . Automatically does git pull and git push when there are no uncommitted changes . <p > Called on startup . Also called when file change detected and the Git status should be updated . < / p > TODO : Add timeout within this method?'"}
{"text": "'public SortedMap < String , Table > getTables ( ) throws SQLException { synchronized ( getTablesLock ) { if ( getTablesCache == null ) { SortedMap < String , Table > newTables = new TreeMap <> ( DatabaseMetaData . getCollator ( ) ) ; try ( ResultSet results = catalog . getMetaData ( ) . getMetaData ( ) . getTables ( catalog . getName ( ) , name , null , null ) ) { while ( results . next ( ) ) { Table newTable = new Table ( this , results . getString ( \"TABLE_NAME\" ) , results . getString ( \"TABLE_TYPE\" ) ) ; if ( newTables . put ( newTable . getName ( ) , newTable ) != null ) throw new AssertionError ( \"Duplicate table: \" + newTable ) ; } } getTablesCache = AoCollections . optimalUnmodifiableSortedMap ( newTables ) ; } return getTablesCache ; } }'", "label": "'Gets all tables for this schema keyed by unique name .'"}
{"text": "'public Table getTable ( String name ) throws NoRowException , SQLException { Table table = getTables ( ) . get ( name ) ; if ( table == null ) throw new NoRowException ( ) ; return table ; }'", "label": "'Gets the table of the provided name .'"}
{"text": "'@ SuppressWarnings ( \"deprecation\" ) private static String getRow ( ResultSet result ) throws SQLException { StringBuilder sb = new StringBuilder ( ) ; sb . append ( \\' \\' ) ; ResultSetMetaData metaData = result . getMetaData ( ) ; int colCount = metaData . getColumnCount ( ) ; for ( int c = 1 ; c <= colCount ; c ++ ) { if ( c > 1 ) sb . append ( \", \" ) ; int colType = metaData . getColumnType ( c ) ; switch ( colType ) { case Types . BIGINT : case Types . BIT : case Types . BOOLEAN : case Types . DECIMAL : case Types . DOUBLE : case Types . FLOAT : case Types . INTEGER : case Types . NUMERIC : case Types . REAL : case Types . SMALLINT : case Types . TINYINT : sb . append ( result . getObject ( c ) ) ; break ; case Types . CHAR : case Types . DATE : case Types . LONGNVARCHAR : case Types . LONGVARCHAR : case Types . NCHAR : case Types . NVARCHAR : case Types . TIME : case Types . TIMESTAMP : case Types . VARCHAR : default : sb . append ( \\' \\' ) ; SQLUtility . escapeSQL ( result . getString ( c ) , sb ) ; sb . append ( \\' \\' ) ; break ; //default : //    throw new SQLException(\"Unexpected column type: \"+colType); } } sb . append ( \\' \\' ) ; return sb . toString ( ) ; }'", "label": "'Gets a user - friendly description of the provided result in a string formatted like <code > ( value value int_value ... ) < / code > . This must not be used generate SQL statements - it is just to provider user display .'"}
{"text": "'private void writeToImpl ( Writer out , long writeStart , long writeEnd ) throws IOException { try ( // TODO: If copying to another SegmentedBufferedWriter or AutoTempFileWriter, we have a chance here for disk-to-disk block level copying instead of going through all the conversions. RandomAccessFile raf = new RandomAccessFile ( tempFile . getFile ( ) , \"r\" ) ) { byte [ ] bytes = BufferManager . getBytes ( ) ; try { char [ ] chars = BufferManager . getChars ( ) ; try { long index = writeStart ; raf . seek ( index << 1 ) ; while ( index < writeEnd ) { // Read a block long blockSizeLong = ( writeEnd - index ) << 1 ; int blockSize = blockSizeLong > BufferManager . BUFFER_SIZE ? BufferManager . BUFFER_SIZE : ( int ) blockSizeLong ; assert ( blockSize & 1 ) == 0 : \"Must be an even number for UTF-16 conversion\" ; raf . readFully ( bytes , 0 , blockSize ) ; // Convert to characters for ( int bpos = 0 , cpos = 0 ; bpos < blockSize ; bpos += 2 , cpos ++ ) { chars [ cpos ] = IoUtils . bufferToChar ( bytes , bpos ) ; } // Write to output out . write ( chars , 0 , blockSize >> 1 ) ; // Update location index += blockSize >> 1 ; } } finally { BufferManager . release ( chars , false ) ; } } finally { BufferManager . release ( bytes , false ) ; } } }'", "label": "'Implementation of writeTo'"}
{"text": "'public SortedMap < String , Catalog > getCatalogs ( ) throws SQLException { synchronized ( getCatalogsLock ) { if ( getCatalogsCache == null ) { SortedMap < String , Catalog > newCatalogs = new TreeMap <> ( englishCollator ) ; try ( ResultSet results = metaData . getCatalogs ( ) ) { while ( results . next ( ) ) { Catalog newCatalog = new Catalog ( this , results . getString ( 1 ) ) ; if ( newCatalogs . put ( newCatalog . getName ( ) , newCatalog ) != null ) throw new AssertionError ( \"Duplicate catalog: \" + newCatalog ) ; } } getCatalogsCache = AoCollections . optimalUnmodifiableSortedMap ( newCatalogs ) ; } return getCatalogsCache ; } }'", "label": "'Gets all catalogs for this database keyed by unique name .'"}
{"text": "'public Catalog getCatalog ( String name ) throws NoRowException , SQLException { Catalog catalog = getCatalogs ( ) . get ( name ) ; if ( catalog == null ) throw new NoRowException ( ) ; return catalog ; }'", "label": "'Gets the catalog of the provided name .'"}
{"text": "'private char [ ] getBuffer ( int additional ) throws IOException { long newLen = ( long ) length + additional ; if ( newLen > MAX_LENGTH ) throw new IOException ( \"Maximum buffer length is \" + MAX_LENGTH + \", \" + newLen + \" requested\" ) ; char [ ] buf = this . buffer ; int bufLen = buf . length ; if ( newLen > bufLen ) { // Find the next power of two that will hold all of the contents int newBufLen = bufLen == 0 ? BufferManager . BUFFER_SIZE : ( bufLen << 1 ) ; while ( newBufLen < newLen ) { newBufLen <<= 1 ; } char [ ] newBuf = ( newBufLen == BufferManager . BUFFER_SIZE ) ? BufferManager . getChars ( ) : new char [ newBufLen ] ; System . arraycopy ( buf , 0 , newBuf , 0 , length ) ; // Recycle buffer if ( bufLen == BufferManager . BUFFER_SIZE ) { BufferManager . release ( buf , false ) ; } buf = newBuf ; this . buffer = buf ; } return buf ; }'", "label": "'Grows as - needed to fit the provided new capacity .'"}
{"text": "'private void log ( Encoder encoder ) throws IOException { if ( encoder == null ) log . write ( \"null\" ) ; else { String className = encoder . getClass ( ) . getName ( ) ; // Some shortcuts from the ao-encoding project, classnames used here to avoid hard dependency if ( \"com.aoindustries.encoding.JavaScriptInXhtmlAttributeEncoder\" . equals ( className ) ) { log . write ( \"javaScriptInXhtmlAttributeEncoder\" ) ; } else if ( \"com.aoindustries.encoding.JavaScriptInXhtmlEncoder\" . equals ( className ) ) { log . write ( \"javaScriptInXhtmlEncoder\" ) ; } else if ( \"com.aoindustries.encoding.TextInXhtmlAttributeEncoder\" . equals ( className ) ) { log . write ( \"textInXhtmlAttributeEncoder\" ) ; } else { log . write ( className ) ; } } }'", "label": "'Provides detailed logging for a media encoder .'"}
{"text": "'private void log ( Writer writer ) throws IOException { if ( writer == null ) { log . write ( \"null\" ) ; } else if ( writer instanceof LoggingWriter ) { LoggingWriter loggingWriter = ( LoggingWriter ) writer ; log . write ( \"writer[\" ) ; log . write ( Long . toString ( loggingWriter . getId ( ) ) ) ; log . write ( \\' \\' ) ; } else if ( writer instanceof EncoderWriter ) { EncoderWriter encoderWriter = ( EncoderWriter ) writer ; log . write ( \"new EncoderWriter(\" ) ; log ( encoderWriter . getEncoder ( ) ) ; log . write ( \", \" ) ; log ( encoderWriter . getOut ( ) ) ; log . write ( \\' \\' ) ; } else { String classname = writer . getClass ( ) . getName ( ) ; if ( classname . equals ( \"org.apache.jasper.runtime.BodyContentImpl\" ) ) log . write ( \"bodyContent\" ) ; else if ( classname . equals ( \"org.apache.jasper.runtime.JspWriterImpl\" ) ) log . write ( \"jspWriter\" ) ; else log . write ( classname ) ; } }'", "label": "'Provides detailed logging for a writer .'"}
{"text": "'public static < F > LexicalPosition < F > zeroWithFile ( final F file ) { return LexicalPosition . of ( 0 , 0 , Optional . of ( file ) ) ; }'", "label": "'Construct a lexical position at line 0 column 0 with the given file .'"}
{"text": "\"private void append ( int segmentIndex , StringBuilder buffer ) { switch ( segmentTypes [ segmentIndex ] ) { case SegmentedWriter . TYPE_STRING : int off = segmentOffsets [ segmentIndex ] ; buffer . append ( ( String ) segmentValues [ segmentIndex ] , off , off + segmentLengths [ segmentIndex ] ) ; break ; case SegmentedWriter . TYPE_CHAR_NEWLINE : assert segmentOffsets [ segmentIndex ] == 0 ; assert segmentLengths [ segmentIndex ] == 1 ; buffer . append ( ' ' ) ; break ; case SegmentedWriter . TYPE_CHAR_QUOTE : assert segmentOffsets [ segmentIndex ] == 0 ; assert segmentLengths [ segmentIndex ] == 1 ; buffer . append ( ' ' ) ; break ; case SegmentedWriter . TYPE_CHAR_APOS : assert segmentOffsets [ segmentIndex ] == 0 ; assert segmentLengths [ segmentIndex ] == 1 ; buffer . append ( ' ' ) ; break ; case SegmentedWriter . TYPE_CHAR_OTHER : assert segmentOffsets [ segmentIndex ] == 0 ; assert segmentLengths [ segmentIndex ] == 1 ; buffer . append ( ( ( Character ) segmentValues [ segmentIndex ] ) . charValue ( ) ) ; break ; default : throw new AssertionError ( ) ; } }\"", "label": "'Appends the full segment ( with original offset and length ) to the buffer .'"}
{"text": "\"private void append ( int segmentIndex , int off , int len , StringBuilder buffer ) { switch ( segmentTypes [ segmentIndex ] ) { case SegmentedWriter . TYPE_STRING : buffer . append ( ( String ) segmentValues [ segmentIndex ] , off , off + len ) ; break ; case SegmentedWriter . TYPE_CHAR_NEWLINE : assert off == 0 ; assert len == 1 ; buffer . append ( ' ' ) ; break ; case SegmentedWriter . TYPE_CHAR_QUOTE : assert off == 0 ; assert len == 1 ; buffer . append ( ' ' ) ; break ; case SegmentedWriter . TYPE_CHAR_APOS : assert off == 0 ; assert len == 1 ; buffer . append ( ' ' ) ; break ; case SegmentedWriter . TYPE_CHAR_OTHER : assert off == 0 ; assert len == 1 ; buffer . append ( ( ( Character ) segmentValues [ segmentIndex ] ) . charValue ( ) ) ; break ; default : throw new AssertionError ( ) ; } }\"", "label": "'Appends the given range of a segment . to the buffer .'"}
{"text": "\"private void writeSegment ( int segmentIndex , Encoder encoder , Writer out ) throws IOException { switch ( segmentTypes [ segmentIndex ] ) { case SegmentedWriter . TYPE_STRING : encoder . write ( ( String ) segmentValues [ segmentIndex ] , segmentOffsets [ segmentIndex ] , segmentLengths [ segmentIndex ] , out ) ; break ; case SegmentedWriter . TYPE_CHAR_NEWLINE : assert segmentOffsets [ segmentIndex ] == 0 ; assert segmentLengths [ segmentIndex ] == 1 ; encoder . write ( ' ' , out ) ; break ; case SegmentedWriter . TYPE_CHAR_QUOTE : assert segmentOffsets [ segmentIndex ] == 0 ; assert segmentLengths [ segmentIndex ] == 1 ; encoder . write ( ' ' , out ) ; break ; case SegmentedWriter . TYPE_CHAR_APOS : assert segmentOffsets [ segmentIndex ] == 0 ; assert segmentLengths [ segmentIndex ] == 1 ; encoder . write ( ' ' , out ) ; break ; case SegmentedWriter . TYPE_CHAR_OTHER : assert segmentOffsets [ segmentIndex ] == 0 ; assert segmentLengths [ segmentIndex ] == 1 ; encoder . write ( ( Character ) segmentValues [ segmentIndex ] , out ) ; break ; default : throw new AssertionError ( ) ; } }\"", "label": "'Writes the full segment ( with original offset and length ) to the given writer using the given encoder .'"}
{"text": "\"private void writeSegment ( int segmentIndex , int off , int len , Encoder encoder , Writer out ) throws IOException { switch ( segmentTypes [ segmentIndex ] ) { case SegmentedWriter . TYPE_STRING : encoder . write ( ( String ) segmentValues [ segmentIndex ] , off , len , out ) ; break ; case SegmentedWriter . TYPE_CHAR_NEWLINE : assert off == 0 ; assert len == 1 ; encoder . write ( ' ' , out ) ; break ; case SegmentedWriter . TYPE_CHAR_QUOTE : assert off == 0 ; assert len == 1 ; encoder . write ( ' ' , out ) ; break ; case SegmentedWriter . TYPE_CHAR_APOS : assert off == 0 ; assert len == 1 ; encoder . write ( ' ' , out ) ; break ; case SegmentedWriter . TYPE_CHAR_OTHER : assert off == 0 ; assert len == 1 ; encoder . write ( ( Character ) segmentValues [ segmentIndex ] , out ) ; break ; default : throw new AssertionError ( ) ; } }\"", "label": "'Writes the given range of a segment to the given writer using the given encoder .'"}
{"text": "\"private static char charAt ( byte type , Object value , int charIndex ) { switch ( type ) { case SegmentedWriter . TYPE_STRING : return ( ( String ) value ) . charAt ( charIndex ) ; case SegmentedWriter . TYPE_CHAR_NEWLINE : assert charIndex == 0 ; return ' ' ; case SegmentedWriter . TYPE_CHAR_QUOTE : assert charIndex == 0 ; return ' ' ; case SegmentedWriter . TYPE_CHAR_APOS : assert charIndex == 0 ; return ' ' ; case SegmentedWriter . TYPE_CHAR_OTHER : assert charIndex == 0 ; return ( Character ) value ; default : throw new AssertionError ( ) ; } }\"", "label": "'Gets the character at the given index in a segment . This is the absolute index the offset is not added - in .'"}
{"text": "'private Map < String , Class < ? > > getSqlDataTypes ( ) throws SQLException { if ( sqlDataTypes == null ) { // Load custom types from ServiceLoader Map < String , Class < ? > > newMap = new LinkedHashMap <> ( ) ; Iterator < SQLData > iter = ServiceLoader . load ( SQLData . class ) . iterator ( ) ; while ( iter . hasNext ( ) ) { SQLData sqlData = iter . next ( ) ; newMap . put ( sqlData . getSQLTypeName ( ) , sqlData . getClass ( ) ) ; } sqlDataTypes = newMap ; } return sqlDataTypes ; }'", "label": "'Loads the custom types when first needed and caches the results .'"}
{"text": "'public void executeTransaction ( final DatabaseRunnable runnable ) throws SQLException { executeTransaction ( RuntimeException . class , new DatabaseCallableE < Void , RuntimeException > ( ) { @ Override public Void call ( DatabaseConnection db ) throws SQLException { runnable . run ( db ) ; return null ; } } ) ; }'", "label": "'@see #executeTransaction ( com . aoindustries . sql . DatabaseCallableE )'"}
{"text": "'public < E extends Exception > void executeTransaction ( Class < E > eClass , final DatabaseRunnableE < E > runnable ) throws SQLException , E { executeTransaction ( eClass , new DatabaseCallableE < Void , E > ( ) { @ Override public Void call ( DatabaseConnection db ) throws SQLException , E { runnable . run ( db ) ; return null ; } } ) ; }'", "label": "'@see #executeTransaction ( com . aoindustries . sql . DatabaseCallableE )'"}
{"text": "'public < V > V executeTransaction ( final DatabaseCallable < V > callable ) throws SQLException { return executeTransaction ( RuntimeException . class , new DatabaseCallableE < V , RuntimeException > ( ) { @ Override public V call ( DatabaseConnection db ) throws SQLException { return callable . call ( db ) ; } } ) ; }'", "label": "'@see #executeTransaction ( com . aoindustries . sql . DatabaseCallableE )'"}
{"text": "'public < V , E extends Exception > V executeTransaction ( Class < E > eClass , DatabaseCallableE < V , E > callable ) throws SQLException , E { DatabaseConnection conn = transactionConnection . get ( ) ; if ( conn != null ) { // Reuse existing connection try { return callable . call ( conn ) ; } catch ( RuntimeException err ) { conn . rollback ( ) ; throw err ; } catch ( NoRowException err ) { throw err ; } catch ( SQLException err ) { conn . rollbackAndClose ( ) ; throw err ; } catch ( Exception e ) { conn . rollback ( ) ; if ( eClass . isInstance ( e ) ) throw eClass . cast ( e ) ; throw new SQLException ( e ) ; } } else { // Create new connection conn = createDatabaseConnection ( ) ; try { transactionConnection . set ( conn ) ; try { V result = callable . call ( conn ) ; conn . commit ( ) ; return result ; } finally { transactionConnection . remove ( ) ; } } catch ( RuntimeException | NoRowException err ) { conn . rollback ( ) ; throw err ; } catch ( SQLException err ) { conn . rollbackAndClose ( ) ; throw err ; } catch ( Exception e ) { conn . rollback ( ) ; if ( eClass . isInstance ( e ) ) throw eClass . cast ( e ) ; throw new SQLException ( e ) ; } finally { conn . releaseConnection ( ) ; } } }'", "label": "'<p > Executes an arbitrary transaction providing automatic commit rollback and connection management . Rolls - back the transaction on RuntimeException . Rolls - back the transaction on NoRowException on the outer - most transaction only . Rolls - back and closes the connection on all SQLException except NoRowException . Rolls - back the transaction on E . < / p > <p > The connection allocated is stored as a ThreadLocal and will be automatically reused if another transaction is performed within this transaction . Any nested transaction will automatically become part of the enclosing transaction . For safety a nested transaction will still rollback the entire transaction on any exception . < / p >'"}
{"text": "'public static Method getValueOfIntMethod ( Class < ? > clazz ) { Method existing = valueOfIntMethods . get ( clazz ) ; if ( existing == null ) { Method newMethod ; try { newMethod = clazz . getMethod ( \"valueOf\" , Integer . TYPE ) ; int mod = newMethod . getModifiers ( ) ; if ( ! Modifier . isStatic ( mod ) || ! Modifier . isPublic ( mod ) ) newMethod = notExists ; } catch ( NoSuchMethodException err ) { newMethod = notExists ; } existing = valueOfIntMethods . put ( clazz , newMethod ) ; if ( existing == null ) existing = newMethod ; } return existing == notExists ? null : existing ; }'", "label": "'Gets the <code > valueOf ( int ) < / code > for the provided class or <code > null< / code > if doesn t exist or is non - static or non - public .'"}
{"text": "'public static Method getValueOfStringMethod ( Class < ? > clazz ) { //System.err.println(\"clazz=\"+clazz); Method existing = valueOfStringMethods . get ( clazz ) ; if ( existing == null ) { Method newMethod ; try { newMethod = clazz . getMethod ( \"valueOf\" , String . class ) ; int mod = newMethod . getModifiers ( ) ; if ( ! Modifier . isStatic ( mod ) || ! Modifier . isPublic ( mod ) ) newMethod = notExists ; } catch ( NoSuchMethodException err ) { newMethod = notExists ; } existing = valueOfStringMethods . put ( clazz , newMethod ) ; if ( existing == null ) existing = newMethod ; } return existing == notExists ? null : existing ; }'", "label": "'Gets the <code > valueOf ( String ) < / code > for the provided class or <code > null< / code > if doesn t exist or is non - static or non - public .'"}
{"text": "'@ Override public T createObject ( ResultSet result ) throws SQLException { try { ResultSetMetaData metaData = result . getMetaData ( ) ; int numColumns = metaData . getColumnCount ( ) ; int numParams = prefixParams . length + numColumns ; Object [ ] params = new Object [ numParams ] ; // Find the candidate constructor List < String > warnings = null ; Constructor < ? > [ ] constructors = clazz . getConstructors ( ) ; CONSTRUCTORS : for ( Constructor < ? > constructor : constructors ) { Class < ? > [ ] paramTypes = constructor . getParameterTypes ( ) ; if ( paramTypes . length == numParams ) { for ( int i = 0 ; i < prefixParams . length ; i ++ ) { Class < ? > paramType = paramTypes [ i ] ; if ( ! paramType . isAssignableFrom ( prefixParams [ i ] . getClass ( ) ) ) continue CONSTRUCTORS ; params [ i ] = prefixParams [ i ] ; //System.err.println(paramType.getName()+\" ? \"+(params[i]==null ? \"null\" : params[i].getClass())); } // All remaining columns must be assignable from JDBC for ( int c = 1 ; c <= numColumns ; c ++ ) { int i = prefixParams . length + c - 1 ; Class < ? > paramType = paramTypes [ i ] ; // String first because it is commonly used if ( paramType == String . class ) { params [ i ] = result . getString ( c ) ; // Primitives } else if ( paramType == Integer . TYPE ) { int value = result . getInt ( c ) ; if ( result . wasNull ( ) ) throw new SQLException ( c + \": \" + metaData . getColumnName ( c ) + \": null int\" ) ; params [ i ] = value ; } else if ( paramType == Short . TYPE ) { short value = result . getShort ( c ) ; if ( result . wasNull ( ) ) throw new SQLException ( c + \": \" + metaData . getColumnName ( c ) + \": null short\" ) ; params [ i ] = value ; } else if ( paramType == Boolean . TYPE ) { boolean b = result . getBoolean ( c ) ; if ( result . wasNull ( ) ) throw new SQLException ( c + \": \" + metaData . getColumnName ( c ) + \": null boolean\" ) ; params [ i ] = b ; } else if ( paramType == Float . TYPE ) { float value = result . getFloat ( c ) ; if ( result . wasNull ( ) ) throw new SQLException ( c + \": \" + metaData . getColumnName ( c ) + \": null float\" ) ; params [ i ] = value ; } else if ( paramType == Long . TYPE ) { long value = result . getLong ( c ) ; if ( result . wasNull ( ) ) throw new SQLException ( c + \": \" + metaData . getColumnName ( c ) + \": null long\" ) ; params [ i ] = value ; // Other types } else if ( paramType == Date . class ) { params [ i ] = result . getDate ( c ) ; } else if ( paramType == Boolean . class ) { boolean b = result . getBoolean ( c ) ; params [ i ] = result . wasNull ( ) ? null : b ; } else if ( paramType == Timestamp . class ) { params [ i ] = result . getTimestamp ( c ) ; } else if ( paramType == Integer . class ) { int value = result . getInt ( c ) ; params [ i ] = result . wasNull ( ) ? null : value ; } else if ( paramType == Float . class ) { float value = result . getFloat ( c ) ; params [ i ] = result . wasNull ( ) ? null : value ; } else if ( paramType == Short . class ) { short value = result . getShort ( c ) ; params [ i ] = result . wasNull ( ) ? null : value ; } else if ( paramType == Long . class ) { long value = result . getLong ( c ) ; params [ i ] = result . wasNull ( ) ? null : value ; } else { // Try to find valueOf(int) for unknown types Method valueOfIntMethod = getValueOfIntMethod ( paramType ) ; if ( valueOfIntMethod != null ) { int value = result . getInt ( c ) ; if ( result . wasNull ( ) ) params [ i ] = null ; params [ i ] = valueOfIntMethod . invoke ( null , value ) ; } else { // Try to find valueOf(String) for unknown types Method valueOfStringMethod = getValueOfStringMethod ( paramType ) ; if ( valueOfStringMethod != null ) { String value = result . getString ( c ) ; params [ i ] = result . wasNull ( ) ? null : valueOfStringMethod . invoke ( null , value ) ; } else { if ( warnings == null ) warnings = new ArrayList <> ( ) ; warnings . add ( \"Unexpected parameter class: \" + paramType . getName ( ) ) ; continue CONSTRUCTORS ; } } } //System.err.println(paramType.getName()+\" ? \"+(params[i]==null ? \"null\" : params[i].getClass())); } Object newInstance = constructor . newInstance ( params ) ; //System.err.println(newInstance.getClass().getName()+\": \"+newInstance); return clazz . cast ( newInstance ) ; } } StringBuilder message = new StringBuilder ( \"Unable to find matching constructor\" ) ; if ( warnings != null ) for ( String warning : warnings ) message . append ( EOL ) . append ( warning ) ; throw new SQLException ( message . toString ( ) ) ; } catch ( InstantiationException | IllegalAccessException | InvocationTargetException err ) { throw new SQLException ( err ) ; } } }'", "label": "'Creates one object from the current values in the ResultSet . Looks for a constructor that is assignable to the prefixParams and the result set values . The constructor must exactly match the number of prefixParams plus the result set .'"}
{"text": "'public SortedMap < String , Column > getColumnMap ( ) throws SQLException { synchronized ( getColumnMapLock ) { if ( getColumnMapCache == null ) { SortedMap < String , Column > newColumnMap = new TreeMap <> ( DatabaseMetaData . getCollator ( ) ) ; try ( ResultSet results = schema . getCatalog ( ) . getMetaData ( ) . getMetaData ( ) . getColumns ( schema . getCatalog ( ) . getName ( ) , schema . getName ( ) , name , null ) ) { while ( results . next ( ) ) { Column newColumn = new Column ( this , results . getString ( \"COLUMN_NAME\" ) , results . getInt ( \"DATA_TYPE\" ) , results . getString ( \"TYPE_NAME\" ) , getInteger ( results , \"COLUMN_SIZE\" ) , getInteger ( results , \"DECIMAL_DIGITS\" ) , results . getInt ( \"NULLABLE\" ) , results . getString ( \"COLUMN_DEF\" ) , getInteger ( results , \"CHAR_OCTET_LENGTH\" ) , results . getInt ( \"ORDINAL_POSITION\" ) , results . getString ( \"IS_NULLABLE\" ) , results . getString ( \"IS_AUTOINCREMENT\" ) ) ; if ( newColumnMap . put ( newColumn . getName ( ) , newColumn ) != null ) throw new AssertionError ( \"Duplicate column: \" + newColumn ) ; } } getColumnMapCache = AoCollections . optimalUnmodifiableSortedMap ( newColumnMap ) ; } return getColumnMapCache ; } }'", "label": "'Gets all columns for this schema keyed by unique name .'"}
{"text": "'public Column getColumn ( String name ) throws NoRowException , SQLException { Column column = getColumnMap ( ) . get ( name ) ; if ( column == null ) throw new NoRowException ( ) ; return column ; }'", "label": "'Gets the column of the provided name .'"}
{"text": "'public List < Column > getColumns ( ) throws SQLException { synchronized ( getColumnsLock ) { if ( getColumnsCache == null ) { SortedMap < String , Column > columnMap = getColumnMap ( ) ; List < Column > newColumns = new ArrayList <> ( columnMap . size ( ) ) ; for ( int i = 0 ; i < columnMap . size ( ) ; i ++ ) newColumns . ( null ) ; for ( Column column : columnMap . values ( ) ) { int ordinalPosition = column . getOrdinalPosition ( ) ; if ( newColumns . set ( ordinalPosition - 1 , column ) != null ) throw new SQLException ( \"Duplicate ordinal position: \" + ordinalPosition ) ; } for ( int i = 0 ; i < newColumns . size ( ) ; i ++ ) { if ( newColumns . get ( i ) == null ) throw new SQLException ( \"Missing ordinal position: \" + ( i + 1 ) ) ; } getColumnsCache = AoCollections . optimalUnmodifiableList ( newColumns ) ; } return getColumnsCache ; } }'", "label": "'Gets all columns for this schema in their ordinal position order . Column with ordinal position one is at index zero .'"}
{"text": "'public Column getColumn ( int ordinalPosition ) throws NoRowException , SQLException { try { return getColumns ( ) . get ( ordinalPosition - 1 ) ; } catch ( IndexOutOfBoundsException exc ) { throw new NoRowException ( exc ) ; } }'", "label": "'Gets the column of the provided ordinal position where positions start at one .'"}
{"text": "'public Index getPrimaryKey ( ) throws SQLException { synchronized ( getPrimaryKeyLock ) { if ( ! getPrimaryKeyCached ) { String pkName = null ; List < Column > columns = new AutoGrowArrayList <> ( ) ; try ( ResultSet results = schema . getCatalog ( ) . getMetaData ( ) . getMetaData ( ) . getPrimaryKeys ( schema . getCatalog ( ) . getName ( ) , schema . getName ( ) , name ) ) { while ( results . next ( ) ) { String columnName = results . getString ( \"COLUMN_NAME\" ) ; int keySeq = results . getInt ( \"KEY_SEQ\" ) ; String newPkName = results . getString ( \"PK_NAME\" ) ; if ( newPkName != null ) { if ( pkName == null ) pkName = newPkName ; else if ( ! newPkName . equals ( pkName ) ) throw new SQLException ( \"Mismatched PK_NAME values: \" + newPkName + \"!=\" + pkName ) ; } if ( columns . set ( keySeq - 1 , getColumn ( columnName ) ) != null ) throw new SQLException ( \"Duplicate key sequence: \" + keySeq ) ; } } if ( columns . isEmpty ( ) ) { getPrimaryKeyCache = null ; getPrimaryKeyCached = true ; } else { // Make sure no gaps in the key sequence for ( int i = 0 ; i < columns . size ( ) ; i ++ ) { if ( columns . get ( i ) == null ) throw new SQLException ( \"Missing key sequence in index: \" + ( i + 1 ) ) ; } getPrimaryKeyCache = new Index ( this , pkName , IndexType . PRIMARY_KEY , columns ) ; getPrimaryKeyCached = true ; } } return getPrimaryKeyCache ; } }'", "label": "'Gets the primary key for this table or <code > null< / code > if not found .'"}
{"text": "'public Set < ? extends Table > getImportedTables ( ) throws SQLException { synchronized ( getImportedTablesLock ) { if ( getImportedTablesCache == null ) { Set < Table > newImportedTables = new LinkedHashSet <> ( ) ; Catalog catalog = schema . getCatalog ( ) ; DatabaseMetaData metaData = catalog . getMetaData ( ) ; try ( ResultSet results = schema . getCatalog ( ) . getMetaData ( ) . getMetaData ( ) . getImportedKeys ( schema . getCatalog ( ) . getName ( ) , schema . getName ( ) , name ) ) { while ( results . next ( ) ) { String pkCat = results . getString ( \"PKTABLE_CAT\" ) ; Catalog pkCatalog = pkCat == null ? catalog : metaData . getCatalog ( pkCat ) ; newImportedTables . add ( pkCatalog . getSchema ( results . getString ( \"PKTABLE_SCHEM\" ) ) . getTable ( results . getString ( \"PKTABLE_NAME\" ) ) ) ; } } getImportedTablesCache = AoCollections . optimalUnmodifiableSet ( newImportedTables ) ; } return getImportedTablesCache ; } }'", "label": "'Gets the set of tables that this table depends on .'"}
{"text": "'public Set < ? extends Table > getExportedTables ( ) throws SQLException { synchronized ( getExportedTablesLock ) { if ( getExportedTablesCache == null ) { Set < Table > newExportedTables = new LinkedHashSet <> ( ) ; Catalog catalog = schema . getCatalog ( ) ; DatabaseMetaData metaData = catalog . getMetaData ( ) ; try ( ResultSet results = schema . getCatalog ( ) . getMetaData ( ) . getMetaData ( ) . getExportedKeys ( schema . getCatalog ( ) . getName ( ) , schema . getName ( ) , name ) ) { while ( results . next ( ) ) { String fkCat = results . getString ( \"FKTABLE_CAT\" ) ; Catalog fkCatalog = fkCat == null ? catalog : metaData . getCatalog ( fkCat ) ; newExportedTables . add ( fkCatalog . getSchema ( results . getString ( \"FKTABLE_SCHEM\" ) ) . getTable ( results . getString ( \"FKTABLE_NAME\" ) ) ) ; } } getExportedTablesCache = AoCollections . optimalUnmodifiableSet ( newExportedTables ) ; } return getExportedTablesCache ; } }'", "label": "'Gets the set of tables that depend on this table .'"}
{"text": "'private void addSegment ( byte type , Object value , int off , int len ) { assert ! isClosed ; assert len > 0 : \"Empty segments should never be added\" ; final int arraylen = segmentValues . length ; if ( segmentCount == arraylen ) { // Need to grow if ( arraylen == 0 ) { this . segmentTypes = new byte [ START_LEN ] ; this . segmentValues = new Object [ START_LEN ] ; this . segmentOffsets = new int [ START_LEN ] ; this . segmentLengths = new int [ START_LEN ] ; } else { // Double capacity and copy int newLen = arraylen << 1 ; byte [ ] newTypes = new byte [ newLen ] ; System . arraycopy ( segmentTypes , 0 , newTypes , 0 , arraylen ) ; this . segmentTypes = newTypes ; Object [ ] newValues = new Object [ newLen ] ; System . arraycopy ( segmentValues , 0 , newValues , 0 , arraylen ) ; this . segmentValues = newValues ; int [ ] newOffsets = new int [ newLen ] ; System . arraycopy ( segmentOffsets , 0 , newOffsets , 0 , arraylen ) ; this . segmentOffsets = newOffsets ; int [ ] newLengths = new int [ newLen ] ; System . arraycopy ( segmentLengths , 0 , newLengths , 0 , arraylen ) ; this . segmentLengths = newLengths ; } } segmentTypes [ segmentCount ] = type ; segmentValues [ segmentCount ] = value ; segmentOffsets [ segmentCount ] = off ; segmentLengths [ segmentCount ++ ] = len ; }'", "label": "'Adds a new segment .'"}
{"text": "'private void log ( char ch ) throws IOException { if ( ch == \\' \\' ) log . write ( \"\\'\\\\\\\\t\\'\" ) ; else if ( ch == \\' \\' ) log . write ( \"\\'\\\\\\\\b\\'\" ) ; else if ( ch == \\' \\' ) log . write ( \"\\'\\\\\\\\n\\'\" ) ; else if ( ch == \\' \\' ) log . write ( \"\\'\\\\\\\\r\\'\" ) ; else if ( ch == \\' \\' ) log . write ( \"\\'\\\\\\\\f\\'\" ) ; else if ( ch == \\' \\' ) log . write ( \"\\'\\\\\\\\\\'\" ) ; else if ( ch == \\' \\' ) log . write ( \"\\'\\\\\\\\\\\\\\\\\\'\" ) ; else if ( ch == \\' \\' ) log . write ( \"\\'\\\\\\\\\\\\\"\\'\" ) ; else if ( ch < \\' \\' ) { log . write ( \"\\'\\\\\\\\u\" ) ; String hex = Integer . toHexString ( ch ) ; for ( int l = hex . length ( ) ; l < 4 ; l ++ ) log . write ( \\' \\' ) ; log . write ( hex ) ; log . write ( \\' \\' ) ; } else { log . write ( \\' \\' ) ; log . write ( ch ) ; log . write ( \\' \\' ) ; } }'", "label": "'Writes a character unicode escaping as needed .'"}
{"text": "'private void log ( String value ) throws IOException { if ( value == null ) { log . write ( \"(String)null\" ) ; } else { log . write ( \\' \\' ) ; for ( int i = 0 , len = value . length ( ) ; i < len ; i ++ ) { char ch = value . charAt ( i ) ; if ( ch == \\' \\' ) log . write ( \"\\\\\\\\t\" ) ; else if ( ch == \\' \\' ) log . write ( \"\\\\\\\\b\" ) ; else if ( ch == \\' \\' ) log . write ( \"\\\\\\\\n\" ) ; else if ( ch == \\' \\' ) log . write ( \"\\\\\\\\r\" ) ; else if ( ch == \\' \\' ) log . write ( \"\\\\\\\\f\" ) ; else if ( ch == \\' \\' ) log . write ( \"\\\\\\\\\\\\\\\\\" ) ; else if ( ch == \\' \\' ) log . write ( \"\\\\\\\\\\\\\"\" ) ; else if ( ch < \\' \\' ) { log . write ( \"\\\\\\\\u\" ) ; String hex = Integer . toHexString ( ch ) ; for ( int l = hex . length ( ) ; l < 4 ; l ++ ) log . write ( \\' \\' ) ; log . write ( hex ) ; } else { log . write ( ch ) ; } } log . write ( \\' \\' ) ; } }'", "label": "'Writes a String unicode escaping as needed .'"}
{"text": "'public static BeanManager getBeanManager ( ) { try { InitialContext initialContext = new InitialContext ( ) ; return ( BeanManager ) initialContext . lookup ( \"java:comp/BeanManager\" ) ; } catch ( NamingException e ) { if ( beanManager != null ) { return beanManager ; } throw new IllegalStateException ( \"BeanManager not found in JNDI and not set via setBeanManager()\" ) ; } }'", "label": "'Looks up the current bean manager in JNDI or returns the value set by { @link #setBeanManager ( BeanManager ) } as fallback .'"}
{"text": "'public static ContentValues acquire ( ) { ContentValues vals = sPool . acquire ( ) ; return vals != null ? vals : new ContentValues ( ) ; }'", "label": "'Get an empty set of values from the pool . Make sure to {'"}
{"text": "'public static ContentValues putAll ( ContentValues target , Object ... values ) { int length = values . length ; checkArgument ( length % 2 == 0 , \"values length must be a multiple of two\" ) ; for ( int i = 0 ; i < length ; i += 2 ) { String key = ( String ) values [ i ] ; Object val = values [ i + 1 ] ; if ( val == null ) { target . putNull ( key ) ; } else if ( val instanceof String ) { target . put ( key , ( String ) val ) ; } else if ( val instanceof Long ) { target . put ( key , ( Long ) val ) ; } else if ( val instanceof Integer ) { target . put ( key , ( Integer ) val ) ; } else if ( val instanceof Boolean ) { target . put ( key , ( Boolean ) val ) ; } else if ( val instanceof Double ) { target . put ( key , ( Double ) val ) ; } else if ( val instanceof Float ) { target . put ( key , ( Float ) val ) ; } else if ( val instanceof byte [ ] ) { target . put ( key , ( byte [ ] ) val ) ; } else if ( val instanceof Byte ) { target . put ( key , ( Byte ) val ) ; } else if  ( val instanceof Short )  { target . put ( key , ( Short ) val ) ; } else  { throw new IllegalArgumentException ( \"ContentValues does not support values of type \" + val . getClass ( ) . getName ( ) + \" (provided for key \\'\" + key + \"\\')\" ) ; } }'", "label": "'Put all of the values into the existing set .'"}
{"text": "'public void onBind ( B binding , E item , int position , List < Object > payloads ) { onBind ( binding , item , position ) ; }'", "label": "'Update the contents of the binding to reflect the item at the position . Any payload info can be used to run an efficient partial update .'"}
{"text": "'public void moveCameraToLastLocation ( GoogleMap map , float zoom ) { mProvider . getLastLocation ( ) . subscribe ( location -> map . moveCamera ( CameraUpdateFactory . newLatLngZoom ( new LatLng ( location . getLatitude ( ) , location . getLongitude ( ) ) , zoom ) ) ) ; }'", "label": "'Move and zoom to the most recently reported location .'"}
{"text": "'public void animateCameraToIncludePosition ( GoogleMap map , LatLng position , long delay ) { if ( ! map . getProjection ( ) . getVisibleRegion ( ) . latLngBounds . contains ( position ) ) { if ( delay > 0 ) { new Handler ( Looper . getMainLooper ( ) ) . postDelayed ( ( ) -> doAnimateCameraToIncludePosition ( map , position ) , delay ) ; } else { doAnimateCameraToIncludePosition ( map , position ) ; } } }'", "label": "'If the position is not visible on the map animate the camera to include it after the delay .'"}
{"text": "'@ UiThread public void postWhenResumed ( Runnable action ) { if ( ! mStateSaved ) { if ( mHandler == null ) { mHandler = new Handler ( ) ; } mHandler . post ( action ) ; } else { if ( mPosts == null ) { mPosts = new ArrayDeque <> ( ) ; } mPosts . offer ( action ) ; } }'", "label": "'If {'"}
{"text": "'public static Uri appendId ( Uri uri , Cursor cursor ) { return ContentUris . withAppendedId ( uri , cursor . getLong ( cursor . getColumnIndexOrThrow ( _ID ) ) ) ; }'", "label": "'Append the cursor s { @link BaseColumns#_ID _ID } value to the URI .'"}
{"text": "'public static Uri groupBy ( Uri uri , String groupBy ) { return groupByHavingLimit ( uri , groupBy , null , null ) ; }'", "label": "'Append a { @link Content#GROUP_BY group_by } query parameter to the URI .'"}
{"text": "'public static Uri groupByHaving ( Uri uri , String groupBy , String having ) { return groupByHavingLimit ( uri , groupBy , having , null ) ; }'", "label": "'Append { @link Content#GROUP_BY group_by } and { @link Content#HAVING having } query parameters to the URI .'"}
{"text": "'public static Uri limit ( Uri uri , int limit ) { return limit ( uri , String . valueOf ( limit ) ) ; }'", "label": "'Append a { @link Content#LIMIT limit } query parameter to the URI .'"}
{"text": "'public static Uri limit ( Uri uri , String limit ) { return groupByHavingLimit ( uri , null , null , limit ) ; }'", "label": "'Append a {'"}
{"text": "'public static Uri groupByHavingLimit ( Uri uri , String groupBy , String having , String limit ) { Builder builder = uri . buildUpon ( ) ; if ( ! TextUtils . isEmpty ( groupBy ) ) { builder . appendQueryParameter ( GROUP_BY , groupBy ) ; } if ( ! TextUtils . isEmpty ( having ) ) { builder . appendQueryParameter ( HAVING , having ) ; } if ( ! TextUtils . isEmpty ( limit ) ) { builder . appendQueryParameter ( LIMIT , limit ) ; } return builder . build ( ) ; }'", "label": "'Append { @link Content#GROUP_BY group_by } { @link Content#HAVING having } and { @link Content#LIMIT limit } query parameters to the URI . Any null or empty parameters are skipped .'"}
{"text": "'public static Uri notifyChange ( Uri uri , long id , boolean notify ) { Builder builder = uri . buildUpon ( ) ; if ( id > 0 ) { ContentUris . appendId ( builder , id ) ; } return builder . appendQueryParameter ( NOTIFY_CHANGE , notify ? \"1\" : \"0\" ) . build ( ) ; }'", "label": "'Append the ID if it is greater than zero and a { @link Content#NOTIFY_CHANGE notify_change } query parameter to the URI .'"}
{"text": "'public static Uri mailto ( List < String > to , List < String > cc , List < String > bcc , String subject , String body ) { String encSubject = Uri . encode ( subject ) ; String encBody = Uri . encode ( body ) ; StringBuilder ssp = new StringBuilder ( CollectionUtils . size ( to ) * 34 + CollectionUtils . size ( cc ) * 34 + CollectionUtils . size ( bcc ) * 34 + StringUtils . length ( encSubject ) + StringUtils . length ( encBody ) ) ; Joiner joiner = Joiner . on ( \\' \\' ) ; if ( CollectionUtils . isNotEmpty ( to ) ) { joiner . appendTo ( ssp , to ) ; } boolean start = true ; if ( CollectionUtils . isNotEmpty ( cc ) ) { //noinspection ConstantConditions joiner . appendTo ( ssp . append ( separator ( start ) ) . append ( \"cc=\" ) , cc ) ; start = false ; } if ( CollectionUtils . isNotEmpty ( bcc ) ) { joiner . appendTo ( ssp . append ( separator ( start ) ) . append ( \"bcc=\" ) , bcc ) ; start = false ; } if ( ! TextUtils . isEmpty ( encSubject ) ) { ssp . append ( separator ( start ) ) . append ( \"subject=\" ) . append ( encSubject ) ; start = false ; } if ( ! TextUtils . isEmpty ( encBody ) ) { ssp . append ( separator ( start ) ) . append ( \"body=\" ) . append ( encBody ) ; //noinspection UnusedAssignment start = false ; } return new Builder ( ) . scheme ( \"mailto\" ) . encodedOpaquePart ( ssp . toString ( ) ) . build ( ) ; }'", "label": "'Get a {'"}
{"text": "'static void init ( Context context ) { Context app = context . getApplicationContext ( ) ; sProvider = DoubleCheck . provider ( ( ) -> ( app . getApplicationInfo ( ) . flags & FLAG_DEBUGGABLE ) == FLAG_DEBUGGABLE ? DaggerSprocketsComponent_Debug . builder ( ) . context ( app ) . build ( ) : DaggerSprocketsComponent_Release . builder ( ) . context ( app ) . build ( ) ) ; }'", "label": "'Called by {'"}
{"text": "'public static Animator circleToRect ( View circle , View rect ) { return circleRect ( circle , rect , true ) ; }'", "label": "'Get an Animator that reveals the rectangular View from the circular View .'"}
{"text": "'public static Animator circleFromRect ( View circle , View rect ) { return circleRect ( circle , rect , false ) ; }'", "label": "'Get an Animator that unreveals the rectangular View to the circular View .'"}
{"text": "'public static UserHeaderNavigationFragment newInstance ( @ DrawableRes int headerBackground ) { UserHeaderNavigationFragment frag = new UserHeaderNavigationFragment ( ) ; Bundle args = Fragments . arguments ( frag ) ; args . putInt ( HEADER_BACKGROUND , headerBackground ) ; return frag ; }'", "label": "'Display the Drawable as the header background .'"}
{"text": "'public static ProgressBarFragment newInstance ( @ AttrRes int style ) { ProgressBarFragment frag = new ProgressBarFragment ( ) ; Bundle args = Fragments . arguments ( frag ) ; args . putInt ( STYLE , style ) ; return frag ; }'", "label": "'Create a ProgressBar with the style of the theme attribute .'"}
{"text": "\"@ UiThread public static void tryDelayed ( ViewGroup sceneRoot ) { if ( ! sceneRoot . isLaidOut ( ) ) { // transition won't run return ; } if ( sDelayedTransition == null ) { sDelayedTransition = new AutoTransition ( ) . addListener ( new SimpleTransitionListener ( ) { @ Override public void onTransitionEnd ( Transition transition ) { super . onTransitionEnd ( transition ) ; sDelayedTransitionRunning = false ; } } ) ; } if ( ! sDelayedTransitionRunning ) { sDelayedTransitionRunning = true ; TransitionManager . beginDelayedTransition ( sceneRoot , sDelayedTransition ) ; } }\"", "label": "'{'"}
{"text": "'public static Transition arcMotion ( Context context ) { if ( sArc == null ) { sArc = TransitionInflater . from ( context ) . inflateTransition ( R . transition . sprockets_arc_motion ) ; } return sArc ; }'", "label": "'Get a cached arc motion transition .'"}
{"text": "'public static StyleSpan bold ( int i ) { if ( sBolds == null ) { sBolds = new ArrayList <> ( ) ; sBolds . add ( bold ( ) ) ; } if ( i < sBolds . size ( ) ) { return sBolds . get ( i ) ; } else { StyleSpan bold = new StyleSpan ( Typeface . BOLD ) ; sBolds . add ( bold ) ; return bold ; } }'", "label": "'Get a cached bold span .'"}
{"text": "'public static ForegroundColorSpan foregroundColor ( @ ColorInt int color , int i ) { if ( sForeColors == null ) { sForeColors = new SparseArray <> ( ) ; } List < ForegroundColorSpan > spans = sForeColors . get ( color ) ; if ( spans == null ) { spans = new ArrayList <> ( ) ; sForeColors . put ( color , spans ) ; } if ( i < spans . size ( ) ) { return spans . get ( i ) ; } else { ForegroundColorSpan span = new ForegroundColorSpan ( color ) ; spans . add ( span ) ; return span ; } }'", "label": "'Get a cached foreground color span .'"}
{"text": "'public static ViewPropertyAnimator scaleIn ( View view ) { return scale ( view , 1.0f , enterScreen ( ) , R . integer . anim_duration_enter ) ; }'", "label": "'Scale in the View to full size .'"}
{"text": "'public static ViewPropertyAnimator scaleOut ( View view ) { return scale ( view , 0.0f , exitScreen ( ) , R . integer . anim_duration_exit ) ; }'", "label": "'Scale out the View to zero size .'"}
{"text": "'public static ViewPropertyAnimator scaleSwap ( ImageView image , @ DrawableRes int drawableId ) { return scaleSwap ( image , drawableId , null ) ; }'", "label": "'Scale out the image swap in the Drawable resource and scale it back in . <p > <strong > Note : < / strong > The returned animator s { @code endAction } is already set so don t overwrite it with your own . To perform an action after the image is scaled back in call { @link #scaleSwap ( ImageView int Runnable ) } instead . < / p >'"}
{"text": "'public static ViewPropertyAnimator scaleSwap ( ImageView image , @ DrawableRes int drawableId , Runnable endAction ) { return scale ( image , ( ) -> image . setImageResource ( drawableId ) , endAction ) ; }'", "label": "'Scale out the image swap in the Drawable resource scale it back in and run the action .'"}
{"text": "'public static ViewPropertyAnimator scaleShowNext ( ViewSwitcher view , Runnable endAction ) { return scale ( view , view :: showNext , endAction ) ; }'", "label": "'Scale out the ViewSwitcher show the next View scale it back in and run the action .'"}
{"text": "'@ Nullable public static ViewPropertyAnimator makeScaleDownAnimation ( Activity a ) { Rect to = a . getIntent ( ) . getSourceBounds ( ) ; return to != null ? makeScaleDownAnimation ( a , to ) : null ; }'", "label": "'Scale the Activity down to the rectangle provided by its { @link Intent#getSourceBounds () getIntent () . getSourceBounds () } . To see the Activity behind this one you must include the below attributes [ 1 ] in your Activity theme . You may further modify the animator for example to fade out the Activity by decreasing its { @link ViewPropertyAnimator#alpha ( float ) alpha } and / or set an { @link ViewPropertyAnimator#withEndAction ( Runnable ) end action } that finishes the Activity . When finishing the Activity in this way you may wish to also call { @link Activity#overridePendingTransition ( int int ) Activity . overridePendingTransition ( 0 0 ) } in order to prevent the system Activity close animation from running . <p > 1 . Activity theme attributes < / p > { @code <item name = android : windowBackground > @android : color / transparent< / item > } <br / > { @code <item name = android : windowIsTranslucent > true< / item > }'"}
{"text": "'public static ViewPropertyAnimator makeScaleDownAnimation ( Activity a , Rect to ) { View view = a . getWindow ( ) . getDecorView ( ) ; Rect frame = Windows . getFrame ( a ) ; float sx = ( float ) to . width ( ) / view . getWidth ( ) ; float sy = ( float ) to . height ( ) / ( view . getHeight ( ) - frame . top ) ; // ignore status bar view . setPivotX ( 0.0f ) ; view . setPivotY ( 0.0f ) ; return view . animate ( ) . translationX ( to . left ) . translationY ( to . top - frame . top * sy ) . scaleX ( sx ) . scaleY ( sy ) . withLayer ( ) ; }'", "label": "'Scale the Activity down to the rectangle . To see the Activity behind this one you must include the below attributes [ 1 ] in your Activity theme . You may further modify the animator for example to fade out the Activity by decreasing its { @link ViewPropertyAnimator#alpha ( float ) alpha } and / or set an { @link ViewPropertyAnimator#withEndAction ( Runnable ) end action } that finishes the Activity . When finishing the Activity in this way you may wish to also call { @link Activity#overridePendingTransition ( int int ) Activity . overridePendingTransition ( 0 0 ) } in order to prevent the system Activity close animation from running . <p > 1 . Activity theme attributes < / p > { @code <item name = android : windowBackground > @android : color / transparent< / item > } <br / > { @code <item name = android : windowIsTranslucent > true< / item > }'"}
{"text": "'public static int getCount ( Context context , Uri uri ) { String [ ] proj = { \"COUNT(*)\" } ; return Cursors . firstInt ( context . getContentResolver ( ) . query ( uri , proj , null , null , null ) ) ; }'", "label": "'Get the number of rows at the URI .'"}
{"text": "'public static void requestSyncNow ( Account account , String authority , @ Nullable Bundle extras ) { if ( extras == null ) { extras = new Bundle ( ) ; } extras . putBoolean ( SYNC_EXTRAS_MANUAL , true ) ; extras . putBoolean ( SYNC_EXTRAS_EXPEDITED , true ) ; ContentResolver . requestSync ( account , authority , extras ) ; }'", "label": "'Request that a sync starts immediately .'"}
{"text": "'public static String concatAddressLines ( Address address , String delimiter ) { StringBuilder s = new StringBuilder ( 256 ) ; for ( int i = 0 , max = address . getMaxAddressLineIndex ( ) ; i <= max ; i ++ ) { if ( i > 0 ) { s . append ( delimiter ) ; } s . append ( address . getAddressLine ( i ) ) ; } return s . toString ( ) ; }'", "label": "'Get a single line address which uses the delimiter between the original lines .'"}
{"text": "'public static GoogleApiClient connect ( GoogleApiClient client , ConnectedListener connected , OnConnectionFailedListener failed ) { client . registerConnectionCallbacks ( new ConnectionListener ( connected ) ) ; client . registerConnectionFailedListener ( failed ) ; client . connect ( ) ; return client ; }'", "label": "'Register the listeners and then connect the client .'"}
{"text": "'public static Bundle arguments ( Fragment frag ) { Bundle args = frag . getArguments ( ) ; if ( args == null ) { if ( ! frag . isAdded ( ) ) { args = new Bundle ( ) ; try { frag . setArguments ( args ) ; } catch ( IllegalStateException e ) { // \"attached\" but not yet \"added\" args = EMPTY ; } } else { args = EMPTY ; } } return args ; }'", "label": "'Get the arguments for the Fragment . If the Fragment doesn t have arguments and it isn t attached to an Activity a new Bundle will be set as its arguments . Otherwise an empty ( and immutable ) Bundle will be returned .'"}
{"text": "'@ SuppressLint ( \"CommitTransaction\" ) private static FragmentTransaction transit ( FragmentManager fm , int transit ) { return fm != null ? fm . beginTransaction ( ) . setTransition ( transit ) : null ; }'", "label": "'Begin a transaction that uses the transition .'"}
{"text": "'@ Nullable public static < T extends Fragment > T findById ( Activity a , @ IdRes int id ) { return findById ( a . getFragmentManager ( ) , id ) ; }'", "label": "'Get the Fragment with the ID .'"}
{"text": "'@ Nullable public static < T extends Fragment > T findById ( Fragment frag , @ IdRes int id ) { return findById ( frag . getFragmentManager ( ) , id ) ; }'", "label": "'Get the Fragment with the ID .'"}
{"text": "'@ Nullable @ SuppressWarnings ( \"unchecked\" ) public static < T extends Fragment > T findById ( FragmentManager fm , @ IdRes int id ) { return ( T ) fm . findFragmentById ( id ) ; }'", "label": "'Get the Fragment with the ID .'"}
{"text": "'@ Override public int getForegroundColor ( ) { return Color . argb ( mAlpha , Color . red ( mColor ) , Color . green ( mColor ) , Color . blue ( mColor ) ) ; }'", "label": "'Get the result of applying the alpha to the color .'"}
{"text": "'public static < T extends View > T visible ( @ Nullable T view ) { return set ( view , VISIBLE ) ; }'", "label": "'Make the View visible if it isn t already .'"}
{"text": "'public static < T extends View > T invisible ( @ Nullable T view ) { return set ( view , INVISIBLE ) ; }'", "label": "'Make the View invisible if it isn t already .'"}
{"text": "'public static < T extends View > T gone ( @ Nullable T view ) { return set ( view , GONE ) ; }'", "label": "'Make the View gone if it isn t already .'"}
{"text": "'public static < T extends View > T measure ( T view , ViewGroup parent ) { LayoutParams p = view . getLayoutParams ( ) ; int w = parent != null && p . width == MATCH_PARENT ? parent . getMeasuredWidth ( ) : p . width ; int h = parent != null && p . height == MATCH_PARENT ? parent . getMeasuredHeight ( ) : p . height ; return measure ( view , w , h ) ; }'", "label": "'{ @link View#measure ( int int ) Measure } the View in its parent . You can then call { @link View#getMeasuredWidth () } and { @link View#getMeasuredHeight () } .'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public static < T extends View > T inflate ( ViewStub stub , @ Nullable T view ) { return view == null ? ( T ) stub . inflate ( ) : view ; }'", "label": "'Inflate the ViewStub if the View is null . Otherwise just get the previously inflated View .'"}
{"text": "'public static void setOnClickListeners ( OnClickListener listener , View ... views ) { for ( View view : views ) { view . setOnClickListener ( listener ) ; } }'", "label": "'Set the listener on all of the Views .'"}
{"text": "'public void e ( Object src , String msg , @ Nullable Throwable thrown ) { maybeLog ( ERROR , src , msg , thrown ) ; }'", "label": "'Send an ERROR log message and log the exception .'"}
{"text": "'public void w ( Object src , String msg , @ Nullable Throwable thrown ) { maybeLog ( WARN , src , msg , thrown ) ; }'", "label": "'Send a WARN log message and log the exception .'"}
{"text": "'public void i ( Object src , String msg , @ Nullable Throwable thrown ) { maybeLog ( INFO , src , msg , thrown ) ; }'", "label": "'Send an INFO log message and log the exception .'"}
{"text": "'public void d ( Object src , String msg , @ Nullable Throwable thrown ) { maybeLog ( DEBUG , src , msg , thrown ) ; }'", "label": "'Send a DEBUG log message and log the exception .'"}
{"text": "'public void v ( Object src , String msg , @ Nullable Throwable thrown ) { maybeLog ( VERBOSE , src , msg , thrown ) ; }'", "label": "'Send a VERBOSE log message and log the exception .'"}
{"text": "'public static String getLevelName ( int level ) { switch ( level ) { case VERBOSE : return \"VERBOSE\" ; case DEBUG : return \"DEBUG\" ; case INFO : return \"INFO\" ; case WARN : return \"WARN\" ; case ERROR : return \"ERROR\" ; case ASSERT : return \"ASSERT\" ; default : return \"?\" ; } }'", "label": "'Get the name of the level .'"}
{"text": "'public static ActivityOptions makeScaleUpAnimation ( View source ) { return ActivityOptions . makeScaleUpAnimation ( source , 0 , 0 , source . getWidth ( ) , source . getHeight ( ) ) ; }'", "label": "'Scale the new Activity from the View to its full size .'"}
{"text": "'public static void show ( View view ) { view . postDelayed ( ( ) -> Managers . inputMethod ( view . getContext ( ) ) . showSoftInput ( view , 0 ) , 300L ) ; // give InputMethodManager some time to recognise that the View is focused }'", "label": "'Show the current input method for the focused View which can receive input .'"}
{"text": "'public static void hide ( View view ) { Managers . inputMethod ( view . getContext ( ) ) . hideSoftInputFromWindow ( view . getWindowToken ( ) , 0 ) ; }'", "label": "'Hide the input method for the View s window .'"}
{"text": "'public static boolean hasPosition ( Cursor cursor , int position ) { return ! cursor . isClosed ( ) && position >= 0 && position < cursor . getCount ( ) ; }'", "label": "'True if the cursor has a row at the position .'"}
{"text": "'public static int count ( Cursor cursor , boolean close ) { int count = cursor . getCount ( ) ; close ( cursor , close ) ; return count ; }'", "label": "'Get the number of rows in the cursor .'"}
{"text": "'public static int firstInt ( Cursor cursor , boolean close ) { int i = cursor . moveToFirst ( ) ? cursor . getInt ( 0 ) : Integer . MIN_VALUE ; close ( cursor , close ) ; return i ; }'", "label": "'Get the int value in the first row and column .'"}
{"text": "'public static long firstLong ( Cursor cursor , boolean close ) { long l = cursor . moveToFirst ( ) ? cursor . getLong ( 0 ) : Long . MIN_VALUE ; close ( cursor , close ) ; return l ; }'", "label": "'Get the long value in the first row and column .'"}
{"text": "'@ Nullable public static String firstString ( Cursor cursor , boolean close ) { String s = cursor . moveToFirst ( ) ? cursor . getString ( 0 ) : null ; close ( cursor , close ) ; return s ; }'", "label": "'Get the String value in the first row and column .'"}
{"text": "'public static int [ ] allInts ( Cursor cursor , boolean close ) { int [ ] i = EMPTY_INT_ARRAY ; if ( cursor . moveToFirst ( ) ) { i = new int [ cursor . getCount ( ) ] ; do { i [ cursor . getPosition ( ) ] = cursor . getInt ( 0 ) ; } while ( cursor . moveToNext ( ) ) ; } close ( cursor , close ) ; return i ; }'", "label": "'Get all int values in the first column .'"}
{"text": "'public static long [ ] allLongs ( Cursor cursor , boolean close ) { long [ ] l = EMPTY_LONG_ARRAY ; if ( cursor . moveToFirst ( ) ) { l = new long [ cursor . getCount ( ) ] ; do { l [ cursor . getPosition ( ) ] = cursor . getLong ( 0 ) ; } while ( cursor . moveToNext ( ) ) ; } close ( cursor , close ) ; return l ; }'", "label": "'Get all long values in the first column .'"}
{"text": "'public static String [ ] allStrings ( Cursor cursor , boolean close ) { String [ ] s = EMPTY_STRING_ARRAY ; if ( cursor . moveToFirst ( ) ) { s = new String [ cursor . getCount ( ) ] ; do { s [ cursor . getPosition ( ) ] = cursor . getString ( 0 ) ; } while ( cursor . moveToNext ( ) ) ; } close ( cursor , close ) ; return s ; }'", "label": "'Get all String values in the first column .'"}
{"text": "'public void onBind ( B binding , int position , List < Object > payloads ) { onBind ( binding , position ) ; }'", "label": "'Update the contents of the binding to reflect the item at the position . Any payload info can be used to run an efficient partial update .'"}
{"text": "'@ BindingAdapter ( value = { \"sprockets_placeholder\" , \"sprockets_load\" , \"sprockets_resize\" , \"sprockets_transform\" } , requireAll = false ) public static void load ( ImageView view , Drawable placeholder , Uri load , boolean resize , String transform ) { RequestCreator req = Picasso . with ( view . getContext ( ) ) . load ( load ) . placeholder ( placeholder ) ; if ( resize ) { req . fit ( ) . centerCrop ( ) ; // view width/height isn\\'t available yet } if ( TextUtils . equals ( transform , \"circle\" ) ) { req . transform ( Transformations . circle ( ) ) ; } req . into ( view ) ; }'", "label": "'Set a placeholder before loading an image optionally resizing and transforming it . All attributes are optional .'"}
{"text": "'public static int getOrientation ( RecyclerView view ) { LayoutManager layout = view . getLayoutManager ( ) ; if ( layout instanceof LinearLayoutManager ) { return ( ( LinearLayoutManager ) layout ) . getOrientation ( ) ; } else if ( layout instanceof StaggeredGridLayoutManager ) { return ( ( StaggeredGridLayoutManager ) layout ) . getOrientation ( ) ; } return - 1 ; }'", "label": "'Get the orientation of the RecyclerView s LayoutManager .'"}
{"text": "'public static int getSpanCount ( RecyclerView view ) { LayoutManager layout = view . getLayoutManager ( ) ; if ( layout != null ) { if ( layout instanceof GridLayoutManager ) { return ( ( GridLayoutManager ) layout ) . getSpanCount ( ) ; } else if ( layout instanceof StaggeredGridLayoutManager ) { return ( ( StaggeredGridLayoutManager ) layout ) . getSpanCount ( ) ; } return 1 ; // assuming LinearLayoutManager } return 0 ; }'", "label": "'Get the number of spans laid out by the RecyclerView s LayoutManager .'"}
{"text": "'public static SpanSizeLookup getSpanSizeLookup ( RecyclerView view ) { LayoutManager layout = view . getLayoutManager ( ) ; if ( layout instanceof GridLayoutManager ) { return ( ( GridLayoutManager ) layout ) . getSpanSizeLookup ( ) ; } if ( sDefSpanSizeLookup == null ) { sDefSpanSizeLookup = new DefaultSpanSizeLookup ( ) ; } return sDefSpanSizeLookup ; }'", "label": "'If the RecyclerView uses a {'"}
{"text": "'public static SearchView setBackground ( SearchView view , @ DrawableRes int drawableId ) { int id = view . getResources ( ) . getIdentifier ( \"android:id/search_plate\" , null , null ) ; if ( id > 0 ) { View search = view . findViewById ( id ) ; if ( search != null ) { search . setBackgroundResource ( drawableId ) ; } } return view ; }'", "label": "'Override the default background with a theme version .'"}
{"text": "'public static RelativeLayout . LayoutParams addRule ( View view , int verb , int anchor ) { RelativeLayout . LayoutParams params = getParams ( view ) ; params . addRule ( verb , anchor ) ; view . requestLayout ( ) ; return params ; }'", "label": "'Add the rule to the View s RelativeLayout params and request a layout of the View .'"}
{"text": "'@ Override public D loadInBackground ( ) { synchronized ( this ) { if ( isLoadInBackgroundCanceled ( ) ) { throw new OperationCanceledException ( ) ; } mCancellationSignal = new CancellationSignal ( ) ; } try { Cursor cursor = getContext ( ) . getContentResolver ( ) . query ( mUri , mProjection , mSelection , mSelectionArgs , mSortOrder , mCancellationSignal ) ; if ( cursor != null ) { try { // Ensure the cursor window is filled. cursor . getCount ( ) ; cursor . registerContentObserver ( mObserver ) ; } catch ( RuntimeException ex ) { cursor . close ( ) ; throw ex ; } return wrap ( cursor ) ; } return null ; } finally { synchronized ( this ) { mCancellationSignal = null ; } } }'", "label": "'/ * Runs on a worker thread'"}
{"text": "'public CursorAdapter < VH > setCursor ( @ Nullable Cursor cursor ) { if ( cursor != mCursor ) { mCursor = cursor == null || cursor instanceof EasyCursor ? ( EasyCursor ) cursor : new EasyCursor ( cursor ) ; notifyDataSetChanged ( ) ; } return this ; }'", "label": "'Use the cursor for the items .'"}
{"text": "'@ Nullable public static Drawable tint ( Context context , @ DrawableRes int drawableId , @ AttrRes int attrId ) { Drawable d = context . getDrawable ( drawableId ) ; if ( d != null ) { d . setTint ( Themes . getColor ( context , attrId ) ) ; } return d ; }'", "label": "'Tint the Drawable with the color specified by the attribute in the Context s theme .'"}
{"text": "'@ Nullable public static Drawable matchText ( Context context , @ DrawableRes int drawableId , TextView text ) { Drawable d = context . getDrawable ( drawableId ) ; if ( d != null ) { int size = Math . round ( text . getTextSize ( ) ) ; d . setBounds ( 0 , 0 , size , size ) ; d . setTint ( text . getCurrentTextColor ( ) ) ; } return d ; }'", "label": "'Set the Drawable s size and tint to be the same as the text .'"}
{"text": "'public static ShapeDrawable oval ( @ ColorInt int color ) { if ( sOval == null ) { sOval = new OvalShape ( ) ; } ShapeDrawable d = new ShapeDrawable ( sOval ) ; d . setIntrinsicWidth ( - 1 ) ; d . setIntrinsicHeight ( - 1 ) ; d . getPaint ( ) . setColor ( color ) ; return d ; }'", "label": "'Get a colored oval .'"}
{"text": "'public static Rect getFrame ( Activity a ) { Rect frame = new Rect ( ) ; a . getWindow ( ) . getDecorView ( ) . getWindowVisibleDisplayFrame ( frame ) ; return frame ; }'", "label": "'Get the {'"}
{"text": "'public boolean wasRead ( ) { int pos = getPosition ( ) ; if ( pos < 0 || pos >= mRead . length ) { return false ; } boolean read = mRead [ pos ] ; if ( ! read ) { mRead [ pos ] = true ; } return read ; }'", "label": "'True if this method has been previously called for the current row . False if the cursor is before the first row or after the last row .'"}
{"text": "'public NavigationDrawerActivity setDrawerLayout ( DrawerLayout drawer ) { mDrawer = drawer ; if ( mDrawer . getFitsSystemWindows ( ) ) { // let it draw the status bar getWindow ( ) . setStatusBarColor ( TRANSPARENT ) ; } return this ; }'", "label": "'Connect the DrawerLayout to the ActionBar . Should be called in {'"}
{"text": "'public static Looper mineOrMain ( ) { Looper looper = Looper . myLooper ( ) ; return looper != null ? looper : Looper . getMainLooper ( ) ; }'", "label": "'Get this thread s Looper if it s a Looper thread . Otherwise get the main thread Looper .'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public static < E > List < E > values ( SparseArray < E > array ) { return ( List < E > ) values ( array , null , null , null , null ) ; }'", "label": "'Get the values of the SparseArray .'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public static < E > List < E > values ( LongSparseArray < E > array ) { return ( List < E > ) values ( null , null , null , null , array ) ; }'", "label": "'Get the values of the LongSparseArray .'"}
{"text": "'private void checkAdapter ( ) { PagerAdapter adapter = mPager . getAdapter ( ) ; if ( mAdapter != adapter ) { if ( mAdapter != null ) { mAdapter . unregisterDataSetObserver ( mObserver ) ; } mAdapter = adapter ; if ( mAdapter != null ) { mAdapter . registerDataSetObserver ( mObserver ) ; } reset ( ) ; } }'", "label": "'Check if the pager has a new adapter and switch to it if it does .'"}
{"text": "\"private void checkDrawable ( ) { Drawable drawable = mView . getDrawable ( ) ; if ( mDrawable != drawable ) { /* get the latest View size and ensure that it's been measured */ mViewWidth = mView . getWidth ( ) ; mViewHeight = mView . getHeight ( ) ; if ( mViewWidth > 0 && mViewHeight > 0 ) { mDrawable = drawable ; // don't save until now so above is repeated until measured if ( mDrawable != null ) { mDrawableWidth = mDrawable . getIntrinsicWidth ( ) ; mDrawableHeight = mDrawable . getIntrinsicHeight ( ) ; if ( mDrawableWidth > 0 && mDrawableHeight > 0 ) { // e.g. colors don't have size float widthRatio = ( float ) mViewWidth / mDrawableWidth ; float heightRatio = ( float ) mViewHeight / mDrawableHeight ; mScale = widthRatio > heightRatio ? widthRatio : heightRatio ; } else { // nothing to scale, ensure matrix is skipped mScale = 0.0f ; } } } else { // don't update matrix until View is measured mScale = 0.0f ; } reset ( ) ; } }\"", "label": "'Check if the ImageView has a new Drawable and calculate the new scaling if it does .'"}
{"text": "'private void updateMatrix ( int position , float offset ) { if ( mDrawable != null && mScale > 0.0f ) { if ( mPageCount == - 1 && mAdapter != null ) { // cache page count and translation values mPageCount = mAdapter . getCount ( ) ; if ( mPageCount > 1 ) { mPageX = ( mDrawableWidth * mScale - mViewWidth ) / ( mPageCount - 1 ) ; mPageY = ( mDrawableHeight * mScale - mViewHeight ) / ( mPageCount - 1 ) ; } } mMatrix . setTranslate ( - mPageX * position - mPageX * offset , - mPageY * position - mPageY * offset ) ; mMatrix . preScale ( mScale , mScale ) ; mView . setScaleType ( MATRIX ) ; mView . setImageMatrix ( mMatrix ) ; } }'", "label": "'Scale the image and translate it according to the pager position and offset .'"}
{"text": "'private int updDel ( int op , Uri uri , ContentValues vals , String sel , String [ ] args ) { /* get the IDs of records that will be affected */ Sql sql = elements ( op , uri , new String [ ] { \"rowid\" } , sel , args , null ) ; long [ ] ids = Cursors . allLongs ( sql . mResult ) ; /* update or delete the records and then notify about any changes */ SQLiteDatabase db = mHelper . getWritableDatabase ( ) ; int rows = op == UPDATE ? db . update ( sql . table ( ) , vals , sql . sel ( ) , sql . args ( ) ) : db . delete ( sql . table ( ) , ! TextUtils . isEmpty ( sql . sel ( ) ) ? sql . sel ( ) : \"1\" , sql . args ( ) ) ; if ( rows > 0 ) { for ( long id : ids ) { notifyChange ( ContentUris . withAppendedId ( sql . notifyUri ( ) , id ) , uri ) ; } } return rows ; }'", "label": "'Update or delete records and get the number of rows affected .'"}
{"text": "'@ SuppressWarnings ( \"ConstantConditions\" ) private void notifyChange ( Uri notify , Uri orig ) { if ( orig . getBooleanQueryParameter ( NOTIFY_CHANGE , true ) ) { getContext ( ) . getContentResolver ( ) . notifyChange ( notify , null , ! orig . getBooleanQueryParameter ( CALLER_IS_SYNCADAPTER , false ) ) ; } }'", "label": "'Notify observers of a change at notify URI . This will be a no - op if the original URI specifies {'"}
{"text": "'private Sql elements ( int op , Uri uri , String [ ] proj , String sel , String [ ] args , String order ) { MutableSql sql = translate ( uri ) ; if ( sql == null ) { sql = Sql . create ( ) ; } if ( sql . table ( ) == null ) { sql . table ( uri . getPathSegments ( ) . get ( 0 ) ) ; } if ( sql . notifyUri ( ) == null && op != SELECT ) { sql . notifyUri ( uri . buildUpon ( ) . path ( sql . table ( ) ) . clearQuery ( ) . fragment ( null ) . build ( ) ) ; } if ( op != INSERT ) { // run the query and return the cursor String from = sql . join ( ) != null ? sql . table ( ) + \\' \\' + sql . join ( ) : sql . table ( ) ; if ( ( sql . sel ( ) == null || sql . args ( ) == null ) && uri . getPathSegments ( ) . size ( ) == 2 ) { try { // filter on ID if URI in /table/id format long id = ContentUris . parseId ( uri ) ; if ( id > 0 ) { if ( sql . sel ( ) == null ) { sql . sel ( \"rowid = ?\" ) ; } if ( sql . args ( ) == null ) { sql . args ( String . valueOf ( id ) ) ; } } } catch ( NumberFormatException e ) { // last segment not a number } } if ( sel != null ) { // append caller values sql . sel ( DatabaseUtils . concatenateWhere ( sql . sel ( ) , sel ) ) ; } if ( args != null ) { sql . args ( DatabaseUtils . appendSelectionArgs ( sql . args ( ) , args ) ) ; } String groupBy = uri . getQueryParameter ( GROUP_BY ) ; if ( groupBy != null ) { // prefer caller\\'s value sql . groupBy ( groupBy ) ; } String having = uri . getQueryParameter ( HAVING ) ; if ( having != null ) { sql . having ( having ) ; } if ( order != null ) { sql . orderBy ( order ) ; } String limit = uri . getQueryParameter ( LIMIT ) ; if ( limit != null ) { sql . limit ( limit ) ; } sql . mResult = mHelper . getReadableDatabase ( ) . query ( from , proj , sql . sel ( ) , sql . args ( ) , sql . groupBy ( ) , sql . having ( ) , sql . orderBy ( ) , sql . limit ( ) ) ; } return sql ; }'", "label": "'Get the updated SQL elements for the URI and when not inserting a cursor with the query results .'"}
{"text": "'public static int getByteCount ( int width , int height , Config config ) { int bytes = 0 ; switch ( config ) { case ALPHA_8 : bytes = 1 ; break ; case RGB_565 : bytes = 2 ; break ; case ARGB_4444 : bytes = 2 ; break ; case ARGB_8888 : bytes = 4 ; break ; } return width * height * bytes ; }'", "label": "'Get the number of bytes that would be used to store a bitmap with the size in pixels and storage config .'"}
{"text": "'@ Nullable public static Bitmap mutable ( Bitmap source ) { if ( source . isMutable ( ) ) { return source ; } Config config = source . getConfig ( ) ; Bitmap bm = source . copy ( config != null ? config : ARGB_8888 , true ) ; if ( bm != null ) { source . recycle ( ) ; } return bm ; }'", "label": "'If the bitmap is immutable get a mutable copy of it . After a copy is created the source bitmap will be recycled . If the bitmap is already mutable it will be returned .'"}
{"text": "'public static boolean hasActivity ( Context context , Intent intent ) { return context . getPackageManager ( ) . resolveActivity ( intent , MATCH_DEFAULT_ONLY ) != null ; }'", "label": "'True if the Intent can be resolved to an Activity .'"}
{"text": "'public static Intent mailto ( List < String > to , List < String > cc , List < String > bcc , String subject , String body ) { return new Intent ( ACTION_SENDTO , Uris . mailto ( to , cc , bcc , subject , body ) ) ; }'", "label": "'Get an Activity Intent that launches an email app with the headers . Any null or empty parameters are skipped . The subject and body will be encoded .'"}
{"text": "'@ Nullable public static Intent placePicker ( Activity a ) { int errorCode ; try { return new PlacePicker . IntentBuilder ( ) . build ( a ) ; } catch ( GooglePlayServicesNotAvailableException e ) { errorCode = e . errorCode ; } catch ( GooglePlayServicesRepairableException e ) { errorCode = e . getConnectionStatusCode ( ) ; } GoogleApiAvailability . getInstance ( ) . showErrorDialogFragment ( a , errorCode , R . id . sprockets_gmsError ) ; return null ; }'", "label": "'Get an Activity Intent that launches a { @link PlacePicker } . If the required version of Google Play services is not available an appropriate dialog will be shown and null will be returned . You can listen for the dismissal of the dialog in { @link Activity#onActivityResult ( int int Intent ) onActivityResult } with requestCode { @code R . id . sprockets_gmsError } .'"}
{"text": "'public void setDefaultContentView ( ) { setContentView ( R . layout . sprockets_panes , R . id . panes , R . id . pane1 , R . id . pane2 ) ; }'", "label": "'Use the default layout for the panes .'"}
{"text": "'@ SuppressWarnings ( \"ConstantConditions\" ) public void setContentView ( @ LayoutRes int layoutId , @ IdRes int pagerId , @ IdRes int pane1Id , @ IdRes int pane2Id ) { setContentView ( layoutId ) ; Fragment pane1 = findFragmentByPane ( 1 ) ; Fragment pane2 = findFragmentByPane ( 2 ) ; ViewPager pager = ( ViewPager ) findViewById ( pagerId ) ; /* do we need to move the fragments between the single and multi-pane layouts? */ FragmentManager fm = getFragmentManager ( ) ; FragmentTransaction ft = null ; if ( pane2 == null ) { pane2 = getFragment ( 2 ) ; } else if ( pane2 . getId ( ) != ( pager != null ? pagerId : pane2Id ) ) { ft = fm . beginTransaction ( ) . remove ( pane2 ) ; // remove in reverse to preserve indices } if ( pane1 == null ) { pane1 = getFragment ( 1 ) ; } else if ( pane1 . getId ( ) != ( pager != null ? pagerId : pane1Id ) ) { if ( ft == null ) { ft = fm . beginTransaction ( ) ; } ft . remove ( pane1 ) ; } if ( ft != null ) { ft . commitAllowingStateLoss ( ) ; fm . executePendingTransactions ( ) ; // force removes so can add to a different container } /* add the fragments to the panes */ if ( pager != null ) { pager . setAdapter ( new PanesAdapter ( pane1 , pane2 ) ) ; } else { ft = null ; if ( pane1 . getId ( ) != pane1Id ) { ft = Fragments . open ( this ) . add ( pane1Id , pane1 , PANE_1 ) ; } if ( pane2 . getId ( ) != pane2Id ) { if ( ft == null ) { ft = Fragments . open ( this ) ; } ft . add ( pane2Id , pane2 , PANE_2 ) ; } if ( ft != null ) { ft . commitAllowingStateLoss ( ) ; } } }'", "label": "'Use your own layout for the panes .'"}
{"text": "'@ Nullable @ SuppressWarnings ( \"unchecked\" ) public < T extends Fragment > T findFragmentByPane ( @ IntRange ( from = 1 , to = 2 ) int pane ) { String tag = Elements . get ( sPanes , pane - 1 ) ; return tag != null ? ( T ) getFragmentManager ( ) . findFragmentByTag ( tag ) : null ; }'", "label": "'Get the fragment that is displayed in the pane .'"}
{"text": "'public static SprocketsPreferenceFragment newInstance ( @ XmlRes int prefs , boolean logChanges ) { SprocketsPreferenceFragment frag = new SprocketsPreferenceFragment ( ) ; Bundle args = Fragments . arguments ( frag ) ; args . putInt ( PREFS , prefs ) ; args . putBoolean ( LOG_CHANGES , logChanges ) ; return frag ; }'", "label": "'Display the preferences and log changes in analytics .'"}
{"text": "\"protected void setSummary ( Preference pref ) { SharedPreferences prefs = getPreferenceManager ( ) . getSharedPreferences ( ) ; if ( pref instanceof RingtonePreference ) { String val = prefs . getString ( pref . getKey ( ) , null ) ; if ( ! TextUtils . isEmpty ( val ) ) { Ringtone tone = RingtoneManager . getRingtone ( a , Uri . parse ( val ) ) ; if ( tone != null ) { pref . setSummary ( tone . getTitle ( a ) ) ; } } else { pref . setSummary ( R . string . none ) ; } } else if ( pref instanceof MultiSelectListPreference ) { Set < String > vals = prefs . getStringSet ( pref . getKey ( ) , null ) ; if ( vals != null ) { if ( ! vals . isEmpty ( ) ) { MultiSelectListPreference multi = ( MultiSelectListPreference ) pref ; ArrayIntList indexList = new ArrayIntList ( vals . size ( ) ) ; for ( String val : vals ) { // find selected entry indexes int i = multi . findIndexOfValue ( val ) ; if ( i >= 0 ) { indexList . add ( i ) ; } } int [ ] indexes = indexList . toArray ( ) ; Arrays . sort ( indexes ) ; // to display in same order as dialog pref . setSummary ( TextUtils . join ( getString ( R . string . delimiter ) , Elements . slice ( multi . getEntries ( ) , indexes ) ) ) ; } else { pref . setSummary ( R . string . none ) ; } } } else if ( pref instanceof EditTextPreference ) { pref . setSummary ( prefs . getString ( pref . getKey ( ) , null ) ) ; } else if ( pref . getClass ( ) . equals ( Preference . class ) ) { String val = prefs . getString ( pref . getKey ( ) , null ) ; if ( ! TextUtils . isEmpty ( val ) ) { // don't clear existing summary pref . setSummary ( val ) ; } } }\"", "label": "'Set the preference s value ( s ) as its summary .'"}
{"text": "'public static Bundle of ( String key , int value ) { Bundle b = new Bundle ( 1 ) ; b . putInt ( key , value ) ; return b ; }'", "label": "'Get a Bundle of the key and value .'"}
{"text": "'public static Bundle of ( String key1 , int value1 , String key2 , int value2 ) { Bundle b = new Bundle ( 2 ) ; b . putInt ( key1 , value1 ) ; b . putInt ( key2 , value2 ) ; return b ; }'", "label": "'Get a Bundle of the keys and values .'"}
{"text": "'public static Bundle of ( String key , long value ) { Bundle b = new Bundle ( 1 ) ; b . putLong ( key , value ) ; return b ; }'", "label": "'Get a Bundle of the key and value .'"}
{"text": "'public static Bundle of ( String key , float value ) { Bundle b = new Bundle ( 1 ) ; b . putFloat ( key , value ) ; return b ; }'", "label": "'Get a Bundle of the key and value .'"}
{"text": "'public static Bundle of ( String key , String value ) { Bundle b = new Bundle ( 1 ) ; b . putString ( key , value ) ; return b ; }'", "label": "'Get a Bundle of the key and value .'"}
{"text": "'public static Intent newIntent ( Context context , String action , Uri data , ContentValues values ) { return newIntent ( context , action , data , values , null , null ) ; }'", "label": "'Get an Intent to insert or update rows of the content .'"}
{"text": "'public static Intent newUpdateIntent ( Context context , Uri data , ContentValues values , String selection , String [ ] selectionArgs ) { return newIntent ( context , ACTION_EDIT , data , values , selection , selectionArgs ) ; }'", "label": "'Get an Intent to update the selected rows of the content .'"}
{"text": "'public static Intent newDeleteIntent ( Context context , Uri data ) { return newIntent ( context , ACTION_DELETE , data , null , null , null ) ; }'", "label": "'Get an Intent to delete rows of the content .'"}
{"text": "'public static Intent newDeleteIntent ( Context context , Uri data , String selection , String [ ] selectionArgs ) { return newIntent ( context , ACTION_DELETE , data , null , selection , selectionArgs ) ; }'", "label": "'Get an Intent to delete the selected rows of the content .'"}
{"text": "'public static int getColor ( Context context , @ AttrRes int attrId ) { int color = 0 ; TypedArray a = context . obtainStyledAttributes ( new int [ ] { attrId } ) ; try { color = a . getColor ( 0 , 0 ) ; } catch ( UnsupportedOperationException e ) { error ( \"color\" , attrId , e ) ; } a . recycle ( ) ; return color ; }'", "label": "'Get the color specified by the attribute in the Context s theme .'"}
{"text": "'@ Nullable public static Drawable getDrawable ( Context context , @ AttrRes int attrId ) { Drawable d = null ; TypedArray a = context . obtainStyledAttributes ( new int [ ] { attrId } ) ; try { d = a . getDrawable ( 0 ) ; } catch ( UnsupportedOperationException e ) { error ( \"drawable\" , attrId , e ) ; } a . recycle ( ) ; return d ; }'", "label": "'Get the Drawable specified by the attribute in the Context s theme .'"}
{"text": "'public static int getActionBarSize ( Context context ) { TypedArray a = context . obtainStyledAttributes ( sActionBarSize ) ; int size = a . getDimensionPixelSize ( 0 , 0 ) ; a . recycle ( ) ; return size ; }'", "label": "'Get the ActionBar height in the Context s theme .'"}
{"text": "'@ Nullable public static Drawable getActionBarBackground ( Context context ) { int [ ] attrs = { android . R . attr . actionBarStyle } ; TypedArray a = context . obtainStyledAttributes ( attrs ) ; int id = a . getResourceId ( 0 , 0 ) ; a . recycle ( ) ; if ( id > 0 ) { attrs [ 0 ] = android . R . attr . background ; a = context . obtainStyledAttributes ( id , attrs ) ; Drawable background = a . getDrawable ( 0 ) ; a . recycle ( ) ; return background ; } return null ; }'", "label": "'Get the ActionBar background in the Context s theme .'"}
{"text": "'public static boolean isConnected ( Context context ) { NetworkInfo info = Managers . connectivity ( context ) . getActiveNetworkInfo ( ) ; return info != null && info . isConnected ( ) ; }'", "label": "'True if a data network is connected .'"}
{"text": "'public void diff_cleanupSemantic ( LinkedList < Diff > diffs ) { if ( diffs . isEmpty ( ) ) { return ; } boolean changes = false ; Stack < Diff > equalities = new Stack < Diff > ( ) ; // Stack of qualities. String lastequality = null ; // Always equal to equalities.lastElement().text ListIterator < Diff > pointer = diffs . listIterator ( ) ; // Number of characters that changed prior to the equality. int length_insertions1 = 0 ; int length_deletions1 = 0 ; // Number of characters that changed after the equality. int length_insertions2 = 0 ; int length_deletions2 = 0 ; Diff thisDiff = pointer . next ( ) ; while ( thisDiff != null ) { if ( thisDiff . operation == Operation . EQUAL ) { // Equality found. equalities . push ( thisDiff ) ; length_insertions1 = length_insertions2 ; length_deletions1 = length_deletions2 ; length_insertions2 = 0 ; length_deletions2 = 0 ; lastequality = thisDiff . text ; } else { // An insertion or deletion. if ( thisDiff . operation == Operation . INSERT ) { length_insertions2 += thisDiff . text . length ( ) ; } else { length_deletions2 += thisDiff . text . length ( ) ; } // Eliminate an equality that is smaller or equal to the edits on both // sides of it. if ( lastequality != null && ( lastequality . length ( ) <= Math . max ( length_insertions1 , length_deletions1 ) ) && ( lastequality . length ( ) <= Math . max ( length_insertions2 , length_deletions2 ) ) ) { //System.out.println(\"Splitting: \\'\" + lastequality + \"\\'\"); // Walk back to offending equality. while ( thisDiff != equalities . lastElement ( ) ) { thisDiff = pointer . previous ( ) ; } pointer . next ( ) ; // Replace equality with a delete. pointer . set ( new Diff ( Operation . DELETE , lastequality ) ) ; // Insert a corresponding an insert. pointer . add ( new Diff ( Operation . INSERT , lastequality ) ) ; equalities . pop ( ) ; // Throw away the equality we just deleted. if ( ! equalities . empty ( ) ) { // Throw away the previous equality (it needs to be reevaluated). equalities . pop ( ) ; } if ( equalities . empty ( ) ) { // There are no previous equalities, walk back to the start. while ( pointer . hasPrevious ( ) ) { pointer . previous ( ) ; } } else { // There is a safe equality we can fall back to. thisDiff = equalities . lastElement ( ) ; while ( thisDiff != pointer . previous ( ) ) { // Intentionally empty loop. } } length_insertions1 = 0 ; // Reset the counters. length_insertions2 = 0 ; length_deletions1 = 0 ; length_deletions2 = 0 ; lastequality = null ; changes = true ; } } thisDiff = pointer . hasNext ( ) ? pointer . next ( ) : null ; } // Normalize the diff. if ( changes ) { diff_cleanupMerge ( diffs ) ; } diff_cleanupSemanticLossless ( diffs ) ; // Find any overlaps between deletions and insertions. // e.g: <del>abcxxx</del><ins>xxxdef</ins> //   -> <del>abc</del>xxx<ins>def</ins> // e.g: <del>xxxabc</del><ins>defxxx</ins> //   -> <ins>def</ins>xxx<del>abc</del> // Only extract an overlap if it is as big as the edit ahead or behind it. pointer = diffs . listIterator ( ) ; Diff prevDiff = null ; thisDiff = null ; if ( pointer . hasNext ( ) ) { prevDiff = pointer . next ( ) ; if ( pointer . hasNext ( ) ) { thisDiff = pointer . next ( ) ; } } while ( thisDiff != null ) { if ( prevDiff . operation == Operation . DELETE && thisDiff . operation == Operation . INSERT ) { String deletion = prevDiff . text ; String insertion = thisDiff . text ; int overlap_length1 = this . diff_commonOverlap ( deletion , insertion ) ; int overlap_length2 = this . diff_commonOverlap ( insertion , deletion ) ; if ( overlap_length1 >= overlap_length2 ) { if ( overlap_length1 >= deletion . length ( ) / 2.0 || overlap_length1 >= insertion . length ( ) / 2.0 ) { // Overlap found. Insert an equality and trim the surrounding edits. pointer . previous ( ) ; pointer . add ( new Diff ( Operation . EQUAL , insertion . substring ( 0 , overlap_length1 ) ) ) ; prevDiff . text = deletion . substring ( 0 , deletion . length ( ) - overlap_length1 ) ; thisDiff . text = insertion . substring ( overlap_length1 ) ; // pointer.add inserts the element before the cursor, so there is // no need to step past the new element. } } else { if ( overlap_length2 >= deletion . length ( ) / 2.0 || overlap_length2 >= insertion . length ( ) / 2.0 ) { // Reverse overlap found. // Insert an equality and swap and trim the surrounding edits. pointer . previous ( ) ; pointer . add ( new Diff ( Operation . EQUAL , deletion . substring ( 0 , overlap_length2 ) ) ) ; prevDiff . operation = Operation . INSERT ; prevDiff . text = insertion . substring ( 0 , insertion . length ( ) - overlap_length2 ) ; thisDiff . operation = Operation . DELETE ; thisDiff . text = deletion . substring ( overlap_length2 ) ; // pointer.add inserts the element before the cursor, so there is // no need to step past the new element. } } thisDiff = pointer . hasNext ( ) ? pointer . next ( ) : null ; } prevDiff = thisDiff ; thisDiff = pointer . hasNext ( ) ? pointer . next ( ) : null ; } }'", "label": "'Reduce the number of edits by eliminating semantically trivial equalities .'"}
{"text": "\"public void diff_cleanupSemanticLossless ( LinkedList < Diff > diffs ) { String equality1 , edit , equality2 ; String commonString ; int commonOffset ; int score , bestScore ; String bestEquality1 , bestEdit , bestEquality2 ; // Create a new iterator at the start. ListIterator < Diff > pointer = diffs . listIterator ( ) ; Diff prevDiff = pointer . hasNext ( ) ? pointer . next ( ) : null ; Diff thisDiff = pointer . hasNext ( ) ? pointer . next ( ) : null ; Diff nextDiff = pointer . hasNext ( ) ? pointer . next ( ) : null ; // Intentionally ignore the first and last element (don't need checking). while ( nextDiff != null ) { if ( prevDiff . operation == Operation . EQUAL && nextDiff . operation == Operation . EQUAL ) { // This is a single edit surrounded by equalities. equality1 = prevDiff . text ; edit = thisDiff . text ; equality2 = nextDiff . text ; // First, shift the edit as far left as possible. commonOffset = diff_commonSuffix ( equality1 , edit ) ; if ( commonOffset != 0 ) { commonString = edit . substring ( edit . length ( ) - commonOffset ) ; equality1 = equality1 . substring ( 0 , equality1 . length ( ) - commonOffset ) ; edit = commonString + edit . substring ( 0 , edit . length ( ) - commonOffset ) ; equality2 = commonString + equality2 ; } // Second, step character by character right, looking for the best fit. bestEquality1 = equality1 ; bestEdit = edit ; bestEquality2 = equality2 ; bestScore = diff_cleanupSemanticScore ( equality1 , edit ) + diff_cleanupSemanticScore ( edit , equality2 ) ; while ( edit . length ( ) != 0 && equality2 . length ( ) != 0 && edit . charAt ( 0 ) == equality2 . charAt ( 0 ) ) { equality1 += edit . charAt ( 0 ) ; edit = edit . substring ( 1 ) + equality2 . charAt ( 0 ) ; equality2 = equality2 . substring ( 1 ) ; score = diff_cleanupSemanticScore ( equality1 , edit ) + diff_cleanupSemanticScore ( edit , equality2 ) ; // The >= encourages trailing rather than leading whitespace on edits. if ( score >= bestScore ) { bestScore = score ; bestEquality1 = equality1 ; bestEdit = edit ; bestEquality2 = equality2 ; } } if ( ! prevDiff . text . equals ( bestEquality1 ) ) { // We have an improvement, save it back to the diff. if ( bestEquality1 . length ( ) != 0 ) { prevDiff . text = bestEquality1 ; } else { pointer . previous ( ) ; // Walk past nextDiff. pointer . previous ( ) ; // Walk past thisDiff. pointer . previous ( ) ; // Walk past prevDiff. pointer . remove ( ) ; // Delete prevDiff. pointer . next ( ) ; // Walk past thisDiff. pointer . next ( ) ; // Walk past nextDiff. } thisDiff . text = bestEdit ; if ( bestEquality2 . length ( ) != 0 ) { nextDiff . text = bestEquality2 ; } else { pointer . remove ( ) ; // Delete nextDiff. nextDiff = thisDiff ; thisDiff = prevDiff ; } } } prevDiff = thisDiff ; thisDiff = nextDiff ; nextDiff = pointer . hasNext ( ) ? pointer . next ( ) : null ; } }\"", "label": "'Look for single edits surrounded on both sides by equalities which can be shifted sideways to align the edit to a word boundary . e . g : The c<ins > at c< / ins > ame . - > The <ins > cat < / ins > came .'"}
{"text": "\"private int diff_cleanupSemanticScore ( String one , String two ) { if ( one . length ( ) == 0 || two . length ( ) == 0 ) { // Edges are the best. return 6 ; } // Each port of this function behaves slightly differently due to // subtle differences in each language's definition of things like // 'whitespace'.  Since this function's purpose is largely cosmetic, // the choice has been made to use each language's native features // rather than force total conformity. char char1 = one . charAt ( one . length ( ) - 1 ) ; char char2 = two . charAt ( 0 ) ; boolean nonAlphaNumeric1 = ! Character . isLetterOrDigit ( char1 ) ; boolean nonAlphaNumeric2 = ! Character . isLetterOrDigit ( char2 ) ; boolean whitespace1 = nonAlphaNumeric1 && Character . isWhitespace ( char1 ) ; boolean whitespace2 = nonAlphaNumeric2 && Character . isWhitespace ( char2 ) ; boolean lineBreak1 = whitespace1 && Character . getType ( char1 ) == Character . CONTROL ; boolean lineBreak2 = whitespace2 && Character . getType ( char2 ) == Character . CONTROL ; boolean blankLine1 = lineBreak1 && BLANKLINEEND . matcher ( one ) . find ( ) ; boolean blankLine2 = lineBreak2 && BLANKLINESTART . matcher ( two ) . find ( ) ; if ( blankLine1 || blankLine2 ) { // Five points for blank lines. return 5 ; } else if ( lineBreak1 || lineBreak2 ) { // Four points for line breaks. return 4 ; } else if ( nonAlphaNumeric1 && ! whitespace1 && whitespace2 ) { // Three points for end of sentences. return 3 ; } else if ( whitespace1 || whitespace2 ) { // Two points for whitespace. return 2 ; } else if ( nonAlphaNumeric1 || nonAlphaNumeric2 ) { // One point for non-alphanumeric. return 1 ; } return 0 ; }\"", "label": "'Given two strings compute a score representing whether the internal boundary falls on logical boundaries . Scores range from 6 ( best ) to 0 ( worst ) .'"}
{"text": "'public void diff_cleanupEfficiency ( LinkedList < Diff > diffs ) { if ( diffs . isEmpty ( ) ) { return ; } boolean changes = false ; Stack < Diff > equalities = new Stack < Diff > ( ) ; // Stack of equalities. String lastequality = null ; // Always equal to equalities.lastElement().text ListIterator < Diff > pointer = diffs . listIterator ( ) ; // Is there an insertion operation before the last equality. boolean pre_ins = false ; // Is there a deletion operation before the last equality. boolean pre_del = false ; // Is there an insertion operation after the last equality. boolean post_ins = false ; // Is there a deletion operation after the last equality. boolean post_del = false ; Diff thisDiff = pointer . next ( ) ; Diff safeDiff = thisDiff ; // The last Diff that is known to be unsplitable. while ( thisDiff != null ) { if ( thisDiff . operation == Operation . EQUAL ) { // Equality found. if ( thisDiff . text . length ( ) < Diff_EditCost && ( post_ins || post_del ) ) { // Candidate found. equalities . push ( thisDiff ) ; pre_ins = post_ins ; pre_del = post_del ; lastequality = thisDiff . text ; } else { // Not a candidate, and can never become one. equalities . clear ( ) ; lastequality = null ; safeDiff = thisDiff ; } post_ins = post_del = false ; } else { // An insertion or deletion. if ( thisDiff . operation == Operation . DELETE ) { post_del = true ; } else { post_ins = true ; } /*\\n         * Five types to be split:\\n         * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\\n         * <ins>A</ins>X<ins>C</ins><del>D</del>\\n         * <ins>A</ins><del>B</del>X<ins>C</ins>\\n         * <ins>A</del>X<ins>C</ins><del>D</del>\\n         * <ins>A</ins><del>B</del>X<del>C</del>\\n         */ if ( lastequality != null && ( ( pre_ins && pre_del && post_ins && post_del ) || ( ( lastequality . length ( ) < Diff_EditCost / 2 ) && ( ( pre_ins ? 1 : 0 ) + ( pre_del ? 1 : 0 ) + ( post_ins ? 1 : 0 ) + ( post_del ? 1 : 0 ) ) == 3 ) ) ) { //System.out.println(\"Splitting: \\'\" + lastequality + \"\\'\"); // Walk back to offending equality. while ( thisDiff != equalities . lastElement ( ) ) { thisDiff = pointer . previous ( ) ; } pointer . next ( ) ; // Replace equality with a delete. pointer . set ( new Diff ( Operation . DELETE , lastequality ) ) ; // Insert a corresponding an insert. pointer . add ( thisDiff = new Diff ( Operation . INSERT , lastequality ) ) ; equalities . pop ( ) ; // Throw away the equality we just deleted. lastequality = null ; if ( pre_ins && pre_del ) { // No changes made which could affect previous entry, keep going. post_ins = post_del = true ; equalities . clear ( ) ; safeDiff = thisDiff ; } else { if ( ! equalities . empty ( ) ) { // Throw away the previous equality (it needs to be reevaluated). equalities . pop ( ) ; } if ( equalities . empty ( ) ) { // There are no previous questionable equalities, // walk back to the last known safe diff. thisDiff = safeDiff ; } else { // There is an equality we can fall back to. thisDiff = equalities . lastElement ( ) ; } while ( thisDiff != pointer . previous ( ) ) { // Intentionally empty loop. } post_ins = post_del = false ; } changes = true ; } } thisDiff = pointer . hasNext ( ) ? pointer . next ( ) : null ; } if ( changes ) { diff_cleanupMerge ( diffs ) ; } }'", "label": "'Reduce the number of edits by eliminating operationally trivial equalities .'"}
{"text": "'protected int match_bitap ( String text , String pattern , int loc ) { assert ( Match_MaxBits == 0 || pattern . length ( ) <= Match_MaxBits ) : \"Pattern too long for this application.\" ; // Initialise the alphabet. Map < Character , Integer > s = match_alphabet ( pattern ) ; // Highest score beyond which we give up. double score_threshold = Match_Threshold ; // Is there a nearby exact match? (speedup) int best_loc = text . indexOf ( pattern , loc ) ; if ( best_loc != - 1 ) { score_threshold = Math . min ( match_bitapScore ( 0 , best_loc , loc , pattern ) , score_threshold ) ; // What about in the other direction? (speedup) best_loc = text . lastIndexOf ( pattern , loc + pattern . length ( ) ) ; if ( best_loc != - 1 ) { score_threshold = Math . min ( match_bitapScore ( 0 , best_loc , loc , pattern ) , score_threshold ) ; } } // Initialise the bit arrays. int matchmask = 1 << ( pattern . length ( ) - 1 ) ; best_loc = - 1 ; int bin_min , bin_mid ; int bin_max = pattern . length ( ) + text . length ( ) ; // Empty initialization added to appease Java compiler. int [ ] last_rd = new int [ 0 ] ; for ( int d = 0 ; d < pattern . length ( ) ; d ++ ) { // Scan for the best match; each iteration allows for one more error. // Run a binary search to determine how far from \\'loc\\' we can stray at // this error level. bin_min = 0 ; bin_mid = bin_max ; while ( bin_min < bin_mid ) { if ( match_bitapScore ( d , loc + bin_mid , loc , pattern ) <= score_threshold ) { bin_min = bin_mid ; } else { bin_max = bin_mid ; } bin_mid = ( bin_max - bin_min ) / 2 + bin_min ; } // Use the result from this iteration as the maximum for the next. bin_max = bin_mid ; int start = Math . max ( 1 , loc - bin_mid + 1 ) ; int finish = Math . min ( loc + bin_mid , text . length ( ) ) + pattern . length ( ) ; int [ ] rd = new int [ finish + 2 ] ; rd [ finish + 1 ] = ( 1 << d ) - 1 ; for ( int j = finish ; j >= start ; j -- ) { int charMatch ; if ( text . length ( ) <= j - 1 || ! s . containsKey ( text . charAt ( j - 1 ) ) ) { // Out of range. charMatch = 0 ; } else { charMatch = s . get ( text . charAt ( j - 1 ) ) ; } if ( d == 0 ) { // First pass: exact match. rd [ j ] = ( ( rd [ j + 1 ] << 1 ) | 1 ) & charMatch ; } else { // Subsequent passes: fuzzy match. rd [ j ] = ( ( ( rd [ j + 1 ] << 1 ) | 1 ) & charMatch ) | ( ( ( last_rd [ j + 1 ] | last_rd [ j ] ) << 1 ) | 1 ) | last_rd [ j + 1 ] ; } if ( ( rd [ j ] & matchmask ) != 0 ) { double score = match_bitapScore ( d , j - 1 , loc , pattern ) ; // This match will almost certainly be better than any existing // match.  But check anyway. if ( score <= score_threshold ) { // Told you so. score_threshold = score ; best_loc = j - 1 ; if ( best_loc > loc ) { // When passing loc, don\\'t exceed our current distance from loc. start = Math . max ( 1 , 2 * loc - best_loc ) ; } else { // Already passed loc, downhill from here on in. break ; } } } } if ( match_bitapScore ( d + 1 , loc , loc , pattern ) > score_threshold ) { // No hope for a (better) match at greater error levels. break ; } last_rd = rd ; } return best_loc ; }'", "label": "'Locate the best instance of pattern in text near loc using the Bitap algorithm . Returns - 1 if no match found .'"}
{"text": "'public LinkedList < Patch > patch_make ( String text1 , LinkedList < Diff > diffs ) { if ( text1 == null || diffs == null ) { throw new IllegalArgumentException ( \"Null inputs. (patch_make)\" ) ; } LinkedList < Patch > patches = new LinkedList < Patch > ( ) ; if ( diffs . isEmpty ( ) ) { return patches ; // Get rid of the null case. } Patch patch = new Patch ( ) ; int char_count1 = 0 ; // Number of characters into the text1 string. int char_count2 = 0 ; // Number of characters into the text2 string. // Start with text1 (prepatch_text) and apply the diffs until we arrive at // text2 (postpatch_text). We recreate the patches one by one to determine // context info. String prepatch_text = text1 ; String postpatch_text = text1 ; for ( Diff aDiff : diffs ) { if ( patch . diffs . isEmpty ( ) && aDiff . operation != Operation . EQUAL ) { // A new patch starts here. patch . start1 = char_count1 ; patch . start2 = char_count2 ; } switch ( aDiff . operation ) { case INSERT : patch . diffs . add ( aDiff ) ; patch . length2 += aDiff . text . length ( ) ; postpatch_text = postpatch_text . substring ( 0 , char_count2 ) + aDiff . text + postpatch_text . substring ( char_count2 ) ; break ; case DELETE : patch . length1 += aDiff . text . length ( ) ; patch . diffs . add ( aDiff ) ; postpatch_text = postpatch_text . substring ( 0 , char_count2 ) + postpatch_text . substring ( char_count2 + aDiff . text . length ( ) ) ; break ; case EQUAL : if ( aDiff . text . length ( ) <= 2 * Patch_Margin && ! patch . diffs . isEmpty ( ) && aDiff != diffs . getLast ( ) ) { // Small equality inside a patch. patch . diffs . add ( aDiff ) ; patch . length1 += aDiff . text . length ( ) ; patch . length2 += aDiff . text . length ( ) ; } if ( aDiff . text . length ( ) >= 2 * Patch_Margin ) { // Time for a new patch. if ( ! patch . diffs . isEmpty ( ) ) { patch_addContext ( patch , prepatch_text ) ; patches . add ( patch ) ; patch = new Patch ( ) ; // Unlike Unidiff, our patch lists have a rolling context. // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff // Update prepatch text & pos to reflect the application of the // just completed patch. prepatch_text = postpatch_text ; char_count1 = char_count2 ; } } break ; } // Update the current character count. if ( aDiff . operation != Operation . INSERT ) { char_count1 += aDiff . text . length ( ) ; } if ( aDiff . operation != Operation . DELETE ) { char_count2 += aDiff . text . length ( ) ; } } // Pick up the leftover patch if not empty. if ( ! patch . diffs . isEmpty ( ) ) { patch_addContext ( patch , prepatch_text ) ; patches . add ( patch ) ; } return patches ; }'", "label": "'Compute a list of patches to turn text1 into text2 . text2 is not provided diffs are the delta between text1 and text2 .'"}
{"text": "'public List < Patch > patch_fromText ( String textline ) throws IllegalArgumentException { List < Patch > patches = new LinkedList < Patch > ( ) ; if ( textline . length ( ) == 0 ) { return patches ; } List < String > textList = Arrays . asList ( textline . split ( \"\\\\n\" ) ) ; LinkedList < String > text = new LinkedList < String > ( textList ) ; Patch patch ; Pattern patchHeader = Pattern . compile ( \"^@@ -(\\\\\\\\d+),?(\\\\\\\\d*) \\\\\\\\+(\\\\\\\\d+),?(\\\\\\\\d*) @@$\" ) ; Matcher m ; char sign ; String line ; while ( ! text . isEmpty ( ) ) { m = patchHeader . matcher ( text . getFirst ( ) ) ; if ( ! m . matches ( ) ) { throw new IllegalArgumentException ( \"Invalid patch string: \" + text . getFirst ( ) ) ; } patch = new Patch ( ) ; patches . add ( patch ) ; patch . start1 = Integer . parseInt ( m . group ( 1 ) ) ; if ( m . group ( 2 ) . length ( ) == 0 ) { patch . start1 -- ; patch . length1 = 1 ; } else if ( m . group ( 2 ) . equals ( \"0\" ) ) { patch . length1 = 0 ; } else { patch . start1 -- ; patch . length1 = Integer . parseInt ( m . group ( 2 ) ) ; } patch . start2 = Integer . parseInt ( m . group ( 3 ) ) ; if ( m . group ( 4 ) . length ( ) == 0 ) { patch . start2 -- ; patch . length2 = 1 ; } else if ( m . group ( 4 ) . equals ( \"0\" ) ) { patch . length2 = 0 ; } else { patch . start2 -- ; patch . length2 = Integer . parseInt ( m . group ( 4 ) ) ; } text . removeFirst ( ) ; while ( ! text . isEmpty ( ) ) { try { sign = text . getFirst ( ) . charAt ( 0 ) ; } catch ( IndexOutOfBoundsException e ) { // Blank line?  Whatever. text . removeFirst ( ) ; continue ; } line = text . getFirst ( ) . substring ( 1 ) ; line = line . replace ( \"+\" , \"%2B\" ) ; // decode would change all \"+\" to \" \" try { line = URLDecoder . decode ( line , \"UTF-8\" ) ; } catch ( UnsupportedEncodingException e ) { // Not likely on modern system. throw new Error ( \"This system does not support UTF-8.\" , e ) ; } catch ( IllegalArgumentException e ) { // Malformed URI sequence. throw new IllegalArgumentException ( \"Illegal escape in patch_fromText: \" + line , e ) ; } if ( sign == \\' \\' ) { // Deletion. patch . diffs . add ( new Diff ( Operation . DELETE , line ) ) ; } else if ( sign == \\' \\' ) { // Insertion. patch . diffs . add ( new Diff ( Operation . INSERT , line ) ) ; } else if ( sign == \\' \\' ) { // Minor equality. patch . diffs . add ( new Diff ( Operation . EQUAL , line ) ) ; } else if ( sign == \\' \\' ) { // Start of next patch. break ; } else { // WTF? throw new IllegalArgumentException ( \"Invalid patch mode \\'\" + sign + \"\\' in: \" + line ) ; } text . removeFirst ( ) ; } } return patches ; }'", "label": "'Parse a textual representation of patches and return a List of Patch objects .'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public < T > Either < T , R > map ( Function < L , T > function ) { return either . isLeft ( ) ? Left ( function . apply ( get ( ) ) ) : ( Either < T , R > ) either ; }'", "label": "'If this projection contains a { @link Left } then a new { @link Left } is returned containing the value from the original { @link Right } mapped via the provided function else the contained Either is returned as is .'"}
{"text": "'@ Override public boolean tryComplete ( Try < T > result ) { Validator . requireNonNull ( result , \"Must provide a valid result\" ) ; return tryComplete ( future -> future . complete ( result ) ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public boolean tryCompleteWith ( Future < T > result ) { return tryComplete ( future -> result . onComplete ( response -> future . complete ( response ) ) ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'private boolean tryComplete ( Consumer < FutureImpl < T > > c ) { if ( completed . compareAndSet ( false , true ) ) { //This Try is only here to manage any unforeseen exception raised by the Future event listener //See issue#41 Try ( ( ) -> c . accept ( future ) ) ; return true ; } return false ; }'", "label": "'Internal try complete method that takes a consumer to apply the Future this Promise holds . <br > Performs a check if this Promise already has been fulfilled or not .'"}
{"text": "'public static < T > T requireNonNull ( T obj , String message ) { if ( obj == null ) { throw new IllegalArgumentException ( message ) ; } return obj ; }'", "label": "'Checks that the specified object reference is not { @code null } and throws a customized { @link IllegalArgumentException } if it is . <br > Essentially this is very much the same as { @link Objects#requireNonNull ( Object String ) } but throws an { @link IllegalArgumentException } as opposed to the { @link NullPointerException } the SDK class throws .'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public < R > Option < R > map ( ThrowableFunction1 < T , R > function ) { return ( Option < R > ) this ; }'", "label": "'Always returns <code > this< / code > . <br > I . e . the function is never used as { @link None } represents nothing / no value .'"}
{"text": "'@ Override public < R > Option < R > flatMap ( ThrowableFunction1 < T , Option < R > > function ) { // uses the Map method as it anyways produces the same result return map ( null ) ; }'", "label": "'Always returns <code > this< / code > . <br > I . e . the function is never used as { @link None } represents nothing / no value .'"}
{"text": "'@ Override public < R > Either < T , R > toLeft ( Supplier < R > right ) { return Right ( right . get ( ) ) ; }'", "label": "'Returns a { @link Right } containing the value from the provided supplier .'"}
{"text": "'@ Override public < L > Either < L , T > toRight ( Supplier < L > left ) { return Left ( left . get ( ) ) ; }'", "label": "'Returns a { @link Left } containing the value from the provided supplier .'"}
{"text": "'public static Future < Unit > Future ( VoidFunction0 function ) { return Future ( ( ) -> { function . apply ( ) ; return Unit . Instance ; } ) ; }'", "label": "'Allows for easy creation of asynchronous computations that will be executed in the future . <br > The purpose is to allow the user to invoke a side - effecting function that may succeed / fail but has now return type . <br > E . g . deleting something from a database may not have an interesting return type . One is only interested of the outcome { @link Success } / { @link Failure } . <br > The method relays the execution to { @link Future#apply ( ThrowableFunction0 ) } . <br > Best used in conjunction with statically importing this method .'"}
{"text": "'public static Future < Unit > Future ( VoidFunction0 function , Executor executor ) { return Future ( ( ) -> { function . apply ( ) ; return Unit . Instance ; } , executor ) ; }'", "label": "'Allows for easy creation of asynchronous computations that will be executed in the future . <br > The purpose is to allow the user to invoke a side - effecting function that may succeed / fail but has now return type . <br > E . g . deleting something from a database may not have an interesting return type . One is only interested of the outcome { @link Success } / { @link Failure } . <br > The method relays the execution to { @link Future#apply ( ThrowableFunction0 ) } . <br > Best used in conjunction with statically importing this method .'"}
{"text": "'public static < T > Future < T > Future ( ThrowableFunction0 < T > function ) { return Future . apply ( function ) ; }'", "label": "'Allows for easy creation of asynchronous computations that will be executed in the future . <br > The method relays the execution to { @link Future#apply ( ThrowableFunction0 ) } . <br > Best used in conjunction with statically importing this method .'"}
{"text": "'public static < T > Future < T > Future ( ThrowableFunction0 < T > function , Executor executor ) { return Future . apply ( function , executor ) ; }'", "label": "'Allows for easy creation of asynchronous computations that will be executed in the future . <br > The method relays the execution to { @link Future#apply ( ThrowableFunction0 ) } . <br > Best used in conjunction with statically importing this method .'"}
{"text": "'public static < T > Future < T > Future ( java . util . concurrent . Future < T > future ) { return Future . apply ( ( ) -> future . get ( ) ) ; }'", "label": "'Allows for converting a blocking JDK { @link java . util . concurrent . Future Future } into a non - blocking future . <br > This will use the default executor to wait / block on the provided future .'"}
{"text": "'public static Executor createCachedThreadPoolExecutor ( ThreadFactory threadFactory ) { return create ( java . util . concurrent . Executors . newCachedThreadPool ( threadFactory ) ) ; }'", "label": "'Creates an executor that uses the { @link java . util . concurrent . Executors#newCachedThreadPool ( ThreadFactory ) } .'"}
{"text": "'public static Executor createFixedThreadPoolExecutor ( int threads , ThreadFactory threadFactory ) { return create ( java . util . concurrent . Executors . newFixedThreadPool ( threads , threadFactory ) ) ; }'", "label": "'Creates an executor that uses the { @link java . util . concurrent . Executors#newFixedThreadPool ( int ThreadFactory ) }'"}
{"text": "'private static Executor createDefaultExecutor ( ) { Try < Executor > t = ReflectionUtil . newInstance ( System . getProperty ( \"javascalautils.concurrent.executorprovider\" ) ) ; return t . getOrElse ( ( ) -> createCachedThreadPoolExecutor ( new NamedSequenceThreadFactory ( \"Executors-Default\" ) ) ) ; }'", "label": "'Creates the default { @link Executor } instance . <br > Either by getting the provider class from the system property or using the default .'"}
{"text": "'@ Override public void onFailure ( Consumer < Throwable > consumer ) { Validator . requireNonNull ( consumer , \"Null is not a valid consumer\" ) ; // register a complete handler and ignore any Success responses onComplete ( result -> { // transform Failure to a Success with the Throwable // should it be a Success it will be transformed into a Failure and forEach will do nothing result . failed ( ) . forEach ( consumer ) ; } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void onSuccess ( Consumer < T > consumer ) { Validator . requireNonNull ( consumer , \"Null is not a valid consumer\" ) ; // register a complete handler and ignore any Failure responses onComplete ( result -> { // should it be a Failure the forEach will do nothing result . forEach ( consumer ) ; } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void onComplete ( Consumer < Try < T > > c ) { Validator . requireNonNull ( c , \"Null is not a valid consumer\" ) ; eventHandlers . add ( new EventHandler ( c ) ) ; // invoke all new handlers in case this Future is already completed notifyHandlers ( ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public < R > Future < R > map ( ThrowableFunction1 < T , R > function ) { // the onFailure function just passed the error as-is without transformation return transform ( function , t -> t ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public < R > Future < R > flatMap ( ThrowableFunction1 < T , Future < R > > function ) { Validator . requireNonNull ( function , \"Null is not a valid function\" ) ; // Create new future expected to hold the value of the mapped type FutureImpl < R > future = new FutureImpl <> ( ) ; // install success handler that will map the result before applying it onSuccess ( value -> { // use the provided function to create a mapped future //it might actually fail due to the provided function throws an exception, hence we wrap it with a Try Try < Future < R >> mapped = Try ( ( ) -> function . apply ( value ) ) ; //add a recover function to the Try that fails this future with the error, else we complete this Future with the mapped Future mapped . recover ( t -> Future . failed ( t ) ) . forEach ( f -> f . onComplete ( v -> future . complete ( v ) ) ) ; } ) ; // install failure handler that just passes the failure/result through onFailure ( t -> future . failure ( t ) ) ; return future ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public Future < T > filter ( Predicate < T > predicate ) { Validator . requireNonNull ( predicate , \"Null is not a valid predicate\" ) ; // Create new future expected to hold the value of the mapped type FutureImpl < T > future = new FutureImpl <> ( ) ; // install success handler that will filter the result before applying it onSuccess ( value -> { if ( predicate . test ( value ) ) { future . success ( value ) ; } else { future . failure ( new NoSuchElementException ( \"The predicate failed on value [\" + value + \"]\" ) ) ; } } ) ; // install failure handler that just passes the result through onFailure ( t -> future . failure ( t ) ) ; return future ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public < R > Future < R > transform ( ThrowableFunction1 < T , R > onSuccess , ThrowableFunction1 < Throwable , Throwable > onFailure ) { Validator . requireNonNull ( onSuccess , \"Null is not a valid function\" ) ; Validator . requireNonNull ( onFailure , \"Null is not a valid function\" ) ; // Create new future expected to hold the value of the mapped type FutureImpl < R > future = new FutureImpl <> ( ) ; // install success handler that will map the result before applying it onSuccess ( value -> future . complete ( Try ( ( ) -> onSuccess . apply ( value ) ) ) ) ; // install failure handler that will map the error before applying it onFailure ( t -> Try ( ( ) -> onFailure . apply ( t ) ) . recover ( ex -> ex ) . forEach ( ex -> future . failure ( ex ) ) ) ; return future ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public Future < T > recover ( ThrowableFunction1 < Throwable , T > recoverFunction ) { Validator . requireNonNull ( recoverFunction , \"Null is not a valid function\" ) ; // Create new future expected to hold the value of the mapped type FutureImpl < T > future = new FutureImpl <> ( ) ; // installs a handler that will automatically recover the result/Try should it be needed onComplete ( t -> future . complete ( t . recover ( recoverFunction ) ) ) ; return future ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public T result ( long duration , TimeUnit timeUnit ) throws Throwable , TimeoutException { // The response is now set to Some // return the value of the response (Try), should it be a Failure the exception is raised return ready ( duration , timeUnit ) . response . get ( ) . get ( ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public FutureImpl < T > ready ( long duration , TimeUnit timeUnit ) throws TimeoutException , InterruptedException { Validator . requireNonNull ( timeUnit , \"Null is not a valid time unit\" ) ; CountDownLatch latch = new CountDownLatch ( 1 ) ; // install a handler that releases the count down latch when notified with a result. // the actual result/response is of no interest as we anyways have access to it internally in this class/instance. onComplete ( t -> latch . countDown ( ) ) ; // block for either the time to pass or the Future gets completed if ( ! latch . await ( duration , timeUnit ) ) { throw new TimeoutException ( \"Timeout waiting [\" + duration + \"] [\" + timeUnit + \"] for Future to complete\" ) ; } //The future is now complete, return ourselves return this ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'Future < T > complete ( Try < T > result ) { // save the result this . response = Some ( result ) ; // notify all potential handlers notifyHandlers ( ) ; return this ; }'", "label": "'Completes this Future with a result . <br > Invoked by the Promise owning this instance .'"}
{"text": "'private < R > void notifyHandlers ( ) { // the response may or may not exist at this point response . forEach ( t -> eventHandlers . stream ( ) . forEach ( h -> h . notify ( t ) ) ) ; }'", "label": "'Invoke all handlers with the value of this Future . <br > The response may or may not exist at this point . <br > A filter is applied to make sure we only notify handlers that have not been notified before .'"}
{"text": "'@ Override public < R > Option < R > map ( ThrowableFunction1 < T , R > f ) { return flatMap ( v -> Option . apply ( f . apply ( v ) ) ) ; }'", "label": "'Returns an { @link Option } containing the value of applying the given function to the current value .'"}
{"text": "'@ Override public < R > Option < R > flatMap ( ThrowableFunction1 < T , Option < R > > function ) { try { return function . apply ( value ) ; } catch ( Throwable ex ) { throw new BrokenFunctionException ( \"Caught exception while applying function\" , ex ) ; } }'", "label": "'Returns an Option consisting of the result of applying the given function to the current value .'"}
{"text": "'@ Override public < R > Either < T , R > toLeft ( Supplier < R > right ) { return Left ( value ) ; }'", "label": "'Returns a { @link Left } containing the value of this instance .'"}
{"text": "'@ Override public < L > Either < L , T > toRight ( Supplier < L > left ) { return Right ( value ) ; }'", "label": "'Returns a { @link Right } containing the value of this instance .'"}
{"text": "'@ Override public Thread newThread ( Runnable runnable ) { return new Thread ( runnable , threadName + \"-\" + counter . getAndIncrement ( ) ) ; }'", "label": "'Creates a new thread using the provided name and sequence counter . <br > E . g . <i > threadName - nnn< / i >'"}
{"text": "'@ Override public R getOrElse ( Supplier < R > supplier ) { return either . fold ( v -> supplier . get ( ) , v -> v ) ; }'", "label": "'Returns the value if this is a { @link Right } else the value provided by the supplier .'"}
{"text": "'public Option < Either < L , R > > filter ( Predicate < R > predicate ) { return Option . apply ( exists ( predicate ) ? either : null ) ; }'", "label": "'Returns a { @link Some } wrapping the { @link Either } if it s a { @link Right } and the value of the { @link Right } matches the predicate else { @link None } .'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public < T > Either < L , T > map ( Function < R , T > function ) { return either . isRight ( ) ? Right ( function . apply ( get ( ) ) ) : ( Either < L , T > ) either ; }'", "label": "'If this projection contains a { @link Right } then a new { @link Right } is returned containing the value from the original { @link Right } mapped via the provided function else the contained Either is returned as is .'"}
{"text": "'@ Override public Try < T > orElse ( Supplier < Try < T > > supplier ) { return supplier . get ( ) ; }'", "label": "'Always returns the value provided by the supplier . <br > As per definition this is a failure without any data to return .'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) @ Override public < R > Try < R > map ( ThrowableFunction1 < T , R > function ) { return ( Try < R > ) this ; }'", "label": "'Always returns <i > this< / i > . <br > As per definition this is a failure without any data to map .'"}
{"text": "'@ Override public Try < T > recover ( ThrowableFunction1 < Throwable , T > function ) { return recoverWith ( t -> Success ( function . apply ( t ) ) ) ; }'", "label": "'Applies the provided function to the Throwable of this { @link Failure } and returns a { @link Success } with the result .'"}
{"text": "'@ Override public Try < T > recoverWith ( ThrowableFunction1 < Throwable , Try < T > > function ) { try { return function . apply ( throwable ) ; } catch ( Throwable t ) { return new Failure <> ( t ) ; } }'", "label": "'Applies the provided function to the Throwable of this { @link Failure } and returns the result .'"}
{"text": "'public static Try < Unit > Try ( VoidFunction0 function ) { return Try . apply ( ( ) -> { function . apply ( ) ; return Unit . Instance ; } ) ; }'", "label": "'Creates an instance of { @link Try } with a { @link Unit } return type . <br > The purpose is to allow the user to invoke a side - effecting function that may succeed / fail but has now return type . <br > E . g . deleting something from a database may not have an interesting return type . One is only interested of the outcome { @link Success } / { @link Failure } . Best used in conjunction with statically importing this method .'"}
{"text": "'public static < T > Try < T > Try ( ThrowableFunction0 < T > function ) { return Try . apply ( function ) ; }'", "label": "'Creates an instance of { @link Try } wrapping the result of the provided function . <br > Best used in conjunction with statically importing this method .'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) static < T > Try < T > newInstance ( String className ) { return Try ( ( ) -> ( T ) Class . forName ( className ) . newInstance ( ) ) ; }'", "label": "'Attempts to create an instance of the provided class . <br > This expects the class to be public and have a public ( default ) constructor with no arguments .'"}
{"text": "'@ Override public < T > Future < T > execute ( final Executable < T > executable ) { final Promise < T > promise = Promise ( ) ; return execute ( promise , ( ) -> { try { executable . execute ( promise ) ; // if the implementation didn\\'t respond to the Promise we mark it as a failure. if ( ! promise . isCompleted ( ) ) { promise . failure ( new IllegalStateException ( \"No response was provided by the Promise\" ) ) ; } } catch ( Exception ex ) { promise . failure ( ex ) ; } } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public < T > Future < T > execute ( final Callable < T > callable ) { final Promise < T > promise = Promise ( ) ; return execute ( promise , ( ) -> { try { promise . success ( callable . call ( ) ) ; } catch ( Exception ex ) { promise . failure ( ex ) ; } } ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public < T > List < Future < T > > executeAll ( @ SuppressWarnings ( \"unchecked\" ) Executable < T > ... executables ) { List < Future < T >> responses = new ArrayList <> ( ) ; for ( Executable < T > executable : executables ) { responses . add ( execute ( executable ) ) ; } return responses ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public < T > List < Future < T > > executeAll ( @ SuppressWarnings ( \"unchecked\" ) Callable < T > ... callables ) { List < Future < T >> responses = new ArrayList <> ( ) ; for ( Callable < T > callable : callables ) { responses . add ( execute ( callable ) ) ; } return responses ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'private < T > Future < T > execute ( Promise < T > promise , Runnable runnable ) { try { executor . execute ( runnable ) ; } catch ( RejectedExecutionException ex ) { // could be rejected due to resource starvation, report a failure promise . failure ( ex ) ; } return promise . future ( ) ; }'", "label": "'Executes the provided { @link Runnable } on the internal executor . <br > Any issues related to the internal executor are reported to the provided { @link Promise }'"}
{"text": "'@ Override public < R > Try < R > map ( ThrowableFunction1 < T , R > function ) { return Try ( ( ) -> function . apply ( value ) ) ; }'", "label": "'Applies the value to the function and returns the { @link Try } representing the mapped value .'"}
{"text": "'@ Override public < R > Try < R > flatMap ( ThrowableFunction1 < T , Try < R > > function ) { try { return function . apply ( value ) ; } catch ( Throwable t ) { return new Failure <> ( t ) ; } }'", "label": "'Applies the value to the function and returns the { @link Try } generated by the function .'"}
{"text": "'@ Override public Try < T > filter ( Predicate < T > predicate ) { return predicate . test ( value ) ? this : new Failure <> ( new NoSuchElementException ( \"Predicate did not match value, now empty result\" ) ) ; }'", "label": "'Applies the predicate to the value of this instance if it matches <i > this< / i > is returned else a { @link Failure } .'"}
{"text": "'@ Override public < T > T fold ( Function < L , T > func_left , Function < R , T > func_right ) { return func_right . apply ( value ) ; }'", "label": "'Applies the provided <code > func_right< / code > to the wrapped value and returns the result .'"}
{"text": "'String convertSoapMessageAsString ( SOAPMessage soapMessage ) { if ( soapMessage == null ) { return \"null\" ; } try { ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; soapMessage . writeTo ( os ) ; return new String ( os . toByteArray ( ) , determineMessageEncoding ( soapMessage ) ) ; } catch ( Exception e ) { logger . error ( \"Couldn\\'t create string representation of soapMessage: \" + soapMessage . toString ( ) ) ; return \"ERROR\" ; } }'", "label": "'Converts a SOAPMessage instance to string representation .'"}
{"text": "'public boolean shouldBeProcessed ( final ProfileSettings profileSettings ) { if ( profileSettings != null ) { String propertyName = GetterUtilities . getFullQualifiedFieldName ( baseType , method ) ; Boolean shouldBeProcessed = profileSettings . getPropertyValue ( propertyName ) ; if ( shouldBeProcessed == null ) { propertyName = baseType . getCanonicalName ( ) + \".\" + method . getName ( ) ; shouldBeProcessed = profileSettings . getPropertyValue ( propertyName ) ; } if ( shouldBeProcessed == null && annotation != null ) { shouldBeProcessed = annotation . enabledPerDefault ( ) ; } if ( shouldBeProcessed != null ) { return shouldBeProcessed ; } } return true ; }'", "label": "'Determines if a method should be processed . This will either be if no { @link io . tracee . contextlogger . contextprovider . api . TraceeContextProviderMethod } annotation is present or if an empty property name is defined in the annotation or if passed profileSettings are null or if the property name is disabled in the { @link io . tracee . contextlogger . profile . ProfileSettings } .'"}
{"text": "'protected boolean hasTraceeContextProviderAnnotation ( final Object instance ) { if ( instance == null ) { return false ; } TraceeContextProvider annotation = TraceeContextLogAnnotationUtilities . getAnnotationFromType ( instance ) ; return annotation != null ; }'", "label": "'Checks whether the passed instance type is annotated with the { @link io . tracee . contextlogger . contextprovider . api . TraceeContextProvider } annotation .'"}
{"text": "'protected boolean isExtendingTraceeContextProvider ( final Object instance ) { if ( instance == null ) { return false ; } return ImplicitContextData . class . isAssignableFrom ( instance . getClass ( ) ) || WrappedContextData . class . isAssignableFrom ( instance . getClass ( ) ) ; }'", "label": "'Checks whether the passed instance extends the { @link ImplicitContextData } or { @link io . tracee . contextlogger . contextprovider . api . WrappedContextData } types .'"}
{"text": "'public static boolean isListOfType ( Object instance , Class type ) { if ( instance == null || type == null ) { return false ; } if ( List . class . isAssignableFrom ( instance . getClass ( ) ) ) { // check whether the list is empty or the first instance is of passed type List list = ( List ) instance ; boolean isEmpty = list . size ( ) == 0 ; for ( Object element : list ) { if ( element != null && ! type . isAssignableFrom ( element . getClass ( ) ) ) { return false ; } } return true ; } return false ; }'", "label": "'Checks if passed instance is of type { @link java . util . List } and contains elements of the passed type . Warning : Only the first element of the list will be checked'"}
{"text": "'public static < T > List < T > getListOfType ( Object instance , Class < T > elementType ) { if ( instance == null || elementType == null || ! isListOfType ( instance , elementType ) ) { return null ; } try { return ( List < T > ) instance ; } catch ( ClassCastException e ) { return null ; } }'", "label": "'Check if the passed instance is a { @link java . util . List } and contains only elements of the passed element types . In that case it casts the passed instance to a List of the passed element type .'"}
{"text": "'protected static synchronized FileObjectWrapper getOrCreateProfileProperties ( final Filer filer , String fileName ) throws IOException { FileObjectWrapper fileObject = traceeProfileProperties . get ( fileName ) ; if ( fileObject == null ) { fileObject = new FileObjectWrapper ( filer . createResource ( StandardLocation . SOURCE_OUTPUT , \"\" , fileName , null ) ) ; traceeProfileProperties . put ( fileName , fileObject ) ; } return fileObject ; }'", "label": "'Central method to get cached FileObjectWrapper . Creates new FileObjectWrapper if it can t be found'"}
{"text": "'protected boolean isValidMethod ( Element element ) { // must be of type class if ( element . getKind ( ) != ElementKind . METHOD ) { error ( element , \"Element %s annotated with annotation %s must be a method\" , element . getSimpleName ( ) , TraceeContextProviderMethod . class . getSimpleName ( ) ) ; return false ; } // must be public if ( ! element . getModifiers ( ) . contains ( Modifier . PUBLIC ) ) { error ( element , \"Method %s annotated with annotation %s must be public\" , element . getSimpleName ( ) , TraceeContextProviderMethod . class . getSimpleName ( ) ) ; return false ; } // must not abstract if ( element . getModifiers ( ) . contains ( Modifier . ABSTRACT ) ) { error ( element , \"Method %s annotated with annotation %s must not be abstract\" , element . getSimpleName ( ) , TraceeContextProviderMethod . class . getSimpleName ( ) ) ; return false ; } // must not be static if ( element . getModifiers ( ) . contains ( Modifier . STATIC ) ) { error ( element , \"Method %s annotated with annotation %s must not be static\" , element . getSimpleName ( ) , TraceeContextProviderMethod . class . getSimpleName ( ) ) ; return false ; } return true ; }'", "label": "'Checks if passed element is a method declared as public not abstract and not static'"}
{"text": "'protected boolean isGetterMethod ( ExecutableElement executableElement ) { // must have a return value TypeMirror returnTypeMirror = executableElement . getReturnType ( ) ; if ( returnTypeMirror . getKind ( ) . equals ( TypeKind . VOID ) ) { error ( executableElement , \"method %s must have a non void return type\" , executableElement . getSimpleName ( ) . toString ( ) ) ; return false ; } // check if method takes no parameters List parameters = executableElement . getParameters ( ) ; if ( parameters != null && parameters . size ( ) > 0 ) { error ( executableElement , \"method %s must have no parameters \" , executableElement . getSimpleName ( ) . toString ( ) ) ; return false ; } return true ; }'", "label": "'Checks if passed element has a non void return type and takes no parameters'"}
{"text": "'protected boolean isParentAnnotatedWithTraceeContextProvider ( final Element element ) { Element parentElement = element . getEnclosingElement ( ) ; if ( parentElement == null || parentElement . getKind ( ) != ElementKind . CLASS || ! isTypeAnnotatedWithTraceeContextProvider ( ( TypeElement ) parentElement ) ) { error ( element , \"Enclosing type of method %s annotated with annotation %s is not annotated with annotation %s.\" , element . getSimpleName ( ) , Flatten . class . getSimpleName ( ) , TraceeContextProvider . class . getSimpleName ( ) ) ; return false ; } return true ; }'", "label": "'Checks if passed elements parent is type element and annotated with { @link TraceeContextProvider } .'"}
{"text": "'public Boolean getPropertyValue ( final String propertyKey ) { if ( propertyKey == null ) { return null ; } // check system property override if ( toTraceeContextStringRepresentationBuilder != null && toTraceeContextStringRepresentationBuilder . getManualContextOverrides ( ) != null ) { Boolean manualOverrideCheck = toTraceeContextStringRepresentationBuilder . getManualContextOverrides ( ) . get ( propertyKey ) ; if ( manualOverrideCheck != null ) { return manualOverrideCheck ; } } // check profile properties if ( profileProperties != null ) { String value = profileProperties . getProperty ( propertyKey ) ; if ( value != null ) { return Boolean . valueOf ( value ) ; } } return null ; }'", "label": "'Checks whether the property for the passed key is enabled or not .'"}
{"text": "'protected boolean checkIfClassHasNoargsConstructor ( TypeElement typeElement ) { // check if annotated class has noargs constructor boolean foundConstructor = false ; boolean foundNoargsConstructor = false ; for ( Element child : typeElement . getEnclosedElements ( ) ) { if ( ElementKind . CONSTRUCTOR . equals ( child . getKind ( ) ) ) { foundConstructor = true ; ExecutableElement constructor = ( ExecutableElement ) child ; if ( constructor . getParameters ( ) . size ( ) == 0 ) { foundNoargsConstructor = true ; break ; } } } return ! ( foundConstructor && ! foundNoargsConstructor ) ; }'", "label": "'Checks if class has noargs constructor or default noargs constructor .'"}
{"text": "'public static < T extends Annotation > T getAnnotationFromType ( final Object instance , Class < T > annotation ) { if ( instance == null || annotation == null ) { return null ; } return instance . getClass ( ) . getAnnotation ( annotation ) ; }'", "label": "'Gets an annotation of passed instance .'"}
{"text": "'public static List < MethodAnnotationPair > getAnnotatedMethodsOfInstance ( final Object instance ) { List < MethodAnnotationPair > result = new ArrayList < MethodAnnotationPair > ( ) ; for ( Method method : instance . getClass ( ) . getDeclaredMethods ( ) ) { if ( checkIsPublic ( method ) && checkMethodHasNoParameters ( method ) && checkMethodHasNonVoidReturnType ( method ) ) { TraceeContextProviderMethod annotation = method . getAnnotation ( TraceeContextProviderMethod . class ) ; // check if method has no parameters and is annotated if ( annotation != null ) { result . add ( new MethodAnnotationPair ( instance . getClass ( ) , method , annotation ) ) ; } } } return result ; }'", "label": "'Extracts all { @link io . tracee . contextlogger . contextprovider . api . TraceeContextProviderMethod } annotated methods of the passed instance .'"}
{"text": "'public static boolean checkMethodHasNonVoidReturnType ( final Method method ) { if ( method == null ) { return false ; } try { return ! ( Void . TYPE == method . getReturnType ( ) ) ; } catch ( Exception e ) { return false ; } }'", "label": "'Checks whether the passsed method has a non void return value .'"}
{"text": "'public static Set < Method > getGetterMethodsRecursively ( final Class type ) { Set < Method > getterMethods = new HashSet < Method > ( ) ; if ( type != null ) { Method [ ] methods = null ; try { methods = type . getDeclaredMethods ( ) ; } catch ( SecurityException e ) { // use fallback - checks against fields might not work methods = type . getMethods ( ) ; } for ( Method method : methods ) { if ( IsGetterMethodPredicate . check ( type , method ) ) { getterMethods . add ( method ) ; } } // process supertype getterMethods . addAll ( getGetterMethodsRecursively ( type . getSuperclass ( ) ) ) ; } return getterMethods ; }'", "label": "'Gets all getter methods recursively ( for all superclasses ) .'"}
{"text": "'public boolean apply ( final StringBuilder stringBuilder , final OutputStyle outputStyle , final OutputElement outputElement ) { boolean result = false ; if ( outputElement != null ) { if ( OutputElementType . COLLECTION . equals ( outputElement . getOutputElementType ( ) ) ) { result = handleCollectionType ( stringBuilder , outputStyle , outputElement ) ; } else if ( OutputElementType . COMPLEX . equals ( outputElement . getOutputElementType ( ) ) ) { if ( TraceeContextLogAnnotationUtilities . getAnnotationFromType ( outputElement . getEncapsulatedInstance ( ) ) != null ) { result = handleTraceeContextprovider ( stringBuilder , outputStyle , outputElement ) ; } else { result = handleComplexType ( stringBuilder , outputStyle , outputElement ) ; } } } return result ; }'", "label": "'Write the type string to the Stringbuilder'"}
{"text": "'public static Set < Class > findWrapperClasses ( ) { final List < TypeToWrapper > localTypeToWrapperList = getTypeToWrapper ( ) ; Set < Class > resultList = new HashSet < Class > ( ) ; if ( localTypeToWrapperList != null ) { for ( TypeToWrapper typeToWrapper : localTypeToWrapperList ) { resultList . add ( typeToWrapper . getWrapperType ( ) ) ; } } return resultList ; }'", "label": "'Gets a list with all wrapper classes .'"}
{"text": "'public static Set < ImplicitContextData > getImplicitContextDataProviders ( ) { final Set < ImplicitContextData > result = new HashSet < ImplicitContextData > ( ) ; for ( Class clazz : ContextProviderServiceLoader . getServiceLocator ( ) . getImplicitContextProvider ( ) ) { try { if ( ImplicitContextData . class . isAssignableFrom ( clazz ) ) { ImplicitContextData instance = ( ImplicitContextData ) ( clazz . newInstance ( ) ) ; result . add ( instance ) ; } } catch ( Throwable e ) { // to be ignored } } return result ; }'", "label": "'Generic function to get a implicit data provider classes from resource files .'"}
{"text": "'public static List < TypeToWrapper > getAvailableWrappers ( ) { final List < TypeToWrapper > result = new ArrayList < TypeToWrapper > ( ) ; for ( Class clazz : ContextProviderServiceLoader . getServiceLocator ( ) . getContextProvider ( ) ) { try { if ( WrappedContextData . class . isAssignableFrom ( clazz ) ) { // try to create instance to get the wrapped type final WrappedContextData instance = ( WrappedContextData ) clazz . newInstance ( ) ; result . add ( new TypeToWrapper ( instance . getWrappedType ( ) , clazz ) ) ; } } catch ( Throwable e ) { // to be ignored } } return result ; }'", "label": "'Method to get all available wrappers .'"}
{"text": "'private void initConnectors ( ) { // first get all connector configuration Names Set < String > connectorConfigurationNames = this . getConnectorConfigurationNames ( ) ; for ( String connectorConfigurationName : connectorConfigurationNames ) { Connector connector = this . createConnector ( connectorConfigurationName ) ; if ( connector != null ) { this . connectorMap . put ( connectorConfigurationName , connector ) ; } } // Add mandatory logger if ( ! isConnectorConfigured ( LogConnector . class ) ) { Connector logConnector = new LogConnector ( ) ; this . connectorMap . put ( \"LOGGER\" , logConnector ) ; } }'", "label": "'Initializes all available connectors .'"}
{"text": "'final void sendErrorReportToConnectors ( ConnectorOutputProvider connectorOutputProvider ) { for ( Connector connector : this . connectorMap . values ( ) ) { connector . sendErrorReport ( connectorOutputProvider ) ; } }'", "label": "'Send error report to all initialized connector instances .'"}
{"text": "'final Set < String > getConnectorConfigurationNames ( ) { Set < String > connectorNames = new HashSet < String > ( ) ; Enumeration < Object > keyEnumeration = getSystemProperties ( ) . keys ( ) ; while ( keyEnumeration . hasMoreElements ( ) ) { String key = keyEnumeration . nextElement ( ) . toString ( ) ; // check if property key has tracee connector format Matcher matcher = KEY_MATCHER_PATTERN . matcher ( key ) ; if ( matcher . matches ( ) && matcher . groupCount ( ) > 0 ) { connectorNames . add ( matcher . group ( 1 ) ) ; } } return connectorNames ; }'", "label": "'Extracts all names for connector configurations from System properties .'"}
{"text": "'final Map < String , String > getPropertiesForConnectorConfigurationName ( final String connectorName ) { final Map < String , String > propertyMap = new HashMap < String , String > ( ) ; final String patternString = String . format ( CONNECTOR_PROPERTY_GRABBER_PATTERN , connectorName ) ; final Pattern propertyGrabPattern = Pattern . compile ( patternString ) ; final Set < Map . Entry < Object , Object > > entries = getSystemProperties ( ) . entrySet ( ) ; for ( Map . Entry < Object , Object > entry : entries ) { final String key = entry . getKey ( ) . toString ( ) ; final Object value = entry . getValue ( ) ; // check if property key has tracee connector format final Matcher matcher = propertyGrabPattern . matcher ( key ) ; if ( value != null && matcher . matches ( ) && matcher . groupCount ( ) > 0 ) { final String propertyName = matcher . group ( 1 ) ; propertyMap . put ( propertyName , value . toString ( ) ) ; } } return propertyMap ; }'", "label": "'Collects all properties for a given connector configuration name and writes them to a Map .'"}
{"text": "'final Connector createConnector ( final String connectorConfigurationName ) { Map < String , String > propertyMap = this . getPropertiesForConnectorConfigurationName ( connectorConfigurationName ) ; String type = propertyMap . get ( TraceeContextLoggerConstants . SYSTEM_PROPERTY_CONTEXT_LOGGER_CONNECTOR_TYPE ) ; // get canonical class name for well known connectors if ( WELL_KNOW_CONNECTOR_MAPPINGS . containsKey ( type ) ) { type = WELL_KNOW_CONNECTOR_MAPPINGS . get ( type ) ; } try { // try to create connector instance Connector connector = ( Connector ) Class . forName ( type ) . newInstance ( ) ; // now try to call init method connector . init ( propertyMap ) ; return connector ; } catch ( Exception e ) { LOGGER . error ( \"An error occurred while creating connector with name \\'\" + connectorConfigurationName + \"\\' of type \\'\" + type + \"\\'\" , e ) ; } return null ; }'", "label": "'Tries to create a Connector for a given connector configuration name .'"}
{"text": "'private boolean isConnectorConfigured ( Class connectorClass ) { for ( Connector connector : this . connectorMap . values ( ) ) { if ( connectorClass . isInstance ( connector ) ) { return true ; } } return false ; }'", "label": "'Checks whether the LogConnector is defined or not .'"}
{"text": "'boolean hasGetterPrefixInMethodName ( Method method ) { String methodName = method . getName ( ) ; if ( methodName != null ) { for ( String prefix : GETTER_PREFIXES ) { if ( methodName . startsWith ( prefix ) ) { return true ; } } } return false ; }'", "label": "'Getter method names must have a specific prefix .'"}
{"text": "'boolean isPublicNonStaticMethod ( final Method method ) { int modifiers = method . getModifiers ( ) ; return ! Modifier . isStatic ( modifiers ) && Modifier . isPublic ( modifiers ) ; }'", "label": "'Getter methods must be public and not be static .'"}
{"text": "'boolean hasReturnValue ( final Method method ) { Class returnType = method . getReturnType ( ) ; return ! Void . TYPE . equals ( returnType ) ; }'", "label": "'Getter methods must have return type ( must not be of type Void )'"}
{"text": "'boolean hasCompatibleReturnTypes ( Class type , Method method ) { Field correspondingField = getCorrespondingField ( type , method ) ; return correspondingField != null && method . getReturnType ( ) . isAssignableFrom ( correspondingField . getType ( ) ) ; }'", "label": "'Getter method and field must have compatible fields .'"}
{"text": "'Field getCorrespondingField ( Class type , Method method ) { try { return type . getDeclaredField ( GetterUtilities . getFieldName ( method ) ) ; } catch ( NoSuchFieldException e ) { return null ; } }'", "label": "'Helper method for getting a corresponsing field for a method'"}
{"text": "'public static boolean isGetterMethod ( final String methodName ) { if ( methodName != null ) { for ( String prefix : GETTER_PREFIXES ) { if ( methodName . startsWith ( prefix ) ) { return true ; } } } return false ; }'", "label": "'Checks whether the method name starts with a getter prefix .'"}
{"text": "'public static String getFieldName ( final String methodName ) { if ( isGetterMethod ( methodName ) ) { return decapitalizeFirstCharOfString ( stripGetterPrefix ( methodName ) ) ; } return null ; }'", "label": "'Strips getter prefix from method name .'"}
{"text": "'public static String getFieldName ( final Method method ) { if ( method != null ) { return getFieldName ( method . getName ( ) ) ; } else { return null ; } }'", "label": "'Strips getter prefix from method name .'"}
{"text": "'public static String getFullQualifiedFieldName ( final Class type , final Method method ) { if ( method != null ) { // get the name of the type from passed type or method final String typeName ; if ( type != null ) { typeName = type . getCanonicalName ( ) ; } else { typeName = method . getDeclaringClass ( ) . getCanonicalName ( ) ; } // get field name from getter method or method name for non getter methods final String fieldName ; if ( isGetterMethod ( method . getName ( ) ) ) { fieldName = getFieldName ( method . getName ( ) ) ; } else { fieldName = method . getName ( ) ; } return typeName + \".\" + fieldName ; } else { return null ; } }'", "label": "'Gets the full qualified name of a field or non getter method . Result has following format : Full Qualified Classname . field name for getter methods or method name for non getter methods .'"}
{"text": "'static String capitalizeFirstCharOfString ( final String input ) { if ( input == null || input . length ( ) == 0 ) { return \"\" ; } else if ( input . length ( ) == 1 ) { return input . toUpperCase ( ) ; } else { return input . substring ( 0 , 1 ) . toUpperCase ( ) + input . substring ( 1 ) ; } }'", "label": "'Capitalizes first char of an input string .'"}
{"text": "'static String decapitalizeFirstCharOfString ( final String input ) { if ( input == null || input . length ( ) == 0 ) { return \"\" ; } else if ( input . length ( ) == 1 ) { return input . toLowerCase ( ) ; } else { return input . substring ( 0 , 1 ) . toLowerCase ( ) + input . substring ( 1 ) ; } }'", "label": "'Decapitalizes first char of an input string .'"}
{"text": "'static String stripGetterPrefix ( final String input ) { if ( input != null ) { for ( String prefix : GETTER_PREFIXES ) { if ( input . startsWith ( prefix ) ) { return input . substring ( prefix . length ( ) ) ; } } } return input ; }'", "label": "'Strips getter prefix from input string'"}
{"text": "\"protected Object invokeGetter ( final Object instance , final Method method ) { try { return method . invoke ( instance ) ; } catch ( IllegalAccessException e ) { // shouldn't occur } catch ( InvocationTargetException e ) { // shouldn't occur } return null ; }\"", "label": "'Invokes the getter and return the return values'"}
{"text": "\"protected Object invokeField ( final Object instance , final Method method ) { if ( instance == null || method == null ) { return null ; } try { Field field = FieldUtilities . getField ( instance . getClass ( ) , GetterUtilities . getFieldName ( method ) ) ; field . setAccessible ( true ) ; return field . get ( instance ) ; } catch ( IllegalAccessException e ) { // shouldn't occur } catch ( IllegalArgumentException e ) { // ignore } return null ; }\"", "label": "'Invokes the getter and return the return values'"}
{"text": "'void sendErrorReportToConnectors ( ProceedingJoinPoint proceedingJoinPoint , String annotatedId , Throwable e ) { // try to get error message annotation ErrorMessage errorMessage = WatchdogUtils . getErrorMessageAnnotation ( proceedingJoinPoint ) ; if ( errorMessage == null ) { TraceeContextLogger . create ( ) . enforceOrder ( ) . apply ( ) . logWithPrefixedMessage ( MessagePrefixProvider . provideLogMessagePrefix ( MessageLogLevel . ERROR , Watchdog . class ) , CoreImplicitContextProviders . COMMON , CoreImplicitContextProviders . TRACEE , WatchdogDataWrapper . wrap ( annotatedId , proceedingJoinPoint ) , e ) ; } else { TraceeContextLogger . create ( ) . enforceOrder ( ) . apply ( ) . logWithPrefixedMessage ( MessagePrefixProvider . provideLogMessagePrefix ( MessageLogLevel . ERROR , Watchdog . class ) , TraceeMessage . wrap ( errorMessage . value ( ) ) , CoreImplicitContextProviders . COMMON , CoreImplicitContextProviders . TRACEE , WatchdogDataWrapper . wrap ( annotatedId , proceedingJoinPoint ) , e ) ; } }'", "label": "'Sends the error reports to all connectors .'"}
{"text": "'public Object apply ( ContextLoggerConfiguration contextLoggerConfiguration , Object instanceToWrap ) { // check for implicit context if ( IsImplicitContextEnumValuePredicate . getInstance ( ) . apply ( instanceToWrap ) ) { return createInstance ( ( Class ) contextLoggerConfiguration . getImplicitContextProviderClass ( ( ImplicitContext ) instanceToWrap ) ) ; } // now try to find instance type in known wrapper types map Class matchingWrapperType = contextLoggerConfiguration . getContextProviderClass ( instanceToWrap . getClass ( ) ) ; if ( matchingWrapperType == null ) { // now try to find instance type in TypeToWrapper List for ( TypeToWrapper wrapper : contextLoggerConfiguration . getWrapperList ( ) ) { if ( wrapper . getWrappedInstanceType ( ) . isAssignableFrom ( instanceToWrap . getClass ( ) ) ) { matchingWrapperType = wrapper . getWrapperType ( ) ; break ; } } } if ( matchingWrapperType != null ) { // now create wrapper instance try { WrappedContextData wrapperInstance = ( WrappedContextData ) createInstance ( matchingWrapperType ) ; wrapperInstance . setContextData ( instanceToWrap ) ; return wrapperInstance ; } catch ( Exception e ) { // continue } } return instanceToWrap ; }'", "label": "'Wraps the passed instance inside a matching tracee context logging provider instance . Will return the passed instance if no matching tracee context logging provider exists .'"}
{"text": "'protected Object createInstance ( final Class type ) { if ( type != null ) { try { return type . newInstance ( ) ; } catch ( Exception e ) { // should not occur } } return null ; }'", "label": "'Creates a new instance of the passed type via reflection .'"}
{"text": "'protected boolean hasTraceeContextProviderPrimitiveTypeAnnotation ( final Object instance ) { if ( instance == null ) { return false ; } TraceeContextProviderPrimitiveType annotation = TraceeContextLogAnnotationUtilities . getAnnotationFromType ( instance , TraceeContextProviderPrimitiveType . class ) ; return annotation != null ; }'", "label": "'Checks whether the passed instance type is annotated with the { @link io . tracee . contextlogger . contextprovider . api . TraceeContextProvider } annotation .'"}
{"text": "'protected boolean isExtendingTraceeContextProvider ( final Object instance ) { if ( instance == null ) { return false ; } return WrappedPrimitiveTypeContextData . class . isAssignableFrom ( instance . getClass ( ) ) ; }'", "label": "'Checks whether the passed instance extends the { @link io . tracee . contextlogger . contextprovider . api . ImplicitContextData } or { @link io . tracee . contextlogger . contextprovider . api . WrappedContextData } types .'"}
{"text": "'public static Profile getCurrentProfile ( ) { // First get profile from system properties Profile profile = getProfileFromSystemProperties ( ) ; // check if profile has been found otherwise try getting profile from file in classpath if ( profile == null ) { profile = getProfileFromFileInClasspath ( ProfilePropertyNames . PROFILE_SET_BY_FILE_IN_CLASSPATH_FILENAME ) ; } // use DEFAULT profile, if profile has not been found if ( profile == null ) { profile = ProfilePropertyNames . DEFAULT_PROFILE ; } return profile ; }'", "label": "'Gets the current profile . Uses the following algorithm to determine the profile . 1 . If System Property is set force it as profile 2 . If Custom Profile resource can be located in classpath use that file as profile 3 . Use default profile'"}
{"text": "'static Profile getProfileFromSystemProperties ( ) { Profile result = null ; // try to get system property String systemPropertyProfileName = System . getProperty ( ProfilePropertyNames . PROFILE_SET_GLOBALLY_VIA_SYSTEM_PROPERTIES ) ; if ( systemPropertyProfileName != null ) { // try to convert String to enum value try { result = Profile . valueOf ( systemPropertyProfileName ) ; } catch ( IllegalArgumentException e ) { logger . warn ( \"Tracee ContextLoggerBuilder profile property (\\'\" + ProfilePropertyNames . PROFILE_SET_GLOBALLY_VIA_SYSTEM_PROPERTIES + \"\\') is set to the invalid value \\'\" + systemPropertyProfileName + \"\\' ==> Use default profile\" ) ; } } return result ; }'", "label": "'Gets the profile defined via the system properties .'"}
{"text": "'static Profile getProfileFromFileInClasspath ( final String filename ) { Profile result = null ; try { Properties properties = openProperties ( filename ) ; if ( properties != null ) { String profileFromProperties = properties . getProperty ( ProfilePropertyNames . PROFILE_SET_BY_FILE_IN_CLASSPATH_PROPERTY ) ; if ( profileFromProperties != null ) { // try to convert String to enum value try { result = Profile . valueOf ( profileFromProperties ) ; } catch ( IllegalArgumentException e ) { logger . warn ( \"Tracee custom ContextLoggerBuilder profile property (\\'\" + ProfilePropertyNames . PROFILE_SET_BY_FILE_IN_CLASSPATH_PROPERTY + \"\\') is set to the invalid value \\'\" + profileFromProperties + \"\\' and will be ignored\" ) ; } } } } catch ( IOException e ) { // ignore it } return result ; }'", "label": "'Gets the profile defined via the system properties .'"}
{"text": "\"public static Properties openProperties ( final String propertyFileName ) throws IOException { if ( propertyFileName == null ) { return null ; } InputStream inputStream = null ; try { inputStream = Profile . class . getResourceAsStream ( propertyFileName ) ; if ( inputStream != null ) { // file could be opened Properties properties = new Properties ( ) ; properties . load ( inputStream ) ; return properties ; } else { // file doesn't exist return null ; } } finally { if ( inputStream != null ) { inputStream . close ( ) ; } } }\"", "label": "'Loads properties from resources .'"}
{"text": "'private void fillManualContextOverrideMap ( final String [ ] contexts , final boolean value ) { if ( contexts != null ) { for ( String context : contexts ) { if ( ! context . isEmpty ( ) ) { this . manualContextOverrides . put ( context , value ) ; } } } }'", "label": "'Adds passed contexts value pairs to manualContextOverrides .'"}
{"text": "'private TraceeContextStringRepresentationBuilderImpl createContextStringRepresentationLogBuilder ( ) { TraceeContextStringRepresentationBuilderImpl traceeContextStringRepresentationBuilderImpl = new TraceeContextStringRepresentationBuilderImpl ( ) ; traceeContextStringRepresentationBuilderImpl . setManualContextOverrides ( this . getManualContextOverrides ( ) ) ; traceeContextStringRepresentationBuilderImpl . setProfile ( this . getProfile ( ) ) ; traceeContextStringRepresentationBuilderImpl . setEnforceOrder ( this . getEnforceOrder ( ) ) ; traceeContextStringRepresentationBuilderImpl . setOutputWriterConfiguration ( this . getOutputWriterConfiguration ( ) ) ; return traceeContextStringRepresentationBuilderImpl ; }'", "label": "'Creates a TraceeGsonContextStringRepresentationBuilder instance which can be used for creating the createStringRepresentation message .'"}
{"text": "'public static Watchdog getWatchdogAnnotation ( final ProceedingJoinPoint proceedingJoinPoint ) { // get watchdog annotation from method MethodSignature methodSignature = ( MethodSignature ) proceedingJoinPoint . getSignature ( ) ; Watchdog methodAnnotation = methodSignature . getMethod ( ) . getAnnotation ( Watchdog . class ) ; if ( methodAnnotation != null ) { return methodAnnotation ; } // get watchdog annotation at class return ( Watchdog ) proceedingJoinPoint . getSignature ( ) . getDeclaringType ( ) . getAnnotation ( Watchdog . class ) ; }'", "label": "'Tries to get the watchdog annotation for the called method or the methods class .'"}
{"text": "'public static ErrorMessage getErrorMessageAnnotation ( final ProceedingJoinPoint proceedingJoinPoint ) { // get watchdog annotation from method MethodSignature methodSignature = ( MethodSignature ) proceedingJoinPoint . getSignature ( ) ; ErrorMessage methodAnnotation = methodSignature . getMethod ( ) . getAnnotation ( ErrorMessage . class ) ; if ( methodAnnotation != null ) { return methodAnnotation ; } else { return null ; } }'", "label": "'Tries to get the watchdog annotation for the called method or the methods class .'"}
{"text": "'public static boolean checkIfMethodThrowsContainsPassedException ( final ProceedingJoinPoint proceedingJoinPoint , Throwable thrownException ) { if ( proceedingJoinPoint == null || thrownException == null ) { return false ; } Class [ ] throwsClassesFromMethodSignature = getDefinedThrowsFromMethodSignature ( proceedingJoinPoint ) ; return checkClassIsDefinedInThrowsException ( throwsClassesFromMethodSignature , thrownException ) ; }'", "label": "'Checks whether the passed Throwable is contained in methods throws part .'"}
{"text": "'public static boolean checkClassIsDefinedInThrowsException ( Class [ ] classes , Throwable thrownException ) { // return false if either passed classes array or thrownException are null. if ( classes == null || thrownException == null ) { return false ; } // loop through classes array to check for matching type for ( Class clazz : classes ) { if ( clazz . isInstance ( thrownException ) ) { return true ; } } return false ; }'", "label": "'Checks whether the passed Throwable is defined included in passed classes array or is subtype of one of the included classes .'"}
{"text": "'public static Class [ ] getDefinedThrowsFromMethodSignature ( final ProceedingJoinPoint proceedingJoinPoint ) { if ( proceedingJoinPoint == null ) { return new Class [ 0 ] ; } // get watchdog annotation from method MethodSignature methodSignature = ( MethodSignature ) proceedingJoinPoint . getSignature ( ) ; return methodSignature . getMethod ( ) . getExceptionTypes ( ) ; }'", "label": "'Gets all Exceptions declared at the throws part of the method signature .'"}
{"text": "'public static boolean checkProcessWatchdog ( final Watchdog watchdogAnnotation , final ProceedingJoinPoint proceedingJoinPoint , final Throwable throwable ) { // check if watchdog aspect processing is deactivated by annotation if ( watchdogAnnotation != null && watchdogAnnotation . isActive ( ) ) { // checks if throws annotations must be suppressed boolean throwableIsPartOfThrowsDeclaration = WatchdogUtils . checkIfMethodThrowsContainsPassedException ( proceedingJoinPoint , throwable ) ; if ( ! watchdogAnnotation . suppressThrowsExceptions ( ) || ( watchdogAnnotation . suppressThrowsExceptions ( ) && ! throwableIsPartOfThrowsDeclaration ) ) { return true ; } } return false ; }'", "label": "'Checks whether the exception should be processed or not .'"}
{"text": "'@ NotNull LineDiff [ ] compareContents ( @ NotNull File actual , @ NotNull File expected ) throws IOException { InputStream ais = null ; InputStream eis = null ; try { ais = new FileInputStream ( actual ) ; eis = new FileInputStream ( expected ) ; List < LineDiff > diffs = verifyEqualContent ( readerFor ( ais ) , readerFor ( eis ) ) ; return diffs . toArray ( new LineDiff [ diffs . size ( ) ] ) ; } finally { closeQuietly ( eis ) ; closeQuietly ( ais ) ; } }'", "label": "'/ * Verifies that the given files have the same content . Adapted from <a href = http : // junit - addons . sourceforge . net / junitx / framework / FileAssert . html target = _blank > FileAssert< / a > ( from <a href = http : // sourceforge . net / projects / junit - addons > JUnit - addons< / a > . )'"}
{"text": "'public final @ NotNull S isEqualByComparingTo ( T expected ) { isNotNull ( ) ; if ( actual . compareTo ( expected ) == 0 ) { return myself ( ) ; } failIfCustomMessageIsSet ( ) ; throw comparisonFailed ( rawDescription ( ) , actual , expected ) ; }'", "label": "'Verifies that the actual { @link Comparable } is equal to the given one .'"}
{"text": "'public final @ NotNull S isNotEqualByComparingTo ( T expected ) { isNotNull ( ) ; if ( actual . compareTo ( expected ) != 0 ) { return myself ( ) ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedEqual ( actual , expected ) ) ; }'", "label": "'Verifies that the actual { @link Comparable } is <b > not< / b > equal to the given one .'"}
{"text": "'public final @ NotNull S isLessThan ( T other ) { isNotNull ( ) ; if ( actual . compareTo ( other ) < 0 ) { return myself ( ) ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedGreaterThanOrEqualTo ( actual , other ) ) ; }'", "label": "'Verifies that the actual { @link Comparable } is less than the given one .'"}
{"text": "'public final @ NotNull S isGreaterThan ( @ Nullable T other ) { isNotNull ( ) ; if ( actual . compareTo ( other ) > 0 ) { return myself ( ) ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedLessThanOrEqualTo ( actual , other ) ) ; }'", "label": "'Verifies that the actual { @link Comparable } is greater than the given one .'"}
{"text": "'public final @ NotNull S isLessThanOrEqualTo ( @ Nullable T other ) { isNotNull ( ) ; if ( actual . compareTo ( other ) <= 0 ) { return myself ( ) ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedGreaterThan ( actual , other ) ) ; }'", "label": "'Verifies that the actual { @link Comparable } is less than or equal to the given one .'"}
{"text": "'public final @ NotNull S isGreaterThanOrEqualTo ( @ Nullable T other ) { isNotNull ( ) ; if ( actual . compareTo ( other ) >= 0 ) { return myself ( ) ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedLessThan ( actual , other ) ) ; }'", "label": "'Verifies that the actual { @link Comparable } is greater than or equal to the given one .'"}
{"text": "'public static @ Nullable BufferedImage read ( @ NotNull String imageFilePath ) throws IOException { checkNotNull ( imageFilePath ) ; File imageFile = new File ( imageFilePath ) ; if ( ! imageFile . isFile ( ) ) { throw new IllegalArgumentException ( format ( \"The path <%s> does not belong to a file\" , imageFilePath ) ) ; } return imageReader . read ( imageFile ) ; }'", "label": "'Reads the image in the specified path .'"}
{"text": "'@ Override public @ NotNull ImageAssert isEqualTo ( @ Nullable BufferedImage expected ) { return isEqualTo ( expected , ZERO_THRESHOLD ) ; }'", "label": "'Verifies that the actual image is equal to the given one . Two images are equal if they have the same size and the pixels at the same coordinates have the same color .'"}
{"text": "'public @ NotNull ImageAssert isEqualTo ( @ Nullable BufferedImage expected , @ NotNull Threshold threshold ) { checkNotNull ( threshold ) ; if ( areEqual ( actual , expected ) ) { return this ; } failIfNull ( expected ) ; failIfNotEqual ( sizeOf ( actual ) , sizeOf ( expected ) ) ; failIfNotEqualColor ( checkNotNull ( expected ) , threshold ) ; return this ; }'", "label": "'Verifies that the actual image is equal to the given one . Two images are equal if : <ol > <li > they have the same size< / li > <li > the difference between the RGB values of the color of each pixel is less than or equal to the given threshold< / li > < / ol >'"}
{"text": "'@ Override public @ NotNull ImageAssert isNotEqualTo ( @ Nullable BufferedImage image ) { if ( areEqual ( actual , image ) ) { failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedEqual ( actual , image ) ) ; } if ( image == null ) { return this ; } if ( areEqual ( sizeOf ( actual ) , sizeOf ( image ) ) && hasEqualColor ( image ) ) { failIfCustomMessageIsSet ( ) ; throw failure ( \"images are equal\" ) ; } return this ; }'", "label": "'Verifies that the actual image is not equal to the given one . Two images are equal if they have the same size and the pixels at the same coordinates have the same color .'"}
{"text": "'public @ NotNull ImageAssert hasSize ( @ NotNull Dimension expected ) { isNotNull ( ) ; checkNotNull ( expected ) ; Dimension actualDimension = new Dimension ( actual . getWidth ( ) , actual . getHeight ( ) ) ; if ( areEqual ( actualDimension , expected ) ) { return this ; } failWithMessage ( customErrorMessage ( ) ) ; throw comparisonFailed ( rawDescription ( ) , new DimensionFormatter ( actualDimension ) , new DimensionFormatter ( expected ) ) ; }'", "label": "'Verifies that the size of the actual image is equal to the given one .'"}
{"text": "'public static @ NotNull Collection < Object > notFound ( @ Nullable Collection < ? > target , @ NotNull Object ... objects ) { if ( target == null ) { return emptyList ( ) ; } List < Object > notFound = newArrayList ( ) ; for ( Object o : objects ) { if ( ! target . contains ( o ) ) { notFound . add ( o ) ; } } return notFound ; }'", "label": "'Attempts to find the given objects in the given { @code Collection } returning the ones that were not found .'"}
{"text": "'public final @ NotNull S hasSize ( int expected ) { isNotNull ( ) ; int size = actualGroupSize ( ) ; if ( size == expected ) { return myself ( ) ; } failIfCustomMessageIsSet ( ) ; throw failure ( format ( \"expected size:<%s> but was:<%s> for <%s>\" , expected , size , actual ) ) ; }'", "label": "'Verifies that the number of values in the actual group is equal to the given one .'"}
{"text": "'public @ NotNull FileAssert doesNotExist ( ) { isNotNull ( ) ; if ( ! actual . exists ( ) ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( format ( \"file:<%s> should not exist\" , actual ) ) ; }'", "label": "'Verifies that the actual { @code File } does not exist .'"}
{"text": "'public @ NotNull FileAssert hasSize ( long expected ) { isNotNull ( ) ; long size = actual . length ( ) ; if ( size == expected ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( format ( \"size of file:<%s> expected:<%s> but was:<%s>\" , actual , expected , size ) ) ; }'", "label": "'Verifies that the size of the actual { @code File } is equal to the given one .'"}
{"text": "'public @ NotNull FileAssert isDirectory ( ) { isNotNull ( ) ; if ( actual . isDirectory ( ) ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( format ( \"file:<%s> should be a directory\" , actual ) ) ; }'", "label": "'Verifies that the actual { @code File } is a directory .'"}
{"text": "'public @ NotNull FileAssert isFile ( ) { isNotNull ( ) ; if ( actual . isFile ( ) ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( format ( \"file:<%s> should be a file\" , actual ) ) ; }'", "label": "'Verifies that the actual { @code File } is a regular file .'"}
{"text": "'public @ NotNull FileAssert hasSameContentAs ( @ NotNull File expected ) { checkNotNull ( expected ) ; isNotNull ( ) ; assertExists ( actual ) . assertExists ( expected ) ; try { LineDiff [ ] diffs = comparator . compareContents ( actual , expected ) ; if ( ! isNullOrEmpty ( diffs ) ) { fail ( expected , diffs ) ; } } catch ( IOException e ) { cannotCompareToExpectedFile ( expected , e ) ; } return this ; }'", "label": "'Verifies that the content of the actual { @code File } is equal to the content of the given one . Adapted from <a href = http : // junit - addons . sourceforge . net / junitx / framework / FileAssert . html target = _blank > FileAssert< / a > ( from <a href = http : // sourceforge . net / projects / junit - addons > JUnit - addons< / a > . )'"}
{"text": "'public @ NotNull FileAssert isRelative ( ) { isNotNull ( ) ; if ( ! actual . isAbsolute ( ) ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( format ( \"file:<%s> should be a relative path\" , actual ) ) ; }'", "label": "'Verifies that the actual { @code File } is a relative path .'"}
{"text": "'@ Override protected @ NotNull IteratorAssert onProperty ( @ NotNull String propertyName ) { checkNotNull ( propertyName ) ; isNotNull ( ) ; List < Object > subset = PropertySupport . instance ( ) . propertyValues ( propertyName , newArrayList ( contentOfActual ( ) ) ) ; return new IteratorAssert ( subset . iterator ( ) ) ; }'", "label": "'{'"}
{"text": "'@ Override protected @ Nullable List < Object > actualAsList ( ) { if ( actual == null ) { return null ; } return newArrayList ( contentOfActual ( ) ) ; }'", "label": "'{'"}
{"text": "\"@ NotNull List < Object > propertyValues ( @ NotNull String propertyName , @ Nullable Collection < ? > target ) { if ( isNullOrEmpty ( target ) ) { return emptyList ( ) ; } // ignore null elements as we can't extract a property from a null object Collection < ? > nonNullElements = nonNullElementsIn ( target ) ; if ( isNestedProperty ( propertyName ) ) { String firstProperty = firstPropertyIfNested ( propertyName ) ; List < Object > firstPropertyValues = propertyValues ( firstProperty , nonNullElements ) ; // extract next sub property values until reaching a last sub property return propertyValues ( removeFirstPropertyIfNested ( propertyName ) , firstPropertyValues ) ; } return simplePropertyValues ( propertyName , nonNullElements ) ; }\"", "label": "'Returns a list containing the values of the given property name from the elements of the given collection . If the given collection is empty or { @code null } this method will return an empty collection . <p / > For example given the nested property address . street . number this method will : <ol > <li > extract a collection of address from the given collection ( remaining property is street . number ) < / li > <li > extract a collection of street from the address collection ( remaining property is number ) < / li > <li > extract a collection of number from the street collection< / li > < / ol >'"}
{"text": "'boolean isNestedProperty ( String propertyName ) { Preconditions . checkNotNull ( propertyName ) ; return propertyName . contains ( SEPARATOR ) && ! propertyName . startsWith ( SEPARATOR ) && ! propertyName . endsWith ( SEPARATOR ) ; }'", "label": "'Returns { @code true } if property is nested { @code false } otherwise . <p / > Examples : <pre > isNestedProperty ( &quot ; address . street&quot ; ) ; // true isNestedProperty ( &quot ; address . street . name&quot ; ) ; // true isNestedProperty ( &quot ; person&quot ; ) ; // false isNestedProperty ( &quot ; . name&quot ; ) ; // false isNestedProperty ( &quot ; person . &quot ; ) ; // false isNestedProperty ( &quot ; person . name . &quot ; ) ; // false isNestedProperty ( &quot ; . person . name&quot ; ) ; // false isNestedProperty ( &quot ; . &quot ; ) ; // false isNestedProperty ( &quot ; &quot ; ) ; // false < / pre >'"}
{"text": "'@ NotNull String firstPropertyIfNested ( @ NotNull String propertyName ) { if ( ! isNestedProperty ( propertyName ) ) { return propertyName ; } return checkNotNull ( propertyName . substring ( 0 , propertyName . indexOf ( SEPARATOR ) ) ) ; }'", "label": "'Returns the first property from the given property name only if the given property name belongs to a nested property . For example given the nested property address . street . name this method will return address . This method returns the given property name unchanged if it does not belong to a nested property .'"}
{"text": "'public static @ Nullable AssertionError comparisonFailure ( @ Nullable String message , @ Nullable Object expected , @ Nullable Object actual ) { try { return newComparisonFailure ( clean ( message ) , expected , actual ) ; } catch ( Exception e ) { return null ; } }'", "label": "'Creates a new instance of JUnit s { @code ComparisonFailure } only if JUnit 4 + is in the classpath .'"}
{"text": "'public @ NotNull ListAssert contains ( @ Nullable Object o , @ NotNull Index index ) { checkNotNull ( index ) ; isNotNull ( ) . isNotEmpty ( ) ; int indexValue = index . value ( ) ; int listSize = actualGroupSize ( ) ; if ( indexValue < 0 || indexValue >= listSize ) { failIndexOutOfBounds ( indexValue ) ; } Object actualElement = actual . get ( indexValue ) ; if ( ! areEqual ( actualElement , o ) ) { failElementNotFound ( o , actualElement , indexValue ) ; } return this ; }'", "label": "'Verifies that the actual { @code List } contains the given object at the given index .'"}
{"text": "'public @ NotNull ListAssert containsSequence ( @ NotNull Object ... sequence ) { isNotNull ( ) ; checkNotNull ( sequence ) ; int sequenceSize = sequence . length ; if ( sequenceSize == 0 ) { return this ; } int indexOfFirst = actual . indexOf ( sequence [ 0 ] ) ; if ( indexOfFirst == - 1 ) { failIfSequenceNotFound ( sequence ) ; } int listSize = actualGroupSize ( ) ; for ( int i = 0 ; i < sequenceSize ; i ++ ) { int actualIndex = indexOfFirst + i ; if ( actualIndex > listSize - 1 ) { failIfSequenceNotFound ( sequence ) ; } if ( ! areEqual ( sequence [ i ] , actual . get ( actualIndex ) ) ) { failIfSequenceNotFound ( sequence ) ; } } return this ; }'", "label": "'Verifies that the actual { @code List } contains the given sequence of objects without any other objects between them .'"}
{"text": "'public @ NotNull ListAssert startsWith ( @ NotNull Object ... sequence ) { isNotNull ( ) ; checkNotNull ( sequence ) ; int sequenceSize = sequence . length ; int listSize = actualGroupSize ( ) ; if ( sequenceSize == 0 && listSize == 0 ) { return this ; } if ( sequenceSize == 0 && listSize != 0 ) { failIfNotStartingWithSequence ( sequence ) ; } if ( listSize < sequenceSize ) { failIfNotStartingWithSequence ( sequence ) ; } for ( int i = 0 ; i < sequenceSize ; i ++ ) { if ( ! areEqual ( sequence [ i ] , actual . get ( i ) ) ) { failIfNotStartingWithSequence ( sequence ) ; } } return this ; }'", "label": "'Verifies that the actual { @code List } starts with the given sequence of objects without any other objects between them . Same as { @link #containsSequence } but verifies also that first given object is also first element of { @code List } .'"}
{"text": "'public @ NotNull ListAssert endsWith ( @ NotNull Object ... sequence ) { isNotNull ( ) ; checkNotNull ( sequence ) ; int sequenceSize = sequence . length ; int listSize = actualGroupSize ( ) ; if ( sequenceSize == 0 && listSize == 0 ) { return this ; } if ( sequenceSize == 0 && listSize != 0 ) { failIfNotEndingWithSequence ( sequence ) ; } if ( listSize < sequenceSize ) { failIfNotEndingWithSequence ( sequence ) ; } for ( int i = 0 ; i < sequenceSize ; i ++ ) { int sequenceIndex = sequenceSize - 1 - i ; int listIndex = listSize - 1 - i ; if ( ! areEqual ( sequence [ sequenceIndex ] , actual . get ( listIndex ) ) ) { failIfNotEndingWithSequence ( sequence ) ; } } return this ; }'", "label": "'Verifies that the actual { @code List } ends with the given sequence of objects without any other objects between them . Same as { @link #containsSequence } but verifies also that last given object is also last element of { @code List } .'"}
{"text": "'public @ NotNull ListAssert containsExactly ( @ NotNull Object ... objects ) { checkNotNull ( objects ) ; return isNotNull ( ) . isEqualTo ( newArrayList ( objects ) ) ; }'", "label": "'Verifies that the actual { @code List } contains the given objects in the same order . This method works just like { @code isEqualTo ( List ) } with the difference that internally the given array is converted to a { @code List } .'"}
{"text": "'@ Override public @ NotNull ListAssert onProperty ( @ NotNull String propertyName ) { isNotNull ( ) ; if ( actual . isEmpty ( ) ) { return new ListAssert ( emptyList ( ) ) ; } return new ListAssert ( PropertySupport . instance ( ) . propertyValues ( propertyName , actual ) ) ; }'", "label": "'Creates a new instance of { @link ListAssert } whose target list contains the values of the given property name from the elements of this { @code ListAssert } s list . Property access works with both simple properties like { @code Person . age } and nested properties { @code Person . father . age } . <p / > For example let s say we have a list of { @code Person } objects and you want to verify their age : <pre > assertThat ( persons ) . onProperty ( &quot ; age&quot ; ) . containsOnly ( 25 16 44 37 ) ; // simple property assertThat ( persons ) . onProperty ( father . age ) . containsOnly ( 55 46 74 62 ) ; // nested property < / pre >'"}
{"text": "'@ Override protected @ Nullable Set < Object > actualAsSet ( ) { return actual == null ? null : newLinkedHashSet ( actual . toArray ( ) ) ; }'", "label": "'{'"}
{"text": "'@ Deprecated public @ NotNull DoubleAssert isEqualTo ( double expected , Delta delta ) { return isEqualTo ( expected , delta . value ) ; }'", "label": "'Verifies that the actual { @code Double } is equal to the given one within a positive delta .'"}
{"text": "'public @ NotNull DoubleAssert isEqualTo ( double expected , org . fest . assertions . Delta delta ) { return isEqualTo ( expected , delta . doubleValue ( ) ) ; }'", "label": "'Verifies that the actual { @code Double } is equal to the given one within a positive delta .'"}
{"text": "'public @ NotNull DoubleAssert isLessThan ( double other ) { if ( compareTo ( other ) < 0 ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedGreaterThanOrEqualTo ( actual , other ) ) ; }'", "label": "'Verifies that the actual { @code Double } is less than the given one .'"}
{"text": "'public @ NotNull DoubleAssert isGreaterThanOrEqualTo ( double other ) { if ( compareTo ( other ) >= 0 ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedLessThan ( actual , other ) ) ; }'", "label": "'Verifies that the actual { @code Double } is greater or equal to the given one .'"}
{"text": "'public @ NotNull DoubleAssert isLessThanOrEqualTo ( double other ) { if ( compareTo ( other ) <= 0 ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedGreaterThan ( actual , other ) ) ; }'", "label": "'Verifies that the actual { @code Double } is less or equal to the given one .'"}
{"text": "'public @ NotNull LongAssert isGreaterThan ( long other ) { if ( actual > other ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedLessThanOrEqualTo ( actual , other ) ) ; }'", "label": "'Verifies that the actual { @code Long } is greater than the given one .'"}
{"text": "'public @ NotNull LongAssert isLessThan ( long other ) { if ( actual < other ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedGreaterThanOrEqualTo ( actual , other ) ) ; }'", "label": "'Verifies that the actual { @code Long } is less than the given one .'"}
{"text": "'public @ NotNull LongAssert isGreaterThanOrEqualTo ( long other ) { if ( actual >= other ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedLessThan ( actual , other ) ) ; }'", "label": "'Verifies that the actual { @code Long } is greater or equal to the given one .'"}
{"text": "'public @ NotNull LongAssert isLessThanOrEqualTo ( long other ) { if ( actual <= other ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedGreaterThan ( actual , other ) ) ; }'", "label": "'Verifies that the actual { @code Long } is less or equal to the given one .'"}
{"text": "'protected final void assertContains ( @ NotNull Object ... objects ) { isNotNull ( ) ; checkNotNull ( objects ) ; Collection < Object > notFound = notFoundInActual ( objects ) ; if ( notFound . isEmpty ( ) ) { return ; } throw failureIfExpectedElementsNotFound ( notFound ) ; }'", "label": "'Verifies that the actual actual group of objects contains the given objects in any order .'"}
{"text": "'protected final void assertContainsOnly ( @ NotNull Object ... objects ) { isNotNull ( ) ; checkNotNull ( objects ) ; Set < Object > copy = actualAsSet ( ) ; List < Object > notFound = notFoundInCopy ( copy , newLinkedHashSet ( objects ) ) ; if ( ! notFound . isEmpty ( ) ) { throw failureIfExpectedElementsNotFound ( notFound ) ; } if ( copy == null || copy . isEmpty ( ) ) { return ; } throw failureIfUnexpectedElementsFound ( copy ) ; }'", "label": "'Verifies that the actual group of objects contains the given objects <strong > only< / strong > in any order .'"}
{"text": "'protected final void assertExcludes ( @ NotNull Object ... objects ) { isNotNull ( ) ; checkNotNull ( objects ) ; Collection < Object > found = found ( actualAsSet ( ) , objects ) ; if ( found . isEmpty ( ) ) { return ; } failIfCustomMessageIsSet ( ) ; throw failure ( format ( \"<%s> does not exclude element(s):<%s>\" , actual , found ) ) ; }'", "label": "'Verifies that the actual group of objects does not contain the given objects .'"}
{"text": "'protected final void assertDoesNotHaveDuplicates ( ) { isNotNull ( ) ; Collection < ? > duplicates = duplicatesFrom ( actualAsList ( ) ) ; if ( duplicates . isEmpty ( ) ) { return ; } failIfCustomMessageIsSet ( ) ; throw failure ( format ( \"<%s> contains duplicate(s):<%s>\" , actual , duplicates ) ) ; }'", "label": "'Verifies that the actual group of objects does not have duplicates .'"}
{"text": "'public static @ NotNull String format ( @ Nullable Description description , @ NotNull String message ) { checkNotNull ( message ) ; String s = valueOf ( description ) ; return format ( s ) + message ; }'", "label": "'Returns the given message formatted as follows : <pre > [ description ] message . < / pre >'"}
{"text": "'public static @ Nullable String valueOf ( @ Nullable Description description ) { return description == null ? null : description . value ( ) ; }'", "label": "'Returns the value of the given { @link Description } .'"}
{"text": "'public static @ NotNull String format ( @ NotNull String format , @ NotNull Object ... args ) { Object [ ] argsAsText = new String [ args . length ] ; for ( int i = 0 ; i < args . length ; i ++ ) { argsAsText [ i ] = toStringOf ( args [ i ] ) ; } return String . format ( format , argsAsText ) ; }'", "label": "'Returns a formatted string using the specified format { @code String } and arguments .'"}
{"text": "'public static @ NotNull IteratorAssert assertThat ( @ Nullable Iterable < ? > actual ) { Iterator < ? > iterator = actual == null ? null : actual . iterator ( ) ; return assertThat ( iterator ) ; }'", "label": "'Creates a new instance of { @link IteratorAssert } .'"}
{"text": "'public @ NotNull CharAssert isGreaterThan ( char other ) { if ( actual > other ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedLessThanOrEqualTo ( actual , other ) ) ; }'", "label": "'Verifies that the { @code Character } value is greater than the given one .'"}
{"text": "'public @ NotNull CharAssert isLessThan ( char other ) { if ( actual < other ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedGreaterThanOrEqualTo ( actual , other ) ) ; }'", "label": "'Verifies that the { @code Character } value is less than the given one .'"}
{"text": "'public @ NotNull CharAssert isGreaterThanOrEqualTo ( char other ) { if ( actual >= other ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedLessThan ( actual , other ) ) ; }'", "label": "'Verifies that the { @code Character } value is greater or equal to the given one .'"}
{"text": "'public @ NotNull CharAssert isLessThanOrEqualTo ( char other ) { if ( actual <= other ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedGreaterThan ( actual , other ) ) ; }'", "label": "'Verifies that the { @code Character } value is less or equal to the given one .'"}
{"text": "'public @ NotNull CharAssert isUpperCase ( ) { if ( Character . isUpperCase ( actual ) ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( String . format ( \"<%s> should be an upper-case character\" , actual ) ) ; }'", "label": "'Verifies that the { @code Character } value is an upper - case value .'"}
{"text": "'public @ NotNull CharAssert isLowerCase ( ) { if ( Character . isLowerCase ( actual ) ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( String . format ( \"<%s> should be a lower-case character\" , actual ) ) ; }'", "label": "'Verifies that the { @code Character } value is an lower - case value .'"}
{"text": "'protected static void failIfEqual ( @ Nullable String customErrorMessage , @ Nullable Description descriptionOfActual , @ Nullable Object actual , @ Nullable Object other ) { if ( ! areEqual ( actual , other ) ) { return ; } failWithMessage ( customErrorMessage ) ; fail ( format ( descriptionOfActual , unexpectedEqual ( actual , other ) ) ) ; }'", "label": "'Throws an { @code AssertionError } if the given objects are equal .'"}
{"text": "'protected static void failIfNotEqual ( @ Nullable String customErrorMessage , @ Nullable Description descriptionOfActual , @ Nullable Object actual , @ Nullable Object expected ) { if ( areEqual ( actual , expected ) ) { return ; } failWithMessage ( customErrorMessage ) ; throw comparisonFailed ( descriptionOfActual , actual , expected ) ; }'", "label": "'Throws an { @code AssertionError } if actual is not equal to expected . If JUnit 4 ( or greater ) is in the classpath this method will throw a { @code ComparisonFailure } instead . More details about this feature can be found <a href = http : // docs . codehaus . org / display / FEST / JUnit - Specific + Features > here< / a > .'"}
{"text": "'protected static @ NotNull AssertionError comparisonFailed ( @ Nullable Description description , @ Nullable Object actual , @ Nullable Object expected ) { AssertionError comparisonFailure = comparisonFailure ( valueOf ( description ) , expected , actual ) ; if ( comparisonFailure != null ) { return comparisonFailure ; } return failure ( format ( description , unexpectedNotEqual ( actual , expected ) ) ) ; }'", "label": "'Returns a { @code AssertionError } describing a comparison failure .'"}
{"text": "'protected static void failIfActualIsNull ( @ Nullable String customErrorMessage , @ Nullable Description description , @ Nullable Object actual ) { if ( actual != null ) { return ; } failWithMessage ( customErrorMessage ) ; fail ( description , array ( \"expecting actual value not to be null\" ) ) ; }'", "label": "'Throws an { @code AssertionError } if the actual value is { @code null } .'"}
{"text": "'protected static void failIfNull ( @ Nullable String customErrorMessage , @ Nullable Description description , @ Nullable Object o ) { if ( o != null ) { return ; } failWithMessage ( customErrorMessage ) ; fail ( description , array ( \"expecting a non-null object, but it was null\" ) ) ; }'", "label": "'Throws an { @code AssertionError } if the given object is { @code null } .'"}
{"text": "'protected static void failIfNotNull ( @ Nullable String customErrorMessage , @ Nullable Description description , @ Nullable Object o ) { if ( o == null ) { return ; } failWithMessage ( customErrorMessage ) ; fail ( description , array ( inBrackets ( o ) , \" should be null\" ) ) ; }'", "label": "'Throws an { @code AssertionError } if the given object is not { @code null } .'"}
{"text": "'protected static void failIfSame ( @ Nullable String customErrorMessage , @ Nullable Description descriptionOfActual , @ Nullable Object actual , @ Nullable Object other ) { if ( actual != other ) { return ; } failWithMessage ( customErrorMessage ) ; fail ( descriptionOfActual , array ( \"given objects are same:\" , inBrackets ( actual ) ) ) ; }'", "label": "'Throws an { @code AssertionError } if the given objects are the same .'"}
{"text": "'protected static void failWithMessage ( @ Nullable String customErrorMessage , Throwable realCause ) { if ( customErrorMessage != null ) { fail ( customErrorMessage , realCause ) ; } }'", "label": "'Throws an { @code AssertionError } only if the given custom message is not { @code null } .'"}
{"text": "'public static void fail ( String description , @ Nullable Throwable realCause ) { AssertionError error = failure ( description ) ; error . initCause ( realCause ) ; throw error ; }'", "label": "'Throws an { @code AssertionError } with the given message and with the { @code Throwable } that caused the failure .'"}
{"text": "'public @ NotNull ObjectAssert isInstanceOf ( @ NotNull Class < ? > type ) { isNotNull ( ) ; checkNotNull ( type ) ; Class < ? > current = actual . getClass ( ) ; if ( type . isAssignableFrom ( current ) ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( format ( \"expected instance of:<%s> but was instance of:<%s>\" , type , current ) ) ; }'", "label": "'Verifies that the actual { @code Object } is an instance of the given type .'"}
{"text": "'public @ NotNull ObjectAssert isInstanceOfAny ( @ NotNull Class < ? > ... types ) { isNotNull ( ) ; checkNotNull ( types ) ; if ( ! foundInstanceOfAny ( types ) ) { String format = \"expected instance of any:<%s> but was instance of:<%s>\" ; fail ( String . format ( format , typeNames ( types ) , actual . getClass ( ) . getName ( ) ) ) ; } return this ; }'", "label": "'Verifies that the actual { @code Object } is an instance of any of the given types .'"}
{"text": "'public @ NotNull ThrowableAssert isInstanceOf ( @ NotNull Class < ? extends Throwable > type ) { objectAssert . isInstanceOf ( type ) ; return this ; }'", "label": "'Verifies that the actual { @code Throwable } is an instance of the given type .'"}
{"text": "'public @ NotNull ThrowableAssert isExactlyInstanceOf ( @ NotNull Class < ? > type ) { isNotNull ( ) ; checkNotNull ( type ) ; Class < ? > current = actual . getClass ( ) ; if ( type . equals ( current ) ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( format ( \"expected exactly the same type:<%s> but was:<%s>\" , type , current ) ) ; }'", "label": "'Verifies that the actual { @code Throwable } is an instance of the given type . In order for the assertion to pass the type of the actual { @code Throwable } has to be exactly the same as the given type .'"}
{"text": "'public @ NotNull ThrowableAssert hasMessage ( @ Nullable String message ) { isNotNull ( ) ; failIfNotEqual ( customErrorMessage ( ) , rawDescription ( ) , actual . getMessage ( ) , message ) ; return this ; }'", "label": "'Verifies that the message of the actual { @code Throwable } is equal to the given one .'"}
{"text": "'public @ NotNull ThrowableAssert hasNoCause ( ) { isNotNull ( ) ; Throwable actualCause = actual . getCause ( ) ; if ( actualCause == null ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( format ( \"expected exception without cause, but cause was:<%s>\" , actualCause . getClass ( ) ) ) ; }'", "label": "'Verifies that the actual { @code Throwable } does not have a cause .'"}
