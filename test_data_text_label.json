{"text": "'@ Override public @ NotNull ThrowableAssert as ( @ Nullable String description ) { objectAssert . as ( description ) ; return super . as ( description ) ; }'", "label": "'{'"}
{"text": "'@ Override public @ NotNull ThrowableAssert as ( @ Nullable Description description ) { objectAssert . as ( description ) ; return super . as ( description ) ; }'", "label": "'{'"}
{"text": "'@ Override public @ NotNull ThrowableAssert overridingErrorMessage ( @ Nullable String message ) { objectAssert . overridingErrorMessage ( message ) ; return super . overridingErrorMessage ( message ) ; }'", "label": "'{'"}
{"text": "'public static @ NotNull Entry entry ( @ Nullable Object key , @ Nullable Object value ) { return new Entry ( key , value ) ; }'", "label": "'Creates a new map entry .'"}
{"text": "'public @ NotNull MapAssert includes ( @ NotNull Entry ... entries ) { isNotNull ( ) ; checkNotNull ( entries ) ; List < Entry > notFound = newArrayList ( ) ; for ( Entry e : entries ) { if ( ! containsEntry ( checkNotNull ( e ) ) ) { notFound . add ( e ) ; } } if ( ! notFound . isEmpty ( ) ) { failIfNotFound ( entryOrEntries ( notFound ) , notFound ) ; } return this ; }'", "label": "'Verifies that the actual { @code Map } contains the given entries . <p / > Example : <pre > // static import org . fest . assertions . Assertions . * ; // static import org . fest . assertions . MapAssert . * ;'"}
{"text": "'public @ NotNull MapAssert excludes ( @ NotNull Entry ... entries ) { isNotNull ( ) ; checkNotNull ( entries ) ; List < Entry > found = newArrayList ( ) ; for ( Entry e : entries ) { if ( containsEntry ( checkNotNull ( e ) ) ) { found . add ( e ) ; } } if ( ! found . isEmpty ( ) ) { failIfFound ( entryOrEntries ( found ) , found ) ; } return this ; }'", "label": "'Verifies that the actual { @code Map } does not contain the given entries . <p / > Example : <pre > // static import org . fest . assertions . Assertions . * ; // static import org . fest . assertions . MapAssert . * ;'"}
{"text": "'public @ NotNull ShortAssert isGreaterThan ( short other ) { if ( actual > other ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedLessThanOrEqualTo ( actual , other ) ) ; }'", "label": "'Verifies that the actual { @code Short } is greater than the given one .'"}
{"text": "'public @ NotNull ShortAssert isLessThan ( short other ) { if ( actual < other ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedGreaterThanOrEqualTo ( actual , other ) ) ; }'", "label": "'Verifies that the actual { @code Short } is less than the given one .'"}
{"text": "'public @ NotNull ShortAssert isGreaterThanOrEqualTo ( short other ) { if ( actual >= other ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedLessThan ( actual , other ) ) ; }'", "label": "'Verifies that the actual { @code Short } is greater or equal to the given one .'"}
{"text": "'public @ NotNull ShortAssert isLessThanOrEqualTo ( short other ) { if ( actual <= other ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedGreaterThan ( actual , other ) ) ; }'", "label": "'Verifies that the actual { @code Short } is less or equal to the given one .'"}
{"text": "'public final @ NotNull S satisfies ( @ NotNull Condition < A > condition ) { if ( matches ( condition ) ) { return myself ( ) ; } failIfCustomMessageIsSet ( ) ; throw failure ( errorMessageIfConditionNotSatisfied ( condition ) ) ; }'", "label": "'Verifies that the actual value satisfies the given condition .'"}
{"text": "'public final @ NotNull S doesNotSatisfy ( @ NotNull Condition < A > condition ) { if ( ! matches ( condition ) ) { return myself ( ) ; } failIfCustomMessageIsSet ( ) ; throw failure ( errorMessageIfConditionSatisfied ( condition ) ) ; }'", "label": "'Verifies that the actual value does not satisfy the given condition .'"}
{"text": "'public final @ NotNull S is ( @ NotNull Condition < A > condition ) { if ( matches ( condition ) ) { return myself ( ) ; } failIfCustomMessageIsSet ( ) ; throw failure ( errorMessageIfIsNot ( condition ) ) ; }'", "label": "'Alias for { @link #satisfies ( Condition ) } .'"}
{"text": "'public final @ NotNull S isNot ( @ NotNull Condition < A > condition ) { if ( ! matches ( condition ) ) { return myself ( ) ; } failIfCustomMessageIsSet ( ) ; throw failure ( errorMessageIfIs ( condition ) ) ; }'", "label": "'Alias for { @link #doesNotSatisfy ( Condition ) } .'"}
{"text": "'public @ NotNull S isEqualTo ( @ Nullable A expected ) { failIfNotEqual ( customErrorMessage ( ) , rawDescription ( ) , actual , expected ) ; return myself ( ) ; }'", "label": "'Verifies that the actual value is equal to the given one .'"}
{"text": "'public @ NotNull S isNotEqualTo ( @ Nullable A other ) { failIfEqual ( customErrorMessage ( ) , rawDescription ( ) , actual , other ) ; return myself ( ) ; }'", "label": "'Verifies that the actual value is not equal to the given one .'"}
{"text": "'public final @ NotNull S isSameAs ( @ Nullable A expected ) { failIfNotSame ( customErrorMessage ( ) , rawDescription ( ) , actual , expected ) ; return myself ( ) ; }'", "label": "'Verifies that the actual value is the same as the given one .'"}
{"text": "'public final @ NotNull S isNotSameAs ( @ Nullable A other ) { failIfSame ( customErrorMessage ( ) , rawDescription ( ) , actual , other ) ; return myself ( ) ; }'", "label": "'Verifies that the actual value is not the same as the given one .'"}
{"text": "'public final @ NotNull S isIn ( @ NotNull Collection < ? > values ) { checkNotNull ( values ) ; if ( isActualIn ( values ) ) { return myself ( ) ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedNotIn ( actual , values ) ) ; }'", "label": "'Verifies that the actual value is in the given collection .'"}
{"text": "'public final @ NotNull S isNotIn ( @ NotNull Collection < ? > values ) { checkNotNull ( values ) ; if ( ! isActualIn ( values ) ) { return myself ( ) ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedIn ( actual , values ) ) ; }'", "label": "'Verifies that the actual value is in the given collection .'"}
{"text": "'public @ NotNull DoubleArrayAssert isEqualTo ( @ Nullable double [ ] expected , @ NotNull Delta delta ) { checkNotNull ( delta ) ; if ( actual == expected ) { return this ; } if ( actual == null || expected == null ) { throw failureWhenNotEqual ( expected , delta ) ; } int length = expected . length ; if ( actual . length != length ) { failureWhenNotEqual ( expected , delta ) ; } for ( int i = 0 ; i < length ; i ++ ) { if ( ! equals ( expected [ i ] , actual [ i ] , delta ) ) { failureWhenNotEqual ( expected , delta ) ; } } return this ; }'", "label": "'Verifies that the actual { @code double } array is equal to the given array within a positive delta .'"}
{"text": "'@ Override public @ NotNull DoubleArrayAssert isNotEqualTo ( @ Nullable double [ ] array ) { if ( ! Arrays . equals ( actual , array ) ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedEqual ( actual , array ) ) ; }'", "label": "'Verifies that the actual { @code double } array is not equal to the given array . Array equality is checked by { @link Arrays#equals ( double [] double [] ) } .'"}
{"text": "'public @ NotNull ObjectArrayAssert hasAllElementsOfType ( @ NotNull Class < ? > type ) { checkNotNull ( type ) ; isNotNull ( ) ; for ( Object o : actual ) { if ( type . isInstance ( o ) ) { continue ; } failIfCustomMessageIsSet ( ) ; fail ( format ( \"not all elements in array:<%s> belong to the type:<%s>\" , actual , type ) ) ; } return this ; }'", "label": "'Verifies that all the elements in the actual { @code Object } array belong to the specified type . Matching includes subclasses of the given type . <p / > For example consider the following code listing : <pre > Number [] numbers = { 2 6 8 } ; assertThat ( numbers ) . hasAllElementsOfType ( Integer . class ) ; < / pre > <p / > The assertion { @code hasAllElementsOfType } will be successful .'"}
{"text": "'public @ NotNull ObjectArrayAssert hasAtLeastOneElementOfType ( @ NotNull Class < ? > type ) { checkNotNull ( type ) ; isNotNull ( ) ; boolean found = false ; for ( Object o : actual ) { if ( ! type . isInstance ( o ) ) { continue ; } found = true ; break ; } if ( found ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( format ( \"array:<%s> does not have any elements of type:<%s>\" , actual , type ) ) ; }'", "label": "'Verifies that at least one element in the actual { @code Object } array belong to the specified type . Matching includes subclasses of the given type .'"}
{"text": "'@ Override public @ NotNull ObjectArrayAssert isEqualTo ( @ Nullable Object [ ] expected ) { if ( Arrays . deepEquals ( actual , expected ) ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedNotEqual ( actual , expected ) ) ; }'", "label": "'Verifies that the actual { @code Object } array is equal to the given array . Array equality is checked by { @link Arrays#deepEquals ( Object [] Object [] ) } .'"}
{"text": "'@ Override public @ NotNull ObjectArrayAssert isNotEqualTo ( @ Nullable Object [ ] array ) { if ( ! Arrays . deepEquals ( actual , array ) ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedEqual ( actual , array ) ) ; }'", "label": "'Verifies that the actual { @code Object } array is not equal to the given array . Array equality is checked by { @link Arrays#deepEquals ( Object [] Object [] ) } .'"}
{"text": "'@ Override public @ NotNull ObjectArrayAssert onProperty ( @ NotNull String propertyName ) { isNotNull ( ) ; if ( actual . length == 0 ) { return new ObjectArrayAssert ( new Object [ 0 ] ) ; } List < Object > values = PropertySupport . instance ( ) . propertyValues ( propertyName , newArrayList ( actual ) ) ; return new ObjectArrayAssert ( values . toArray ( ) ) ; }'", "label": "'Creates a new instance of { @link ObjectArrayAssert } whose target array contains the values of the given property name from the elements of this { @code ObjectArrayAssert } s array . Property access works with both simple properties like { @code Person . age } and nested properties { @code Person . father . age } . <p / > For example let s say we have a array of { @code Person } objects and you want to verify their age : <pre > assertThat ( persons ) . onProperty ( &quot ; age&quot ; ) . containsOnly ( 25 16 44 37 ) ; // simple property assertThat ( persons ) . onProperty ( father . age ) . containsOnly ( 55 46 74 62 ) ; // nested property'"}
{"text": "'protected final void description ( @ Nullable String d ) { description ( d == null ? null : new BasicDescription ( d ) ) ; }'", "label": "'Sets the description of the actual value to be used in as message of any { @code AssertionError } thrown when an assertion fails .'"}
{"text": "'protected final void fail ( @ NotNull String reason , @ Nullable Throwable cause ) { Fail . fail ( formattedErrorMessage ( reason ) , cause ) ; }'", "label": "'Fails by throwing an { @code AssertionError } .'"}
{"text": "'protected final @ NotNull AssertionError failure ( @ NotNull String reason ) { return Fail . failure ( formattedErrorMessage ( reason ) ) ; }'", "label": "'Creates an { @code AssertionError } adding the description of the actual value to the given message .'"}
{"text": "'public @ NotNull ByteAssert isGreaterThan ( byte other ) { // TODO check for NPE if ( actual > other ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedLessThanOrEqualTo ( actual , other ) ) ; }'", "label": "'Verifies that the actual { @code Byte } value is greater than the given one .'"}
{"text": "'public @ NotNull ByteAssert isLessThan ( byte other ) { if ( actual < other ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedGreaterThanOrEqualTo ( actual , other ) ) ; }'", "label": "'Verifies that the actual { @code Byte } value is less than the given one .'"}
{"text": "'public @ NotNull ByteAssert isGreaterThanOrEqualTo ( byte other ) { if ( actual >= other ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedLessThan ( actual , other ) ) ; }'", "label": "'Verifies that the actual { @code Byte } value is greater or equal to the given one .'"}
{"text": "'public @ NotNull ByteAssert isLessThanOrEqualTo ( byte other ) { if ( actual <= other ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedGreaterThan ( actual , other ) ) ; }'", "label": "'Verifies that the actual { @code Byte } value is less or equal to the given one .'"}
{"text": "'@ Override public @ NotNull CollectionAssert onProperty ( @ NotNull String propertyName ) { isNotNull ( ) ; checkNotNull ( propertyName ) ; if ( actual . isEmpty ( ) ) { return new CollectionAssert ( emptyList ( ) ) ; } return new CollectionAssert ( PropertySupport . instance ( ) . propertyValues ( propertyName , actual ) ) ; }'", "label": "'Creates a new instance of { @link CollectionAssert } whose target collection contains the values of the given property name from the elements of this { @code CollectionAssert } s collection . Property access works with both simple properties like { @code Person . age } and nested properties { @code Person . father . age } . <p / > For example let s say we have a collection of { @code Person } objects and you want to verify their age : <pre > assertThat ( persons ) . onProperty ( &quot ; age&quot ; ) . containsOnly ( 25 16 44 37 ) ; // simple property assertThat ( persons ) . onProperty ( father . age ) . containsOnly ( 55 46 74 62 ) ; // nested property < / pre >'"}
{"text": "'@ Override public @ NotNull IntArrayAssert isEqualTo ( @ Nullable int [ ] expected ) { if ( Arrays . equals ( actual , expected ) ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedNotEqual ( actual , expected ) ) ; }'", "label": "'Verifies that the actual { @code int } array is equal to the given array . Array equality is checked by { @link Arrays#equals ( int [] int [] ) } .'"}
{"text": "'public @ NotNull StringAssert isEqualToIgnoringCase ( String expected ) { if ( actual == null && expected == null ) { return this ; } isNotNull ( ) ; if ( actual . equalsIgnoreCase ( expected ) ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( format ( \"<%s> should be equal to :<%s> ignoring case\" , actual , expected ) ) ; }'", "label": "'Verifies that the actual { @code String } is equal to the given one ignoring case .'"}
{"text": "'public @ NotNull StringAssert contains ( String expected ) { isNotNull ( ) ; if ( actual . indexOf ( expected ) != - 1 ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( format ( \"<%s> should contain the String:<%s>\" , actual , expected ) ) ; }'", "label": "'Verifies that the actual { @code String } contains the given one .'"}
{"text": "'public @ NotNull StringAssert endsWith ( String expected ) { isNotNull ( ) ; if ( actual . endsWith ( expected ) ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( format ( \"<%s> should end with:<%s>\" , actual , expected ) ) ; }'", "label": "'Verifies that the actual { @code String } ends with the given one .'"}
{"text": "'public @ NotNull StringAssert excludes ( String s ) { isNotNull ( ) ; if ( actual . indexOf ( s ) == - 1 ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( format ( \"<%s> should not contain the String:<%s>\" , actual , s ) ) ; }'", "label": "'Verifies that the actual { @code String } does not contains the given one .'"}
{"text": "'public @ NotNull StringAssert doesNotMatch ( String regex ) { isNotNull ( ) ; if ( ! actual . matches ( regex ) ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( format ( \"<%s> should not match the regular expression:<%s>\" , actual , regex ) ) ; }'", "label": "'Verifies that the actual { @code String } does not match the given one .'"}
{"text": "'public @ NotNull StringAssert containsIgnoringCase ( @ NotNull String text ) { checkNotNull ( text ) ; isNotNull ( ) ; if ( actual . toLowerCase ( ) . contains ( text . toLowerCase ( ) ) ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( format ( \"<%s> does not contain <%s>\" , actual , text ) ) ; }'", "label": "'Verifies that the actual { @code String } contains the given text regardless of the case .'"}
{"text": "'public @ NotNull StringAssert doesNotContain ( @ NotNull String text ) { checkNotNull ( text ) ; isNotNull ( ) ; if ( ! actual . contains ( text ) ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( format ( \"<%s> should not contain <%s>\" , actual , text ) ) ; }'", "label": "'Verifies that the actual { @code String } does not contain the given text .'"}
{"text": "'@ Deprecated public @ NotNull FloatAssert isEqualTo ( float expected , @ NotNull Delta delta ) { return isEqualTo ( expected , delta . value ) ; }'", "label": "'Verifies that the actual { @code Float } is equal to the given one within a positive delta .'"}
{"text": "'public @ NotNull FloatAssert isEqualTo ( float expected , @ NotNull org . fest . assertions . Delta delta ) { return isEqualTo ( expected , delta . floatValue ( ) ) ; }'", "label": "'Verifies that the actual { @code Float } is equal to the given one within a positive delta .'"}
{"text": "'public @ NotNull FloatAssert isNotEqualTo ( float other ) { if ( compareTo ( other ) != 0 ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedEqual ( actual , other ) ) ; }'", "label": "'Verifies that the actual { @code Float } is not equal to the given one .'"}
{"text": "'public @ NotNull FloatAssert isGreaterThan ( float other ) { if ( compareTo ( other ) > 0 ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedLessThanOrEqualTo ( actual , other ) ) ; }'", "label": "'Verifies that the actual { @code Float } is greater than the given one .'"}
{"text": "'public static @ NotNull Object [ ] copy ( @ NotNull Object array ) { return copyToList ( checkNotNull ( array ) ) . toArray ( ) ; }'", "label": "'Copies the contents of the given array into an array of objects .'"}
{"text": "'public static @ NotNull List < Object > copyToList ( @ NotNull Object array ) { return copy ( checkNotNull ( array ) , newArrayList ( ) ) ; }'", "label": "'Copies the contents of the given array into a list .'"}
{"text": "'public static @ NotNull Set < Object > copyToSet ( @ NotNull Object array ) { return copy ( checkNotNull ( array ) , newLinkedHashSet ( ) ) ; }'", "label": "'Copies the contents of the given array into a list .'"}
{"text": "'public static int sizeOf ( @ NotNull Object array ) { checkNotNull ( array ) ; validateIsArray ( array ) ; return getLength ( array ) ; }'", "label": "'Returns the size of the given array .'"}
{"text": "'public @ NotNull IntAssert isGreaterThan ( int other ) { if ( actual > other ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedLessThanOrEqualTo ( actual , other ) ) ; }'", "label": "'Verifies that the actual { @code Integer } is greater than the given one .'"}
{"text": "'public @ NotNull IntAssert isLessThan ( int other ) { if ( actual < other ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedGreaterThanOrEqualTo ( actual , other ) ) ; }'", "label": "'Verifies that the actual { @code Integer } is less than the given one .'"}
{"text": "'public @ NotNull IntAssert isGreaterThanOrEqualTo ( int other ) { if ( actual >= other ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedLessThan ( actual , other ) ) ; }'", "label": "'Verifies that the actual { @code Integer } is greater or equal to the given one .'"}
{"text": "'public @ NotNull IntAssert isLessThanOrEqualTo ( int other ) { if ( actual <= other ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( unexpectedGreaterThan ( actual , other ) ) ; }'", "label": "'Verifies that the actual { @code Integer } is less or equal to the given one .'"}
{"text": "'public View getDropDownView ( int index , View convertView , ViewGroup parent ) { return dropDownViewFactory . getView ( convertView , itemList . get ( index ) ) ; }'", "label": "'Declared by SpinnerAdapter this method allows your spinner to show different views in your drop down vs the closed spinned box .'"}
{"text": "'@ Override public final T [ ] terms ( ) { checkStatus ( Status . INITIALIZED ) ; @ SuppressWarnings ( \"unchecked\" ) T [ ] array = ( T [ ] ) Array . newInstance ( this . termClass , this . ordinal ) ; return this . terms . values ( ) . toArray ( array ) ; }'", "label": "'{'"}
{"text": "'@ Override public final T fromName ( String name ) { checkStatus ( Status . INITIALIZED ) ; requireNonNull ( name , \"Term name cannot be null\" ) ; Integer termOrdinal = this . nameOrdinal . get ( name ) ; if ( termOrdinal != null ) { return this . terms . get ( termOrdinal ) ; } return null ; }'", "label": "'{'"}
{"text": "'@ Override public T fromOrdinal ( int ordinal ) { checkStatus ( Status . INITIALIZED ) ; if ( ordinal < 0 || this . ordinal < ordinal ) { throw new IndexOutOfBoundsException ( \"No term available with ordinal \\'\" + ordinal + \"\\'\" ) ; } return this . terms . get ( ordinal ) ; }'", "label": "'{'"}
{"text": "'@ Override public final < V > T fromValue ( V value ) { checkStatus ( Status . INITIALIZED ) ; try { @ SuppressWarnings ( \"unchecked\" ) TypeAdapter < T , V > adapter = ( TypeAdapter < T , V > ) TypeAdapter . createAdapter ( this . termClass , value . getClass ( ) ) ; for ( T candidate : this . terms . values ( ) ) { if ( value . equals ( adapter . adapt ( candidate ) ) ) { return candidate ; } } return null ; } catch ( CannotAdaptClassesException e ) { throw new UnsupportedOperationException ( \"Class \\'\" + this . termClass . getCanonicalName ( ) + \" cannot be transformed to \\'\" + value . getClass ( ) . getCanonicalName ( ) + \"\\'\" , e ) ; } }'", "label": "'{'"}
{"text": "'@ Override public final Iterator < Term > iterator ( ) { checkStatus ( Status . INITIALIZED ) ; final Iterator < ? extends Term > iterator = this . terms . values ( ) . iterator ( ) ; return new Iterator < Term > ( ) { @ Override public boolean hasNext ( ) { return iterator . hasNext ( ) ; } @ Override public Term next ( ) { return iterator . next ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( \"Removal not supported\" ) ; } } ; }'", "label": "'{'"}
{"text": "'protected final int reserveTermName ( String name ) { checkStatus ( Status . INITIALIZING ) ; checkInitializationPrecondition ( TermUtils . isValidTermName ( name ) , \"Object \\'%s\\' is not a valid term name\" , name ) ; checkInitializationPrecondition ( ! this . nameOrdinal . containsKey ( name ) , \"Term \\'%s\\' has been already reserved\" , name ) ; this . nameOrdinal . put ( name , ++ this . ordinal ) ; return this . ordinal ; }'", "label": "'Allow the reservation of term names during the initialization of the vocabulary .'"}
{"text": "'protected final < S extends ImmutableTerm > void registerTerm ( S term ) { checkStatus ( Status . INITIALIZING ) ; checkInitializationPrecondition ( this . nameOrdinal . containsKey ( term . name ( ) ) , \"Term \\'%s\\' has not been reserved\" , term . name ( ) ) ; checkInitializationPrecondition ( term . ordinal ( ) >= 0 && term . ordinal ( ) <= this . ordinal , \"Invalid ordinal \\'%d\\' for reserved name \\'%s\\'\" , term . ordinal ( ) , term . name ( ) ) ; this . terms . put ( term . ordinal ( ) , this . termClass . cast ( term ) ) ; }'", "label": "'Upon reservation the method enables registering the properly built immutable term instance .'"}
{"text": "'protected final void initialize ( ) { checkStatus ( Status . INITIALIZING ) ; if ( this . terms . size ( ) != this . nameOrdinal . size ( ) ) { throw new IllegalStateException ( String . format ( \"Vocabulary \\'%s\\' (%s) initialization failure: not all reserved names have been registered\" , this . namespace , getClass ( ) . getName ( ) ) ) ; } this . status = Status . INITIALIZED ; }'", "label": "'Complete the initialization of the vocabulary . Beyond this point the vocabulary can be put to use .'"}
{"text": "'@ Override public Attachment findAttachment ( ResourceId resourceId ) { checkNotNull ( resourceId , \"Attached resource identifier cannot be null\" ) ; return this . attachmentCollection . attachmendByResourceId ( resourceId ) ; }'", "label": "'{'"}
{"text": "'@ Override public Resource attach ( String attachmentId , ResourceId resourceId ) { return attach ( attachmentId , resourceId , Resource . class ) ; }'", "label": "'{'"}
{"text": "'@ Override public < T extends Resource > T attach ( String attachmentId , ResourceId resourceId , Class < ? extends T > clazz ) { checkNotNull ( attachmentId , \"Attachment identifier cannot be null\" ) ; checkNotNull ( resourceId , \"Attached resource identifier cannot be null\" ) ; checkNotNull ( clazz , \"Attached resource class cannot be null\" ) ; this . attachmentCollection . checkNotAttached ( attachmentId , resourceId ) ; ResourceTemplate attachmentTemplate = super . getTemplate ( resourceId ) ; checkState ( Resources . areCompatible ( clazz , attachmentTemplate ) , \"Attachment \\'%s\\' is not of type \\'%s\\' (%s)\" , attachmentId , clazz . getCanonicalName ( ) , attachmentTemplate . getClass ( ) . getCanonicalName ( ) ) ; JPAResource newResource = createChild ( resourceId , attachmentTemplate ) ; JPAAttachment newAttachment = this . attachmentCollection . attachmentById ( attachmentId ) ; newAttachment . bind ( resourceId ) ; return clazz . cast ( newResource ) ; }'", "label": "'{'"}
{"text": "'@ Override public ConstraintReport addConstraintReport ( Constraints constraints , Date date , HttpRequest request ) { ConstraintReportId reportId = nextConstraintReportId ( ) ; return new JPAConstraintReport ( reportId , date , request , constraints ) ; }'", "label": "'{'"}
{"text": "'@ Override public Set < ConstraintReportId > constraintReports ( ) { Set < String > currentFailures = null ; synchronized ( this ) { currentFailures = ImmutableSet . copyOf ( this . failures ) ; } Builder < ConstraintReportId > builder = ImmutableSet . builder ( ) ; for ( String failure : currentFailures ) { builder . add ( ConstraintReportId . create ( this . id , failure ) ) ; } return builder . build ( ) ; }'", "label": "'{'"}
{"text": "'@ Override public void modify ( EntityTag newEntityTag , Date newLastModified ) { checkState ( this . deleted == null , \"Endpoint is already deleted\" ) ; this . entityTag = newEntityTag ; this . lastModified = new Date ( newLastModified . getTime ( ) ) ; }'", "label": "'{'"}
{"text": "'@ Override public void delete ( Date deleted ) { checkState ( this . deleted == null , \"Endpoint is already deleted\" ) ; this . deleted = deleted ; this . resourceId = null ; }'", "label": "'{'"}
{"text": "'private void registerConstraintReport ( Resource resource , InvalidContentException error ) { ConstraintReport report = resource . addConstraintReport ( error . getConstraints ( ) , new Date ( ) , currentRequest ( ) ) ; this . constraintReportRepository . add ( report ) ; LOGGER . debug ( \"Constraint validation failed. Registered constraint report {}\" , report . id ( ) ) ; error . setConstraintsId ( report . id ( ) . failureId ( ) ) ; }'", "label": "'TODO : How do we do this transactionally'"}
{"text": "'private Date lastModified ( ) { Date clientDate = currentRequest ( ) . clientDate ( ) ; Date lastModified = new Date ( ) ; if ( clientDate != null && clientDate . after ( lastModified ) ) { lastModified = clientDate ; } return lastModified ; }'", "label": "'Enforce http : // tools . ietf . org / html / rfc7232#section - 2 . 2 : if the clock in the request is ahead of the clock of the origin server ( e . g . I request from Spain the update of a resource held in USA ) the last - modified data should be changed to that of the request and not a generated date from the origin server'"}
{"text": "'@ Override public ApplicationContextOperation createOperation ( HttpRequest request ) { checkNotNull ( request , \"Http request cannot be null\" ) ; DefaultApplicationOperation operation = this . currentOperation . get ( ) ; checkState ( operation == null , \"An operation is ongoing on the current thread\" ) ; operation = new DefaultApplicationOperation ( request ) ; this . currentOperation . set ( operation ) ; return operation ; }'", "label": "'{'"}
{"text": "'@ Override public void registerApplicationLifecycleListener ( ApplicationLifecycleListener listener ) { checkNotNull ( listener , APPLICATION_LIFECYCLE_LISTENER_CANNOT_BE_NULL ) ; this . engine ( ) . applicationLifecycleService ( ) . registerApplicationLifecycleListener ( listener ) ; }'", "label": "'{'"}
{"text": "'@ Override public void deregisterApplicationLifecycleListener ( ApplicationLifecycleListener listener ) { checkNotNull ( listener , APPLICATION_LIFECYCLE_LISTENER_CANNOT_BE_NULL ) ; this . engine ( ) . applicationLifecycleService ( ) . deregisterApplicationLifecycleListener ( listener ) ; }'", "label": "'{'"}
{"text": "'@ Override public E fromString ( final String rawValue ) { try { return Enum . valueOf ( this . targetClass , rawValue ) ; } catch ( Exception e ) { throw new ObjectParseException ( e , targetClass ( ) , rawValue ) ; } }'", "label": "'{'"}
{"text": "'@ Override public void delete ( ResourceSnapshot resource , WriteSession session ) throws UnknownResourceException { DataSet dataSet = get ( resource ) ; try { logDebug ( resource , \"Deleting state:%n%s\" , dataSet ) ; remove ( resource . name ( ) ) ; session . delete ( resource ) ; session . saveChanges ( ) ; } catch ( WriteSessionException e ) { // Recover if failed add ( resource . name ( ) , dataSet ) ; throw new ApplicationRuntimeException ( \"Deletion failed\" , e ) ; } }'", "label": "'{ @inheritDoc } <br >'"}
{"text": "'@ Override public void update ( ResourceSnapshot resource , DataSet content , WriteSession session ) throws InconsistentContentException , UnknownResourceException { DataSet dataSet = get ( resource ) ; logDebug ( resource , \"Enforcing consistency...\" ) ; enforceConsistency ( resource , content , dataSet ) ; try { logDebug ( resource , \"Persisting new state:%n%s\" , content ) ; add ( resource . name ( ) , content ) ; session . modify ( resource ) ; session . saveChanges ( ) ; } catch ( Exception e ) { // Recover if failed add ( resource . name ( ) , dataSet ) ; logError ( resource , e , \"Something went wrong\" , e ) ; throw new ApplicationRuntimeException ( \"Update failed\" , e ) ; } }'", "label": "'{ @inheritDoc } <br >'"}
{"text": "'public DataSet getRepresentation ( ) { return DataDSL . dataSet ( ) . individual ( newReference ( ) . toLocalIndividual ( ) . named ( \"anonymous\" ) ) . hasLink ( KNOWS ) . referringTo ( newReference ( ) . toManagedIndividual ( \"unknownTemplate1\" ) . named ( \"r1\" ) ) . individual ( newReference ( ) . toLocalIndividual ( ) . named ( \"anonymous\" ) ) . hasProperty ( CREATED_ON ) . withValue ( new Date ( ) ) . hasLink ( KNOWS ) . referringTo ( newReference ( ) . toManagedIndividual ( \"unknownTemplate2\" ) . named ( \"r1\" ) ) . individual ( newReference ( ) . toManagedIndividual ( \"unknownTemplate2\" ) . named ( \"r1\" ) ) . hasProperty ( CREATION_DATE ) . withValue ( new Date ( ) ) . hasProperty ( AGE ) . withValue ( 34 ) . hasLink ( HAS_FATHER ) . toIndividual ( newReference ( ) . toLocalIndividual ( ) . named ( \"Michel\" ) ) . hasLink ( HAS_WIFE ) . referringTo ( newReference ( ) . toLocalIndividual ( ) . named ( \"Consuelo\" ) ) . build ( ) ; }'", "label": "'Get custom representation with bad data'"}
{"text": "'private static RuntimeDelegate findDelegate ( ) { try { RuntimeDelegate result = createRuntimeDelegateFromSPI ( ) ; if ( result == null ) { result = createRuntimeDelegateFromConfigurationFile ( ) ; } if ( result == null ) { String delegateClassName = System . getProperty ( LDP4J_SERVER_DATA_SPI_PROPERTY ) ; if ( delegateClassName != null ) { result = createRuntimeDelegateForClassName ( delegateClassName ) ; } } if ( result == null ) { result = new DefaultRuntimeInstance ( ) ; } return result ; } catch ( Exception ex ) { throw new IllegalStateException ( \"Could not find runtime delegate\" , ex ) ; } }'", "label": "'Obtain a { @code RuntimeInstance } instance using the method described in { @link #getInstance } .'"}
{"text": "'public static RuntimeDelegate getInstance ( ) { RuntimeDelegate result = RuntimeDelegate . CACHED_DELEGATE . get ( ) ; if ( result != null ) { return result ; } synchronized ( RuntimeDelegate . CACHED_DELEGATE ) { result = RuntimeDelegate . CACHED_DELEGATE . get ( ) ; if ( result == null ) { RuntimeDelegate . CACHED_DELEGATE . set ( findDelegate ( ) ) ; result = RuntimeDelegate . CACHED_DELEGATE . get ( ) ; } return result ; } }'", "label": "'Obtain a { @code RuntimeDelegate } instance . If an instance had not already been created and set via { @link #setInstance ( RuntimeDelegate ) } the first invocation will create an instance which will then be cached for future use .'"}
{"text": "'public static void setInstance ( final RuntimeDelegate delegate ) { SecurityManager security = System . getSecurityManager ( ) ; if ( security != null ) { security . checkPermission ( suppressAccessChecksPermission ) ; } RuntimeDelegate . CACHED_DELEGATE . set ( delegate ) ; }'", "label": "'Set the runtime delegate that will be used by Data API classe . If this method is not called prior to { @link #getInstance } then an implementation will be sought as described in { @link #getInstance } .'"}
{"text": "'private static URIRef relativeResolution ( URI target , URI base ) { URIRef Base = URIRef . create ( base ) ; // NOSONAR URIRef R = URIRef . create ( target ) ; // NOSONAR URIRef T = URIRef . create ( ) ; // NOSONAR if ( defined ( R . scheme ) ) { T . scheme = R . scheme ; T . authority = R . authority ; T . path = removeDotSegments ( R . path ) ; T . query = R . query ; } else { if ( defined ( R . authority ) ) { T . authority = R . authority ; T . path = removeDotSegments ( R . path ) ; T . query = R . query ; } else { resolvePathOnlyTarget ( Base , R , T ) ; } T . scheme = Base . scheme ; } T . fragment = R . fragment ; return T ; }'", "label": "'5 . 2 . Relative Resolution'"}
{"text": "\"private static String merge ( String path , String relativePath , boolean hasAuthority ) { String parent = path ; if ( hasAuthority && parent . isEmpty ( ) ) { parent = SLASH ; } return parent . substring ( 0 , parent . lastIndexOf ( ' ' ) + 1 ) . concat ( relativePath ) ; }\"", "label": "'5 . 2 . 3 . Merge Paths'"}
{"text": "'private static String removeDotSegments ( String path ) { Deque < String > outputBuffer = new LinkedList < String > ( ) ; String input = path == null ? EMPTY : path ; while ( ! input . isEmpty ( ) ) { input = processInput ( outputBuffer , input ) ; } return assembleInOrder ( outputBuffer ) ; }'", "label": "'5 . 2 . 4 . Remove Dot Segments'"}
{"text": "'@ Override public < T extends Resource > T resourceById ( ResourceId id , Class < ? extends T > expectedResourceClass ) { checkNotNull ( expectedResourceClass , \"Expected resource class cannot be null\" ) ; Resource found = find ( id ) ; if ( expectedResourceClass . isInstance ( found ) ) { return expectedResourceClass . cast ( found ) ; } return null ; }'", "label": "'{'"}
{"text": "'@ Override public Resource resourceOfId ( ResourceId id ) { lock . readLock ( ) . lock ( ) ; try { return resources . get ( id ) ; } finally { lock . readLock ( ) . unlock ( ) ; } }'", "label": "'{'"}
{"text": "'@ Override public Container containerOfId ( ResourceId id ) { lock . readLock ( ) . lock ( ) ; try { return containers . get ( id ) ; } finally { lock . readLock ( ) . unlock ( ) ; } }'", "label": "'{'"}
{"text": "'@ Override public void add ( Resource resource ) { checkNotNull ( resource , \"Resource cannot be null\" ) ; lock . writeLock ( ) . lock ( ) ; try { checkState ( find ( resource . id ( ) ) == null , \"A resource with identifier \\'%s\\' already exists\" , resource . id ( ) ) ; resource . accept ( new ResourceVisitor ( ) { @ Override public void visitResource ( Resource resource ) { InMemoryResourceRepository . this . resources . put ( resource . id ( ) , resource ) ; } @ Override public void visitContainer ( Container resource ) { InMemoryResourceRepository . this . containers . put ( resource . id ( ) , resource ) ; } } ) ; } finally { lock . writeLock ( ) . unlock ( ) ; } }'", "label": "'{'"}
{"text": "'@ Override public void remove ( Resource resource ) { checkNotNull ( resource , \"Resource cannot be null\" ) ; lock . writeLock ( ) . lock ( ) ; try { resources . remove ( resource . id ( ) ) ; containers . remove ( resource . id ( ) ) ; } finally { lock . writeLock ( ) . unlock ( ) ; } }'", "label": "'{'"}
{"text": "'@ Override public void shutdown ( ) throws LifecycleException { lock . writeLock ( ) . lock ( ) ; try { resources . clear ( ) ; containers . clear ( ) ; } finally { lock . writeLock ( ) . unlock ( ) ; } }'", "label": "'{'"}
{"text": "'@ Override public List < Charset > supportedCharsets ( ) { return ImmutableList . < Charset > builder ( ) . add ( StandardCharsets . UTF_8 ) . add ( StandardCharsets . ISO_8859_1 ) . add ( StandardCharsets . US_ASCII ) . add ( StandardCharsets . UTF_16 ) . add ( StandardCharsets . UTF_16LE ) . add ( StandardCharsets . UTF_16BE ) . build ( ) ; }'", "label": "'TODO : Add extension point to enable configuring the list of supported charsets'"}
{"text": "'Attachability attachability ( String attachmentId , Name < ? > name ) { // NOSONAR Attachability result = null ; if ( this . attachmentsById . containsKey ( attachmentId ) ) { result = Attachability . ID_ALREADY_USED ; } else { result = Attachability . ATTACHABLE ; } return result ; }'", "label": "'TODO : For the time being the name is not used in here because the checking should not just be local : we should check that that name has not been used for any other resource of the same template and that requires a global checking . Whenever the check is done somewhere else get rid of this parameter'"}
{"text": "'@ Override public ResourceTemplate findByHandler ( Class < ? extends ResourceHandler > handlerClass ) { return ImmutableTemplateFactory . newImmutable ( delegate ( ) . findByHandler ( handlerClass ) ) ; }'", "label": "'{'"}
{"text": "'@ Override public ResourceTemplate findById ( String templateId ) { return ImmutableTemplateFactory . newImmutable ( delegate ( ) . findById ( templateId ) ) ; }'", "label": "'{'"}
{"text": "'@ Override public Parameter getParameter ( String paramName ) { checkNotNull ( paramName , \"Parameter name cannot be null\" ) ; return this . parameters . get ( paramName ) ; }'", "label": "'{'"}
{"text": "'@ Override public synchronized String nextPath ( ) { long id = this . version ++ ; String result = this . preferredPath ; if ( id > 0 ) { result += \"_\" + id ; } return result ; }'", "label": "'{'"}
{"text": "'void configureRootResources ( ) throws ApplicationConfigurationException { validateRootResources ( ) ; final Date creationDate = new Date ( ) ; for ( RootResource entry : this . candidates ) { publish ( entry , creationDate ) ; LOGGER . debug ( \"Published resource \\'{}\\' at \\'{}\\'\" , entry . resourceId ( ) , entry . path ( ) ) ; } }'", "label": "'TODO : Check that root resources are published in different branches'"}
{"text": "'public Name < String > name ( String name , String ... names ) { return createName ( assemble ( name , names ) ) ; }'", "label": "'Concatenates elements to form a dotted name discarding null values and empty strings .'"}
{"text": "'public Name < String > name ( Class < ? > clazz , String ... names ) { return name ( clazz . getCanonicalName ( ) , names ) ; }'", "label": "'Concatenates a canonical class name and elements to form a dotted name discarding any null values or empty strings any null values or empty strings .'"}
{"text": "'@ Override public < S extends ResourceSnapshot > S find ( Class < ? extends S > snapshotClass , Name < ? > name , Class < ? extends ResourceHandler > handlerClass ) { checkNotNull ( snapshotClass , \"Resource snapshot class cannot be null\" ) ; checkNotNull ( name , RESOURCE_NAME_CANNOT_BE_NULL ) ; checkNotNull ( handlerClass , \"Resource handler class cannot be null\" ) ; checkArgument ( ! ContainerSnapshot . class . isAssignableFrom ( snapshotClass ) || ContainerHandler . class . isAssignableFrom ( handlerClass ) , \"Incompatible snapshot and handler classes (\\'%s\\' instances are not handled by \\'%s\\')\" , snapshotClass . getCanonicalName ( ) , handlerClass . getCanonicalName ( ) ) ; ResourceTemplate template = this . writeSessionService . templateManagementService ( ) . templateOfHandler ( handlerClass ) ; checkArgument ( template != null , \"Handler class \\'%s\\' is not associated to any existing template\" , handlerClass . getCanonicalName ( ) ) ; checkArgument ( Snapshots . areCompatible ( snapshotClass , template ) , \"Cannot wrap an object managed by \\'%s\\' with an snapshot of type \\'%s\\'\" , handlerClass . getCanonicalName ( ) , snapshotClass . getCanonicalName ( ) ) ; checkState ( this . status . equals ( Status . ACTIVE ) , WRITE_SESSION_NOT_ACTIVE , this . status ) ; ResourceId id = ResourceId . createId ( name , template ) ; DelegatedResourceSnapshot resource = resolveResource ( id , template ) ; return snapshotClass . cast ( resource ) ; }'", "label": "'{'"}
{"text": "'@ Override public < S extends ResourceSnapshot > S resolve ( final Class < ? extends S > snapshotClass , final Individual < ? , ? > individual ) { checkNotNull ( snapshotClass , \"Resource snapshot class cannot be null\" ) ; checkNotNull ( individual , \"Individual cannot be null\" ) ; checkState ( this . status . equals ( Status . ACTIVE ) , WRITE_SESSION_NOT_ACTIVE , this . status ) ; S result = null ; ResourceId id = getIdentifier ( individual ) ; if ( id != null ) { result = find ( snapshotClass , id ) ; } return result ; }'", "label": "'{'"}
{"text": "'@ Override public void modify ( ResourceSnapshot resource ) { checkNotNull ( resource , RESOURCE_CANNOT_BE_NULL ) ; checkArgument ( resource instanceof DelegatedResourceSnapshot , \"Unknown resource \\'%s\\'\" , resource . name ( ) ) ; checkState ( this . status . equals ( Status . ACTIVE ) , WRITE_SESSION_NOT_ACTIVE , status ) ; DelegatedResourceSnapshot delegatedResource = ( DelegatedResourceSnapshot ) resource ; delegatedResource . modify ( ) ; }'", "label": "'{'"}
{"text": "'@ Override public void saveChanges ( ) throws WriteSessionException { checkState ( this . status . equals ( Status . ACTIVE ) , WRITE_SESSION_NOT_ACTIVE , this . status ) ; this . status = Status . COMPLETED ; for ( Entry < ResourceId , DelegatedResourceSnapshot > entry : this . resourceCache . entrySet ( ) ) { DelegatedResourceSnapshot resource = entry . getValue ( ) ; resource . saveChanges ( ) ; } this . writeSessionService . commitSession ( this ) ; }'", "label": "'{'"}
{"text": "'@ Override public void discardChanges ( ) throws WriteSessionException { checkState ( this . status . equals ( Status . ACTIVE ) , WRITE_SESSION_NOT_ACTIVE , this . status ) ; this . status = Status . ABORTED ; this . writeSessionService . rollbackSession ( this ) ; }'", "label": "'{'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) @ Override protected < T extends Serializable > Name < T > assemble ( Serializable subject ) throws IOException { return ( Name < T > ) subject ; }'", "label": "'{'"}
{"text": "'public static CharsetPreference valueOf ( final String str ) { final String [ ] parts = str . split ( \";\" ) ; if ( parts . length <= 2 ) { final String charsetName = parts [ 0 ] . trim ( ) ; if ( \"*\" . equals ( charsetName ) || TOKEN_MATCHER . matchesAllOf ( charsetName ) ) { int weight = MAX_WEIGHT ; if ( parts . length == 2 ) { final String weightValue = parts [ 1 ] . trim ( ) ; final Matcher matcher = QUALITY_PATTERN . matcher ( weightValue ) ; if ( ! matcher . matches ( ) ) { return null ; } if ( weightValue . charAt ( 2 ) == \\' \\' ) { weight = Integer . parseInt ( Strings . padEnd ( weightValue . substring ( 4 ) , 3 , \\' \\' ) ) ; } } return new CharsetPreference ( charsetName , weight ) ; } } return null ; }'", "label": "'Create a charset preference that matches the following grammar :'"}
{"text": "'@ Override public Set < URI > types ( ) { Property property = this . individual . property ( RDF . TYPE . as ( URI . class ) ) ; if ( property == null ) { return Collections . emptySet ( ) ; } TypeCollector collector = new TypeCollector ( ) ; for ( Value value : property ) { value . accept ( collector ) ; } return collector . collectedTypes ( ) ; }'", "label": "'{'"}
{"text": "'@ Override public final ResourceSnapshot create ( ContainerSnapshot container , DataSet representation , WriteSession session ) { Name < ? > name = NamingScheme . getDefault ( ) . name ( id . incrementAndGet ( ) ) ; DataSetHelper helper = DataSetUtils . newHelper ( representation ) ; ManagedIndividual individual = helper . replace ( DataSetHelper . SELF , ManagedIndividualId . createId ( name , PersonHandler . ID ) , ManagedIndividual . class ) ; individual . addValue ( URI . create ( \"http://www.example.org/vocab#creationDate\" ) , Literals . of ( new Date ( ) ) . dateTime ( ) ) ; try { this . handler . add ( name , representation ) ; ResourceSnapshot member = container . addMember ( name ) ; session . saveChanges ( ) ; return member ; } catch ( Exception e ) { this . handler . remove ( name ) ; throw new ApplicationRuntimeException ( \"Could not create member\" , e ) ; } }'", "label": "'{ @inheritDoc } <br >'"}
{"text": "'public static void preferredSyntax ( MediaRangeSyntax syntax ) { if ( syntax == null ) { SYNTAX . set ( MediaRangeSyntax . RFC7230 ) ; } else { SYNTAX . set ( syntax ) ; } }'", "label": "'Set the preferred syntax to use for parsing media types . If the specified syntax is { @code null } RFC7230 syntax will be used as default .'"}
{"text": "'public static MediaType wildcard ( String type ) { requireNonNull ( type , TYPE_CANNOT_BE_NULL ) ; return new ImmutableMediaType ( MediaTypes . preferredSyntax ( ) , type , WILDCARD_TYPE , null , null ) ; }'", "label": "'Create a wildcard media type for a given primary type'"}
{"text": "'public static MediaType wildcard ( String type , String suffix ) { requireNonNull ( type , TYPE_CANNOT_BE_NULL ) ; requireNonNull ( suffix , \"Suffix cannot be null\" ) ; return new ImmutableMediaType ( MediaTypes . preferredSyntax ( ) , type , WILDCARD_TYPE , suffix , null ) ; }'", "label": "'Create a wildcard structured - syntax media type for a given primary type'"}
{"text": "'public static MediaType of ( String type , String subtype ) { requireNonNull ( type , TYPE_CANNOT_BE_NULL ) ; requireNonNull ( subtype , \"Subtype cannot be null\" ) ; return fromString ( type + \"/\" + subtype ) ; }'", "label": "'Create a media type'"}
{"text": "'public static boolean isWildcardType ( final MediaType mediaType ) { requireNonNull ( mediaType , MEDIA_TYPE_CANNOT_BE_NULL ) ; return WILDCARD_TYPE . equals ( mediaType . type ( ) ) ; }'", "label": "'Indicates whether the { @linkplain MediaType#type () type } is the wildcard character <code > &#42 ; < / code > .'"}
{"text": "'public static boolean isWildcardSubType ( final MediaType mediaType ) { requireNonNull ( mediaType , MEDIA_TYPE_CANNOT_BE_NULL ) ; return WILDCARD_TYPE . equals ( mediaType . subType ( ) ) ; }'", "label": "'Indicates whether the { @linkplain MediaType#subType () subtype } is the wildcard character <code > &#42 ; < / code > .'"}
{"text": "'public static String toHeader ( final MediaType mediaType ) { requireNonNull ( mediaType , REFERENCE_MEDIA_TYPE_CANNOT_BE_NULL ) ; final StringBuilder builder = new StringBuilder ( ) . append ( mediaType . type ( ) . toLowerCase ( Locale . ENGLISH ) ) . append ( \\' \\' ) . append ( mediaType . subType ( ) . toLowerCase ( Locale . ENGLISH ) ) ; final String suffix = mediaType . suffix ( ) ; if ( suffix != null ) { builder . append ( \\' \\' ) . append ( suffix . toLowerCase ( Locale . ENGLISH ) ) ; } final Charset charset = mediaType . charset ( ) ; if ( charset != null ) { builder . append ( \";charset=\" ) . append ( charset . name ( ) . toLowerCase ( Locale . ENGLISH ) ) ; } for ( Entry < String , String > entry : mediaType . parameters ( ) . entrySet ( ) ) { final String key = entry . getKey ( ) ; if ( isStandardParameter ( key ) ) { continue ; } builder . append ( \\' \\' ) . append ( key . toLowerCase ( Locale . ENGLISH ) ) . append ( \\' \\' ) . append ( entry . getValue ( ) ) ; } return builder . toString ( ) ; }'", "label": "'Format the media type in a HTTP - header compliant manner using preferred format .'"}
{"text": "'@ Override public Resource createResource ( ResourceTemplate template , Name < ? > name ) { checkNotNull ( name , \"Resource name cannot be null\" ) ; checkArgument ( this . templateLibrary . contains ( template ) , \"Unknown template \" + template ) ; RootResourceCreator creator = new RootResourceCreator ( ResourceId . createId ( name , template ) ) ; template . accept ( creator ) ; return creator . createdResource ( ) ; }'", "label": "'{'"}
{"text": "'@ Override public void run ( ) { ApplicationContext ctx = ApplicationContext . getInstance ( ) ; LOGGER . debug ( \"Starting resolution process on {}...\" , new Date ( ) ) ; try ( WriteSession session = ctx . createSession ( ) ) { ResourceSnapshot snapshot = session . find ( ResourceSnapshot . class , this . name , DynamicResourceHandler . class ) ; DataSet dataSet = this . handler . get ( snapshot ) ; Individual < ? , ? > individual = dataSet . individualOfId ( ManagedIndividualId . createId ( snapshot . name ( ) , snapshot . templateId ( ) ) ) ; SnapshotResolver snapshotResolver = SnapshotResolver . builder ( ) . withReadSession ( session ) . withCanonicalBase ( CANONICAL_BASE ) . build ( ) ; URI snapshotEndpoint = snapshotResolver . toURI ( snapshot ) ; individual . addValue ( SNAPSHOT_ENDPOINT , Literals . newLiteral ( snapshotEndpoint ) ) ; individual . addValue ( SNAPSHOT_RESOLUTION , Literals . newLiteral ( roundtrip ( snapshotResolver , snapshotEndpoint , snapshot ) ) ) ; this . handler . update ( this . name , dataSet ) ; session . modify ( snapshot ) ; session . saveChanges ( ) ; } catch ( Exception e ) { LOGGER . error ( \"Could not resolve resource\" , e ) ; } finally { LOGGER . debug ( \"Finalized resolution process\" ) ; } }'", "label": "'Update the resource representation adding the path where the resource is published and whether or not if given that URI it can be resolved to the same resource .'"}
{"text": "'@ Override public < V > V as ( Class < ? extends V > valueClass ) { try { return TypeAdapter . adapt ( this , valueClass ) ; } catch ( CannotAdaptClassesException e ) { throw new UnsupportedOperationException ( \"Class \\'\" + getClass ( ) . getCanonicalName ( ) + \" cannot be transformed to \\'\" + valueClass . getCanonicalName ( ) + \"\\'\" , e ) ; } }'", "label": "'{'"}
{"text": "'@ Override public int compareTo ( Term other ) { ImmutableTerm self = this ; if ( self . getDeclaringVocabulary ( ) != other . getDeclaringVocabulary ( ) ) { throw new ClassCastException ( ) ; } return self . ordinal - other . ordinal ( ) ; }'", "label": "'Compares this term with the specified object for order . Returns a negative integer zero or a positive integer as this object is less than equal to or greater than the specified object .'"}
{"text": "'@ Override public ResourceSnapshot create ( ContainerSnapshot container , DataSet representation , WriteSession session ) { NameProvider nameProvider = nameProvider ( container . name ( ) ) ; Name < ? > nextName = nameProvider . nextMemberName ( ) ; try { bookHandler ( ) . add ( nextName , representation ) ; ResourceSnapshot newMember = container . addMember ( nextName ) ; session . saveChanges ( ) ; return newMember ; } catch ( Exception e ) { bookHandler ( ) . remove ( nextName ) ; throw new ApplicationRuntimeException ( \"Could not create member\" , e ) ; } }'", "label": "'{ @inheritDoc } <br >'"}
{"text": "'@ Override public DataSet get ( ResourceSnapshot resource ) throws UnknownResourceException { DataSet dataSet = this . resources . get ( resource . name ( ) ) ; if ( dataSet == null ) { throw new UnknownResourceException ( \"Unknown resource \\'\" + resource . name ( ) + \"\\'\" ) ; } return dataSet ; }'", "label": "'{'"}
{"text": "'@ Override public ConstraintReport constraintReportOfId ( ConstraintReportId id ) { checkNotNull ( id , \"Constraint report identifier cannot be null\" ) ; this . lock . readLock ( ) . lock ( ) ; try { return this . reports . get ( id ) ; } finally { this . lock . readLock ( ) . unlock ( ) ; } }'", "label": "'{'"}
{"text": "'@ Override public void add ( ConstraintReport report ) { checkNotNull ( report , \"Constraint report cannot be null\" ) ; this . lock . writeLock ( ) . lock ( ) ; try { ConstraintReportId id = report . id ( ) ; this . failureIds . put ( id . resourceId ( ) , id . failureId ( ) ) ; this . reports . put ( id , report ) ; } finally { this . lock . writeLock ( ) . unlock ( ) ; } }'", "label": "'{'"}
{"text": "'@ Override public void remove ( ConstraintReport report ) { checkNotNull ( report , \"Constraint report cannot be null\" ) ; this . lock . writeLock ( ) . lock ( ) ; try { ConstraintReportId reportId = report . id ( ) ; this . failureIds . remove ( reportId . resourceId ( ) , reportId . failureId ( ) ) ; this . reports . remove ( reportId ) ; } finally { this . lock . writeLock ( ) . unlock ( ) ; } }'", "label": "'{'"}
{"text": "'@ Override public void removeByResource ( Resource resource ) { checkNotNull ( resource , \"Resource cannot be null\" ) ; this . lock . writeLock ( ) . lock ( ) ; try { ResourceId resourceId = resource . id ( ) ; for ( String constraintsId : this . failureIds . get ( resourceId ) ) { this . reports . remove ( ConstraintReportId . create ( resourceId , constraintsId ) ) ; } this . failureIds . removeAll ( resourceId ) ; } finally { this . lock . writeLock ( ) . unlock ( ) ; } }'", "label": "'{'"}
{"text": "'@ Override public void shutdown ( ) throws LifecycleException { this . lock . writeLock ( ) . lock ( ) ; try { this . reports . clear ( ) ; } finally { this . lock . writeLock ( ) . unlock ( ) ; } }'", "label": "'{'"}
{"text": "'@ Override public Set < AttachedTemplate > attachedTemplates ( ) { return Collections . unmodifiableSet ( new LinkedHashSet < AttachedTemplate > ( attachments . values ( ) ) ) ; }'", "label": "'{'"}
{"text": "'@ Override public AttachedTemplate attachedTemplate ( String attachmentId ) { checkNotNull ( attachmentId , \"AttachmentSnapshot identifier cannot be null\" ) ; return attachments . get ( attachmentId ) ; }'", "label": "'{'"}
{"text": "'@ Override public < T > T firstValue ( Class < ? extends T > aClazz ) { return this . pHelper . firstValue ( aClazz ) ; }'", "label": "'{'"}
{"text": "'@ Override public < T extends Serializable , S extends Individual < T , S > > T firstIndividual ( Class < ? extends S > clazz ) { return this . pHelper . firstIndividual ( clazz ) ; }'", "label": "'{'"}
{"text": "'@ Override public IndividualPropertyHelper withIndividual ( Name < ? > id , String managerId ) { return this . pHelper . withIndividual ( id , managerId ) ; }'", "label": "'{'"}
{"text": "'public List < Name < String > > pendingAttachmentNames ( String attachmentId ) { List < Name < String >> result = new ArrayList < Name < String > > ( ) ; NameSource source = this . attachmentNameSources . get ( attachmentId ) ; if ( source != null ) { result . addAll ( source . pendingNames ) ; } return result ; }'", "label": "'Return the pending names for the specified attachment .'"}
{"text": "'public void addAttachmentName ( String attachmentId , Name < String > nextName ) { nameSource ( attachmentId ) . addName ( nextName ) ; }'", "label": "'Add a name to the list of available names for a given attachment .'"}
{"text": "'public Name < String > nextAttachmentName ( String attachmentId ) { NameSource result = this . attachmentNameSources . get ( attachmentId ) ; if ( result == null ) { result = new NameSource ( \"attachment <<\" + attachmentId + \">>\" ) ; } return result . nextName ( ) ; }'", "label": "'Return the next available name for a given attachment . The name will be removed from the list of available names for the specified attachment .'"}
{"text": "'public static NameProvider create ( Name < String > resource ) { Objects . requireNonNull ( resource , \"Owner name cannot be null\" ) ; return new NameProvider ( resource ) ; }'", "label": "'Create a new name provider .'"}
{"text": "'private boolean hasSameCustomParameters ( final ImmutableMediaType that ) { if ( this . parameters . size ( ) != that . parameters . size ( ) ) { return false ; } for ( final Entry < String , String > parameter : this . parameters . entrySet ( ) ) { final String key = parameter . getKey ( ) ; if ( MediaTypes . isStandardParameter ( key ) ) { continue ; } if ( ! Objects . equals ( parameter . getValue ( ) , that . parameters . get ( key ) ) ) { return false ; } } return true ; }'", "label": "'Determine if the parameters in this {'"}
{"text": "'static ImmutableMediaType fromString ( final String mediaType , final MediaRangeSyntax syntax ) { if ( mediaType == null ) { throw new InvalidMediaTypeException ( \"Media type cannot be null\" ) ; } if ( mediaType . isEmpty ( ) ) { throw new InvalidMediaTypeException ( mediaType , \"Media type cannot be empty\" ) ; } final String [ ] parts = mediaType . split ( PARAM_SEPARATOR ) ; String fullType = parts [ 0 ] ; // java.net.HttpURLConnection returns a *; q=.2 Accept header if ( MediaTypes . WILDCARD_TYPE . equals ( fullType ) ) { fullType = \"*/*\" ; } final MediaRange mr = parseMediaRange ( mediaType , HttpUtils . trimWhitespace ( fullType ) ) ; final Map < String , String > parameters = parseParameters ( mediaType , parts ) ; try { return new ImmutableMediaType ( syntax , mr . type , mr . subType , mr . suffix , parameters ) ; } catch ( final IllegalArgumentException ex ) { throw new InvalidMediaTypeException ( mediaType , ex , \"Could not create media type\" ) ; } }'", "label": "'Parse the given String into a single { @code MediaType } .'"}
{"text": "'private static void parseSuffix ( final MediaRange mr , final String mediaType ) { final String subType = mr . subType ; final int plusIdx = subType . lastIndexOf ( \\' \\' ) ; if ( plusIdx == 0 ) { throw new InvalidMediaTypeException ( mediaType , \"missing subtype for structured media type (\" + subType . substring ( 1 ) + \")\" ) ; } else if ( plusIdx == subType . length ( ) - 1 ) { throw new InvalidMediaTypeException ( mediaType , \"missing suffix for structured media type (\" + subType . substring ( 0 , subType . length ( ) - 1 ) + \")\" ) ; } else if ( plusIdx > 0 ) { mr . subType = subType . substring ( 0 , plusIdx ) ; mr . suffix = subType . substring ( plusIdx + 1 ) ; } // Otherwise the subtype does not define a structuring syntax. }'", "label": "'As per RFC 6838 Section 4 . 2 structuring syntaxes specifier syntaxes are defined after the last + symbol .'"}
{"text": "'private static void checkQuotedString ( final String quotedString ) { boolean quotedPair = false ; for ( int i = 0 ; i < quotedString . length ( ) ; i ++ ) { final char ch = quotedString . charAt ( i ) ; if ( quotedPair ) { checkArgument ( QUOTED_PAIR . get ( ch ) , \"Invalid quoted-pair character \\'%s\\' in quoted string \\'%s\\' at %d\" , ch , quotedString , i ) ; quotedPair = false ; } else if ( ch == SLASH ) { quotedPair = true ; } else { checkArgument ( QDTEXT . get ( ch ) , \"Invalid character \\'%s\\' in quoted string \\'%s\\' at %d\" , ch , quotedString , i ) ; } } checkArgument ( ! quotedPair , \"Missing quoted-pair character in quoted string \\'%s\\' at %d\" , quotedString , quotedString . length ( ) ) ; }'", "label": "'Checks the given quoted string for illegal characters as defined in RFC 7230 section 3 . 2 . 6 .'"}
{"text": "'@ Override public final Status status ( ) { Status result = Status . PUBLISHED ; if ( this . endpoint . deleted ( ) != null ) { return Status . GONE ; } return result ; }'", "label": "'{'"}
{"text": "'@ Override public final Capabilities capabilities ( ) { if ( this . capabilities == null ) { this . capabilities = this . applicationContext . endpointCapabilities ( this . endpoint ) ; } return this . capabilities ; }'", "label": "'{'"}
{"text": "'@ Override public Integer next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( \"No more codepoints available in the CharSequence\" ) ; } this . index = this . next ; final Integer codePoint = Character . codePointAt ( this . s , this . next ) ; this . next += Character . charCount ( codePoint ) ; return codePoint ; }'", "label": "'Returns the next code point in the iteration .'"}
{"text": "'@ Override public void run ( ) { ApplicationContext ctx = ApplicationContext . getInstance ( ) ; Date date = new Date ( ) ; LOGGER . debug ( \"Starting update process on {}...\" , date ) ; try ( WriteSession session = ctx . createSession ( ) ) { ResourceSnapshot snapshot = session . find ( ResourceSnapshot . class , this . name , DynamicResourceHandler . class ) ; DataSet dataSet = this . handler . get ( snapshot ) ; Individual < ? , ? > individual = dataSet . individualOfId ( ManagedIndividualId . createId ( this . name , DynamicResourceHandler . ID ) ) ; individual . addValue ( REFRESHED_ON , Literals . of ( date ) . dateTime ( ) ) ; this . handler . update ( this . name , dataSet ) ; session . modify ( snapshot ) ; session . saveChanges ( ) ; } catch ( Exception e ) { LOGGER . error ( \"Could not update resource\" , e ) ; } finally { LOGGER . debug ( \"Finalized update process\" ) ; } }'", "label": "'Update the resource representation adding a temporal timestamp of when the resource was last updated .'"}
{"text": "'URI toURI ( ) { StringBuilder builder = new StringBuilder ( ) ; if ( defined ( this . scheme ) ) { builder . append ( this . scheme ) ; builder . append ( \":\" ) ; } if ( defined ( this . authority ) ) { builder . append ( \"//\" ) ; builder . append ( this . authority ) ; } if ( defined ( this . path ) ) { builder . append ( this . path ) ; } if ( defined ( this . query ) ) { builder . append ( \"?\" ) ; builder . append ( this . query ) ; } if ( defined ( this . fragment ) ) { builder . append ( \"#\" ) ; builder . append ( this . fragment ) ; } String rawURI = builder . toString ( ) ; return URI . create ( rawURI ) ; }'", "label": "'5 . 3 . Component Recomposition'"}
{"text": "'private static void closeQuietly ( final InputStream is , final String message ) { if ( is != null ) { try { is . close ( ) ; } catch ( final Exception e ) { if ( LOGGER . isWarnEnabled ( ) ) { LOGGER . warn ( message , e ) ; } } } }'", "label": "'Close an input stream logging possible failures .'"}
{"text": "'public static RuntimeInstance getInstance ( ) { RuntimeInstance result = RuntimeInstance . CACHED_DELEGATE . get ( ) ; if ( result != null ) { return result ; } synchronized ( RuntimeInstance . CACHED_DELEGATE ) { result = RuntimeInstance . CACHED_DELEGATE . get ( ) ; if ( result == null ) { RuntimeInstance . CACHED_DELEGATE . set ( findDelegate ( ) ) ; result = RuntimeInstance . CACHED_DELEGATE . get ( ) ; } return result ; } }'", "label": "'Obtain a { @code RuntimeInstance } instance . If an instance had not already been created and set via { @link #setInstance ( RuntimeInstance ) } the first invocation will create an instance which will then be cached for future use .'"}
{"text": "\"static boolean isNameStartChar ( final int codePoint ) { return ( codePoint == ' ' ) || ( codePoint >= ' ' && codePoint <= ' ' ) || ( codePoint == ' ' ) || ( codePoint >= ' ' && codePoint <= ' ' ) || ( codePoint >= 0xC0 && codePoint <= 0xD6 ) || ( codePoint >= 0xD8 && codePoint <= 0xF6 ) || ( codePoint >= 0xF8 && codePoint <= 0x2FF ) || ( codePoint >= 0x370 && codePoint <= 0x37D ) || ( codePoint >= 0x37F && codePoint <= 0x1FFF ) || ( codePoint >= 0x200C && codePoint <= 0x200D ) || ( codePoint >= 0x2070 && codePoint <= 0x218F ) || ( codePoint >= 0x2C00 && codePoint <= 0x2FEF ) || ( codePoint >= 0x3001 && codePoint <= 0xD7FF ) || ( codePoint >= 0xF900 && codePoint <= 0xFDCF ) || ( codePoint >= 0xFDF0 && codePoint <= 0xFFFD ) || ( codePoint >= 0x10000 && codePoint <= 0xEFFFF ) ; }\"", "label": "'Determines if a character is a Name start character .'"}
{"text": "\"static boolean isNameChar ( final int codePoint ) { return isNameStartChar ( codePoint ) || ( codePoint == ' ' ) || ( codePoint == ' ' ) || ( codePoint >= ' ' && codePoint <= ' ' ) || ( codePoint == 0xB7 ) || ( codePoint >= 0x0300 && codePoint <= 0x036F ) || ( codePoint >= 0x203F && codePoint <= 0x2040 ) ; }\"", "label": "'Determines if a character is a Name character .'"}
{"text": "'public static Language of ( final Locale locale ) { requireNonNull ( locale , \"Locale cannot be null\" ) ; checkArgument ( locale . getVariant ( ) . isEmpty ( ) , \"Language does not allow locale variants (%s)\" , locale . getVariant ( ) ) ; return new ImmutableLanguage ( locale ) ; }'", "label": "'Create a { @code Language } for a given { @code Locale } .'"}
{"text": "'public static Language fromString ( final String language ) { requireNonNull ( language , \"Language cannot be null\" ) ; if ( WILDCARD . equals ( language ) ) { return wildcard ( ) ; } else { return of ( parseLocale ( language ) ) ; } }'", "label": "'Create a { @code Language } instance from a valid { @code language - range } definition .'"}
{"text": "'public static boolean includes ( final Language language1 , final Language language2 ) { if ( language1 == null || language2 == null ) { return false ; } if ( language1 . isWildcard ( ) ) { return true ; } if ( language2 . isWildcard ( ) ) { return false ; } return language1 . primaryTag ( ) . equals ( language2 . primaryTag ( ) ) && ( language1 . subTag ( ) . isEmpty ( ) || language1 . subTag ( ) . equals ( language2 . subTag ( ) ) ) ; }'", "label": "'Implements Basic Filtering matching algorithm defined in <a href = https : // tools . ietf . org / html / rfc4647#section - 3 . 3 . 1 > Section 3 . 3 . 1< / a > of the <b > Matching of Language Tags< / b > ( BCP 47 )'"}
{"text": "'@ Override public final String encode ( Name < ? > name ) { if ( name == null ) { return null ; } try { Serializable target = prepare ( name ) ; byte [ ] serializedData = SerializationUtils . serialize ( target ) ; return BaseEncoding . base64 ( ) . encode ( serializedData ) ; } catch ( IOException e ) { throw new AssertionError ( \"Serialization should not fail\" , e ) ; } }'", "label": "'{'"}
{"text": "'@ Override public final < T extends Serializable > Name < T > decode ( String data ) { if ( data == null ) { return null ; } try { byte [ ] serializedData = BaseEncoding . base64 ( ) . decode ( data ) ; Serializable subject = SerializationUtils . deserialize ( serializedData , Serializable . class ) ; return assemble ( subject ) ; } catch ( IOException e ) { throw new AssertionError ( \"Deserialization should not fail\" , e ) ; } }'", "label": "'{'"}
{"text": "'@ Override public IndividualPropertyHelper withIndividual ( Name < ? > id , String managerId , URI path ) { return this . iph ; }'", "label": "'{'"}
{"text": "'private static boolean isCorrectColonNamespaceURISplit ( String namespace , String localName , char lastNsChar ) { return lastNsChar == COLON && isValidColonLocalName ( localName ) && isValidColonNamespace ( namespace ) ; }'", "label": "'correct split if local name has no : and URI contains no # or /'"}
{"text": "'private static boolean isCorrectSlashNamespaceURISplit ( String namespace , String localName , char lastNsChar ) { return lastNsChar == SLASH && isValidSlashLocalName ( localName ) && isValidSlashNamespace ( namespace ) ; }'", "label": "'correct split if local name has no / and URI contains no #'"}
{"text": "'private static boolean isCorrectHashNamespaceURISplit ( String namespace , int nsLength , char lastNsChar ) { return lastNsChar == HASH && namespace . lastIndexOf ( HASH , nsLength - 2 ) == - 1 ; }'", "label": "'correct split if namespace has no other #'"}
{"text": "'static int getLocalNameIndex ( String uri ) { int separatorIdx = uri . indexOf ( HASH ) ; if ( separatorIdx < 0 ) { separatorIdx = uri . lastIndexOf ( SLASH ) ; } if ( separatorIdx < 0 ) { separatorIdx = uri . lastIndexOf ( COLON ) ; } if ( separatorIdx < 0 ) { throw new IllegalArgumentException ( \"No separator character founds in URI: \" + uri ) ; } return separatorIdx + 1 ; }'", "label": "'Finds the index of the first local name character in an ( non - relative ) URI . This index is determined by the following the following steps : <ul > <li > Find the <em > first< / em > occurrence of the # character <li > If this fails find the <em > last< / em > occurrence of the / character <li > If this fails find the <em > last< / em > occurrence of the : character . <li > Add <tt > 1<tt > to the found index and return this value . < / ul > Note that the third step should never fail as every legal ( non - relative ) URI contains at least one : character to separate the scheme from the rest of the URI . If this fails anyway the method will throw an { @link IllegalArgumentException } .'"}
{"text": "'static boolean isCorrectURISplit ( String namespace , String localName ) { assert namespace != null : \"namespace must not be null\" ; assert localName != null : \"localName must not be null\" ; boolean result = false ; int nsLength = namespace . length ( ) ; if ( nsLength > 0 ) { char lastNsChar = namespace . charAt ( nsLength - 1 ) ; result = isCorrectHashNamespaceURISplit ( namespace , nsLength , lastNsChar ) || isCorrectSlashNamespaceURISplit ( namespace , localName , lastNsChar ) || isCorrectColonNamespaceURISplit ( namespace , localName , lastNsChar ) ; } return result ; }'", "label": "'Checks whether the URI consisting of the specified namespace and local name has been split correctly according to the URI splitting rules specified in { @link URI } .'"}
{"text": "'@ Override public < T > T rawValueAs ( Class < ? extends T > clazz ) { return ObjectUtil . fromString ( clazz , rawValue ( ) ) ; }'", "label": "'{'"}
{"text": "'@ Override public < T > List < T > rawValuesAs ( Class < ? extends T > clazz ) { Builder < T > builder = ImmutableList . < T > builder ( ) ; for ( String rawValue : this . rawValues ) { builder . add ( ObjectUtil . fromString ( clazz , rawValue ) ) ; } return builder . build ( ) ; }'", "label": "'{'"}
{"text": "'private static RuntimeDelegate findDelegate ( ) { try { RuntimeDelegate result = createRuntimeInstanceFromSPI ( ) ; if ( result == null ) { result = createRuntimeInstanceFromConfigurationFile ( ) ; } if ( result == null ) { String delegateClassName = System . getProperty ( LDP4J_APPLICATION_SPI_PROPERTY ) ; if ( delegateClassName != null ) { result = createRuntimeInstanceForClassName ( delegateClassName ) ; } } if ( result == null ) { result = new DefaultRuntimeInstance ( ) ; } return result ; } catch ( Exception ex ) { throw new IllegalStateException ( \"Could not find runtime delegate\" , ex ) ; } }'", "label": "'Obtain a { @code RuntimeInstance } instance using the method described in { @link #getInstance } .'"}
{"text": "'public synchronized WriteSession createSession ( ) throws ApplicationContextException { if ( this . threadSession . containsKey ( Thread . currentThread ( ) . getId ( ) ) ) { throw failure ( \"Thread already has an active session\" ) ; } if ( this . delegate . isOffline ( ) ) { throw failure ( \"The Application Engine is off-line\" ) ; } WriteSession nativeSession = this . delegate . createSession ( ) ; if ( nativeSession == null ) { throw failure ( \"Could not create native write session\" ) ; } setUpWriteSessionCleaner ( ) ; return trackSession ( new ContextWriteSessionState ( nativeSession , new CleanerContextWriteSessionStateListener ( ) ) ) ; }'", "label": "'Create a { @code WriteSession } . Only one write session can be active per thread . Sessions should not be shared among threads .'"}
{"text": "'static void checkToken ( final String token , final String message , Object ... args ) { checkNotNull ( message , \"Message cannot be null\" ) ; try { validateLength ( token ) ; validateCharacters ( token ) ; } catch ( IllegalArgumentException e ) { throw new InvalidTokenException ( String . format ( message , args ) , token , e ) ; } }'", "label": "'Checks the given type name for illegal characters as defined in RFC 7230 section 3 . 2 . 6 .'"}
{"text": "'public static Class < ? > getSubclassInScope ( final Class < ? > scopeClass ) { final String callerClass = Thread . currentThread ( ) . getStackTrace ( ) [ 3 ] . getClassName ( ) ; try { final Class < ? > candidateClass = Class . forName ( callerClass , false , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; if ( ! scopeClass . isAssignableFrom ( candidateClass ) ) { return null ; } return candidateClass ; } catch ( final ClassNotFoundException e ) { throw new IllegalStateException ( \"The class should always exist\" , e ) ; } }'", "label": "'TODO : Relax this constraint it should be possible to do it from named - inner classes .'"}
{"text": "'public DataTransformator mediaType ( MediaType mediaType ) { checkNotNull ( mediaType , MEDIA_TYPE_CANNOT_BE_NULL ) ; DataTransformator result = new DataTransformator ( this ) ; result . setMediaType ( mediaType ) ; return result ; }'", "label": "'Create transformator with the specified media type'"}
{"text": "'private static RuntimeInstance findDelegate ( ) { try { RuntimeInstance result = createRuntimeInstanceFromSPI ( ) ; if ( result == null ) { result = createRuntimeInstanceFromConfigurationFile ( ) ; } if ( result == null ) { final String delegateClassName = System . getProperty ( RDF_API_SPI_PROPERTY ) ; if ( delegateClassName != null ) { result = createRuntimeInstanceForClassName ( delegateClassName ) ; } } if ( result == null ) { result = new DefaultRuntimeInstance ( ) ; } return result ; } catch ( final Exception ex ) { throw new IllegalStateException ( \"Could not find runtime delegate\" , ex ) ; } }'", "label": "'Obtain a { @code RuntimeInstance } instance using the method described in { @link #getInstance } .'"}
{"text": "'@ Override public Attachment findAttachment ( ResourceId resourceId ) { checkNotNull ( resourceId , \"Attached resource identifier cannot be null\" ) ; return this . attachments . get ( this . attachmentsByResourceId . get ( resourceId ) ) ; }'", "label": "'{'"}
{"text": "'@ Override public < T extends Resource > T attach ( String attachmentId , ResourceId resourceId , Class < ? extends T > clazz ) { checkNotNull ( attachmentId , \"Attachment identifier cannot be null\" ) ; checkNotNull ( resourceId , \"Attached resource identifier cannot be null\" ) ; checkNotNull ( clazz , \"Attached resource class cannot be null\" ) ; AttachmentId aId = AttachmentId . createId ( attachmentId , resourceId ) ; checkState ( ! attachments . containsKey ( aId ) , \"Resource \\'%s\\' is already attached as \\'%s\\'\" , resourceId , attachmentId ) ; checkState ( ! attachmentsById . containsKey ( attachmentId ) , \"A resource is already attached as \\'%s\\'\" , attachmentId ) ; checkState ( ! attachmentsByResourceId . containsKey ( resourceId ) , \"Resource \\'%s\\' is already attached\" , resourceId ) ; ResourceTemplate attachmentTemplate = super . getTemplate ( resourceId ) ; checkState ( Resources . areCompatible ( clazz , attachmentTemplate ) , \"Attachment \\'%s\\' is not of type \\'%s\\' (%s)\" , attachmentId , clazz . getCanonicalName ( ) , attachmentTemplate . getClass ( ) . getCanonicalName ( ) ) ; InMemoryResource newResource = createChild ( resourceId , attachmentTemplate ) ; InMemoryAttachment newAttachment = new InMemoryAttachment ( aId , this . versionGenerator . nextVersion ( attachmentId ) ) ; attachments . put ( newAttachment . attachmentId ( ) , newAttachment ) ; attachmentsById . put ( aId . id ( ) , aId ) ; attachmentsByResourceId . put ( aId . resourceId ( ) , aId ) ; return clazz . cast ( newResource ) ; }'", "label": "'{'"}
{"text": "'@ Override public boolean detach ( Attachment attachment ) { boolean found = this . attachments . containsValue ( attachment ) ; if ( found ) { AttachmentId remove = this . attachmentsById . remove ( attachment . id ( ) ) ; this . attachmentsByResourceId . remove ( attachment . resourceId ( ) ) ; this . attachments . remove ( remove ) ; } return found ; }'", "label": "'{'"}
{"text": "'@ Override public Set < InMemoryAttachment > attachments ( ) { return Collections . unmodifiableSet ( new LinkedHashSet < InMemoryAttachment > ( this . attachments . values ( ) ) ) ; }'", "label": "'{'"}
{"text": "'@ Override public Set < ConstraintReportId > constraintReports ( ) { Set < ConstraintReportId > currentReports = null ; synchronized ( this ) { currentReports = ImmutableSet . copyOf ( this . reports . values ( ) ) ; } return currentReports ; }'", "label": "'{'"}
{"text": "'@ Override public void removeFailure ( ConstraintReport report ) { if ( report != null ) { String failureId = report . id ( ) . failureId ( ) ; synchronized ( this ) { this . reports . remove ( failureId ) ; } } }'", "label": "'{'"}
{"text": "'@ Override public String convertToDatabaseColumn ( Date attribute ) { if ( attribute == null ) { return null ; } return Long . toString ( attribute . getTime ( ) ) ; }'", "label": "'{'"}
{"text": "'@ Override public Date convertToEntityAttribute ( String dbData ) { if ( dbData == null ) { return null ; } return new Date ( Long . parseLong ( dbData ) ) ; }'", "label": "'{'"}
{"text": "'private Date getModificationDate ( Endpoint endpoint , Date modificationDate ) { Date result = endpoint . lastModified ( ) ; if ( modificationDate . after ( result ) ) { result = modificationDate ; } return result ; }'", "label": "'Enforce http : // tools . ietf . org / html / rfc7232#section - 2 . 2 : if the clock in the request is ahead of the clock of the origin server ( e . g . I request from Spain the update of a resource held in USA ) the last - modified data should be changed to that of the request and not a generated date from the origin server'"}
{"text": "'@ Override public Endpoint endpointOfPath ( String path ) { this . readLock . lock ( ) ; try { return this . endpointsByPath . get ( path ) ; } finally { this . readLock . unlock ( ) ; } }'", "label": "'{'"}
{"text": "'@ Override public Endpoint endpointOfResource ( ResourceId id ) { this . readLock . lock ( ) ; try { Endpoint endpoint = this . endpointsByResourceName . get ( id ) ; if ( endpoint != null && endpoint . deleted ( ) != null ) { endpoint = null ; } return endpoint ; } finally { this . readLock . unlock ( ) ; } }'", "label": "'{'"}
{"text": "'@ Override public void add ( Endpoint endpoint ) { this . writeLock . lock ( ) ; try { if ( this . endpointsByPath . containsKey ( endpoint . path ( ) ) ) { throw new IllegalArgumentException ( \"An endpoint with path \\'\" + endpoint . path ( ) + \"\\' already exists\" ) ; } Endpoint other = endpointOfResource ( endpoint . resourceId ( ) ) ; if ( other != null ) { throw new IllegalArgumentException ( \"An endpoint with resource name \\'\" + endpoint . resourceId ( ) + \"\\' already exists (\" + other + \")\" ) ; } this . endpointsByPath . put ( endpoint . path ( ) , endpoint ) ; this . endpointsByResourceName . put ( endpoint . resourceId ( ) , endpoint ) ; } finally { this . writeLock . unlock ( ) ; } }'", "label": "'{'"}
{"text": "'@ Override public void shutdown ( ) throws LifecycleException { this . writeLock . lock ( ) ; try { this . endpointsByPath . clear ( ) ; this . endpointsByResourceName . clear ( ) ; } finally { this . writeLock . unlock ( ) ; } }'", "label": "'{'"}
{"text": "'@ Override public synchronized < S extends ResourceSnapshot > S resolve ( Class < ? extends S > snapshotClass , Individual < ? , ? > individual ) { verifyExecutability ( ) ; return this . delegate . resolve ( snapshotClass , individual ) ; }'", "label": "'{'"}
{"text": "'@ Override public synchronized < S extends ResourceSnapshot > S find ( Class < ? extends S > snapshotClass , Name < ? > id , Class < ? extends ResourceHandler > handlerClass ) { verifyExecutability ( ) ; return this . delegate . find ( snapshotClass , id , handlerClass ) ; }'", "label": "'{'"}
{"text": "'@ Override public String convertToDatabaseColumn ( EntityTag attribute ) { if ( attribute == null ) { return null ; } return attribute . toString ( ) ; }'", "label": "'{'"}
{"text": "'@ Override public EntityTag convertToEntityAttribute ( String dbData ) { if ( dbData == null ) { return null ; } return EntityTag . valueOf ( dbData ) ; }'", "label": "'{'"}
{"text": "'@ Override protected Properties mergeProperties ( ) throws IOException { Properties result = super . mergeProperties ( ) ; if ( canShowConfiguration ( getModuleName ( ) ) ) { table . setProperties ( result ) ; table . dump ( System . out ) ; // NOSONAR } return result ; }'", "label": "'TODO : Enable selecting where the configuration should be logged to : System . out or a Logger'"}
{"text": "'static void registerAdapterClass ( Class < ? > clazz ) { Objects . requireNonNull ( clazz , \"Adapter class cannot be null\" ) ; TypeAdapter . ADAPTER_CLASSES . addIfAbsent ( clazz ) ; }'", "label": "'Register a new adapter class .'"}
{"text": "'static < S , T > TypeAdapter < S , T > createAdapter ( Class < ? extends S > sourceType , Class < ? extends T > targetType ) { return doCreateAdapter ( targetType , AdapterMethodValidator . newInstance ( targetType , sourceType ) ) ; }'", "label": "'Get an adapter capable of transforming instances of a source type into instances of a target type .'"}
{"text": "'static < S , T > T adapt ( S object , Class < ? extends T > resultClass ) { return TypeAdapter . < S , T > doCreateAdapter ( resultClass , AdapterMethodValidator . newInstance ( resultClass , object ) ) . adapt ( object ) ; }'", "label": "'Transform a given object into an instance of the specified type .'"}
{"text": "'@ Override public < T > T firstValue ( final Class < ? extends T > aClazz ) { Property property = getProperty ( ) ; if ( property == null ) { return null ; } LiteralValueExtractor < T > extractor = LiteralValueExtractor . newInstance ( aClazz ) ; for ( Value value : property ) { value . accept ( extractor ) ; if ( extractor . isAvailable ( ) ) { break ; } } return extractor . getValue ( ) ; }'", "label": "'{'"}
{"text": "'@ Override public IndividualHelper firstIndividual ( ) { Property property = getProperty ( ) ; if ( property == null ) { return null ; } for ( Value value : property ) { if ( value instanceof Individual < ? , ? > ) { return new IndividualHelperImpl ( ( Individual < ? , ? > ) value ) ; } } return null ; }'", "label": "'{'"}
{"text": "'@ Override public < T extends Serializable , S extends Individual < T , S > > T firstIndividual ( final Class < ? extends S > clazz ) { Property property = getProperty ( ) ; if ( property == null ) { return null ; } IndividualExtractor < T , S > extractor = IndividualExtractor . newInstance ( clazz ) ; for ( Value value : property ) { value . accept ( extractor ) ; if ( extractor . isAvailable ( ) ) { return extractor . getValue ( ) . id ( ) ; } } return null ; }'", "label": "'{'"}
{"text": "'@ Override public IndividualPropertyHelper withLiteral ( Object rawValue ) { if ( rawValue != null ) { Literal < ? > value = Literals . newLiteral ( rawValue ) ; this . individual . addValue ( this . propertyId , value ) ; } return new IndividualPropertyHelperImpl ( new IndividualHelperImpl ( this . individual ) , this ) ; }'", "label": "'{'"}
{"text": "'@ Override public IndividualPropertyHelper withIndividual ( Name < ? > id ) { if ( id != null ) { @ SuppressWarnings ( \"rawtypes\" ) Individual < ? , ? > srcIndividual = this . individual . dataSet ( ) . individual ( ( Name ) id , LocalIndividual . class ) ; this . individual . addValue ( this . propertyId , srcIndividual ) ; } return new IndividualPropertyHelperImpl ( new IndividualHelperImpl ( this . individual ) , this ) ; }'", "label": "'{'"}
{"text": "'@ Override public IndividualPropertyHelper withIndividual ( Name < ? > id , String managerId ) { if ( id != null ) { Individual < ? , ? > srcIndividual = this . individual . dataSet ( ) . individual ( ManagedIndividualId . createId ( id , managerId ) , ManagedIndividual . class ) ; this . individual . addValue ( this . propertyId , srcIndividual ) ; } return new IndividualPropertyHelperImpl ( new IndividualHelperImpl ( this . individual ) , this ) ; }'", "label": "'{'"}
{"text": "'@ Override public IndividualPropertyHelper withIndividual ( Name < ? > id , String managerId , URI path ) { if ( id != null ) { ManagedIndividualId parentId = ManagedIndividualId . createId ( id , managerId ) ; RelativeIndividualId individualId = RelativeIndividualId . createId ( parentId , path ) ; Individual < ? , ? > srcIndividual = this . individual . dataSet ( ) . individual ( individualId , RelativeIndividual . class ) ; this . individual . addValue ( this . propertyId , srcIndividual ) ; } return new IndividualPropertyHelperImpl ( new IndividualHelperImpl ( this . individual ) , this ) ; }'", "label": "'{'"}
{"text": "'@ Override public IndividualPropertyHelper withIndividual ( Name < ? > id , String managerId , String path ) { if ( id != null ) { return withIndividual ( id , managerId , URI . create ( path ) ) ; } return new IndividualPropertyHelperImpl ( new IndividualHelperImpl ( this . individual ) , this ) ; }'", "label": "'{'"}
{"text": "'@ Override public IndividualPropertyHelper withIndividual ( URI id ) { if ( id != null ) { Individual < ? , ? > srcIndividual = null ; if ( id . isAbsolute ( ) ) { srcIndividual = this . individual . dataSet ( ) . individual ( id , ExternalIndividual . class ) ; } else { srcIndividual = this . individual . dataSet ( ) . individual ( id , NewIndividual . class ) ; } this . individual . addValue ( this . propertyId , srcIndividual ) ; } return new IndividualPropertyHelperImpl ( new IndividualHelperImpl ( this . individual ) , this ) ; }'", "label": "'{'"}
{"text": "'@ Override public IndividualPropertyHelper withIndividual ( String id ) { if ( id != null ) { withIndividual ( URI . create ( id ) ) ; } return new IndividualPropertyHelperImpl ( new IndividualHelperImpl ( this . individual ) , this ) ; }'", "label": "'{'"}
{"text": "'@ Override public IndividualPropertyHelper withIndividual ( Term id ) { if ( id != null ) { withIndividual ( id . qualifiedEntityName ( ) ) ; } return new IndividualPropertyHelperImpl ( new IndividualHelperImpl ( this . individual ) , this ) ; }'", "label": "'{'"}
{"text": "'private static RuntimeDelegate findDelegate ( ) { RuntimeDelegate result = null ; try { result = createRuntimeDelegateFromSPI ( ) ; if ( result == null ) { result = createRuntimeDelegateFromConfigurationFile ( ) ; } if ( result == null ) { String delegateClassName = System . getProperty ( APPLICATION_ENGINE_SPI_PROPERTY ) ; if ( delegateClassName != null ) { result = createRuntimeDelegateForClassName ( delegateClassName ) ; } } } catch ( Exception ex ) { LOGGER . warn ( \"Could not find application engine\" , ex ) ; } return result ; }'", "label": "'Obtain an { @code RuntimeDelegate } instance using the method described in { @link RuntimeDelegate#getInstance () } .'"}
{"text": "'public static void setInstance ( final RuntimeDelegate delegate ) { SecurityManager security = getSecurityManager ( ) ; if ( security != null ) { security . checkPermission ( SUPPRESS_ACCESS_CHECKS_PERMISSION ) ; } synchronized ( RuntimeDelegate . CACHED_DELEGATE ) { RuntimeDelegate . CACHED_DELEGATE . set ( delegate ) ; } }'", "label": "'Set the { @code RuntimeDelegate } that will be used by clients . If this method is not called prior to { @link RuntimeDelegate#getInstance () } then an implementation will be sought as described in { @link RuntimeDelegate#getInstance () } .'"}
{"text": "'@ Override public Boolean fromString ( final String rawValue ) { try { return PrimitiveObjectFactory . parseBoolean ( rawValue ) ; } catch ( final IllegalArgumentException e ) { throw new ObjectParseException ( e , Boolean . class , rawValue ) ; } }'", "label": "'Returns a { @code Boolean } with a value represented by the specified string . The { @code Boolean } returned represents : <ol > <li > a { @code true } value if the string argument is not { @code null } and is equal ignoring case to the string { @code true } . < / li > <li > a { @code false } value if the string argument is not { @code null } and is equal ignoring case to the string { @code false } . < / li > < / ol >'"}
{"text": "'public NegotiationResult negotiate ( ) { return new ContentNegotiationAlgorithm ( this . mediaTypes . build ( ) , this . characterEncodings . build ( ) , this . languages . build ( ) , this . supported . build ( ) , this . accepts . build ( ) , this . acceptCharsets . build ( ) , this . acceptLanguages . build ( ) , this . errorVariant ) . execute ( ) ; }'", "label": "'Carry out the content negotiation taking into account both the supported and the acceptable media types character encodings and languages . <p > The method implements a simplified version of the <b > Remote Variant Selection Algorithm< / b > defined in <a href = https : // tools . ietf . org / html / rfc2296 > RFC 2296< / a > . <p > The differences between the implemented algorithm and the original one are the following : <ol > <li > There is no support for <i > features< / i > <li > Variant <i > source - quality< / i > is assigned linearly ( with ratio - 0 . 125 ) of the values suggested in Section 5 . 3 of RFC 2296 ; <li > The <i > round5< / i > function is not applied during the computation of overall quality values . < / ol > The reason for this latter difference is that in the presence of fine - grained qualities ( <i > i . e . < / i > 0 . 001 ) computed quality values converge to 10<sup > - 12< / sup > and can make variants with non - zero computed qualities appear like they are not amenable to selection .'"}
{"text": "'public ImmutableNamespaces withPrefix ( String prefix , String namespaceURI ) { Objects . requireNonNull ( prefix , \"Prefix cannot be null\" ) ; Objects . requireNonNull ( namespaceURI , \"Namespace URI cannot be null\" ) ; ImmutableNamespaces result = new ImmutableNamespaces ( this . map ) ; result . map . put ( prefix , namespaceURI ) ; return result ; }'", "label": "'Create a copy of the namespaces which includes a mapping between a given prefix and namespace URI .'"}
{"text": "'public ImmutableNamespaces withoutPrefix ( String ... prefixes ) { ImmutableNamespaces result = new ImmutableNamespaces ( this . map ) ; for ( String prefix : prefixes ) { result . map . remove ( prefix ) ; } return result ; }'", "label": "'Create a copy of the namespaces without the prefixes .'"}
{"text": "'@ Override public String getPrefix ( String namespaceURI ) { for ( Entry < String , String > entry : this . map . entrySet ( ) ) { if ( entry . getValue ( ) . equals ( namespaceURI ) ) { return entry . getKey ( ) ; } } return null ; }'", "label": "'{'"}
{"text": "'@ Override public List < String > getPrefixes ( String namespaceURI ) { List < String > list = new ArrayList < String > ( ) ; for ( Entry < String , String > entry : this . map . entrySet ( ) ) { if ( entry . getValue ( ) . equals ( namespaceURI ) ) { list . add ( entry . getKey ( ) ) ; } } return list ; }'", "label": "'{'"}
{"text": "\"public static String escapeXML ( final CharSequence s ) { final StringBuilder sb = new StringBuilder ( s . length ( ) * 2 ) ; final CodePointIterator iterator = new CodePointIterator ( s ) ; while ( iterator . hasNext ( ) ) { final int codePoint = iterator . next ( ) ; if ( codePoint == ' ' ) { sb . append ( LT ) ; } else if ( codePoint == ' ' ) { sb . append ( GT ) ; } else if ( codePoint == ' ' ) { sb . append ( QUOT ) ; } else if ( codePoint == ' ' ) { sb . append ( AMP ) ; } else if ( codePoint == ' ' ) { sb . append ( APOS ) ; } else { sb . appendCodePoint ( codePoint ) ; } } return sb . toString ( ) ; }\"", "label": "'Escapes a character sequence so that it is valid XML .'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) @ Override protected < T extends Serializable > Name < T > assemble ( Serializable subject ) throws IOException { return ( Name < T > ) NamingScheme . getDefault ( ) . name ( subject ) ; }'", "label": "'{'"}
{"text": "'@ Override public DataSet query ( ResourceSnapshot resource , Query query , ReadSession session ) throws InvalidQueryException { return QuerySupport . getDescription ( resource . name ( ) , query ) ; }'", "label": "'Instead of retrieving the contents of the resource return a description of the query received .'"}
{"text": "'public final void addNameProvider ( Name < String > containerName , NameProvider provider ) { this . nameProviders . put ( containerName , provider ) ; }'", "label": "'Add a name provider for a container resource .'"}
{"text": "'public final NameProvider nameProvider ( Name < ? > containerName ) { NameProvider result = this . nameProviders . get ( containerName ) ; if ( result == null ) { throw new ApplicationRuntimeException ( \"Unknown container \\'\" + containerName + \"\\'\" ) ; } return result ; }'", "label": "'Return the name provider registered for a given container resource .'"}
{"text": "'static boolean equalsIgnoreCase ( final CharSequence str1 , final CharSequence str2 ) { if ( str1 == str2 ) { return true ; } else if ( str1 == null || str2 == null ) { return false ; } else if ( str1 . length ( ) != str2 . length ( ) ) { return false ; } else { return regionMatches ( str1 , true , 0 , str2 , 0 , str1 . length ( ) ) ; } }'", "label": "'<p > Compares two CharSequences returning { @code true } if they represent equal sequences of characters ignoring case . < / p >'"}
{"text": "'static boolean regionMatches ( final CharSequence target , final boolean ignoreCase , final int toffset , final CharSequence other , final int ooffset , final int length ) { boolean result ; if ( target instanceof String && other instanceof String ) { result = delegateCheck ( ( String ) target , ignoreCase , toffset , ooffset , length , ( String ) other ) ; } else { result = carryOutCheck ( target , ignoreCase , toffset , other , ooffset , length ) ; } return result ; }'", "label": "'Tests if two { @link CharSequence charsequence } regions are equal . <p > A region of the { @code target } charsequence is compared to a region of the { @code other } charsequence . The result is { @code true } if these regions represent character sequences that are the same ignoring case if and only if { @code ignoreCase } is true . The region of the { @code target } charsequence to be compared begins at index { @code offset } whereas the region of the { @code other } charsequence begins at index { @code start } . Both regions have a length { @code length } . <p > The result is { @code false } if and only if at least one of the following is true : <ul > <li > { @code toffset } is negative . <li > { @code ooffset } is negative . <li > { @code toffset + length } is greater than the length of { @code target } argument . <li > { @code ooffset + length } is greater than the length of { @code other } argument . <li > { @code ignoreCase } is { @code false } and there is some nonnegative integer <i > k< / i > less than { @code length } such that : <blockquote >'"}
{"text": "'private static void addProtocolSpecificHeaders ( ResponseBuilder builder , Class < ? extends PublicResource > clazz ) { List < Term > types = new ArrayList < Term > ( ) ; if ( PublicRDFSource . class . isAssignableFrom ( clazz ) ) { types . add ( LDP . RESOURCE ) ; } if ( PublicBasicContainer . class . isAssignableFrom ( clazz ) ) { types . add ( LDP . BASIC_CONTAINER ) ; } else if ( PublicDirectContainer . class . isAssignableFrom ( clazz ) ) { types . add ( LDP . DIRECT_CONTAINER ) ; } else if ( PublicIndirectContainer . class . isAssignableFrom ( clazz ) ) { types . add ( LDP . INDIRECT_CONTAINER ) ; } for ( Term type : types ) { builder . header ( MoreHttp . LINK_HEADER , MoreHttp . createLink ( type , \"type\" ) ) ; } }'", "label": "'Link : rel = type headers'"}
{"text": "'static String getAcceptableContent ( List < Variant > variants , URI resourceLocation , List < String > supportedCharsets ) { StringBuilder builder = new StringBuilder ( ) ; for ( Variant variant : variants ) { MediaType mediaType = variant . getMediaType ( ) ; builder . append ( mediaType ) . append ( \" : %1$s%n\" ) ; for ( String supportedCharset : supportedCharsets ) { builder . append ( mediaType . withCharset ( supportedCharset ) ) . append ( \" : %1$s%n\" ) ; } } return String . format ( builder . toString ( ) , resourceLocation ) ; }'", "label": "'Get a text / plain representation that indicates the acceptable media types and charsets for the specified resource . The current implementation <b > only< / b > takes care of the media type nor language nor encodings are taken into consideration for generating the acceptable content .'"}
{"text": "'private static ApplicationEngine findDelegate ( ) { try { ApplicationEngine result = createApplicationEngineFromSPI ( ) ; if ( result == null ) { result = createApplicationEngineFromConfigurationFile ( ) ; } if ( result == null ) { final String delegateClassName = System . getProperty ( LDP4J_APPLICATION_ENGINE_PROPERTY ) ; if ( delegateClassName != null ) { result = createApplicationEngineForClassName ( delegateClassName ) ; } } return result ; } catch ( final Exception ex ) { throw new IllegalStateException ( \"Could not find application engine\" , ex ) ; } }'", "label": "'Obtain an { @code ApplicationEngine } instance using the method described in { @link ApplicationEngine#engine () } .'"}
{"text": "'public static ApplicationEngine engine ( ) { ApplicationEngine result = ApplicationEngine . CACHED_DELEGATE . get ( ) ; if ( result != null ) { return result ; } synchronized ( ApplicationEngine . CACHED_DELEGATE ) { result = ApplicationEngine . CACHED_DELEGATE . get ( ) ; if ( result == null ) { result = findDelegate ( ) ; ApplicationEngineState state = ApplicationEngineState . AVAILABLE ; if ( result == null ) { result = new DefaultApplicationEngine ( ) ; state = ApplicationEngineState . UNDEFINED ; } ApplicationEngine . CACHED_DELEGATE . set ( result ) ; result . setState ( state ) ; } return result ; } }'", "label": "'Obtain a { @code ApplicationEngine } instance . If an instance had not already been created and set via { @link #setEngine ( ApplicationEngine ) } the first invocation will create an instance which will then be cached for future use .'"}
{"text": "'public static void setEngine ( final ApplicationEngine delegate ) { final SecurityManager security = System . getSecurityManager ( ) ; if ( security != null ) { security . checkPermission ( SUPPRESS_ACCESS_CHECKS_PERMISSION ) ; } synchronized ( ApplicationEngine . CACHED_DELEGATE ) { final ApplicationEngine current = ApplicationEngine . CACHED_DELEGATE . get ( ) ; if ( current != null ) { try { current . shutdown ( ) ; } catch ( final ApplicationEngineLifecycleException e ) { LOGGER . error ( \"Shutdown of previous engine failed. Full stacktrace follows:\" , e ) ; } } ApplicationEngine . CACHED_DELEGATE . set ( delegate ) ; if ( delegate != null ) { delegate . setState ( ApplicationEngineState . AVAILABLE ) ; } } }'", "label": "'Set the application engine that will be used by clients . If this method is not called prior to { @link ApplicationEngine#engine () } then an implementation will be sought as described in { @link ApplicationEngine#engine () } .'"}
{"text": "'public < T > T unwrap ( final Class < ? extends T > clazz ) throws ApplicationEngineException { checkNotNull ( clazz , \"Target class cannot be null\" ) ; if ( ! clazz . isInstance ( this ) ) { throw new ApplicationEngineException ( \"Application Engine implementation is not compatible with \" + clazz . getCanonicalName ( ) ) ; } return clazz . cast ( this ) ; }'", "label": "'Return an object of the specified type to allow access to the provider - specific API . If the provider s ApplicationEngine implementation does not support the specified class the ApplicationEngineException is thrown .'"}
{"text": "'@ Override public void checkType ( final String type ) { validateLength ( type , \"Type\" ) ; validateFirstChar ( type , \"type\" ) ; validateOtherChars ( type , \"type\" ) ; }'", "label": "'Checks the given { @code type } for illegal characters as defined in RFC 6838 section 4 . 2 . NOTE : * is accepted as a valid type .'"}
{"text": "'@ Override public void checkSubType ( final String subType ) { validateLength ( subType , \"Subtype\" ) ; validateFirstChar ( subType , \"subtype\" ) ; validateOtherChars ( subType , \"subtype\" ) ; }'", "label": "'Checks the given { @code subtype } for illegal characters as defined in RFC 6838 section 4 . 2 . NOTE : * is accepted as a valid subtype .'"}
{"text": "'@ Override public final Collection < PublicResource > members ( ) { List < PublicResource > members = Lists . newArrayList ( ) ; for ( Member member : resolveAs ( Container . class ) . members ( ) ) { members . add ( createResource ( member . memberId ( ) ) ) ; } return Collections . unmodifiableList ( members ) ; }'", "label": "'{'"}
{"text": "'@ Override public DefaultPublicResource createResource ( DataSet dataSet , CreationPreferences preferences ) throws ApplicationExecutionException { verifyInteractionModel ( preferences . getInteractionModel ( ) ) ; Resource resource = applicationContext ( ) . createResource ( endpoint ( ) , dataSet , preferences . getPath ( ) ) ; return createResource ( resource . id ( ) ) ; }'", "label": "'{'"}
{"text": "'private void verifyInteractionModel ( InteractionModel interactionModel ) { if ( interactionModel == null ) { return ; } Set < InteractionModel > acceptable = Sets . newHashSet ( ) ; containerTemplate ( ) . memberTemplate ( ) . accept ( new AcceptableInteractionModelCollector ( acceptable ) ) ; if ( ! acceptable . contains ( interactionModel ) ) { throw new UnsupportedInteractionModelException ( interactionModel , acceptable ) ; } }'", "label": "'NOTE : For the time being containers will always behave as containers . Whenever we support downgrading containers to resources the visitor will have to be updated to reflect that .'"}
{"text": "'@ Override public void setup ( Environment environment , Bootstrap < Configuration > bootstrap ) throws ApplicationSetupException { LOGGER . info ( \"Configuring application: {}, {}\" , environment , bootstrap ) ; PersonHandler resourceHandler = new PersonHandler ( ) ; PersonContainerHandler containerHandler = new PersonContainerHandler ( ) ; RelativeContainerHandler relativesHandler = new RelativeContainerHandler ( ) ; QueryableResourceHandler queryableHandler = new QueryableResourceHandler ( ) ; this . dynamicResourceHandler = new DynamicResourceHandler ( ) ; BadDataResourceHandler badDataHandler = new BadDataResourceHandler ( ) ; containerHandler . setHandler ( resourceHandler ) ; relativesHandler . setHandler ( resourceHandler ) ; resourceHandler . add ( this . personResourceName , getInitialData ( PersonHandler . ID , PERSON_RESOURCE_NAME ) ) ; containerHandler . add ( this . personContainerName , getInitialData ( PersonContainerHandler . ID , PERSON_CONTAINER_NAME ) ) ; relativesHandler . add ( this . relativeContainerResourceName , getInitialData ( RelativeContainerHandler . ID , RELATIVE_CONTAINER_NAME ) ) ; queryableHandler . add ( this . queryableResourceName , getInitialData ( QueryableResourceHandler . ID , QUERYABLE_RESOURCE_NAME ) ) ; this . dynamicResourceHandler . add ( this . dynamicResourceName , getInitialData ( DynamicResourceHandler . ID , DYNAMIC_RESOURCE_NAME ) ) ; badDataHandler . add ( this . badDataResourceName , badDataHandler . getRepresentation ( ) ) ; bootstrap . addHandler ( resourceHandler ) ; bootstrap . addHandler ( containerHandler ) ; bootstrap . addHandler ( relativesHandler ) ; bootstrap . addHandler ( queryableHandler ) ; bootstrap . addHandler ( this . dynamicResourceHandler ) ; bootstrap . addHandler ( badDataHandler ) ; environment . publishResource ( this . personResourceName , PersonHandler . class , ROOT_PERSON_RESOURCE_PATH ) ; environment . publishResource ( this . personContainerName , PersonContainerHandler . class , ROOT_PERSON_CONTAINER_PATH ) ; environment . publishResource ( this . queryableResourceName , QueryableResourceHandler . class , ROOT_QUERYABLE_RESOURCE_PATH ) ; environment . publishResource ( this . dynamicResourceName , DynamicResourceHandler . class , ROOT_DYNAMIC_RESOURCE_PATH ) ; environment . publishResource ( this . badDataResourceName , BadDataResourceHandler . class , ROOT_BAD_DATA_RESOURCE_PATH ) ; this . executorService = Executors . newScheduledThreadPool ( 1 , new ThreadFactoryBuilder ( ) . setNameFormat ( \"daemon-updater-thread-%d\" ) . setUncaughtExceptionHandler ( new LoggedUncaughtExceptionHandler ( LOGGER ) ) . build ( ) ) ; LOGGER . info ( \"Configuration completed.\" ) ; }'", "label": "'{'"}
{"text": "'@ Override public void initialize ( WriteSession session ) throws ApplicationInitializationException { LOGGER . info ( \"Initializing application: {}\" , session ) ; ResourceSnapshot person = session . find ( ResourceSnapshot . class , this . personResourceName , PersonHandler . class ) ; LOGGER . info ( \"Root resource.......: \" + person ) ; LOGGER . info ( \"Root basic container: \" + session . find ( ResourceSnapshot . class , this . personContainerName , PersonContainerHandler . class ) ) ; ContainerSnapshot relativesContainer = person . createAttachedResource ( ContainerSnapshot . class , PersonHandler . RELATIVES_ID , this . relativeContainerResourceName , RelativeContainerHandler . class ) ; LOGGER . info ( \"Attached resource...: \" + relativesContainer ) ; try { session . saveChanges ( ) ; } catch ( WriteSessionException e ) { throw new ApplicationInitializationException ( \"Could not initialize application\" , e ) ; } this . executorService . scheduleAtFixedRate ( new DynamicResourceUpdater ( this . dynamicResourceHandler , this . dynamicResourceName ) , 1 , 15 , TimeUnit . SECONDS ) ; this . executorService . schedule ( new DynamicResourceResolver ( this . dynamicResourceHandler , this . dynamicResourceName ) , 3 , TimeUnit . SECONDS ) ; LOGGER . info ( \"Initialization completed.\" ) ; }'", "label": "'{'"}
{"text": "'@ Override public void shutdown ( ) { LOGGER . info ( \"Shutting down application...\" ) ; this . executorService . shutdown ( ) ; boolean finished = this . executorService . isTerminated ( ) ; while ( ! finished ) { try { this . executorService . awaitTermination ( 100 , TimeUnit . MILLISECONDS ) ; finished = this . executorService . isTerminated ( ) ; } catch ( InterruptedException e ) { finished = true ; } } LOGGER . info ( \"Shutdown completed.\" ) ; }'", "label": "'{'"}
{"text": "\"public boolean isOutOfScope ( ) { // Files are always on scope if ( this . directory == null ) { return false ; } // First, normalize final Path normalize = normalize ( ) ; // If now we are a file, we are in scope if ( normalize . directory == null ) { return false ; } // If we find a segment which is '..' we are out of scope final String [ ] segments = normalize . segments ( ) ; boolean result = false ; for ( int i = 0 ; i < segments . length && ! result ; i ++ ) { result = isDotSegment ( segments [ i ] ) ; } return result ; }\"", "label": "'Checks if the path is out of the scope .'"}
{"text": "'public Path withDirectory ( final String directory ) { final Path result = new Path ( this ) ; result . setDirectory ( directory ) ; return result ; }'", "label": "'Create a new path with a given directory .'"}
{"text": "'public Path withFile ( final String file ) { final Path result = new Path ( this ) ; result . setFile ( file ) ; return result ; }'", "label": "'Create a new path with a given file .'"}
{"text": "'public Path relativize ( final Path path ) { Objects . requireNonNull ( \"Path cannot be null\" ) ; final Path base = this ; // By default, we return the normalized form of the input path final Path defaultRelative = path . normalize ( ) ; // Either root or not if ( base . isRoot ( ) != path . isRoot ( ) ) { return defaultRelative ; } // If the path is not root, return its normalized base if ( ! path . isRoot ( ) ) { return defaultRelative ; } // Beyond this point we need the normalized form final Path nBase = base . normalize ( ) ; // If we are out of the scope... if ( base . isOutOfScope ( ) ) { // ... we must return the input path because it will define the // scope Path relative = defaultRelative ; if ( nBase . equals ( relative ) ) { // ... unless the path is the same as ourselves, in which // case it is safe to return the empty path relative = EMPTY_PATH ; } return relative ; } // Can only compare for equality iff normalized. final Path unBase = nBase . unroot ( ) ; final Path unPath = defaultRelative . unroot ( ) ; // If the base and the target are the same, return the empty path if ( unBase . equals ( unPath ) ) { return EMPTY_PATH ; } return assembleRelativeSegments ( path , base , getRelativeSegments ( unBase . segments ( ) , unPath . segments ( ) ) ) ; }'", "label": "'Computes relative relative path to reference target from base . Uses .. if needed in contrast to { @link URI#relativize ( URI ) } .'"}
{"text": "'private Path assembleRelativeSegments ( final Path path , final Path base , final Deque < String > segments ) { if ( segments . isEmpty ( ) && path . isDirectory ( ) && base . isFile ( ) ) { segments . add ( CURRENT ) ; } return Path . create ( assembleSegments ( segments , path . getFile ( ) ) ) ; }'", "label": "'If there are no segments in the resolved path and we are trying to resolve a directory coming from a path we have to make explicit that we want the directory'"}
{"text": "'@ Override public Response deleteResource ( OperationContext context ) { context . checkOperationSupport ( ) . checkPreconditions ( ) ; try { context . resource ( ) . delete ( ) ; return Response . noContent ( ) . build ( ) ; } catch ( ApplicationExecutionException e ) { throw diagnoseApplicationExecutionException ( context , e ) ; } catch ( ApplicationContextException e ) { throw new InternalServerException ( context , e ) ; } }'", "label": "'TODO : This could be improved by returning an OK with an additional description of all the resources that were deleted as a side effect .'"}
{"text": "'@ Override public Response modifyResource ( OperationContext context ) { context . checkOperationSupport ( ) . checkContents ( ) . checkPreconditions ( ) ; try { context . resource ( ) . modify ( context . dataSet ( ) ) ; ResponseBuilder builder = Response . noContent ( ) ; EndpointControllerUtils . populateRequiredHeaders ( builder , context ) ; return builder . build ( ) ; } catch ( ApplicationExecutionException e ) { throw diagnoseApplicationExecutionException ( context , e ) ; } catch ( ApplicationContextException e ) { throw new InternalServerException ( context , e ) ; } }'", "label": "'TODO : This could be improved by returning an OK with an additional description of all the resources that were modified ( updated created deleted ) as a side effect .'"}
{"text": "'@ Override public IndividualHelper managedIndividual ( final Name < ? > name , final String managerId ) { final ManagedIndividualId individualId = ManagedIndividualId . createId ( name , managerId ) ; final ManagedIndividual individual = this . dataSet . individual ( individualId , ManagedIndividual . class ) ; return new IndividualHelperImpl ( individual ) ; }'", "label": "'{'"}
{"text": "'@ Override public IndividualHelper relativeIndividual ( final Name < ? > name , final String managerId , final URI path ) { final ManagedIndividualId parentId = ManagedIndividualId . createId ( name , managerId ) ; final RelativeIndividualId individualId = RelativeIndividualId . createId ( parentId , path ) ; final RelativeIndividual individual = this . dataSet . individual ( individualId , RelativeIndividual . class ) ; return new IndividualHelperImpl ( individual ) ; }'", "label": "'{'"}
{"text": "'@ Override public IndividualHelper localIndividual ( final Name < ? > name ) { @ SuppressWarnings ( \"rawtypes\" ) final LocalIndividual individual = this . dataSet . individual ( ( Name ) name , LocalIndividual . class ) ; return new IndividualHelperImpl ( individual ) ; }'", "label": "'{'"}
{"text": "'@ Override public IndividualHelper externalIndividual ( final URI uri ) { Individual < ? , ? > individual = null ; if ( uri . isAbsolute ( ) ) { individual = this . dataSet . individual ( uri , ExternalIndividual . class ) ; } else { individual = this . dataSet . individual ( uri , NewIndividual . class ) ; } return new IndividualHelperImpl ( individual ) ; }'", "label": "'{'"}
{"text": "'@ Override public Character fromString ( String rawValue ) { try { return PrimitiveObjectFactory . parseCharacter ( rawValue ) ; } catch ( IllegalArgumentException e ) { throw new ObjectParseException ( e , targetClass ( ) , rawValue ) ; } }'", "label": "'{'"}
{"text": "'static < T > Class < T > getTypeParameter ( Class < ? > clazz , Class < ? super T > bound ) { Type t = checkNotNull ( clazz ) ; while ( t instanceof Class < ? > ) { t = ( ( Class < ? > ) t ) . getGenericSuperclass ( ) ; } /**\\n\\t\\t * This is not guaranteed to work for all cases with convoluted piping\\n\\t\\t * of type parameters: but it can at least resolve straight-forward\\n\\t\\t * extension with single type parameter (as per [Issue-89]). And when it\\n\\t\\t * fails to do that, will indicate with specific exception.\\n\\t\\t */ if ( t instanceof ParameterizedType ) { Class < T > result = processParameterizedType ( bound , ( ParameterizedType ) t ) ; if ( result != null ) { return result ; } } throw new IllegalStateException ( \"Cannot figure out type parameterization for \" + clazz . getName ( ) ) ; }'", "label": "'Finds the type parameter for the given class which is assignable to the bound class .'"}
{"text": "'@ Override @ SuppressWarnings ( \"unchecked\" ) public T fromString ( final String rawValue ) { // NOSONAR try { Object result = null ; if ( byte . class . equals ( this . valueClass ) ) { result = Byte . decode ( rawValue ) ; } else if ( short . class . equals ( this . valueClass ) ) { result = Short . decode ( rawValue ) ; } else if ( int . class . equals ( this . valueClass ) ) { result = Integer . decode ( rawValue ) ; } else if ( long . class . equals ( this . valueClass ) ) { result = Long . decode ( rawValue ) ; } else if ( double . class . equals ( this . valueClass ) ) { result = Double . valueOf ( rawValue ) ; } else if ( float . class . equals ( this . valueClass ) ) { result = Float . valueOf ( rawValue ) ; } else if ( boolean . class . equals ( this . valueClass ) ) { result = parseBoolean ( rawValue ) ; } else { // Must be char result = parseCharacter ( rawValue ) ; } return ( T ) result ; } catch ( final Exception e ) { throw new ObjectParseException ( e , this . valueClass , rawValue ) ; } }'", "label": "'{'"}
{"text": "'public static < T > PrimitiveObjectFactory < T > create ( final Class < ? extends T > valueClass ) { checkNotNull ( valueClass , \"Value class cannot be null\" ) ; checkArgument ( valueClass . isPrimitive ( ) , \"Value class \\'\" + valueClass . getName ( ) + \"\\' is not primitive\" ) ; return new PrimitiveObjectFactory < T > ( valueClass ) ; }'", "label": "'Create a primitive object factory for the specified primitive class'"}
{"text": "'public static List < Variant > createVariants ( MediaType ... mediaTypes ) { return Variant . VariantListBuilder . newInstance ( ) . mediaTypes ( mediaTypes ) . encodings ( ) . languages ( ) . add ( ) . build ( ) ; }'", "label": "'Get a list of acceptable variants . Current implementation only leverages media type for the specification of variants .'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public Individual < T , S > resolve ( DataSet dataSet ) { return ( Individual < T , S > ) dataSet . individualOfId ( ref ( ) ) ; }'", "label": "'Find the individual of the data set with the same identifier'"}
{"text": "'public Activity getMostRecentlyStartedActivity ( ) { List < StartedActivity > activities = getStartedActivities ( ) ; if ( activities . size ( ) == 0 ) { return null ; } return activities . get ( activities . size ( ) - 1 ) . getActivity ( ) ; }'", "label": "'Returns the most recently started {'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public final < T extends Activity > T waitForActivity ( Class < T > activityClass , long timeout , TimeUnit timeUnit ) { long timeoutInMs = timeUnit . toMillis ( timeout ) ; Activity mostRecentlyStartedActivity = getMostRecentlyStartedActivity ( ) ; if ( mostRecentlyStartedActivity != null && mostRecentlyStartedActivity . getClass ( ) . equals ( activityClass ) ) { return ( T ) mostRecentlyStartedActivity ; } int startedActivitiesCount = startedActivities . size ( ) ; if ( startedActivitiesCount > 0 ) { StartedActivity startedActivity = startedActivities . get ( startedActivitiesCount - 1 ) ; if ( startedActivity . getActivity ( ) . getClass ( ) . equals ( activityClass ) ) { return ( T ) startedActivity . getActivity ( ) ; } } // we need some kind of container to be shared between two threads final List < T > activityContainer = new LinkedList < T > ( ) ; // register the listener, we are now informed when the activity starts registerActivityStartListener ( activityClass , new ActivityStartListener ( ) { public void started ( Activity activity ) { synchronized ( activityContainer ) { // OK, the activity has been started. Put its // instance in the container and notify. activityContainer . add ( ( T ) activity ) ; activityContainer . notifyAll ( ) ; } } } ) ; // Now, wait for the activity start by waiting on the container object. synchronized ( activityContainer ) { try { long time = System . currentTimeMillis ( ) ; while ( activityContainer . isEmpty ( ) ) { activityContainer . wait ( 2000 ) ; if ( System . currentTimeMillis ( ) - time > timeoutInMs ) { return null ; } } } catch ( InterruptedException e ) { } if ( activityContainer . size ( ) > 0 ) { return activityContainer . get ( 0 ) ; } } /*\\n         * Container was empty, we were either interrupted or more likely, the\\n         * timeout was reached. Return null.\\n         */ return null ; }'", "label": "'Blocks until an { @link Activity } of the given type is started . The instance of the started activity is then returned . If such an activity is not started within the given amount of milliseconds returns null .'"}
{"text": "'private List < ActivityStartListener > getActivityStartListeners ( Class < ? extends Activity > activityClass ) { List < ActivityStartListener > result = this . activityStartListeners . get ( activityClass ) ; if ( result == null ) { result = new ArrayList < ActivityStartListener > ( ) ; this . activityStartListeners . put ( activityClass , result ) ; } return result ; }'", "label": "'/ * Not synchronized do that in the caller code .'"}
{"text": "'public static < T extends View > Matcher < T > hasText ( String text ) { return HasText . < T > hasText ( text ) ; }'", "label": "'Evaluates to true if the value is a {'"}
{"text": "'public static < T extends ViewGroup > Matcher < T > equalChildrenCountAs ( final int value ) { return ViewGroupComparison . < T > equalChildrenCountAs ( value ) ; }'", "label": "'Has the {'"}
{"text": "'@ Factory public static < T extends ViewGroup > Matcher < T > equalChildrenCountAs ( int value ) { return new ViewGroupComparison < T > ( value , EQUAL , EQUAL ) ; }'", "label": "'Is value = expected?'"}
{"text": "'@ Factory public static < T extends ViewGroup > Matcher < T > moreChildrenThan ( int value ) { return new ViewGroupComparison < T > ( value , GREATER_THAN , GREATER_THAN ) ; }'", "label": "'Is value > expected?'"}
{"text": "'@ Factory public static < T extends ViewGroup > Matcher < T > moreChildrenOrEqual ( int value ) { return new ViewGroupComparison < T > ( value , EQUAL , GREATER_THAN ) ; }'", "label": "'Is value > = expected?'"}
{"text": "'@ Factory public static < T extends ViewGroup > Matcher < T > lessChildrenThan ( int value ) { return new ViewGroupComparison < T > ( value , LESS_THAN , LESS_THAN ) ; }'", "label": "'Is value < expected?'"}
{"text": "'@ Factory public static < T extends ViewGroup > Matcher < T > lessChildrenOrEqual ( int value ) { return new ViewGroupComparison < T > ( value , LESS_THAN , EQUAL ) ; }'", "label": "'Is value < = expected?'"}
{"text": "'public Measures getMeasuresByYearState ( String year , String stateId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Measure.getMeasuresByYearState\" , new ArgMap ( \"year\" , year , \"stateId\" , stateId ) , Measures . class ) ; }'", "label": "'This method returns a list of state ballot measures in a given year .'"}
{"text": "'public Measure getMeasure ( String measureId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Measure.getMeasure\" , new ArgMap ( \"measureId\" , measureId ) , Measure . class ) ; }'", "label": "'This method returns a single Ballot Measure detail .'"}
{"text": "'public Categories getCategories ( String stateId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Rating.getCategories\" , new ArgMap ( \"stateId\" , stateId ) , Categories . class ) ; }'", "label": "'This method dumps categories that contain released ratings according to state . Input : stateId ( default : NA )'"}
{"text": "'public Sigs getSigList ( String categoryId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Rating.getSigList\" , new ArgMap ( \"categoryId\" , categoryId ) , Sigs . class ) ; }'", "label": "'This method dumps Special Interest Groups according to category and state . Input : categoryId * stateId ( default : NA )'"}
{"text": "'public Sig getSig ( String sigId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Rating.getSig\" , new ArgMap ( \"sigId\" , sigId ) , Sig . class ) ; }'", "label": "'This method dumps detailed information an a Special Interest Group . Input : sigId *'"}
{"text": "'public SigRating getSigRatings ( String sigId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Rating.getSigRatings\" , new ArgMap ( \"sigId\" , sigId ) , SigRating . class ) ; }'", "label": "'This method dumps all ratings ( scorecards ) by a Special Interest Group . Input : sigId *'"}
{"text": "'public CandidateRating getCandidateRating ( String candidateId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Rating.getCandidateRating\" , new ArgMap ( \"candidateId\" , candidateId ) , CandidateRating . class ) ; }'", "label": "'This method dumps a candidate s rating by an SIG .'"}
{"text": "'public Rating getRating ( String ratingId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Rating.getRating\" , new ArgMap ( \"ratingId\" , ratingId ) , Rating . class ) ; }'", "label": "'This method dumps all candidate ratings from a scorecard by an SIG .'"}
{"text": "'public Elections getElection ( String electionId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Election.getElection\" , new ArgMap ( \"electionId\" , electionId ) , Elections . class ) ; }'", "label": "'This method grabs district IDs according to the office and state .'"}
{"text": "'public Elections getElectionByYearState ( String year ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Election.getElectionByYearState\" , new ArgMap ( \"year\" , year ) , Elections . class ) ; }'", "label": "'This method grabs district basic election data according to year and stateid .'"}
{"text": "'public ElectionByZip getElectionByZip ( String zip5 ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Election.getElectionByZip\" , new ArgMap ( \"zip5\" , zip5 ) , ElectionByZip . class ) ; }'", "label": "'This method grabs district basic election data according to zip code .'"}
{"text": "'public StageCandidates getStageCandidates ( String electionId , String stageId , String party ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Election.getStageCandidates\" , new ArgMap ( \"electionId\" , electionId , \"stageId\" , stageId , \"party\" , party ) , StageCandidates . class ) ; }'", "label": "'This method grabs district basic election data according to electionId and stageId . Per state lists of a Presidential election are available by specifying the stateId .'"}
{"text": "'public AddressOffice getCampaign ( String candidateId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Address.getCampaign\" , new ArgMap ( \"candidateId\" , candidateId ) , AddressOffice . class ) ; }'", "label": "'This method grabs campaign office ( s ) and basic candidate information for the specified candidate .'"}
{"text": "'public AddressOffice getCampaignByElection ( String electionId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Address.getCampaignByElection\" , new ArgMap ( \"electionId\" , electionId ) , AddressOffice . class ) ; }'", "label": "'This method grabs campaign office ( s ) and basic candidate information for the specified election .'"}
{"text": "'public WebAddress getOfficeWebAddress ( String candidateId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Address.getOfficeWebAddress\" , new ArgMap ( \"candidateId\" , candidateId ) , WebAddress . class ) ; }'", "label": "'This method grabs office s Web address ( es ) and basic candidate information for the specified candidate .'"}
{"text": "'public AddressAddress getOfficeByOfficeState ( String officeId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Address.getOfficeByOfficeState\" , new ArgMap ( \"officeId\" , officeId ) , AddressAddress . class ) ; }'", "label": "'This method grabs office address and basic candidate information according to the officeId and state .'"}
{"text": "'public DistrictList getByOfficeState ( String officeId , String stateId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"District.getByOfficeState\" , new ArgMap ( \"officeId\" , officeId , \"stateId\" , stateId ) , DistrictList . class ) ; }'", "label": "'This method grabs district IDs according to the office and state .'"}
{"text": "'public Offices getOfficesByType ( String officeTypeId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Office.getOfficesByType\" , new ArgMap ( \"officeTypeId\" , officeTypeId ) , Offices . class ) ; }'", "label": "'This method dumps offices we keep track of according to type .'"}
{"text": "'public Offices getOfficesByLevel ( String levelId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Office.getOfficesByLevel\" , new ArgMap ( \"levelId\" , levelId ) , Offices . class ) ; }'", "label": "'This method dumps offices we keep track of according to level .'"}
{"text": "'public Offices getOfficesByTypeLevel ( String officeTypeId , String officeLevelId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Office.getOfficesByTypeLevel\" , new ArgMap ( \"officeTypeId\" , officeTypeId , \"officeLevelId\" , officeLevelId ) , Offices . class ) ; }'", "label": "'This method dumps offices we keep track of according to type and level .'"}
{"text": "'public Offices getOfficesByBranchLevel ( String branchId , String levelId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Office.getOfficesByBranchLevel\" , new ArgMap ( \"branchId\" , branchId , \"levelId\" , levelId ) , Offices . class ) ; }'", "label": "'This method dumps offices we keep track of according to branch and level .'"}
{"text": "'public Counties getCounties ( String stateId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Local.getCounties\" , new ArgMap ( \"stateId\" , stateId ) , Counties . class ) ; }'", "label": "'Fetches counties in a state .'"}
{"text": "'public Cities getCities ( String stateId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Local.getCities\" , new ArgMap ( \"stateId\" , stateId ) , Cities . class ) ; }'", "label": "'Fetches cities in a state .'"}
{"text": "'public LocalCandidateList getOfficials ( String localId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Local.getOfficials\" , new ArgMap ( \"localId\" , localId ) , LocalCandidateList . class ) ; }'", "label": "'Fetches officials for a locality .'"}
{"text": "'public static void setCache ( boolean checkCache ) { if ( VoteSmart . checkCache != checkCache ) logger . fine ( \"Setting checkCache to \" + checkCache ) ; VoteSmart . checkCache = checkCache ; }'", "label": "'Modify whether or not the cache is first checked for files . Note that any JSON read will always be written to the cache .'"}
{"text": "'public < T > T query ( String method , ArgMap argMap , Class < T > responseType ) throws VoteSmartException , VoteSmartErrorException { BufferedReader reader = null ; HttpURLConnection conn = null ; String charSet = \"utf-8\" ; try { if ( isCaching ( method , argMap ) ) { File file = getCacheFile ( method , argMap ) ; long fileLength = file . length ( ) ; logger . fine ( \"Length of File in cache:\" + fileLength + \": \" + file . getName ( ) ) ; if ( fileLength == 0L ) { VoteSmart . cacheFileFromAPI ( method , argMap , file ) ; } reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , charSet ) ) ; } else { conn = VoteSmart . getConnectionFromAPI ( method , argMap ) ; charSet = getCharset ( conn ) ; reader = new BufferedReader ( new InputStreamReader ( conn . getInputStream ( ) , charSet ) ) ; } JAXBElement < T > e = unmarshaller . unmarshal ( new StreamSource ( reader ) , responseType ) ; if ( e . getName ( ) . getLocalPart ( ) . equals ( \"error\" ) ) { //\\t\\t        ErrorBase error = unmarshaller.unmarshal( new StreamSource( reader = new StringReader(XMLStr) ), ErrorBase.class ).getValue(); throw new VoteSmartErrorException ( ( ( ErrorBase ) e . getValue ( ) ) , method , argMap ) ; } else { return e . getValue ( ) ; } /*\\n \\t        Object o = unmarshaller.unmarshal( new StreamSource( reader ) );\\n\\t        if ( o instanceof ErrorBase ) {\\n\\t        \\tthrow new VoteSmartErrorException((ErrorBase) o, method, argMap);\\n\\t        } else {\\n\\t\\t        @SuppressWarnings(\"unchecked\")\\n\\t\\t\\t\\tT e = (T) o;\\n\\t\\t        return e;\\n\\t        }\\n*/ } catch ( JAXBException e ) { throw new VoteSmartException ( e ) ; } catch ( URISyntaxException e ) { throw new VoteSmartException ( e ) ; } catch ( IOException e ) { throw new VoteSmartException ( e ) ; } finally { suspendCache = false ; if ( conn != null ) conn . disconnect ( ) ; if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { throw new VoteSmartException ( e ) ; } } } }'", "label": "'Queries the API server for the information requested'"}
{"text": "'public CandidateList getStatewide ( String stateId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Officials.getStatewide\" , new ArgMap ( \"stateId\" , stateId ) , CandidateList . class ) ; }'", "label": "'This method grabs a list of officials according to state representation .'"}
{"text": "'public CandidateList getByOfficeTypeState ( String officeTypeId , String stateId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Officials.getByOfficeTypeState\" , new ArgMap ( \"officeTypeId\" , officeTypeId , \"stateId\" , stateId ) , CandidateList . class ) ; }'", "label": "'This method grabs a list of officials according to office type and state representation .'"}
{"text": "'public CandidateList getByZip ( String zip5 ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Officials.getByZip\" , new ArgMap ( \"zip5\" , zip5 ) , CandidateList . class ) ; }'", "label": "'This method grabs a list of officials according to the zip code they represent .'"}
{"text": "'public AddlBio getAddlBio ( String candidateId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"CandidateBio.getAddlBio\" , new ArgMap ( \"candidateId\" , candidateId ) , AddlBio . class ) ; }'", "label": "'This method grabs the extended bio for each candidate that has one .'"}
{"text": "'public Bio getBio ( String candidateId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"CandidateBio.getDetailedBio\" , new ArgMap ( \"candidateId\" , candidateId ) , Bio . class ) ; }'", "label": "'This method grabs the extended bio for each candidate that has one . It uses the updated version getDetailedBio of the call .'"}
{"text": "'public CandidateList getByLastname ( String lastName , String electionYear ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Candidates.getByLastname\" , new ArgMap ( \"lastName\" , lastName , \"electionYear\" , electionYear ) , CandidateList . class ) ; }'", "label": "'This method grabs a list of candidates according to a lastname match .'"}
{"text": "'public CandidateList getByElection ( String electionId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Candidates.getByElection\" , new ArgMap ( \"electionId\" , electionId ) , CandidateList . class ) ; }'", "label": "'This method grabs a list of candidates according to a fuzzy lastname match .'"}
{"text": "'public CandidateList getByDistrict ( String districtId , String electionYear ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Candidates.getByDistrict\" , new ArgMap ( \"districtId\" , districtId , \"electionYear\" , electionYear ) , CandidateList . class ) ; }'", "label": "'This method grabs a list of candidates according to the district they represent .'"}
{"text": "'public Committees getCommitteesByTypeState ( String typeId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Committee.getCommitteesByTypeState\" , new ArgMap ( \"typeId\" , typeId ) , Committees . class ) ; }'", "label": "'Returns the list of committees that fit the criteria .'"}
{"text": "'public Committee getCommittee ( String committeeId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Committee.getCommittee\" , new ArgMap ( \"committeeId\" , committeeId ) , Committee . class ) ; }'", "label": "'Returns detailed committee data .'"}
{"text": "'public CommitteeMembers getCommitteeMembers ( String committeeId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Committee.getCommitteeMembers\" , new ArgMap ( \"committeeId\" , committeeId ) , CommitteeMembers . class ) ; }'", "label": "'Returns members of the committee .'"}
{"text": "'public Leadership getPositions ( String stateId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Leadership.getPositions\" , new ArgMap ( \"stateId\" , stateId ) , Leadership . class ) ; }'", "label": "'Gets leadership positions by state and office .'"}
{"text": "'public Leaders getOfficials ( String leadershipId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Leadership.getOfficials\" , new ArgMap ( \"leadershipId\" , leadershipId ) , Leaders . class ) ; }'", "label": "'Gets officials that hold the leadership role in certain states .'"}
{"text": "'public VotesCategories getCategories ( String year ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Votes.getCategories\" , new ArgMap ( \"year\" , year ) , VotesCategories . class ) ; }'", "label": "'This method dumps categories that contain released bills according to year and state . Input : year * stateId ( default : NA )'"}
{"text": "'public Bill getBill ( String billId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Votes.getBill\" , new ArgMap ( \"billId\" , billId ) , Bill . class ) ; }'", "label": "'This method dumps general information on a bill . Input : billId *'"}
{"text": "'public BillAction getBillAction ( String actionId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Votes.getBillAction\" , new ArgMap ( \"actionId\" , actionId ) , BillAction . class ) ; }'", "label": "'This gets detailed action information on a certain stage of the bill Input : actionId *'"}
{"text": "'public BillActionVotes getBillActionVotes ( String actionId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Votes.getBillActionVotes\" , new ArgMap ( \"actionId\" , actionId ) , BillActionVotes . class ) ; }'", "label": "'Method provides votes listed by candidate on a certain bill action . Input : actionId *'"}
{"text": "'public BillActionVotes getBillActionVoteByOfficial ( String actionId , String candidateId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Votes.getBillActionVoteByOfficial\" , new ArgMap ( \"actionId\" , actionId , \"candidateId\" , candidateId ) , BillActionVotes . class ) ; }'", "label": "'Returns a single vote according to official and action . Input : actionId * candidateId *'"}
{"text": "'public Bills getByBillNumber ( String billNumber ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Votes.getByBillNumber\" , new ArgMap ( \"billNumber\" , billNumber ) , Bills . class ) ; }'", "label": "'Returns a list of bills that are like the billNumber input . Input : billNumber *'"}
{"text": "'public Bills getBillsByCategoryYearState ( String categoryId , String year ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Votes.getBillsByCategoryYearState\" , new ArgMap ( \"categoryId\" , categoryId , \"year\" , year ) , Bills . class ) ; }'", "label": "'Returns a list of bills that fit the category year and state input . Input : categoryId * year * stateId'"}
{"text": "'public BillsByOfficial getByOfficial ( String candidateId , String officeId , String categoryId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Votes.getByOfficial\" , new ArgMap ( \"candidateId\" , candidateId , \"officeId\" , officeId , \"categoryId\" , categoryId ) , BillsByOfficial . class ) ; }'", "label": "'This method dumps all the bills an official has voted on based on the candidateId officeId categoryId and year Input : candidateId * officeId categoryId year'"}
{"text": "'public Bills getBillsBySponsorYear ( String candidateId , String year ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Votes.getBillsBySponsorYear\" , new ArgMap ( \"candidateId\" , candidateId , \"year\" , year ) , Bills . class ) ; }'", "label": "'Returns a list of bills that fit the sponsor s candidateId and year . Input : candidateId * year *'"}
{"text": "'public Bills getBillsBySponsorCategory ( String candidateId , String categoryId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Votes.getBillsBySponsorCategory\" , new ArgMap ( \"candidateId\" , candidateId , \"categoryId\" , categoryId ) , Bills . class ) ; }'", "label": "'Returns a list of bills that fit the sponsor s candidateId and category . Input : candidateId * categoryId *'"}
{"text": "'public Bills getBillsByStateRecent ( String amount , String state ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Votes.getBillsByStateRecent\" , new ArgMap ( \"amount\" , amount , \"state\" , state ) , Bills . class ) ; }'", "label": "'Returns a list of recent bills according to the state . Max returned is 100 or however much less you want . Input : amount ( default : 100 max : 100 ) state ( default : NA )'"}
{"text": "'public BillVetoes getVetoes ( String candidateId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Votes.getVetoes\" , new ArgMap ( \"candidateId\" , candidateId ) , BillVetoes . class ) ; }'", "label": "'Returns a list of vetoes according to candidate . Input : candidateId'"}
{"text": "'public State getState ( String stateId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"State.getState\" , new ArgMap ( \"stateId\" , stateId ) , State . class ) ; }'", "label": "'This method grabs a various data we keep on a state . Input : stateId *'"}
{"text": "'public Npat getNpat ( String candidateId ) throws VoteSmartException , VoteSmartErrorException { return api . query ( \"Npat.getNpat\" , new ArgMap ( \"candidateId\" , candidateId ) , Npat . class ) ; }'", "label": "'This method returns the candidates most recently filled out NPAT / PCT . NOTE : This is the only class that responds with recursive data .'"}
{"text": "'private int realRead ( byte [ ] b , int off , int len ) throws IOException { int lenToRead = rateHelper . take ( len ) ; int rd = real . read ( b , off , lenToRead ) ; if ( rd != lenToRead ) rateHelper . giveBack ( lenToRead - rd ) ; return rd ; }'", "label": "'len < = num'"}
{"text": "'@ Override public int read ( byte [ ] b , int off , int len ) throws IOException { int done = 0 ; while ( done < len && ( done == 0 || available ( ) > 0 || ( boring && real . available ( ) > 0 ) ) ) done += realRead ( b , off + done , Math . min ( len - done , Math . max ( 1 , rateHelper . getThingsPerTick ( ) ) ) ) ; return done ; }'", "label": "'This method complies with { @link InputStream#read ( byte [] int int ) } and imposes stronger postconditions .'"}
{"text": "'public static void sleep ( int ms ) { long deadline = System . currentTimeMillis ( ) + ms ; while ( System . currentTimeMillis ( ) < deadline ) { try { Thread . sleep ( Math . max ( 1 , ( deadline - System . currentTimeMillis ( ) ) / 2 ) ) ; } catch ( InterruptedException ignore ) { } } }'", "label": "'Sleeps for the provided amount of milliseconds ignoring thread interrupts .'"}
{"text": "'public void takeOne ( ) { while ( true ) { int stored = spent . get ( ) ; if ( stored >= thingsPerTick ) sleep ( ) ; else if ( spent . compareAndSet ( stored , stored + 1 ) ) break ; } }'", "label": "'Takes one thing ( eg . byte ) . This method blocks until one thing can be used according to the current rate and prescaling settings .'"}
{"text": "'public int take ( int n ) { int lenToTake ; while ( true ) { int stored = spent . get ( ) ; lenToTake = Math . min ( n , thingsPerTick - stored ) ; if ( stored >= thingsPerTick ) sleep ( ) ; else if ( spent . compareAndSet ( stored , stored + lenToTake ) ) break ; } timewiseAvailable -= lenToTake ; return lenToTake ; }'", "label": "'Takes several things ( eg . bytes ) . This method blocks until at least one thing can be used according to the current rate and prescaling settings .'"}
{"text": "'public static Result calculate ( long nanoseconds , float epsilon ) { if ( epsilon <= 0 || epsilon >= 1 ) throw new IllegalArgumentException ( \"0 < epsilon < 1 not satisfied\" ) ; long max_divider = ( int ) ( 1D / epsilon ) ; if ( nanoseconds < max_divider ) return new Result ( nanoseconds , 1 ) ; long interval = Math . min ( MAX_INTERVAL , nanoseconds / max_divider ) ; long correction = nanoseconds / interval ; return new Result ( interval , correction ) ; }'", "label": "'Returns a result for the given delay and epsilon ( error rate ) . Epsilon must be between 0 and 1 exclusively . See { @link DelayCalculator } for details .'"}
{"text": "'@ Override public void removeListener ( TickListener listener ) { super . removeListener ( listener ) ; if ( listeners . isEmpty ( ) && ! keepAlive ) stop ( ) ; }'", "label": "'If the last tick listener has been removed from this source it shuts itself down via {'"}
{"text": "'public void start ( ) { if ( timer != null ) throw new IllegalStateException ( \"already running\" ) ; if ( interval < BUSY_WAITING_THRESHOLD ) timer = new MyBusyTimer ( ) ; else if ( interval < MILLISECOND_THRESHOLD ) timer = new MyWaitingTimer ( ) ; else timer = new MyMillisecondTimer ( ) ; Thread thread = new Thread ( timer , \"timer\" ) ; thread . setDaemon ( true ) ; thread . start ( ) ; }'", "label": "'Starts generating tick events starting from 0 . This method must not be called when the tick source is already running .'"}
{"text": "'public static Result calculate ( float rateBytesPerSecond , int minInterval ) { BigDecimal B_MIN = BigDecimal . ONE ; BigDecimal B_MAX = BigDecimal . valueOf ( MAX_BYTES_PER_TICK ) ; BigDecimal I_MIN = BigDecimal . valueOf ( minInterval ) ; BigDecimal I_MAX = BigDecimal . valueOf ( MAX_INTERVAL_NS ) ; BigDecimal Id_MAX = BigDecimal . valueOf ( Integer . MAX_VALUE ) ; BigDecimal ONEG = BigDecimal . valueOf ( NS_PER_S ) ; BigDecimal TWO = BigDecimal . valueOf ( 2 ) ; BigDecimal E = BigDecimal . valueOf ( Math . E ) ; BigDecimal R = BigDecimal . valueOf ( rateBytesPerSecond ) . divide ( ONEG , SCALE , ROUND ) ; BigDecimal I = I_MAX ; BigDecimal B = R . multiply ( I ) ; BigDecimal ERROR ; BigDecimal ERROR_MAX = BigDecimal . valueOf ( MAX_ERROR ) ; BigDecimal R_set = BigDecimal . valueOf ( rateBytesPerSecond ) . divide ( ONEG , SCALE , ROUND ) ; BigDecimal R_eff ; // bytes per I_MAX <= 1 if ( B . compareTo ( B_MIN ) <= 0 ) { B = BigDecimal . ONE ; I = B . divide ( R , SCALE , ROUND ) ; BigDecimal Id = BigDecimal . ONE ; while ( true ) { while ( I . compareTo ( I_MAX ) > 0 ) { I = I . divide ( E , SCALE , ROUND ) ; Id = Id . multiply ( E ) ; } if ( Id . compareTo ( Id_MAX ) > 0 ) throw new IllegalArgumentException ( \"rate too low (\" + rateBytesPerSecond + \"): prescaler too high\" ) ; BigDecimal B_int = BigDecimal . valueOf ( B . setScale ( 0 , ROUND ) . intValueExact ( ) ) ; BigDecimal I_int = BigDecimal . valueOf ( I . setScale ( 0 , ROUND ) . intValueExact ( ) ) ; BigDecimal Id_int = BigDecimal . valueOf ( Id . setScale ( 0 , ROUND ) . intValueExact ( ) ) ; R_eff = B_int . divide ( I_int , SCALE , ROUND ) . divide ( Id_int , SCALE , ROUND ) ; ERROR = R_eff . divide ( R_set , SCALE , ROUND ) . subtract ( BigDecimal . ONE ) . abs ( ) ; if ( ERROR . compareTo ( ERROR_MAX ) < 0 ) break ; I = I . multiply ( E ) ; B = B . multiply ( E ) ; } return new Result ( B . setScale ( 0 , ROUND ) . intValueExact ( ) , Id . setScale ( 0 , ROUND ) . intValueExact ( ) , I . setScale ( 0 , ROUND ) . intValueExact ( ) ) ; } else { BigDecimal Id = BigDecimal . ONE ; while ( true ) { while ( I . compareTo ( I_MAX ) > 0 ) { I = I . divide ( E , SCALE , ROUND ) ; Id = Id . multiply ( E ) ; } while ( B . compareTo ( B_MAX ) > 0 ) { B = B . divide ( TWO , SCALE , ROUND ) ; I = I . divide ( TWO , SCALE , ROUND ) ; } if ( I . compareTo ( BigDecimal . ONE ) < 0 ) throw new IllegalArgumentException ( \"rate too high (\" + rateBytesPerSecond + \"): interval too low\" ) ; BigDecimal B_int = BigDecimal . valueOf ( B . setScale ( 0 , ROUND ) . intValueExact ( ) ) ; BigDecimal I_int = BigDecimal . valueOf ( I . setScale ( 0 , ROUND ) . intValueExact ( ) ) ; BigDecimal Id_int = BigDecimal . valueOf ( Id . setScale ( 0 , ROUND ) . intValueExact ( ) ) ; R_eff = B_int . divide ( I_int , SCALE , ROUND ) . divide ( Id_int , SCALE , ROUND ) ; ERROR = R_eff . divide ( R_set , SCALE , ROUND ) . subtract ( BigDecimal . ONE ) . abs ( ) ; if ( ERROR . compareTo ( ERROR_MAX ) < 0 ) break ; I = I . multiply ( E ) ; B = B . multiply ( E ) ; } if ( I . compareTo ( I_MIN ) < 0 ) throw new IllegalArgumentException ( \"rate too high (\" + rateBytesPerSecond + \"): interval too low\" ) ; return new Result ( B . setScale ( 0 , ROUND ) . intValueExact ( ) , Id . setScale ( 0 , ROUND ) . intValueExact ( ) , I . setScale ( 0 , ROUND ) . intValueExact ( ) ) ; } }'", "label": "'Performs a calculation with the given minimal interval . See { @link RateCalculator } for details .'"}
{"text": "'public static RateLimitInputStream limitRate ( InputStream base , TickSource tickSource , int bytesPerTick , int prescale ) { return new RateLimitInputStream ( base , tickSource , bytesPerTick , prescale ) ; }'", "label": "'Creates a byte - rate - limited { @link InputStream } . See { @link RateLimitInputStream#RateLimitInputStream ( InputStream TickSource int int ) } for detailed information .'"}
{"text": "'public static RateLimitOutputStream limitRate ( OutputStream base , TickSource tickSource , int bytesPerTick , int prescaler ) { return new RateLimitOutputStream ( base , tickSource , bytesPerTick , prescaler ) ; }'", "label": "'Creates a byte - rate - limited { @link OutputStream } . See { @link RateLimitOutputStream#RateLimitOutputStream ( OutputStream TickSource int int ) } for detailed information .'"}
{"text": "'public static DelayedInputStream addDelay ( InputStream base , TickSource tickSource , long delay , int bufferSize ) { return new DelayedInputStream ( tickSource , base , delay , bufferSize ) ; }'", "label": "'Creates a delayed { @link InputStream } . See { @link DelayedInputStream#DelayedInputStream ( TickSource InputStream long int ) } for detailed information .'"}
{"text": "'public void waitFor ( ) throws Throwable { while ( ! finished ) { try { synchronized ( this ) { this . wait ( 100 ) ; } } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } } if ( t != null ) throw t ; }'", "label": "'Waits until the gobbler finished . If the gobbler encountered any exception it is thrown from this method .'"}
{"text": "'public void close ( ) { cancel = true ; try { thread . interrupt ( ) ; waitFor ( ) ; } catch ( Throwable ignore ) { } try { is . close ( ) ; } catch ( Exception ignore ) { } try { os . close ( ) ; } catch ( Exception ignore ) { } }'", "label": "'Interrupts the gobbler and closes its streams .'"}
{"text": "'private int realWrite ( byte [ ] b , int off , int len ) throws IOException { int lenToWrite = rateHelper . take ( len ) ; real . write ( b , off , lenToWrite ) ; return lenToWrite ; }'", "label": "'len < = num'"}
{"text": "'public static < K , V , M extends Map < K , V > > M merge ( Stream < ? extends Map < K , V > > stream , BinaryOperator < V > mergeFunction , Supplier < M > mapSupplier ) { Assert . notNull ( stream , \"Missing map merge function!\" ) ; Assert . notNull ( mergeFunction , \"Missing map merge function!\" ) ; Assert . notNull ( mapSupplier , \"Missing map supplier!\" ) ; return stream . collect ( mapSupplier , ( a , b ) -> b . forEach ( ( k , v ) -> a . merge ( k , v , mergeFunction ) ) , Map :: putAll ) ; }'", "label": "'Merging single level aggregation maps'"}
{"text": "'public static < K , V > List < Map < K , V > > split ( Map < K , V > map , int limit ) { Assert . notNull ( map , \"Missing map!\" ) ; Assert . isTrue ( limit > 0 , \"Map limit must be > 0!\" ) ; if ( map . size ( ) <= limit ) { return Collections . singletonList ( map ) ; // nothing to do } return map . entrySet ( ) . parallelStream ( ) . collect ( mapSizer ( limit ) ) ; }'", "label": "'Splits map to list of maps'"}
{"text": "'private static < K , V > Collector < Map . Entry < K , V > , ? , List < Map < K , V > > > mapSizer ( int limit ) { return Collector . of ( ArrayList :: new , ( l , e ) -> { if ( l . isEmpty ( ) || l . get ( l . size ( ) - 1 ) . size ( ) == limit ) { l . add ( new HashMap <> ( ) ) ; } l . get ( l . size ( ) - 1 ) . put ( e . getKey ( ) , e . getValue ( ) ) ; } , ( l1 , l2 ) -> { if ( l1 . isEmpty ( ) ) { return l2 ; } if ( l2 . isEmpty ( ) ) { return l1 ; } if ( l1 . get ( l1 . size ( ) - 1 ) . size ( ) < limit ) { Map < K , V > map = l1 . get ( l1 . size ( ) - 1 ) ; ListIterator < Map < K , V > > mapsIte = l2 . listIterator ( l2 . size ( ) ) ; while ( mapsIte . hasPrevious ( ) && map . size ( ) < limit ) { Iterator < Map . Entry < K , V > > ite = mapsIte . previous ( ) . entrySet ( ) . iterator ( ) ; while ( ite . hasNext ( ) && map . size ( ) < limit ) { Map . Entry < K , V > entry = ite . next ( ) ; map . put ( entry . getKey ( ) , entry . getValue ( ) ) ; ite . remove ( ) ; } if ( ! ite . hasNext ( ) ) { mapsIte . remove ( ) ; } } } l1 . addAll ( l2 ) ; return l1 ; } ) ; }'", "label": "'Collector splitting map into seperate maps'"}
{"text": "'public static < K , V > Map < K , V > sort ( Map < K , V > map , Comparator < Map . Entry < K , V > > comparator ) { Assert . notNull ( map , \"Missing map!\" ) ; Assert . notNull ( comparator , \"Missing comparator!\" ) ; List < Map . Entry < K , V > > list = new LinkedList <> ( map . entrySet ( ) ) ; Collections . sort ( list , comparator ) ; Map < K , V > result = new LinkedHashMap <> ( ) ; for ( Map . Entry < K , V > entry : list ) { result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; }'", "label": "'Sorts map with comparator'"}
{"text": "'public static < T > T firstValue ( Map < String , T > map ) { if ( map == null || map . size ( ) == 0 ) { return null ; } String firstKey = map . keySet ( ) . iterator ( ) . next ( ) ; return map . get ( firstKey ) ; }'", "label": "'Returns first value in map as given by the iterator or null if empty'"}
{"text": "'public static < T > void isNull ( T test , String message ) { isTrue ( test == null , message ) ; }'", "label": "'Tests if object is null'"}
{"text": "'public static < T > void notNull ( T test , String message ) { isFalse ( test == null , message ) ; }'", "label": "'Tests if object is ! = null'"}
{"text": "'public static void notNullOrEmptyTrimmed ( String value , String message ) { isFalse ( StringUtils . isNullOrEmptyTrimmed ( value ) , message ) ; }'", "label": "'Tests if String is null or empty when trimmed'"}
{"text": "'public static < T > void notNullOrEmpty ( Collection < T > list , String message ) { isFalse ( list == null || list . size ( ) == 0 , message ) ; }'", "label": "'Tests if list is null or empty'"}
{"text": "'public static < T > void notNullOrEmpty ( Set < T > set , String message ) { isFalse ( set == null || set . size ( ) == 0 , message ) ; }'", "label": "'Tests if list is null or empty'"}
{"text": "'public static < T > void notNullOrEmpty ( T [ ] array , String message ) { isFalse ( array == null || array . length == 0 , message ) ; }'", "label": "'Tests if list is null or empty'"}
{"text": "'public static < T , K > void notNullOrEmpty ( Map < T , K > map , String message ) { isFalse ( map == null || map . size ( ) == 0 , message ) ; }'", "label": "'Tests if map is null or empty'"}
{"text": "'public static < T > void isNullOrEmpty ( List < T > list , String message ) { isTrue ( list == null || list . size ( ) == 0 , message ) ; }'", "label": "'Tests if list is null or empty'"}
{"text": "'public static < T > void isNullOrEmpty ( Set < T > set , String message ) { isTrue ( set == null || set . size ( ) == 0 , message ) ; }'", "label": "'Tests if set is null or empty'"}
{"text": "'public static < T > void isNullOrEmpty ( T [ ] array , String message ) { isTrue ( array == null || array . length == 0 , message ) ; }'", "label": "'Tests if array is null or empty'"}
{"text": "'public static < T , K > void isNullOrEmpty ( Map < T , K > map , String message ) { isTrue ( map == null || map . size ( ) == 0 , message ) ; }'", "label": "'Tests if map is null or empty'"}
{"text": "'@ Deprecated public static String getResourceAsString ( String resourceFile , Class clazz ) { Assert . notNullOrEmptyTrimmed ( resourceFile , \"Missing resource file!\" ) ; Scanner scanner = null ; try { InputStream resource = clazz . getResourceAsStream ( resourceFile ) ; scanner = new Scanner ( resource , UTF_8 ) ; return scanner . useDelimiter ( \"\\\\\\\\A\" ) . next ( ) ; } catch ( Exception e ) { return null ; } finally { if ( scanner != null ) { scanner . close ( ) ; } } }'", "label": "'Loads class resource to String'"}
{"text": "'public static Set < String > getResourceWords ( String resourceFile , Class clazz ) { Assert . notNullOrEmptyTrimmed ( resourceFile , \"Missing resource file!\" ) ; Scanner scanner = null ; try { InputStream resource = clazz . getResourceAsStream ( resourceFile ) ; scanner = new Scanner ( resource , UTF_8 ) ; Set < String > list = new LinkedHashSet <> ( ) ; while ( scanner . hasNext ( ) ) { String next = scanner . next ( ) ; if ( next != null && next . trim ( ) . length ( ) > 0 ) { list . add ( next ) ; } } return list ; } catch ( Exception e ) { return null ; } finally { if ( scanner != null ) { scanner . close ( ) ; } } }'", "label": "'Loads resource as a set of Strings where each word is added to the set'"}
{"text": "'@ Deprecated public static Long getLastModifiedTime ( String resourceFile , Class clazz ) { Assert . notNullOrEmptyTrimmed ( resourceFile , \"Missing resource file!\" ) ; try { URL url = clazz . getResource ( resourceFile ) ; return url . openConnection ( ) . getLastModified ( ) ; // get last modified date of resource } catch ( IOException e ) { return null ; } }'", "label": "'Get resource last modified date'"}
{"text": "'public static String getString ( final InputStream is , String encoding ) { if ( is == null ) { return null ; } if ( StringUtils . isNullOrEmptyTrimmed ( encoding ) ) { encoding = UTF_8 ; } final char [ ] buffer = new char [ BUFFER_SIZE ] ; final StringBuilder out = new StringBuilder ( ) ; try { try ( Reader in = new InputStreamReader ( is , encoding ) ) { for ( ; ; ) { int rsz = in . read ( buffer , 0 , buffer . length ) ; if ( rsz < 0 ) { break ; } out . append ( buffer , 0 , rsz ) ; } } } catch ( IOException ioe ) { throw new RuntimeException ( ioe ) ; } return out . toString ( ) ; }'", "label": "'Load input stream into string'"}
{"text": "'public static byte [ ] getBytes ( InputStream is ) { if ( is == null ) { return null ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; int nRead ; byte [ ] data = new byte [ BUFFER_SIZE ] ; try { while ( ( nRead = is . read ( data , 0 , data . length ) ) != - 1 ) { buffer . write ( data , 0 , nRead ) ; } buffer . flush ( ) ; } catch ( IOException ignored ) { } return buffer . toByteArray ( ) ; }'", "label": "'Load input stream into byte array'"}
{"text": "'public static String readFileToString ( File file ) throws IOException { Assert . isTrue ( file . exists ( ) , \"File \\'\" + file + \"\\' does not exist\" ) ; Assert . isFalse ( file . isDirectory ( ) , \"File \\'\" + file + \"\\' is a directory\" ) ; Assert . isTrue ( file . canRead ( ) , \"File \\'\" + file + \"\\' cannot be read\" ) ; FileInputStream stream = new FileInputStream ( file ) ; return getString ( stream ) ; }'", "label": "'Reads file into String'"}
{"text": "'@ Deprecated public static String getResourceAbsolutePath ( String resource , Class clazz ) { Assert . notNullOrEmptyTrimmed ( resource , \"Missing resource name!\" ) ; URL file = clazz . getResource ( resource ) ; Assert . notNull ( file , \"Resource: \\'\" + resource + \"\\', not found!\" ) ; return file . getFile ( ) ; }'", "label": "'Gets absolute file path of resource'"}
{"text": "'public static String generateString ( int length ) { if ( length <= 0 || length > 100 ) { throw new IllegalArgumentException ( \"Can\\'t generate random id with length: \" + length ) ; } SecureRandom random = new SecureRandom ( ) ; StringBuilder sb = new StringBuilder ( length ) ; for ( int i = 0 ; i < length ; i ++ ) { sb . append ( ELEMENTS . charAt ( random . nextInt ( ELEMENTS . length ( ) ) ) ) ; } return sb . toString ( ) ; }'", "label": "'Generates random string from ELEMENTS set of chars and numbers'"}
{"text": "'public static long generateLong ( int length ) { if ( length <= 0 || length > 19 ) { throw new IllegalArgumentException ( \"Can\\'t generate random id with length: \" + length ) ; } SecureRandom random = new SecureRandom ( ) ; StringBuilder sb = new StringBuilder ( length ) ; // 1st digit should  not be a 0 or 9 if desired length is 19 (as max long is: 9223372036854775807) if ( length == 19 ) { sb . append ( NUMBERS_NO_NINE_AND_ZERO . charAt ( random . nextInt ( NUMBERS_NO_NINE_AND_ZERO . length ( ) ) ) ) ; } else { sb . append ( NUMBERS_NO_ZERO . charAt ( random . nextInt ( NUMBERS_NO_ZERO . length ( ) ) ) ) ; } // all other digits can contain a 0 for ( int i = 1 ; i < length ; i ++ ) { sb . append ( NUMBERS . charAt ( random . nextInt ( NUMBERS . length ( ) ) ) ) ; } return Long . parseLong ( sb . toString ( ) ) ; }'", "label": "'Generates non negative long key of maximum length 18'"}
{"text": "'@ SafeVarargs public static < T > T [ ] join ( final T [ ] array1 , final T ... array2 ) { if ( isEmpty ( array1 ) && isEmpty ( array2 ) ) { return null ; } if ( isEmpty ( array1 ) ) { return array2 ; } if ( isEmpty ( array2 ) ) { return array1 ; } final Class < ? > type1 = array1 . getClass ( ) . getComponentType ( ) ; @ SuppressWarnings ( \"unchecked\" ) // OK, because array is of type T final T [ ] joinedArray = ( T [ ] ) Array . newInstance ( type1 , array1 . length + array2 . length ) ; int index = 0 ; for ( T item : array1 ) { joinedArray [ index ++ ] = item ; } for ( T item : array2 ) { joinedArray [ index ++ ] = item ; } return joinedArray ; }'", "label": "'joins two arrays and preserves array order array1 items are followed by array2 items as given'"}
{"text": "'public static < T > List < Set < T > > split ( Set < T > set , int maxSize ) { Assert . notNull ( set , \"Missing set to be split!\" ) ; Assert . isTrue ( maxSize > 0 , \"Max size must be > 0!\" ) ; if ( set . size ( ) < maxSize ) { return Collections . singletonList ( set ) ; } List < Set < T > > list = new ArrayList <> ( ) ; Iterator < T > iterator = set . iterator ( ) ; while ( iterator . hasNext ( ) ) { Set < T > newSet = new HashSet <> ( ) ; for ( int j = 0 ; j < maxSize && iterator . hasNext ( ) ; j ++ ) { T item = iterator . next ( ) ; newSet . add ( item ) ; } list . add ( newSet ) ; } return list ; }'", "label": "'Splits set in 1 .. N chunks of maxSize or less'"}
{"text": "'public static String formatDateTime ( long time ) { Instant instant = Instant . ofEpochMilli ( time ) ; return formatDateTime ( instant ) ; }'", "label": "'Formats time to String'"}
{"text": "'public static String formatDateTime ( Instant time ) { Assert . notNull ( time , \"Missing time!\" ) ; return DATE_TIME_FORMAT . format ( time ) ; }'", "label": "'Formats time to String'"}
{"text": "'public static String formatDateTimeShort ( long time ) { Instant instant = Instant . ofEpochMilli ( time ) ; return formatDateTimeShort ( instant ) ; }'", "label": "'Formats time to String'"}
{"text": "'public static String formatDateTimeShort ( Instant time ) { Assert . notNull ( time , \"Missing time!\" ) ; return SHORT_TIME_FORMAT . format ( time ) ; }'", "label": "'Formats time to String'"}
{"text": "'public static String formatDate ( long time ) { Instant instant = Instant . ofEpochMilli ( time ) ; return DATE_FORMAT . format ( instant ) ; }'", "label": "'Formats time to date only'"}
{"text": "'public static String formatDate ( Instant time ) { Assert . notNull ( time , \"Missing time!\" ) ; return DATE_FORMAT . format ( time ) ; }'", "label": "'Formats time to date only'"}
{"text": "'public static String format ( long time , DateTimeFormatter format ) { return format ( Instant . ofEpochMilli ( time ) , format ) ; }'", "label": "'Custom date time format'"}
{"text": "'public static String format ( Instant time , DateTimeFormatter format ) { if ( format == null ) { return formatDateTime ( time ) ; } Assert . notNull ( time , \"Missing time!\" ) ; return format . format ( time ) ; }'", "label": "'Custom date time format'"}
{"text": "'public static Instant getTimestamp ( String value , DateTimeFormatter ... formats ) { Assert . notNull ( formats , \"Missing date time formats\" ) ; Assert . isTrue ( formats . length > 0 , \"Missing date time formats\" ) ; if ( StringUtils . isNullOrEmptyTrimmed ( value ) ) { return null ; } // OK check if we have 6 digit milliseconds ... if so truncate if ( value . matches ( \".*\\\\\\\\.\\\\\\\\d{6}.*\" ) ) { // remove 3 milliseconds places int index = value . indexOf ( \".\" ) ; value = value . substring ( 0 , index + 4 ) + value . substring ( index + 7 ) ; } // Go over all formats ... and if success return value for ( DateTimeFormatter format : formats ) { try { TemporalAccessor date = format . parse ( value ) ; return Instant . from ( date ) ; } catch ( DateTimeParseException e ) { // try next one ... } } return null ; }'", "label": "'Convert any given timestamp string to long Note that in case conversion fails to produce a result a 0 timestamp is returned!'"}
{"text": "'public static OffsetDateTime toOffsetDateTime ( long timestamp , ZoneId zoneId ) { Instant time = Instant . ofEpochMilli ( timestamp ) ; return toOffsetDateTime ( time , zoneId ) ; }'", "label": "'Converts timestamp into OffsetDatetime'"}
{"text": "'public static OffsetDateTime toOffsetDateTime ( Instant time , ZoneId zoneId ) { Assert . notNull ( time , \"Missing time!\" ) ; if ( zoneId == null ) { zoneId = ZoneId . from ( time ) ; } return OffsetDateTime . ofInstant ( time , zoneId ) ; }'", "label": "'Converts timestamp into OffsetDatetime'"}
{"text": "'public static Instant getMonthStart ( Instant time ) { Assert . notNull ( time , \"Missing date time\" ) ; LocalDateTime dateTime = LocalDateTime . ofInstant ( time , ZoneOffset . UTC ) ; dateTime = dateTime . withDayOfMonth ( 1 ) . withHour ( 0 ) . withMinute ( 0 ) . withSecond ( 0 ) . with ( ChronoField . MILLI_OF_SECOND , 0 ) ; return dateTime . toInstant ( ZoneOffset . UTC ) ; }'", "label": "'Gets first millisecond of first day in month'"}
{"text": "'public static Instant getMonthEnd ( Instant time ) { Assert . notNull ( time , \"Missing date time\" ) ; LocalDateTime dateTime = LocalDateTime . ofInstant ( time , ZoneOffset . UTC ) ; dateTime = dateTime . withDayOfMonth ( 1 ) . withHour ( 23 ) . withMinute ( 59 ) . withSecond ( 59 ) . with ( ChronoField . MILLI_OF_SECOND , 999 ) ; dateTime = dateTime . plus ( 1 , ChronoUnit . MONTHS ) . minus ( 1 , ChronoUnit . DAYS ) ; return dateTime . toInstant ( ZoneOffset . UTC ) ; }'", "label": "'Returns last millisecond of last day in month ... + 1 = next first day in month'"}
{"text": "'public static boolean overlaps ( Instant startOne , Instant endOne , Instant startTwo , Instant endTwo ) { // (StartDate1 <= EndDate2) and (StartDate2 <= EndDate1) Instant startDate1 = startOne == null ? Instant . MIN : startOne ; Instant endDate1 = endOne == null ? Instant . MAX : endOne ; Assert . isTrue ( startDate1 . isBefore ( endDate1 ) , \"Start date one can\\'t be after end date one!\" ) ; Instant startDate2 = startTwo == null ? Instant . MIN : startTwo ; Instant endDate2 = endTwo == null ? Instant . MAX : endTwo ; Assert . isTrue ( startDate2 . isBefore ( endDate2 ) , \"Start date two can\\'t be after end date two!\" ) ; return startDate1 . compareTo ( endDate2 ) <= 0 && startDate2 . compareTo ( endDate1 ) <= 0 ; }'", "label": "'Check is time periods overlap'"}
{"text": "'public static int compare ( String one , String two ) { if ( one == null && two == null ) { return 0 ; } if ( one == null ) { return - 1 ; } if ( two == null ) { return 1 ; } return one . compareTo ( two ) ; }'", "label": "'Compares two strings with <code > String . compare () < / code > . Method allows <code > null< / code > values .'"}
{"text": "'public static String trimDoubleSpaces ( String value ) { if ( isNullOrEmpty ( value ) ) { return value ; } value = value . trim ( ) ; return value . replaceAll ( \"\\\\\\\\s+\" , \" \" ) ; }'", "label": "'Additionally to outer <code > trim () < / code > double spaces are removed .'"}
{"text": "'public static String trimInner ( String value ) { if ( isNullOrEmpty ( value ) ) { return value ; } value = value . trim ( ) ; return value . replaceAll ( \"\\\\\\\\s+\" , \"\" ) ; }'", "label": "'Additionally to outer <code > trim () < / code > all inner spaces are removed .'"}
{"text": "'public static String trimToNull ( String text ) { text = trim ( text ) ; if ( text == null || text . isEmpty ( ) ) { return null ; } return text ; }'", "label": "'Trims down text to null if empty'"}
{"text": "'public static String capitalize ( String input ) { if ( input == null ) { return null ; } if ( input . length ( ) > 1 ) { for ( int i = 0 ; i < input . length ( ) ; i ++ ) { if ( Character . isAlphabetic ( input . charAt ( i ) ) ) { return input . substring ( 0 , i ) + Character . toString ( input . charAt ( i ) ) . toUpperCase ( ) + input . substring ( i + 1 ) ; } } } return input . toUpperCase ( ) ; }'", "label": "'Capitalizes first character in given string'"}
{"text": "'public static String join ( List < ? > list , String separator ) { return join ( list , separator , null ) ; }'", "label": "'Joins list of string items to a single string where items are separated with a defined separator .'"}
{"text": "'public static String join ( List < ? > list , String separator , Integer limit ) { if ( separator == null || separator . equalsIgnoreCase ( \"\" ) ) { throw new IllegalArgumentException ( \"Missing separator!\" ) ; } StringBuilder output = new StringBuilder ( ) ; if ( limit == null || limit <= 0 ) { limit = list . size ( ) ; } if ( list != null && limit > 0 ) { for ( int i = 1 ; i <= limit ; i ++ ) { if ( i > list . size ( ) ) { break ; } if ( i <= limit ) { output . append ( list . get ( i - 1 ) ) ; if ( i == limit && list . size ( ) > limit ) { // ok list is larger than limit .. and we hit the limit output . append ( separator ) . append ( \"... [\" ) . append ( limit ) . append ( \"/\" ) . append ( list . size ( ) ) . append ( \"]\" ) ; } if ( i < limit ) { output . append ( separator ) ; } } } } return output . toString ( ) ; }'", "label": "'Joins list of string items to a single string where items are separated with a defined separator .'"}
{"text": "'public static String join ( Object [ ] args , String separator , Integer limit ) { if ( separator == null || separator . equalsIgnoreCase ( \"\" ) ) { throw new IllegalArgumentException ( \"Missing separator!\" ) ; } if ( args != null && args . length > 0 ) { List < Object > array = Arrays . asList ( args ) ; return join ( array , separator , limit ) ; } return \"\" ; }'", "label": "'Joins list of string items to a single string where items are separated with a defined separator .'"}
{"text": "'public static String join ( Object [ ] args , String separator ) { return join ( args , separator , null ) ; }'", "label": "'Joins array of objects into string where items are separated with a defined separator .'"}
{"text": "'public static String join ( Set < ? > items , String separator , Integer limit ) { if ( separator == null || separator . equalsIgnoreCase ( \"\" ) ) { throw new IllegalArgumentException ( \"Missing separator!\" ) ; } if ( items != null && items . size ( ) > 0 ) { Object [ ] array = items . toArray ( ) ; return join ( array , separator , limit ) ; } return \"\" ; }'", "label": "'Joins list of string items to a single string where items are separated with a defined separator .'"}
{"text": "'public static String join ( Set < ? > items , String separator ) { return join ( items , separator , null ) ; }'", "label": "'Joins set of items to a single string where items are separated with a defined separator .'"}
{"text": "'public static < T , V > String join ( Map < T , V > map , String separator ) { if ( separator == null || separator . equalsIgnoreCase ( \"\" ) ) { throw new IllegalArgumentException ( \"Missing separator!\" ) ; } StringBuilder output = new StringBuilder ( ) ; if ( map != null ) { for ( Object key : map . keySet ( ) ) { if ( output . length ( ) > 0 ) { output . append ( separator ) ; } output . append ( key ) . append ( \"=\" ) . append ( map . get ( key ) ) ; } } return output . toString ( ) ; }'", "label": "'Joins list of string items to a single string where items are separated with a defined separator .'"}
{"text": "'public static List < String > getWords ( String text ) { List < String > output = new ArrayList <> ( ) ; if ( isNullOrEmptyTrimmed ( text ) ) { return output ; } Pattern p = Pattern . compile ( \"\\\\\\\\b\\\\\\\\p{L}+\\\\\\\\b\" ) ; Matcher m = p . matcher ( text ) ; while ( m . find ( ) ) { output . add ( m . group ( ) ) ; } return output ; }'", "label": "'Extracts words from text removing non alpha characters'"}
{"text": "'public static List < String > split ( String text , String regEx ) { if ( isNullOrEmptyTrimmed ( text ) ) { return Collections . emptyList ( ) ; } String [ ] items = text . trim ( ) . split ( regEx ) ; return Arrays . asList ( items ) ; }'", "label": "'Wrapper around String . split ( regEx ) method'"}
{"text": "'public static String trimTextDown ( String text , int size ) { if ( text == null || text . length ( ) <= size ) { return text ; } int pos = text . lastIndexOf ( \" \" , size ) ; if ( pos < 0 ) { return text . substring ( 0 , size ) ; } return text . substring ( 0 , pos ) ; }'", "label": "'Reduces text to max given size preserving words'"}
{"text": "'public static String trimTextDown ( String text , int sizeMinusAppend , String append ) { Assert . notNull ( append , \"Missing append!\" ) ; if ( text == null || text . length ( ) <= sizeMinusAppend ) { return text ; } sizeMinusAppend = sizeMinusAppend - append . length ( ) ; int pos = text . lastIndexOf ( \" \" , sizeMinusAppend ) ; if ( pos < 0 ) { return text . substring ( 0 , sizeMinusAppend ) + append ; } return text . substring ( 0 , pos ) + append ; }'", "label": "'Reduces text size to a given size'"}
{"text": "'public static List < String > asListOfChars ( String text ) { List < String > list = new ArrayList <> ( ) ; if ( StringUtils . isNullOrEmptyTrimmed ( text ) ) { return list ; } for ( int i = 0 ; i < text . length ( ) ; i ++ ) { list . add ( Character . toString ( text . charAt ( i ) ) ) ; } return list ; }'", "label": "'Converts text to list of characters'"}
{"text": "'public static boolean isWord ( String word ) { if ( isNullOrEmptyTrimmed ( word ) ) { return false ; } List < String > list = getWords ( word ) ; return list . size ( ) == 1 ; }'", "label": "'Checks if given string is a single word ( doesn t accepts words with - as a single word! )'"}
{"text": "'public static int relevance ( String value , String search ) { if ( StringUtils . isNullOrEmptyTrimmed ( value ) || StringUtils . isNullOrEmptyTrimmed ( search ) ) { return - 1 ; } if ( search . length ( ) > value . length ( ) ) { return - 1 ; } int relevance = - 1 ; // start at -1 ... so -1 is returned for no result int delta = 1 ; // first delta at 1 ... producing a sum of 0 when first letter is found int len = value . length ( ) ; int searchLen = search . length ( ) ; int letterIndex = 0 ; for ( int searchIndex = 0 ; searchIndex < searchLen ; searchIndex ++ ) { char match = search . charAt ( searchIndex ) ; while ( letterIndex < len ) { char letter = value . charAt ( letterIndex ) ; letterIndex ++ ; if ( match == letter ) { relevance = relevance + delta ; // reverse to get higher value for better match delta = 0 ; break ; } else { delta ++ ; } } // we matched all characters ... and found the last one ... if ( delta == 0 && searchIndex == searchLen - 1 ) { return relevance ; } if ( letterIndex == len ) { break ; } } return - 1 ; }'", "label": "'Calculates matching relevance between given string and search expression'"}
{"text": "'public static String sanitizeWhitespace ( String input ) { Assert . notNull ( input , \"Missing input!\" ) ; input = input . replaceAll ( \"\\\\\\\\s+\" , \" \" ) ; return input . trim ( ) ; }'", "label": "'Removes all multiple - consecutive whitespace characters ( space tab newline ) and replaces them with single space . Also removes leading and trailing spaces .'"}
{"text": "'public static byte [ ] sanitizeWhitespace ( byte [ ] input ) { Assert . isFalse ( input == null || input . length == 0 , \"Missing input!\" ) ; try { String stringFileData = new String ( input , \"utf-8\" ) ; return sanitizeWhitespace ( stringFileData ) . getBytes ( \"utf-8\" ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }'", "label": "'Removes all multiple - consecutive whitespace characters ( space tab newline ) and replaces them with single space . Also removes leading and trailing spaces .'"}
{"text": "'public static String enumerate ( Integer number ) { if ( number == null || number <= 0 ) { return null ; } int lastDigit = number % 10 ; switch ( number ) { // special case for first five case 1 : return \"first\" ; case 2 : return \"second\" ; case 3 : return \"third\" ; case 4 : return \"fourth\" ; case 5 : return \"fifth\" ; default : switch ( lastDigit ) { case 1 : return number + \"st\" ; case 2 : return number + \"nd\" ; case 3 : return number + \"rd\" ; default : return number + \"th\" ; } } }'", "label": "'Simple enumeration : first second third ... 5th 6th .. etc for given number'"}
{"text": "'public static String unQuote ( String text ) { if ( isNullOrEmptyTrimmed ( text ) ) { return text ; } if ( ( text . startsWith ( \"\\\\\"\" ) && text . endsWith ( \"\\\\\"\" ) ) || ( text . startsWith ( \"\\'\" ) && text . endsWith ( \"\\'\" ) ) ) { return text . substring ( 1 , text . length ( ) - 1 ) ; } return text ; }'", "label": "'Removes double or single quotes if any are present'"}
{"text": "'public static String formatDateTime ( long time ) { SimpleDateFormat format = getTimeFormat ( ) ; Calendar calendar = getCalendar ( time ) ; return format . format ( calendar . getTime ( ) ) ; }'", "label": "'Formats time to String'"}
{"text": "'public static String formatDateTimeShort ( long time ) { SimpleDateFormat format = getDateTimeFormat ( ) ; Calendar calendar = getCalendar ( time ) ; return format . format ( calendar . getTime ( ) ) ; }'", "label": "'Formats time to String'"}
{"text": "'public static String formatDate ( long time ) { SimpleDateFormat format = getDateFormat ( ) ; Calendar calendar = getCalendar ( time ) ; return format . format ( calendar . getTime ( ) ) ; }'", "label": "'Formats time to date only'"}
{"text": "'public static long getTimezoneTime ( long time , int timezone ) { Calendar calendar = getCalendar ( time ) ; int hour = calendar . get ( Calendar . HOUR_OF_DAY ) ; hour = ( hour + timezone ) % 24 ; if ( hour < 0 ) { hour = 24 + hour ; calendar . add ( Calendar . DAY_OF_MONTH , - 1 ) ; } calendar . set ( Calendar . HOUR_OF_DAY , hour ) ; return calendar . getTimeInMillis ( ) ; }'", "label": "'Returns time for given time zone'"}
{"text": "'public static OffsetDateTime toOffsetDateTime ( long timestamp ) { Calendar calendar = DateTimeUtils . getCalendar ( timestamp ) ; return OffsetDateTime . ofInstant ( calendar . toInstant ( ) , calendar . getTimeZone ( ) . toZoneId ( ) ) ; }'", "label": "'Converts timestamp into OffsetDatetime'"}
{"text": "'public static int getDayInWeek ( long time ) { int dayInWeek = getCalendar ( time ) . get ( Calendar . DAY_OF_WEEK ) - 1 ; // SUNDAY == 1 - 1 == 0 if ( dayInWeek == 0 ) { dayInWeek = 7 ; // make sunday the last day of the week } return dayInWeek ; }'", "label": "'Returns number of day in week where monday is the first day of the week ( 1 )'"}
{"text": "'public static long getTimestamp ( String value , SimpleDateFormat [ ] formats ) { Assert . notNull ( formats , \"Missing date time formats\" ) ; Assert . isTrue ( formats . length > 0 , \"Missing date time formats\" ) ; if ( StringUtils . isNullOrEmptyTrimmed ( value ) ) { return 0 ; } // OK check if we have 6 digit milliseconds ... if so truncate if ( value . matches ( \".*\\\\\\\\.\\\\\\\\d{6}.*\" ) ) { // remove 3 milliseconds places int index = value . indexOf ( \".\" ) ; value = value . substring ( 0 , index + 4 ) + value . substring ( index + 7 ) ; } // Go over all formats ... and if success return value for ( SimpleDateFormat format : formats ) { TimeZone oldDefaultTimeZone = TimeZone . getDefault ( ) ; try { // make sure we are in the correct time zone while doing this TimeZone . setDefault ( TimeZone . getTimeZone ( \"UTC\" ) ) ; Date date = format . parse ( value ) ; return date . getTime ( ) ; } catch ( ParseException e ) { // try next one ... } finally { TimeZone . setDefault ( oldDefaultTimeZone ) ; } } return 0 ; }'", "label": "'Convert any given timestamp string to long Note that in case conversion fails to produce a result a 0 timestamp is returned!'"}
{"text": "'public static boolean overlaps ( Instant startOne , Instant endOne , Instant startTwo , Instant endTwo ) { return InstantTimeUtils . overlaps ( startOne , endOne , startTwo , endTwo ) ; }'", "label": "'Check is time periods overlap'"}
{"text": "'public List < Integer > hasTag ( final Integer tagID ) { final List < Integer > retValue = new ArrayList < Integer > ( ) ; for ( final FilterTag tag : getFilterTags ( ) ) { if ( tag . getTag ( ) . getTagId ( ) . equals ( tagID ) ) retValue . add ( tag . getTagState ( ) ) ; } return retValue ; }'", "label": "'Loops through the FilterTags held by this Filter and returns the state of the tag if it exists and - 1 if it does not .'"}
{"text": "'@ Transient public ArrayList < Category > getFilterTagCategories ( ) { final ArrayList < Category > categories = new ArrayList < Category > ( ) ; for ( final FilterTag filterTag : filterTags ) { final int filterTagState = filterTag . getTagState ( ) ; if ( filterTagState == CommonFilterConstants . MATCH_TAG_STATE || filterTagState == CommonFilterConstants . NOT_MATCH_TAG_STATE ) { final Tag tag = filterTag . getTag ( ) ; final Set < TagToCategory > tagToCategories = tag . getTagToCategories ( ) ; if ( tagToCategories . size ( ) != 0 ) { for ( final TagToCategory category : tagToCategories ) { if ( ! categories . contains ( category . getCategory ( ) ) ) { categories . add ( category . getCategory ( ) ) ; } } } else { if ( ! categories . contains ( null ) ) categories . add ( null ) ; } } } return categories ; }'", "label": "'Not all FilterTags assigned to a filter have an associated FilterCategory . If a FilterTags belongs to a category that does not have an associated FilterCategory the default boolean logic is used . <p / > This function returns all the categories that the tags in this filter belong to . These are then matched to any associated FilterCategories to find out how the tags are matched ( i . e . are we matching all the tags ( And logic ) or one or more of the tags matches ( Or logic )) using the default logic ( Or ) if no associated FilterCategory exists .'"}
{"text": "'@ SuppressWarnings ( \"PMD\" ) public void add ( final Statement ... toAdd ) { if ( toAdd != null ) { Arrays . stream ( toAdd ) . filter ( Objects :: nonNull ) . forEach ( c -> { // Resolve the type of the current Statement, and assign it to // the appropriate internal state. if ( c instanceof CommonEdgeAttributes ) { this . commonEdgeAttributes = ( CommonEdgeAttributes ) c ; } else if ( c instanceof CommonGraphAttributes ) { this . commonGraphAttributes = ( CommonGraphAttributes ) c ; } else if ( c instanceof CommonNodeAttributes ) { this . commonNodeAttributes = ( CommonNodeAttributes ) c ; } else if ( c instanceof Node ) { this . nodes . add ( ( Node ) c ) ; } else if ( c instanceof Identifier ) { this . identifiers . add ( ( Identifier ) c ) ; } else if ( c instanceof Edge ) { this . edges . add ( ( Edge ) c ) ; } else if ( c instanceof Subgraph ) { this . subgraphs . add ( ( Subgraph ) c ) ; } } ) ; } }'", "label": "'Adds one or more { @link Statement } objects to this { @link Statements } holder .'"}
{"text": "'public Node findNode ( final String identifier , final boolean recursive ) { Optional < Node > toReturn = getNodes ( ) . stream ( ) . filter ( c -> c . getId ( ) . equals ( identifier ) ) . findFirst ( ) ; if ( ! toReturn . isPresent ( ) && recursive && getSubgraphs ( ) != null && ! getSubgraphs ( ) . isEmpty ( ) ) { // Does the Node with the given identifier exist in any Subgraph? toReturn = getSubgraphs ( ) . stream ( ) . map ( c -> c . getStatements ( ) . findNode ( identifier , true ) ) . filter ( c -> c != null ) . findFirst ( ) ; } // All Done. return toReturn . orElse ( null ) ; }'", "label": "'Finds the Node with the supplied identifier within this Statements ( and within any contained Subgraphs if the { @code recursive } flag is true ) .'"}
{"text": "'public Edge findEdge ( final String fromId , final String toId , final boolean recursive ) { Optional < Edge > toReturn = getEdges ( ) . stream ( ) . filter ( c -> c . getId ( ) . equals ( fromId ) && c . getRightSideEdge ( ) . getId ( ) . equals ( toId ) ) . findFirst ( ) ; if ( ! toReturn . isPresent ( ) && recursive ) { // Does the Node with the given identifier exist in any Subgraph? toReturn = subgraphs . stream ( ) . map ( c -> c . getStatements ( ) . findEdge ( fromId , toId , true ) ) . findFirst ( ) ; } // All Done. return toReturn . orElse ( null ) ; }'", "label": "'Finds the Edge with the supplied identifier within this Statements ( and within any contained Subgraphs if the { @code recursive } flag is true ) .'"}
{"text": "'public Subgraph findSubgraph ( final String identifier , final boolean recursive ) { Optional < Subgraph > toReturn = getSubgraphs ( ) . stream ( ) . filter ( c -> c . getId ( ) . equals ( identifier ) ) . findFirst ( ) ; if ( ! toReturn . isPresent ( ) && recursive && getSubgraphs ( ) != null && ! getSubgraphs ( ) . isEmpty ( ) ) { // Does the Node with the given identifier exist in any Subgraph? toReturn = getSubgraphs ( ) . stream ( ) . map ( c -> c . getStatements ( ) . findSubgraph ( identifier , true ) ) . filter ( c -> c != null ) . findFirst ( ) ; } // All Done. return toReturn . orElse ( null ) ; }'", "label": "'Finds the Subgraph with the supplied identifier within this Statements ( and within any contained Subgraphs if the { @code recursive } flag is true ) .'"}
{"text": "'public Edge addEdge ( final String fromId , final String toId , final Graph parentGraph ) { // Check sanity if ( fromId == null || fromId . isEmpty ( ) ) { throw new IllegalArgumentException ( \"Cannot handle null or empty \\'fromId\\' argument.\" ) ; } if ( toId == null || toId . isEmpty ( ) ) { throw new IllegalArgumentException ( \"Cannot handle null or empty \\'toId\\' argument.\" ) ; } if ( parentGraph == null ) { throw new IllegalArgumentException ( \"Cannot handle null \\'parentGraph\\' argument.\" ) ; } Edge toReturn = null ; // Find the nodes between which the Edge should be created. final Node fromNode = findNode ( fromId , true ) ; final Subgraph fromSubgraph = findSubgraph ( fromId , true ) ; if ( fromNode != null || fromSubgraph != null ) { // Find the RHS edge data. final Node toNode = findNode ( toId , true ) ; final Subgraph toSubgraph = findSubgraph ( toId , true ) ; final NodeID toNodeId = toNode == null ? null : toNode . getNodeID ( ) ; // Can we actually create an Edge? if ( toNodeId != null || toSubgraph != null ) { // Start by creating the RightSideEdge. final RightSideEdge rightSideEdge = toNodeId == null ? new RightSideEdge ( toSubgraph ) : new RightSideEdge ( toNodeId ) ; // Finally, create the Edge to return. toReturn = fromNode == null ? new Edge ( fromSubgraph , rightSideEdge ) : new Edge ( fromNode . getNodeID ( ) , rightSideEdge ) ; } } // Add the newly created Edge, if applicable. if ( toReturn != null ) { add ( toReturn ) ; } // All Done. return toReturn ; }'", "label": "'Convenience method to add and return an Edge between a Node / Subgraph and another Node / Subgraph .'"}
{"text": "'public void execute ( ) throws MojoExecutionException , MojoFailureException { if ( skip ) { return ; } if ( ! skipExec ) { if ( checkstyleRules != null ) { if ( ! \"sun_checks.xml\" . equals ( configLocation ) ) { throw new MojoExecutionException ( \"If you use inline configuration for rules, don\\'t specify \" + \"a configLocation\" ) ; } if ( checkstyleRules . getChildCount ( ) > 1 ) { throw new MojoExecutionException ( \"Currently only one root module is supported\" ) ; } PlexusConfiguration checkerModule = checkstyleRules . getChild ( 0 ) ; try { FileUtils . forceMkdir ( rulesFiles . getParentFile ( ) ) ; FileUtils . fileWrite ( rulesFiles , CHECKSTYLE_FILE_HEADER + checkerModule . toString ( ) ) ; } catch ( final IOException e ) { throw new MojoExecutionException ( e . getMessage ( ) , e ) ; } configLocation = rulesFiles . getAbsolutePath ( ) ; } ClassLoader currentClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { CheckstyleExecutorRequest request = new CheckstyleExecutorRequest ( ) ; request . setConsoleListener ( getConsoleListener ( ) ) . setConsoleOutput ( consoleOutput ) . setExcludes ( excludes ) . setFailsOnError ( failsOnError ) . setIncludes ( includes ) . setResourceIncludes ( resourceIncludes ) . setResourceExcludes ( resourceExcludes ) . setIncludeResources ( includeResources ) . setIncludeTestResources ( includeTestResources ) . setIncludeTestSourceDirectory ( includeTestSourceDirectory ) . setListener ( getListener ( ) ) . setProject ( project ) . setSourceDirectories ( getSourceDirectories ( ) ) . setResources ( resources ) . setTestResources ( testResources ) . setStringOutputStream ( stringOutputStream ) . setSuppressionsLocation ( suppressionsLocation ) . setTestSourceDirectories ( getTestSourceDirectories ( ) ) . setConfigLocation ( configLocation ) . setConfigurationArtifacts ( collectArtifacts ( \"config\" ) ) . setPropertyExpansion ( propertyExpansion ) . setHeaderLocation ( headerLocation ) . setLicenseArtifacts ( collectArtifacts ( \"license\" ) ) . setCacheFile ( cacheFile ) . setSuppressionsFileExpression ( suppressionsFileExpression ) . setEncoding ( encoding ) . setPropertiesLocation ( propertiesLocation ) ; checkstyleExecutor . executeCheckstyle ( request ) ; } catch ( CheckstyleException e ) { throw new MojoExecutionException ( \"Failed during checkstyle configuration\" , e ) ; } catch ( CheckstyleExecutorException e ) { throw new MojoExecutionException ( \"Failed during checkstyle execution\" , e ) ; } finally { //be sure to restore original context classloader Thread . currentThread ( ) . setContextClassLoader ( currentClassLoader ) ; } } if ( ! \"xml\" . equals ( outputFileFormat ) ) { throw new MojoExecutionException ( \"Output format is \\'\" + outputFileFormat + \"\\', checkstyle:check requires format to be \\'xml\\'.\" ) ; } if ( ! outputFile . exists ( ) ) { getLog ( ) . info ( \"Unable to perform checkstyle:check, unable to find checkstyle:checkstyle outputFile.\" ) ; return ; } Reader reader = null ; try { reader = new BufferedReader ( ReaderFactory . newXmlReader ( outputFile ) ) ; XmlPullParser xpp = new MXParser ( ) ; xpp . setInput ( reader ) ; int violations = countViolations ( xpp ) ; if ( violations > maxAllowedViolations ) { if ( failOnViolation ) { String msg = \"You have \" + violations + \" Checkstyle violation\" + ( ( violations > 1 ) ? \"s\" : \"\" ) + \".\" ; if ( maxAllowedViolations > 0 ) { msg += \" The maximum number of allowed violations is \" + maxAllowedViolations + \".\" ; } throw new MojoFailureException ( msg ) ; } getLog ( ) . warn ( \"checkstyle:check violations detected but failOnViolation set to false\" ) ; } reader . close ( ) ; reader = null ; } catch ( IOException | XmlPullParserException e ) { throw new MojoExecutionException ( \"Unable to read Checkstyle results xml: \" + outputFile . getAbsolutePath ( ) , e ) ; } finally { IOUtil . close ( reader ) ; } }'", "label": "'{'"}
{"text": "'private boolean isViolation ( String severity ) { if ( \"error\" . equals ( severity ) ) { return \"error\" . equals ( violationSeverity ) || \"warning\" . equals ( violationSeverity ) || \"info\" . equals ( violationSeverity ) ; } else if ( \"warning\" . equals ( severity ) ) { return \"warning\" . equals ( violationSeverity ) || \"info\" . equals ( violationSeverity ) ; } else if ( \"info\" . equals ( severity ) ) { return \"info\" . equals ( violationSeverity ) ; } else { return false ; } }'", "label": "'Checks if the given severity is considered a violation .'"}
{"text": "'private static Map < String , Set > compareAndAggregate ( Map sourceMap , Map targetMap ) { //keys witch values are different System . out . println ( \"compare maps\" ) ; System . out . println ( \"source: \" + sourceMap ) ; System . out . println ( \"target: \" + targetMap ) ; Map < String , Set > aggregationInfo = new HashMap < String , Set > ( ) ; Set < Object > keysForDiffValues = new HashSet < Object > ( ) ; for ( Object regionKey : targetMap . keySet ( ) ) { if ( ! targetMap . get ( regionKey ) . equals ( sourceMap . get ( regionKey ) ) ) //we compare not original values, but it\\'s hash code keysForDiffValues . add ( regionKey ) ; } aggregationInfo . put ( \"diffValues\" , keysForDiffValues ) ; return aggregationInfo ; }'", "label": "'compare two snapshots from source and target maps format : key : absentKeys or map'"}
{"text": "'@ Transient public String getTopicSearchText ( ) { if ( topicXML == null ) return \"\" ; final Source source = new Source ( topicXML ) ; source . fullSequentialParse ( ) ; return source . getTextExtractor ( ) . toString ( ) ; }'", "label": "'This function will take the XML in the topicXML String and use it to generate a text only view . The text extraction uses Jericho - http : // jericho . htmlparser . net /'"}
{"text": "'public void iconSeverity ( String level ) { sink . figure ( ) ; sink . figureGraphics ( \"images/icon_\" + level + \"_sml.gif\" ) ; sink . figure_ ( ) ; }'", "label": "'Render a simple icon of given level .'"}
{"text": "'public void iconSeverity ( String level , int textType ) { sink . figure ( ) ; sink . figureGraphics ( \"images/icon_\" + level + \"_sml.gif\" ) ; sink . figure_ ( ) ; if ( textType > 0 ) { sink . nonBreakingSpace ( ) ; sink . text ( bundle . getString ( \"report.checkstyle.\" + level + suffix ( textType ) ) ) ; } }'", "label": "'Render an icon of given level with associated text .'"}
{"text": "'@ Transient public String getTagsList ( final boolean brLineBreak ) { // define the line breaks for html and for tooltips final String lineBreak = brLineBreak ? \"<br/>\" : \"\\\\n\" ; final String boldStart = brLineBreak ? \"<b>\" : \"\" ; final String boldEnd = brLineBreak ? \"</b>\" : \"\" ; final TreeMap < NameIDSortMap , ArrayList < String > > tags = new TreeMap < NameIDSortMap , ArrayList < String > > ( ) ; for ( final TagToProject tagToProject : tagToProjects ) { final Tag tag = tagToProject . getTag ( ) ; final Set < TagToCategory > tagToCategories = tag . getTagToCategories ( ) ; if ( tagToCategories . size ( ) == 0 ) { NameIDSortMap categoryDetails = new NameIDSortMap ( \"Uncategorised\" , - 1 , 0 ) ; if ( ! tags . containsKey ( categoryDetails ) ) tags . put ( categoryDetails , new ArrayList < String > ( ) ) ; tags . get ( categoryDetails ) . add ( tag . getTagName ( ) ) ; } else { for ( final TagToCategory category : tagToCategories ) { NameIDSortMap categoryDetails = new NameIDSortMap ( category . getCategory ( ) . getCategoryName ( ) , category . getCategory ( ) . getCategoryId ( ) , category . getCategory ( ) . getCategorySort ( ) == null ? 0 : category . getCategory ( ) . getCategorySort ( ) ) ; if ( ! tags . containsKey ( categoryDetails ) ) tags . put ( categoryDetails , new ArrayList < String > ( ) ) ; tags . get ( categoryDetails ) . add ( tag . getTagName ( ) ) ; } } } String tagsList = \"\" ; for ( final NameIDSortMap key : tags . keySet ( ) ) { // sort alphabetically Collections . sort ( tags . get ( key ) ) ; if ( tagsList . length ( ) != 0 ) tagsList += lineBreak ; tagsList += boldStart + key . getName ( ) + boldEnd + \": \" ; String thisTagList = \"\" ; for ( final String tag : tags . get ( key ) ) { if ( thisTagList . length ( ) != 0 ) thisTagList += \", \" ; thisTagList += tag ; } tagsList += thisTagList + \" \" ; } return tagsList ; }'", "label": "'Generates a HTML formatted and categorized list of the tags that are associated with this topic'"}
{"text": "'public void executeReport ( final Locale locale ) throws MavenReportException { locator . addSearchPath ( FileResourceLoader . ID , project . getFile ( ) . getParentFile ( ) . getAbsolutePath ( ) ) ; locator . addSearchPath ( \"url\" , \"\" ) ; locator . setOutputDirectory ( new File ( project . getBuild ( ) . getDirectory ( ) ) ) ; // for when we start using maven-shared-io and maven-shared-monitor... // locator = new Locator( new MojoLogMonitorAdaptor( getLog() ) ); // locator = new Locator( getLog(), new File( project.getBuild().getDirectory() ) ); ClassLoader currentClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { CheckstyleExecutorRequest request = createRequest ( ) . setLicenseArtifacts ( collectArtifacts ( \"license\" ) ) . setConfigurationArtifacts ( collectArtifacts ( \"configuration\" ) ) ; CheckstyleResults results = checkstyleExecutor . executeCheckstyle ( request ) ; ResourceBundle bundle = getBundle ( locale ) ; generateReportStatics ( ) ; generateMainReport ( results , bundle ) ; if ( enableRSS ) { CheckstyleRssGeneratorRequest checkstyleRssGeneratorRequest = new CheckstyleRssGeneratorRequest ( this . project , this . getCopyright ( ) , outputDirectory , getLog ( ) ) ; checkstyleRssGenerator . generateRSS ( results , checkstyleRssGeneratorRequest ) ; } } catch ( CheckstyleException e ) { throw new MavenReportException ( \"Failed during checkstyle configuration\" , e ) ; } catch ( CheckstyleExecutorException e ) { throw new MavenReportException ( \"Failed during checkstyle execution\" , e ) ; } finally { //be sure to restore original context classloader Thread . currentThread ( ) . setContextClassLoader ( currentClassLoader ) ; } }'", "label": "'{'"}
{"text": "'@ Transient public void setNextAndClean ( CSNode next ) { setNextInternal ( next ) ; if ( next != null ) { next . setPreviousInternal ( this ) ; } }'", "label": "'Sets the Next Node and cleans up any old references .'"}
{"text": "'@ Transient public void setPreviousAndClean ( CSNode previous ) { setPreviousInternal ( previous ) ; if ( previous != null ) { previous . setNextInternal ( this ) ; } }'", "label": "'Sets the Previous Node and cleans up any old references .'"}
{"text": "'public static < T extends AuditedEntity > Date getFixedLastModifiedDate ( final EntityManager entityManager , final T entity ) { return entity . getLastModifiedDate ( ) != null ? entity . getLastModifiedDate ( ) : getLatestRevisionDate ( entityManager , entity ) ; }'", "label": "'When returning a collection of entity revisions the lastModified property is set automatically ( in the getRevision method ) . For entities returned from a database query the last modified date needs to be found manually .'"}
{"text": "'public Node find ( String host , int port ) { return socketToNodeMap . get ( Utils . toKey ( host , port ) ) ; }'", "label": "'Finds the node by host and port .'"}
{"text": "'public Set < Node > find ( String host ) { Set < Node > resultSet = new HashSet < Node > ( ) ; if ( host != null ) { for ( Node node : socketToNodeMap . values ( ) ) { if ( host . equals ( node . getHost ( ) ) ) { resultSet . add ( node ) ; } } } return resultSet ; }'", "label": "'Finds the set of nodes by host .'"}
{"text": "'public Set < Node > getAllNotDead ( ) { Set < Node > allNotDeadNodesSet = new HashSet < Node > ( ) ; for ( Node node : socketToNodeMap . values ( ) ) { if ( ! NodeStatus . DEAD . equals ( node . getStatus ( ) ) ) { allNotDeadNodesSet . add ( node ) ; } } return allNotDeadNodesSet ; }'", "label": "'Gets all the nodes not in status DEAD .'"}
{"text": "'public void add ( Node node ) { socketToNodeMap . put ( Utils . toKey ( node ) , node ) ; sendEvent ( node , NodeEventType . ADDED ) ; }'", "label": "'Adds one more node to the container .'"}
{"text": "'public void remove ( Node node ) { socketToNodeMap . remove ( Utils . toKey ( node ) ) ; sendEvent ( node , NodeEventType . REMOVED ) ; }'", "label": "'Removes the specified node .'"}
{"text": "'public void markAsAlive ( Node node ) { if ( ! NodeStatus . ALIVE . equals ( node . getStatus ( ) ) ) { socketToNodeMap . get ( Utils . toKey ( node ) ) . markAsAlive ( ) ; sendEvent ( node , NodeEventType . MARKED_AS_ALIVE ) ; } }'", "label": "'Marks the node as ALIVE in case of its status is not ALIVE .'"}
{"text": "'public void markAsDead ( Node node ) { if ( ! NodeStatus . DEAD . equals ( node . getStatus ( ) ) ) { socketToNodeMap . get ( Utils . toKey ( node ) ) . markAsDead ( ) ; sendEvent ( node , NodeEventType . MARKED_AS_DEAD ) ; } }'", "label": "'Marks the node as DEAD in case of its status is not DEAD .'"}
{"text": "'private void sendEvent ( Node node , NodeEventType type ) { NodeEvent event = new NodeEvent ( node , type ) ; for ( NodeEventHandler handler : handlers ) { handler . handle ( event ) ; } }'", "label": "'Sends the event to all the handlers .'"}
{"text": "'public < Concept , S extends Statement > AbstractStatementConverter < Concept , S > get ( final Class < Concept > conceptClass ) { // Check sanity if ( conceptClass == null ) { throw new NullPointerException ( \"Cannot handle null \\'conceptClass\\' argument.\" ) ; } // Fetch stashed converters final AbstractStatementConverter < Concept , S > toReturn = statementConverters . get ( conceptClass ) ; if ( toReturn == null && log . isDebugEnabled ( ) ) { log . debug ( \"No AbstractStatementConverter to convert [\" + conceptClass . getName ( ) + \"] into a Statement subtype was registered.\" ) ; } // All Done. return toReturn ; }'", "label": "'Retrieves an { @link AbstractStatementConverter } subclass which can convert the given Concept class into a { @link Statement } . Null arguments are not permitted .'"}
{"text": "'public < Concept , S extends Statement > void put ( final Class < Concept > conceptClass , final AbstractStatementConverter < Concept , S > converter ) { // Check sanity if ( conceptClass == null ) { throw new NullPointerException ( \"Cannot handle null \\'conceptClass\\' argument.\" ) ; } if ( converter == null ) { throw new NullPointerException ( \"Cannot handle null \\'converter\\' argument.\" ) ; } }'", "label": "'Adds the supplied { @link AbstractStatementConverter } for the given Concept class . Null arguments are not permitted .'"}
{"text": "'@ Override public final Graph convert ( final From toConvert ) { // Handle nulls if ( toConvert == null && ! acceptsNullValues ( ) ) { throw new IllegalArgumentException ( \"Converter [\" + getClass ( ) . getName ( ) + \"] cannot accept null \\'toConvert\\' arguments.\" ) ; } // All Done return doConvert ( toConvert ) ; }'", "label": "'{'"}
{"text": "'private String getCheckstyleVersion ( ) { Package checkstyleApiPackage = Configuration . class . getPackage ( ) ; return ( checkstyleApiPackage == null ) ? null : checkstyleApiPackage . getImplementationVersion ( ) ; }'", "label": "'Get the effective Checkstyle version at runtime .'"}
{"text": "'private void configureResourceLocator ( final ResourceManager resourceManager , final CheckstyleExecutorRequest request , final List < Artifact > additionalArtifacts ) { final MavenProject project = request . getProject ( ) ; resourceManager . setOutputDirectory ( new File ( project . getBuild ( ) . getDirectory ( ) ) ) ; // Recurse up the parent hierarchy and add project directories to the search roots MavenProject parent = project ; while ( parent != null && parent . getFile ( ) != null ) { // MCHECKSTYLE-131 ( olamy ) I don\\'t like this hack. // (dkulp) Me either.   It really pollutes the location stuff // by allowing searches of stuff outside the current module. File dir = parent . getFile ( ) . getParentFile ( ) ; resourceManager . addSearchPath ( FileResourceLoader . ID , dir . getAbsolutePath ( ) ) ; parent = parent . getParent ( ) ; } resourceManager . addSearchPath ( \"url\" , \"\" ) ; // MCHECKSTYLE-225: load licenses from additional artifacts, not from classpath if ( additionalArtifacts != null ) { for ( Artifact licenseArtifact : additionalArtifacts ) { try { // MCHECKSTYLE-287, MCHECKSTYLE-294: Ignore null licenseArtifacts ... if ( licenseArtifact != null ) { if ( getLogger ( ) . isDebugEnabled ( ) ) { getLogger ( ) . debug ( \"Adding licenceArtifact [\" + licenseArtifact . getGroupId ( ) + \":\" + licenseArtifact . getArtifactId ( ) + \":\" + licenseArtifact . getVersion ( ) + \"] to resourceManager.\" ) ; } resourceManager . addSearchPath ( \"jar\" , \"jar:\" + licenseArtifact . getFile ( ) . toURI ( ) . toURL ( ) ) ; } } catch ( MalformedURLException e ) { // noop } } } }'", "label": "'Configures search paths in the resource locator . This method should only be called once per execution .'"}
{"text": "'@ Override public boolean start ( final RootDoc root ) { // Check sanity if ( this . dotFacade == null ) { throw new IllegalStateException ( \"The DotFacade cannot be null.\" ) ; } // Wrap the received RootDoc instance. final VisualizationWrappedRootDoc rootDoc = new VisualizationWrappedRootDoc ( root ) ; htmlDoclet . configuration . root = root ; try { htmlDoclet . configuration . setOptions ( ) ; } catch ( Configuration . Fault fault ) { fault . printStackTrace ( ) ; } for ( ClassDoc cDoc : rootDoc . classes ( ) ) { // Log somewhat if ( log . isDebugEnabled ( ) ) { log . debug ( getJavaDocAndTagsLog ( cDoc ) ) ; } } for ( PackageDoc pDoc : rootDoc . specifiedPackages ( ) ) { // Log somewhat if ( log . isDebugEnabled ( ) ) { log . debug ( getJavaDocAndTagsLog ( pDoc ) ) ; } } // Convert the DOT-generated Map and write the image. // dotFacade.writePngImageAndImageMap(rootDoc, theDotDiagram, outputDirectory, fileName); // Delegate further execution to the standard Doclet. return HtmlDoclet . start ( root ) ; }'", "label": "'{'"}
{"text": "'@ Override public boolean validateJavaDocOptions ( final String [ ] [ ] options , final DocErrorReporter errorReporter ) { // This Visualization Doclet recognizes no special options. // Simply delegate to the standard doclet. try { htmlDoclet . sharedInstanceForOptions . setOptions ( options ) ; } catch ( Configuration . Fault fault ) { fault . printStackTrace ( ) ; } // All done? return HtmlDoclet . validOptions ( options , errorReporter ) ; }'", "label": "'{'"}
{"text": "'@ Override public int optionLength ( final String option ) { // #1) Handle the -help option. if ( JavaDocOption . HELP . getOption ( ) . equals ( option ) ) { // First, provide the help text from the Standard Doclet. final int toReturn = HtmlDoclet . optionLength ( option ) ; // Print the options provided by VisualizationDoclet. System . out . println ( ) ; System . out . println ( \"Provided by \" + VisualizationDoclet . class . getName ( ) + \":\" ) ; for ( JavaDocOption current : JavaDocOption . values ( ) ) { if ( current != JavaDocOption . HELP ) { System . out . println ( current . getOption ( ) + \" \" + current . getHelpText ( ) ) ; } } // Delegate to the standard Doclet implementation. return toReturn ; } // #2) Handle all JavaDoc options known to this Doclet for ( JavaDocOption current : JavaDocOption . values ( ) ) { if ( current . getOption ( ) . equals ( option ) ) { return current . getOptionLength ( ) ; } } // #3) Delegate to the standard Doclet. return HtmlDoclet . optionLength ( option ) ; }'", "label": "'{'"}
{"text": "'public T build ( Object ... attributes ) { List < Object > attributeList = new ArrayList < Object > ( Arrays . asList ( attributes ) ) ; //kinda wacky but Arrays.asList returns a unmodifiable list String [ ] traitNames = getTraitNames ( attributeList ) ; applyTraits ( traitNames ) ; T object = ReflectionUtils . createObject ( factoryClass , constructorArgs ) ; // merge default properties with supplied attributes Map < String , Object > propertyValues = createObjectPropertyValues ( this . propertyValues , attributeList ) ; // now set properties and fields to the created object setProperties ( object , propertyValues ) ; setFields ( object , fieldValues ) ; executeCallbacks ( AfterFactoryBuild . class , object ) ; return object ; }'", "label": "'Build object .'"}
{"text": "'private void setProperty ( Object target , String name , Object value ) { if ( ! ReflectionUtils . setProperty ( target , name , getValue ( value ) ) ) { // no property was found, try to set the field directly setField ( target , name , value ) ; } }'", "label": "'Private methods *'"}
{"text": "\"private Map < String , Object > createObjectPropertyValues ( Map < String , Object > defaultPropertyValues , List < Object > attributes ) { Map < String , Object > propertyValues = new HashMap < String , Object > ( defaultPropertyValues ) ; if ( attributes != null ) { Iterator < Object > iterator = attributes . iterator ( ) ; Map < String , Object > propertyOverrideMap = new HashMap < String , Object > ( ) ; while ( iterator . hasNext ( ) ) { String name = ( String ) iterator . next ( ) ; // we can only create a map entry if we have both a key and value, so make sure there's a value left if ( iterator . hasNext ( ) ) { Object object = iterator . next ( ) ; propertyOverrideMap . put ( name , object ) ; } } propertyValues . putAll ( propertyOverrideMap ) ; } return propertyValues ; }\"", "label": "'Merge passed attributes with the supplied property values .'"}
{"text": "'private int currentSequence ( String name ) { Map < String , Integer > sequencesForClass = sequences . get ( getClass ( ) ) ; if ( sequencesForClass == null ) { sequencesForClass = new HashMap < String , Integer > ( ) ; sequences . put ( getClass ( ) , sequencesForClass ) ; } Integer seq = sequencesForClass . get ( name ) ; seq = seq == null ? 1 : seq + 1 ; sequencesForClass . put ( name , seq ) ; return seq ; }'", "label": "'Retrieve the current sequence value for the given property .'"}
{"text": "'@ Override protected String doRender ( final RenderConfiguration config , final Subgraph subgraph ) { final String prologue = config . getIndent ( ) + \"subgraph \" + quote ( subgraph . getId ( ) ) + \" { \" + config . getNewline ( ) ; // Render the statements within this subgraph. final Statements statements = subgraph . getStatements ( ) ; final StatementsRenderer statementsRenderer = new StatementsRenderer ( ) ; final String renderedStatements = statementsRenderer . render ( config . cloneAndChangeIndentation ( 1 ) , statements ) ; // All Done. return prologue + renderedStatements + config . getNewline ( ) + config . getIndent ( ) + \"}\" ; }'", "label": "'{'"}
{"text": "'@ Override protected String doRender ( final RenderConfiguration config , final CommonNodeAttributes entity ) { return config . getIndent ( ) + entity . getId ( ) + \" \" + attributeRenderer . render ( config , entity . getAttributes ( ) ) ; }'", "label": "'{'"}
{"text": "'@ Override protected Graph doConvert ( final Set < ClassDoc > toConvert ) { final ClassDoc [ ] clDocs = toConvert . toArray ( new ClassDoc [ toConvert . size ( ) ] ) ; final SortedMap < PackageDoc , SortedSet < ClassDoc > > clPerPackage = Comparators . sortClassesPerPackage ( clDocs ) ; final Map . Entry < PackageDoc , SortedSet < ClassDoc > > packageAndClasses = clPerPackage . entrySet ( ) . stream ( ) . filter ( e -> relevantPackage . getName ( ) . equalsIgnoreCase ( e . getKey ( ) . name ( ) ) ) . findFirst ( ) . orElseThrow ( ( ) -> new IllegalStateException ( \"No retrieved classes in expected package [\" + relevantPackage . getName ( ) + \"]. Found: \" + clPerPackage . keySet ( ) . stream ( ) . map ( Doc :: name ) . reduce ( ( l , r ) -> l + \", r\" ) . orElse ( \"<none>\" ) ) ) ; final PackageDoc packageDoc = packageAndClasses . getKey ( ) ; final SortedSet < ClassDoc > classDocs = packageAndClasses . getValue ( ) ; // Create the Graph. final Graph toReturn = new Graph ( \"Graph_\" + packageDoc . name ( ) , true , true ) ; final Subgraph packageSubgraph = new Subgraph ( packageDoc . name ( ) ) ; final CommonGraphAttributes subgraphAttrs = new CommonGraphAttributes ( ) ; packageSubgraph . add ( subgraphAttrs ) ; final GraphAttributes subAttrs = subgraphAttrs . getAttributes ( ) ; subAttrs . label = \"Package: \" + packageDoc . name ( ) ; // Add a Subgraph for the package toReturn . add ( renderPackageSubGraph ( classDocs ) ) ; // All Done. return toReturn ; }'", "label": "'{'"}
{"text": "'@ Override public int compareTo ( final NodeID that ) { // Fail fast if ( that == this ) { return 0 ; } else if ( null == that ) { return - 1 ; } // Delegate to internal state return this . getId ( ) . compareTo ( that . getId ( ) ) ; }'", "label": "'Compares the supplied NodeID to this one .'"}
{"text": "'public List < NodeEvent > getAndClearEventslist ( ) { ArrayList < NodeEvent > result = new ArrayList < NodeEvent > ( eventslist ) ; eventslist . clear ( ) ; return result ; }'", "label": "'Gets the copy of the buffer and clears the buffer .'"}
{"text": "'public static boolean containsVisualizationDocletTag ( final String message ) { if ( message != null ) { for ( VisualizationDocletTag current : VisualizationDocletTag . values ( ) ) { if ( message . contains ( current . toString ( ) + \" \" ) ) { // The message contains an entry on the form \\'@nazgul_vis.xxxx \\' // which implies that it has to do with a VisualizationDoclet javadoc Tag. return true ; } } } // Nopes. return false ; }'", "label": "'Checks if ths supplied message contains an { @link VisualizationDocletTag } reference on the form { @code @nazgul_vis . xxxx } .'"}
{"text": "'public SortedSet < PackageDoc > findPackagesFromClassesInJavaDocRun ( ) { final SortedSet < PackageDoc > toReturn = new TreeSet <> ( Comparators . PACKAGE_NAME_COMPARATOR ) ; final ClassDoc [ ] currentExecutionClasses = classes ( ) ; if ( currentExecutionClasses != null ) { Arrays . stream ( currentExecutionClasses ) . map ( ProgramElementDoc :: containingPackage ) . forEach ( toReturn :: add ) ; } // All Done. return toReturn ; }'", "label": "'Finds all PackageDoc objects from the classes in this JavaDoc execution .'"}
{"text": "'public static void checkClassIsSerialized ( final Class < ? > clazz ) throws InvalidClassException { // class checkClassIsAnnotationMarked ( clazz ) ; checkClassIsPublic ( clazz ) ; checkClassIsNotNested ( clazz ) ; // constructor Constructor < ? > constructor = checkConstructorNoArg ( clazz ) ; checkConstructorPublic ( constructor ) ; checkConstructorWithoutExceptions ( constructor ) ; checkParentConstructor ( clazz ) ; // getters Map < String , Method > gettersMap = getPropertyGetters ( clazz ) ; for ( Map . Entry < String , Method > getterEntry : gettersMap . entrySet ( ) ) { Method getter = getterEntry . getValue ( ) ; checkGetterPublic ( getter ) ; checkGetterNoArg ( getter ) ; checkGetterWithoutExceptions ( getter ) ; Method setter = getSetterForGetter ( clazz , getter ) ; checkSetterPublic ( setter ) ; checkSetterOneArg ( setter ) ; checkSetterReturnVoid ( setter ) ; checkSetterWithoutExceptions ( setter ) ; checkGetterSetterTheSameType ( getter , setter ) ; } }'", "label": "'-------------------------- PUBLIC'"}
{"text": "'protected static void checkParentConstructor ( Class < ? > clazz ) throws InvalidClassException { if ( clazz != Object . class ) { Class < ? > parentClazz = clazz . getSuperclass ( ) ; try { checkConstructorNoArg ( parentClazz ) ; } catch ( InvalidClassException e ) { checkClassIsAnnotationMarked ( parentClazz ) ; } } }'", "label": "'Checks if parent class ( if exists ) is annotated as AutoSerializable or have parameterless public constructor .'"}
{"text": "'protected static Map < String , Method > getPropertyGetters ( Class < ? > clazz ) { //todo: clazz.getDeclaredMethods() + hierarchy up OR clazz.getMethods()? Map < String , Method > result = new HashMap < String , Method > ( ) ; if ( clazz != Object . class ) { Method [ ] methodArr = clazz . getMethods ( ) ; for ( Method method : methodArr ) { if ( isNameSuitableForGetter ( method ) ) { if ( method . getDeclaringClass ( ) != Object . class && ! method . isBridge ( ) ) { //remove Object.getClass() final Annotation [ ] annArr = method . getDeclaredAnnotations ( ) ; boolean find = false ; for ( Annotation ann : annArr ) { if ( ann . annotationType ( ) == Transient . class ) { find = true ; break ; } } if ( ! find ) { String fieldName ; if ( method . getReturnType ( ) == Boolean . TYPE && method . getName ( ) . startsWith ( \"is\" ) ) fieldName = method . getName ( ) . substring ( 2 , 3 ) . toLowerCase ( ) + method . getName ( ) . substring ( 3 ) ; else fieldName = method . getName ( ) . substring ( 3 , 4 ) . toLowerCase ( ) + method . getName ( ) . substring ( 4 ) ; result . put ( fieldName , method ) ; } } } } clazz = clazz . getSuperclass ( ) ; } return result ; }'", "label": "'1 ) move hierarchy up 2 ) look for method with name 3 ) check @TransientGetter'"}
{"text": "'public static synchronized List < Class < ? > > generateDataSerializerClasses ( ClassLoader classLoader , List < Class < ? > > classList , String outputDir ) throws CannotCompileException , InvalidClassException { checkClassesValid ( classList ) ; List < CtClass > dataSerializerClassList = new ArrayList < CtClass > ( ) ; // create new ClassPool for every method call // 1) low memory consumption - any caches with internal data structures of created classes // 2) any collision between methods called serially - all crated classes are forgotten // 3) any references on created classes from this lib ClassPool classPool = newClassPool ( classLoader ) ; // #1: create dataSerializers with stubs toData/fromData for ( Class < ? > clazz : classList ) { String serializerClsName = createDataSerializerClassNameForClass ( clazz ) ; if ( existsClass ( serializerClsName , classLoader ) ) { logger . debug ( \"Serializer for class {} exists. Skipping generation\" , clazz . getName ( ) ) ; break ; } // create class CtClass cc = createClass ( classPool , clazz , serializerClsName ) ; dataSerializerClassList . add ( cc ) ; // add static Register addStaticConstruct ( clazz , cc , serializerClsName ) ; // add methods addMethodGetId ( clazz , cc ) ; addMethodGetSupportedClasses ( clazz , cc ) ; // add stub-methods toData/fromData addMethodToDataStub ( clazz , cc ) ; addMethodFromDataStub ( clazz , cc ) ; // we need this for Javassist do some magic with CtClass try { cc . toBytecode ( ) ; } catch ( IOException e ) { throw new CannotCompileException ( \"Error during end of compilation phase #1 (call CtClass.toBytecode() for some Javassist-magic with CtClass) for \" + cc . getName ( ) , e ) ; } catch ( CannotCompileException e ) { throw new CannotCompileException ( \"Error during end of compilation phase #1 (call CtClass.toBytecode() for some Javassist-magic with CtClass) for \" + cc . getName ( ) , e ) ; } } List < Class < ? > > result = new ArrayList < Class < ? > > ( ) ; // #2: change stubs toData/fromData in dataSerializers -> real methods for ( int k = 0 ; k < classList . size ( ) ; k ++ ) { Class < ? > clazz = classList . get ( k ) ; CtClass cc = dataSerializerClassList . get ( k ) ; // make changing methods real: defrost CtClass cc . defrost ( ) ; // change stub toData/fromData -> real methods addMethodToData ( clazz , cc ) ; addMethodFromData ( clazz , cc ) ; // generate result final Class < ? > resultClass ; try { resultClass = cc . toClass ( classLoader , null ) ; // ProtectionDomain == null logger . info ( \"compiled data serializer for class: {}; id: {}; version: {}\" , new Object [ ] { clazz , clazz . getAnnotation ( AutoSerializable . class ) . dataSerializerID ( ) , clazz . getAnnotation ( BeanVersion . class ) . value ( ) } ) ; if ( ( outputDir != null ) && ( outputDir . length ( ) > 0 ) ) { try { cc . writeFile ( outputDir ) ; } catch ( IOException e ) { throw new RuntimeException ( \"couldn\\'t save DataSerializer for class \" + clazz . getName ( ) , e ) ; } } } catch ( CannotCompileException e ) { throw new CannotCompileException ( \"Error during end of compilation phase #2 (call CtClass.toClass()) for \" + cc . getName ( ) + \". Probably you second time try generate and load DataSerializer class \" + cc . getName ( ) + \" for class \" + clazz . getName ( ) , e ) ; } // dump code to listener if ( listener != null ) { listener . generated ( clazz . getName ( ) , cc . getName ( ) , new ClassProcessor ( ) . process ( new XClass ( clazz ) , cc . getName ( ) ) ) ; } result . add ( resultClass ) ; } return result ; }'", "label": "'2 - stage compilation scheme of group of classes : <p > hack from http : // www . csg . is . titech . ac . jp / ~chiba / javassist / tutorial / tutorial2 . html#add <p > order of return of serializer - classes in response corresponds to order of arg - classes'"}
{"text": "\"private static boolean existsClass ( String clsName , ClassLoader clsLoader ) { String resource = clsName . replace ( ' ' , ' ' ) ; return clsLoader . getResource ( resource ) != null ; }\"", "label": "'TODO .'"}
{"text": "'private static void checkClassesValid ( List < Class < ? > > classList ) throws InvalidClassException { // check classes is valid for generating DataSerializer, if not - throw NotSerializableException with detailed // reason for ( Class < ? > clazz : classList ) { Introspector . checkClassIsSerialized ( clazz ) ; } // check classes do not contain duplicated @AutoSerializable.dataSerializerID checkDataSerializerIDIsUnique ( classList ) ; }'", "label": "'------------------------ PRIVATE'"}
{"text": "'@ Override @ SuppressWarnings ( \"PMD.PreserveStackTrace\" ) protected void performValidation ( final MavenProject project , final EnforcerRuleHelper helper ) throws RuleFailureException { try { ProjectType . getProjectType ( project ) ; } catch ( IllegalArgumentException e ) { throw new RuleFailureException ( e . getMessage ( ) ) ; } }'", "label": "'Delegate method implemented by concrete subclasses .'"}
{"text": "'public String process ( XProperty field ) { String fieldName = field . getName ( ) ; String getter = \"get\" + CodeGenUtils . firstLetterToUpperCase ( fieldName ) + \"()\" ; String allowJavaSerialization = Boolean . toString ( Configuration . get ( ) . isJavaSerializationEnabled ( ) ) ; return \"if (concrete.\" + getter + \" == null) {\\\\n\" + tab ( \"out.writeByte(0);\\\\n\" ) + \"} else {\\\\n\" + tab ( \"out.writeByte(1);\\\\n\" ) + tab ( \"com.gemstone.gemfire.DataSerializer.writeObject(concrete.\" + getter + \", out, \" + allowJavaSerialization + \");\\\\n\" ) + \"}\\\\n\" ; }'", "label": "'}'"}
{"text": "'@ Override public void execute ( FunctionContext functionContext ) { Map < String , Object > args = ( HashMap ) functionContext . getArguments ( ) ; String regionName = ( String ) args . get ( \"regionName\" ) ; Region region = CacheFactory . getAnyInstance ( ) . getRegion ( regionName ) ; if ( region == null ) { functionContext . getResultSender ( ) . lastResult ( new HashSet ( ) ) ; return ; } int bucket = 0 ; if ( PartitionRegionHelper . isPartitionedRegion ( region ) ) { bucket = ( Integer ) args . get ( \"bucket\" ) ; //todo: NPE if actual region is different from parameter (replicate vs partition) PartitionedRegion pr = ( PartitionedRegion ) region ; Set keys = new HashSet ( ) ; if ( pr . getDataStore ( ) . getAllLocalPrimaryBucketIds ( ) . contains ( bucket ) ) { try { keys . addAll ( pr . getDataStore ( ) . getKeysLocally ( bucket ) ) ; } catch ( Exception e ) { throw new RuntimeException ( \"error getting local keys for bucket \" + bucket , e ) ; } } functionContext . getResultSender ( ) . lastResult ( ( HashSet ) keys ) ; return ; } //todo: it\\'s ugly. better: to ask a particular batch of keys (between oldBatch upper bound and nextBatch lower bound) Set keys = region . keySet ( ) ; Iterator iterator = keys . iterator ( ) ; Set keysBatch = new HashSet ( BATCH_SIZE ) ; while ( iterator . hasNext ( ) ) { keysBatch . add ( iterator . next ( ) ) ; if ( ( keysBatch . size ( ) + 1 ) % BATCH_SIZE == 0 ) { functionContext . getResultSender ( ) . sendResult ( ( HashSet ) keysBatch ) ; keysBatch = new HashSet ( BATCH_SIZE ) ; } } functionContext . getResultSender ( ) . lastResult ( ( HashSet ) keysBatch ) ; }'", "label": "'todo : how to customize this parameter . also it exists in regioninfofunction . ugly .'"}
{"text": "'@ Override public final String render ( final RenderConfiguration configuration , final Object entity ) { // Check sanity if ( configuration == null ) { throw new IllegalArgumentException ( \"Cannot handle null \\'configuration\\' argument.\" ) ; } if ( entity == null ) { throw new IllegalArgumentException ( \"Cannot handle null \\'entity\\' argument.\" ) ; } if ( ! accept ( entity ) ) { throw new IllegalArgumentException ( \"Entity of type [\" + entity . getClass ( ) . getName ( ) + \"] was not accepted for rendering. Only [\" + acceptedType . getName ( ) + \"] types can be rendered by this \" + getClass ( ) . getSimpleName ( ) + \" renderer.\" ) ; } // Find out the combination of newline and \\';\\' which should be emitted after rendering. String epilogue = \"\" ; if ( entity instanceof Subgraph ) { epilogue = configuration . getNewline ( ) ; } else if ( entity instanceof Statement ) { epilogue = \" ;\" + configuration . getNewline ( ) ; } // All Done. final T castEntity = acceptedType . cast ( entity ) ; return doRender ( configuration , castEntity ) + epilogue ; }'", "label": "'{'"}
{"text": "'@ Override public boolean accept ( final Object entity ) { return entity != null && acceptedType . isAssignableFrom ( entity . getClass ( ) ) ; }'", "label": "'{'"}
{"text": "'public static boolean setProperty ( Object target , String name , Object value ) { try { for ( PropertyDescriptor pd : Introspector . getBeanInfo ( target . getClass ( ) ) . getPropertyDescriptors ( ) ) { if ( pd . getWriteMethod ( ) != null && pd . getName ( ) . equals ( name ) ) { pd . getWriteMethod ( ) . invoke ( target , value ) ; return true ; } } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } return false ; }'", "label": "'Set the property identified by name to the provided value .'"}
{"text": "'public static boolean setField ( Object target , String name , Object value ) { try { Field field = target . getClass ( ) . getDeclaredField ( name ) ; field . setAccessible ( true ) ; field . set ( target , value ) ; return true ; } catch ( NoSuchFieldException e ) { return false ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }'", "label": "'Set the field identified by name to the given value .'"}
{"text": "'public static List < Method > getAnnotatedMethods ( Class targetClass , Class < ? extends Annotation > annotationType ) { List < Method > annotatedMethods = new ArrayList < Method > ( ) ; for ( Method method : targetClass . getDeclaredMethods ( ) ) { if ( method . isAnnotationPresent ( annotationType ) ) { annotatedMethods . add ( method ) ; } } return annotatedMethods ; }'", "label": "'Get all methods on the given class that are annotated with the given annotation type .'"}
{"text": "'public static void invokeMethod ( Object target , Method method , Object ... arguments ) { method . setAccessible ( true ) ; // so we can call private and protected methods too try { method . invoke ( target , arguments ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }'", "label": "'Invoke the given method on the given target using the given arguments . Allows to call private and protected methods .'"}
{"text": "'public static < T > T createObject ( Class < T > clazz , Object ... constructorArgs ) { if ( constructorArgs == null ) return createObject ( clazz ) ; T object ; Class [ ] parameterTypes = new Class [ constructorArgs . length ] ; for ( int i = 0 ; i < constructorArgs . length ; i ++ ) { parameterTypes [ i ] = constructorArgs [ i ] . getClass ( ) ; } try { Constructor ctor = clazz . getConstructor ( parameterTypes ) ; object = ( T ) ctor . newInstance ( constructorArgs ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } return object ; }'", "label": "'Create an empty object of the given class .'"}
{"text": "'public static < T > T createObject ( Class < T > clazz ) { T object ; try { object = clazz . newInstance ( ) ; } catch ( InstantiationException e ) { throw new RuntimeException ( e ) ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( e ) ; } return object ; }'", "label": "'Create an empty object of the given class .'"}
{"text": "'public static void main ( String [ ] args ) throws Exception { if ( args . length > 0 ) { loadClasses ( args [ 0 ] ) ; } startCacheServer ( ) ; ConsoleUtils . waitForEnter ( JavaProcessLauncher . PROCESS_STARTUP_COMPLETED ) ; stopCacheServer ( ) ; }'", "label": "'Server entry point .'"}
{"text": "'private String getConfigAttribute ( Configuration config , ChainedItem < Configuration > parentConfiguration , String attributeName , String defaultValue ) { String ret ; try { ret = config . getAttribute ( attributeName ) ; } catch ( CheckstyleException e ) { // Try to find the attribute in a parent, if there are any if ( parentConfiguration != null ) { ret = getConfigAttribute ( parentConfiguration . value , parentConfiguration . parent , attributeName , defaultValue ) ; } else { ret = defaultValue ; } } return ret ; }'", "label": "'Get the value of the specified attribute from the Checkstyle configuration . If parentConfigurations is non - null and non - empty the parent configurations are searched if the attribute cannot be found in the current configuration . If the attribute is still not found the specified default value will be returned .'"}
{"text": "'private void doRulesSummary ( CheckstyleResults results ) { if ( checkstyleConfig == null ) { return ; } sink . section1 ( ) ; sink . sectionTitle1 ( ) ; sink . text ( bundle . getString ( \"report.checkstyle.rules\" ) ) ; sink . sectionTitle1_ ( ) ; sink . table ( ) ; sink . tableRow ( ) ; sink . tableHeaderCell ( ) ; sink . text ( bundle . getString ( \"report.checkstyle.rule.category\" ) ) ; sink . tableHeaderCell_ ( ) ; sink . tableHeaderCell ( ) ; sink . text ( bundle . getString ( \"report.checkstyle.rule\" ) ) ; sink . tableHeaderCell_ ( ) ; sink . tableHeaderCell ( ) ; sink . text ( bundle . getString ( \"report.checkstyle.violations\" ) ) ; sink . tableHeaderCell_ ( ) ; sink . tableHeaderCell ( ) ; sink . text ( bundle . getString ( \"report.checkstyle.column.severity\" ) ) ; sink . tableHeaderCell_ ( ) ; sink . tableRow_ ( ) ; // Top level should be the checker. if ( \"checker\" . equalsIgnoreCase ( checkstyleConfig . getName ( ) ) ) { String category = null ; for ( ConfReference ref : sortConfiguration ( results ) ) { doRuleRow ( ref , results , category ) ; category = ref . category ; } } else { sink . tableRow ( ) ; sink . tableCell ( ) ; sink . text ( bundle . getString ( \"report.checkstyle.norule\" ) ) ; sink . tableCell_ ( ) ; sink . tableRow_ ( ) ; } sink . table_ ( ) ; sink . section1_ ( ) ; }'", "label": "'Create the rules summary section of the report .'"}
{"text": "'private void doRuleRow ( ConfReference ref , CheckstyleResults results , String previousCategory ) { Configuration checkerConfig = ref . configuration ; ChainedItem < Configuration > parentConfiguration = ref . parentConfiguration ; String ruleName = checkerConfig . getName ( ) ; sink . tableRow ( ) ; // column 1: rule category sink . tableCell ( ) ; String category = ref . category ; if ( ! category . equals ( previousCategory ) ) { sink . text ( category ) ; } sink . tableCell_ ( ) ; // column 2: Rule name + configured attributes sink . tableCell ( ) ; if ( ! \"extension\" . equals ( category ) ) { sink . link ( \"http://checkstyle.sourceforge.net/config_\" + category + \".html#\" + ruleName ) ; sink . text ( ruleName ) ; sink . link_ ( ) ; } else { sink . text ( ruleName ) ; } List < String > attribnames = new ArrayList <> ( Arrays . asList ( checkerConfig . getAttributeNames ( ) ) ) ; attribnames . remove ( \"severity\" ) ; // special value (deserves unique column) if ( ! attribnames . isEmpty ( ) ) { sink . list ( ) ; for ( String name : attribnames ) { sink . listItem ( ) ; sink . text ( name ) ; String value = getConfigAttribute ( checkerConfig , null , name , \"\" ) ; // special case, Header.header and RegexpHeader.header if ( \"header\" . equals ( name ) && ( \"Header\" . equals ( ruleName ) || \"RegexpHeader\" . equals ( ruleName ) ) ) { String [ ] lines = StringUtils . split ( value , \"\\\\\\\\n\" ) ; int linenum = 1 ; for ( String line : lines ) { sink . lineBreak ( ) ; sink . rawText ( \"<span style=\\\\\"color: gray\\\\\">\" ) ; sink . text ( linenum + \":\" ) ; sink . rawText ( \"</span>\" ) ; sink . nonBreakingSpace ( ) ; sink . monospaced ( ) ; sink . text ( line ) ; sink . monospaced_ ( ) ; linenum ++ ; } } else if ( \"headerFile\" . equals ( name ) && \"RegexpHeader\" . equals ( ruleName ) ) { sink . text ( \": \" ) ; sink . monospaced ( ) ; sink . text ( \"\\\\\"\" ) ; if ( basedir != null ) { // Make the headerFile value relative to ${basedir} String path = siteTool . getRelativePath ( value , basedir . getAbsolutePath ( ) ) ; sink . text ( path . replace ( \\' \\' , \\' \\' ) ) ; } else { sink . text ( value ) ; } sink . text ( \"\\\\\"\" ) ; sink . monospaced_ ( ) ; } else { sink . text ( \": \" ) ; sink . monospaced ( ) ; sink . text ( \"\\\\\"\" ) ; sink . text ( value ) ; sink . text ( \"\\\\\"\" ) ; sink . monospaced_ ( ) ; } sink . listItem_ ( ) ; } sink . list_ ( ) ; } sink . tableCell_ ( ) ; // column 3: rule violation count sink . tableCell ( ) ; sink . text ( String . valueOf ( ref . violations ) ) ; sink . tableCell_ ( ) ; // column 4: severity sink . tableCell ( ) ; // Grab the severity from the rule configuration, this time use error as default value // Also pass along all parent configurations, so that we can try to find the severity there String severity = getConfigAttribute ( checkerConfig , parentConfiguration , \"severity\" , \"error\" ) ; iconTool . iconSeverity ( severity , IconTool . TEXT_SIMPLE ) ; sink . tableCell_ ( ) ; sink . tableRow_ ( ) ; }'", "label": "'Create a summary for one Checkstyle rule .'"}
{"text": "'public boolean matchRule ( AuditEvent event , String ruleName , String expectedMessage , String expectedSeverity ) { if ( ! ruleName . equals ( RuleUtil . getName ( event ) ) ) { return false ; } // check message too, for those that have a specific one. // like GenericIllegalRegexp and Regexp if ( expectedMessage != null ) { // event.getMessage() uses java.text.MessageFormat in its implementation. // Read MessageFormat Javadoc about single quote: // http://java.sun.com/j2se/1.4.2/docs/api/java/text/MessageFormat.html String msgWithoutSingleQuote = StringUtils . replace ( expectedMessage , \"\\'\" , \"\" ) ; return expectedMessage . equals ( event . getMessage ( ) ) || msgWithoutSingleQuote . equals ( event . getMessage ( ) ) ; } // Check the severity. This helps to distinguish between // different configurations for the same rule, where each // configuration has a different severity, like JavadocMetod. // See also http://jira.codehaus.org/browse/MCHECKSTYLE-41 if ( expectedSeverity != null ) { return expectedSeverity . equals ( event . getSeverityLevel ( ) . getName ( ) ) ; } return true ; }'", "label": "'Check if a violation matches a rule .'"}
{"text": "'public static String className ( Class < ? > clazz ) { //todo: rename //todo: is that correct algorithm? final String naiveName = clazz . getName ( ) ; if ( ! clazz . isArray ( ) ) { //todo: what about enum return naiveName ; } else { int count = 0 ; String ending = \"\" ; while ( clazz . isArray ( ) ) { count ++ ; ending += \"[]\" ; clazz = clazz . getComponentType ( ) ; } if ( clazz . isPrimitive ( ) ) { String primitiveClassName ; if ( clazz == boolean . class ) { primitiveClassName = \"boolean\" ; } else if ( clazz == byte . class ) { primitiveClassName = \"byte\" ; } else if ( clazz == char . class ) { primitiveClassName = \"char\" ; } else if ( clazz == short . class ) { primitiveClassName = \"short\" ; } else if ( clazz == int . class ) { primitiveClassName = \"int\" ; } else if ( clazz == long . class ) { primitiveClassName = \"long\" ; } else if ( clazz == float . class ) { primitiveClassName = \"float\" ; } else if ( clazz == double . class ) { primitiveClassName = \"double\" ; } else { throw new RuntimeException ( \"Never here! - You try to generate code for Void[]...[]: clazz = \" + clazz ) ; } return primitiveClassName + ending ; } else { return naiveName . substring ( count + 1 , naiveName . length ( ) - 1 ) + ending ; } } }'", "label": "'<p > Integer [] [] . class - > Integer [] [] <p > int [] [] . class - > int [] [] <p > Naive : Integer [] [] . class . getName () - > [[ Ljava . lang . Integer ; <p > Naive : int [] [] . class . getName () - > [[ LI ;'"}
{"text": "'private String createReceivedAtKey ( String fromClusterName , String toClusterName ) { return KEY_PREFIX + fromClusterName + \"-\" + toClusterName + KEY_POSTFIX_DURATION ; }'", "label": "'Creates the receivedAt key'"}
{"text": "'private void init ( ) { try { debug ( \"GuestNode#init(): Creating Cache\" ) ; ClientCacheFactory clientCacheFactory = new ClientCacheFactory ( ) ; Properties gemfireProperties = PropertiesHelper . filterProperties ( System . getProperties ( ) , GEMFIRE_PREFIX ) ; for ( Object keyObject : gemfireProperties . keySet ( ) ) { String key = ( String ) keyObject ; String value = gemfireProperties . getProperty ( key ) ; String name = key . substring ( GEMFIRE_PREFIX . length ( ) ) ; debug ( \"GuestNode#init(): Configuring ClientCacheFactory with key = \" + name + \", value = \" + value ) ; clientCacheFactory . set ( name , value ) ; } clientCacheFactory . setPoolSubscriptionEnabled ( true ) ; String locators = clustersProperties . getProperty ( localClusterName ) ; String [ ] locatorsArray = locators . split ( \",\" ) ; for ( String locator : locatorsArray ) { String locatorHost = locator . substring ( 0 , locator . indexOf ( \"[\" ) ) ; String locatorPortString = locator . substring ( locator . indexOf ( \"[\" ) + 1 , locator . indexOf ( \"]\" ) ) ; int locatorPort = Integer . parseInt ( locatorPortString ) ; debug ( \"GuestNode#init(): Adding locator to pool: locatorHost = \" + locatorHost + \", locatorPort = \" + locatorPort ) ; clientCacheFactory . addPoolLocator ( locatorHost , locatorPort ) ; } clientCache = clientCacheFactory . create ( ) ; ClientRegionFactory < String , Long > clientRegionFactory = clientCache . createClientRegionFactory ( ClientRegionShortcut . PROXY ) ; region = clientCache . getRegion ( regionName ) ; debug ( \"GuestNode#init(): Get region with name = \" + regionName + \": region = \" + region ) ; if ( region == null ) { region = clientRegionFactory . create ( regionName ) ; } debug ( \"GuestNode#init(): Create region with name = \" + regionName + \": region = \" + region ) ; } catch ( Throwable t ) { debug ( \"GuestNode#init(): Throwable caught with message = \" + t . getMessage ( ) , t ) ; } }'", "label": "'Initializes the technical region'"}
{"text": "'private void waitForStarted ( ) { debug ( \"GuestNode#waitForStarted(): Waiting for other clusters started\" ) ; while ( true ) { boolean othersStarted = true ; for ( Object key : clustersProperties . keySet ( ) ) { String clusterName = ( String ) key ; Long startedAt = region . get ( createStartedAtKey ( clusterName ) ) ; debug ( \"GuestNode#waitForStarted(): Checking startedAt: startedAt = \" + startedAt + \", processingStartedAt = \" + processingStartedAt ) ; if ( ( startedAt == null ) || ( startedAt . longValue ( ) < processingStartedAt ) ) { othersStarted = false ; break ; } } if ( othersStarted ) { break ; } try { TimeUnit . MILLISECONDS . sleep ( CHECK_PERIOD ) ; } catch ( InterruptedException e ) { } } debug ( \"GuestNode#waitForStarted(): Other clusters started\" ) ; }'", "label": "'Wait until the other clients started'"}
{"text": "'private void waitForSent ( ) { debug ( \"GuestNode#waitForSent(): Waiting for other clusters sent\" ) ; while ( true ) { boolean othersSent = true ; Map < String , Long > clusterNameToReceivedAtMap = new HashMap < String , Long > ( ) ; for ( Object key : clustersProperties . keySet ( ) ) { String clusterName = ( String ) key ; if ( localClusterName . equals ( clusterName ) ) { continue ; } Long sentAt = region . get ( createSentAtKey ( clusterName ) ) ; long receivedAt = System . currentTimeMillis ( ) ; if ( ( sentAt != null ) && ( sentAt . longValue ( ) > processingStartedAt ) ) { clusterNameToReceivedAtMap . put ( clusterName , receivedAt ) ; } } for ( Object key : clustersProperties . keySet ( ) ) { String clusterName = ( String ) key ; if ( localClusterName . equals ( clusterName ) ) { continue ; } Long receivedAt = clusterNameToReceivedAtMap . get ( clusterName ) ; if ( receivedAt == null ) { if ( othersSent ) { othersSent = false ; } } else { region . put ( createReceivedAtKey ( clusterName , localClusterName ) , receivedAt ) ; } } if ( othersSent ) { break ; } try { TimeUnit . MILLISECONDS . sleep ( CHECK_PERIOD ) ; } catch ( InterruptedException e ) { } } debug ( \"GuestNode#waitForSent(): Other clusters sent\" ) ; }'", "label": "'Wait until received all the entries from other clients . Put the receivedAt entries to cache .'"}
{"text": "'private void waitForConnected ( ) { debug ( \"GuestNode#waitForConnected(): Waiting for all the clusters connected\" ) ; while ( true ) { boolean connected = true ; for ( Object fromKey : clustersProperties . keySet ( ) ) { String fromClusterName = ( String ) fromKey ; for ( Object toKey : clustersProperties . keySet ( ) ) { String toClusterName = ( String ) toKey ; if ( fromClusterName . equals ( toClusterName ) ) { continue ; } Long receivedAt = region . get ( createReceivedAtKey ( fromClusterName , toClusterName ) ) ; if ( receivedAt == null ) { connected = false ; break ; } } } if ( connected ) { break ; } try { TimeUnit . MILLISECONDS . sleep ( CHECK_PERIOD ) ; } catch ( InterruptedException e ) { } } debug ( \"GuestNode#waitForConnected(): All the clusters connected\" ) ; }'", "label": "'Wait until all the clients received all the receivedAt entries .'"}
{"text": "'public boolean waitFor ( long timeout ) { debug ( \"GuestNode#waitFor(long): Waiting for task finish with timeout = \" + timeout ) ; ProcessingTask connectionCheckTask = new ProcessingTask ( ) ; Utils . execute ( connectionCheckTask , timeout ) ; boolean connected = connectionCheckTask . isConnected ( ) ; debug ( \"GuestNode#waitFor(long): Task finished connected = \" + connected ) ; return connected ; }'", "label": "'Waits for processing finished .'"}
{"text": "'public void close ( ) { try { debug ( \"GuestNode#close(): Closing the cache\" ) ; clientCache . close ( ) ; debug ( \"GuestNode#close(): Cache closed = \" + clientCache . isClosed ( ) ) ; } catch ( Throwable t ) { debug ( \"GuestNode#close(): Throwable caught with message = \" + t . getMessage ( ) , t ) ; } }'", "label": "'Finalizes work with the guest node'"}
{"text": "'public void printState ( boolean connected ) { if ( ! quiet ) { StringBuilder sb = new StringBuilder ( ) ; if ( connected ) { sb . append ( localClusterName ) . append ( \" <= \" ) ; Iterator < Object > it = clustersProperties . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { String clusterName = ( String ) it . next ( ) ; if ( localClusterName . equals ( clusterName ) ) { continue ; } Long sentAt = region . get ( createSentAtKey ( clusterName ) ) ; Long receivedAt = region . get ( createReceivedAtKey ( clusterName , localClusterName ) ) ; long duration = receivedAt - sentAt ; sb . append ( \"[\" ) . append ( clusterName ) . append ( \", \" ) . append ( duration ) . append ( \"ms]\" ) ; } } else { sb . append ( \"Connection process is not finished for \" ) . append ( localClusterName ) ; } System . out . println ( sb . toString ( ) ) ; } }'", "label": "'Prints the current state of connections'"}
{"text": "'public static void main ( String [ ] args ) { try { if ( args . length != 7 ) { Utils . exitWithFailure ( ) ; } String cluster = args [ 0 ] ; Properties clustersProperties = PropertiesHelper . stringToProperties ( args [ 1 ] ) ; long timeout = Long . parseLong ( args [ 2 ] ) ; String regionName = args [ 3 ] ; boolean debugEnabled = ( \"true\" . equals ( args [ 4 ] ) ? true : false ) ; boolean quiet = ( \"true\" . equals ( args [ 5 ] ) ? true : false ) ; long processingStartedAt = Long . parseLong ( args [ 6 ] ) ; GuestNode guestNode = new GuestNode ( cluster , clustersProperties , regionName , debugEnabled , quiet , processingStartedAt ) ; boolean connected = guestNode . waitFor ( timeout ) ; guestNode . printState ( connected ) ; guestNode . close ( ) ; if ( connected ) { Utils . exitWithSuccess ( ) ; } Utils . exitWithFailure ( ) ; } catch ( Throwable t ) { Utils . exitWithFailure ( ) ; } }'", "label": "'Configures and starts the guest node'"}
{"text": "'private void debug ( String message , Throwable t ) { if ( debugEnabled ) { long currentTime = System . currentTimeMillis ( ) ; long timeSinceProcessingStart = currentTime - processingStartedAt ; System . err . println ( timeSinceProcessingStart + \" [\" + localClusterName + \"] \" + message ) ; if ( t != null ) { t . printStackTrace ( System . err ) ; } } }'", "label": "'Prints debug information if the debug is enabled'"}
{"text": "'@ Override @ SuppressWarnings ( \"PMD\" ) protected String doRender ( final RenderConfiguration config , final AbstractAttributes entity ) { // Collect all non-null properties into a SortedMap using reflection. final SortedMap < String , String > dotAttributes = new TreeMap <> ( ) ; for ( Class < ? > current = entity . getClass ( ) ; current != null && current != Object . class ; current = current . getSuperclass ( ) ) { for ( Field currentField : current . getDeclaredFields ( ) ) { if ( isConfigurationField ( currentField ) ) { String key = null ; Object value = null ; try { // #1) Do we have a non-null value in the Field? value = currentField . get ( entity ) ; if ( value == null ) { continue ; } // #2) Do we have @DotProperty annotation on the Field? final DotProperty dotPropertyAnnotation = currentField . getAnnotation ( DotProperty . class ) ; if ( dotPropertyAnnotation == null ) { continue ; } // #3) Does this field need special treatment? if ( dotPropertyAnnotation . specialTreatment ( ) ) { if ( \"labelSize\" . equals ( currentField . getName ( ) ) && PointOrRectangle . class . equals ( currentField . getType ( ) ) ) { final PointOrRectangle rect = ( PointOrRectangle ) value ; dotAttributes . put ( quote ( \"lwidth\" ) , BigDecimal . valueOf ( rect . getxOrWidth ( ) ) . toPlainString ( ) ) ; dotAttributes . put ( quote ( \"lheight\" ) , BigDecimal . valueOf ( rect . getyOrHeight ( ) ) . toPlainString ( ) ) ; // All Done for this Field. continue ; } } // #4) Use the DotProperty \"name\" attribute, or fallback to the field name. key = dotPropertyAnnotation . name ( ) ; if ( key . isEmpty ( ) || \"##default\" . equalsIgnoreCase ( key ) ) { key = currentField . getName ( ) ; } // #5) Transform the value if required, and add the key/value pair to the outbound Map. dotAttributes . put ( key , getDotConfigValueFor ( value ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( \"Could not add configuration for field [\" + currentField + \"] --> [\" + key + \"] in class [\" + entity . getClass ( ) . getSimpleName ( ) + \"]\" , e ) ; } } } } // Check sanity if ( dotAttributes . isEmpty ( ) ) { return \"\" ; } // Synthesize the required attribute List form. final StringBuilder builder = new StringBuilder ( START_TOKEN ) ; for ( Map . Entry < String , String > current : dotAttributes . entrySet ( ) ) { builder . append ( current . getKey ( ) + SEPARATOR + \"\\\\\"\" + current . getValue ( ) + \"\\\\\"\" + DELIMITER ) ; } // Remove the last delimiter builder . delete ( builder . length ( ) - DELIMITER . length ( ) , builder . length ( ) ) ; // All Done. builder . append ( END_TOKEN ) ; return builder . toString ( ) ; }'", "label": "'{'"}
{"text": "'protected boolean initialize ( final RootDoc rootDoc ) { // #0) Don\\'t initialize twice, unless required to. if ( isInitializedOK ) { return true ; } // #1) Output the discovery log. for ( String current : discoveryLog ) { rootDoc . printNotice ( current ) ; } rootDoc . printNotice ( \"GraphViz home: \" + getHomeDirectory ( ) . getAbsolutePath ( ) ) ; rootDoc . printNotice ( \"Executable   : \" + getExecutableNameOrPath ( ) ) ; // #2) Create a ProcessBuilder which synthesizes a call to the executable and determine its version. // final ProcessBuilder pb = new ProcessBuilder ( getExecutableNameOrPath ( ) , \"-V\" ) ; pb . redirectErrorStream ( true ) ; if ( homeDirectory != null ) { pb . directory ( homeDirectory ) ; } Process p ; try { // Launch the executable p = pb . start ( ) ; } catch ( IOException e ) { rootDoc . printWarning ( e . getMessage ( ) ) ; return false ; } try ( BufferedReader in = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; OutputStream out = p . getOutputStream ( ) ; ) { // We don\\'t need to send any more commands to the process, so close the output stream. out . close ( ) ; // Read all input from the process, searching for the pattern \"graphviz\" ignoring case. String line = null ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . matches ( GRAPHVIZ_EXECUTABLE_FIRST_LINE_CHECK ) ) { // We found the expected output from the executable. rootDoc . printNotice ( \"GraphViz Version: \" + line ) ; isInitializedOK = true ; return true ; } else { // Unknown output. Printout a warning and die. rootDoc . printWarning ( \"Unknown GraphViz output: \" + line ) ; } } // Cache the result. isInitializedOK = false ; return false ; } catch ( IOException e ) { // Nopes. rootDoc . printWarning ( \"Problem detecting GraphViz: \" + e . getMessage ( ) ) ; isInitializedOK = false ; return false ; } finally { for ( ; ; ) { try { p . waitFor ( ) ; break ; } catch ( InterruptedException e ) { // Ignore this } } } }'", "label": "'<p > This method should be invoked from within subclasses worker methods to validate that the executable found is actually a GraphViz program . < / p > <p > The method fires the command <b > <code > <i > executableNameOrPath< / i > - V< / code > < / b > capturing the output to determine if it contains the pattern { @link #GRAPHVIZ_EXECUTABLE_FIRST_LINE_CHECK } in which case it is deemed to be a proper GraphViz executable . For instance the two executables dot and neato responds as follows : < / p > <ul > <li > <i > dot - V< / i > : <code > dot - graphviz version 2 . 36 . 0 ( 20140111 . 2315 ) < / code > < / li > <li > <i > neato - V< / i > : <code > neato - graphviz version 2 . 36 . 0 ( 20140111 . 2315 ) < / code > < / li > < / ul >'"}
{"text": "'@ Override protected String doRender ( final RenderConfiguration config , final Identifier entity ) { return config . getIndent ( ) + quote ( entity . getId ( ) ) + \" = \" + quote ( entity . getTargetIdentifier ( ) ) ; }'", "label": "'{'"}
{"text": "'public void writePngImageAndImageMap ( final RootDoc rootDoc , final String dotDiagram , final File outputDirectory , final String filename ) throws IOException { // Check sanity if ( filename == null || filename . isEmpty ( ) ) { throw new IllegalArgumentException ( \"Cannot handle null or empty \\'filename\\' argument.\" ) ; } if ( rootDoc == null ) { throw new IllegalArgumentException ( \"Cannot handle null \\'rootDoc\\' argument.\" ) ; } // #0) Initialize if ( ! initialize ( rootDoc ) ) { rootDoc . printWarning ( \"Could not initialize DotFacade. Aborting writing PNG image and ImageMap files.\" ) ; } // #1) Ensure that the PNG and MAP files can be written to. final File pngFile = new File ( outputDirectory , filename + \".png\" ) ; final File mapFile = new File ( outputDirectory , filename + \".map\" ) ; pngFile . delete ( ) ; mapFile . delete ( ) ; // #2) Compile the arguments used to launch Graphviz. final ProcessBuilder pb = new ProcessBuilder ( getExecutableNameOrPath ( ) , \"-Tcmapx\" , \"-o\" , mapFile . getAbsolutePath ( ) , \"-Tpng\" , \"-o\" , pngFile . getAbsolutePath ( ) ) ; pb . redirectErrorStream ( true ) ; if ( getHomeDirectory ( ) != null ) { pb . directory ( getHomeDirectory ( ) ) ; } // #3) Launch Graphviz. Harvest output. final Process p = pb . start ( ) ; try ( final BufferedReader in = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; final Writer out = new OutputStreamWriter ( p . getOutputStream ( ) , AbstractExecutableFacade . UTF8_ENCODING ) ) { // Send the diagram to the process, and close the stream after that. out . write ( dotDiagram ) ; out . close ( ) ; // Got error output? String line = null ; while ( ( line = in . readLine ( ) ) != null ) { System . err . println ( line ) ; } } finally { while ( true ) { try { int result = p . waitFor ( ) ; if ( result != 0 ) { throw new IllegalStateException ( \"GraphViz exited with a non-zero return value: \" + result ) ; } break ; } catch ( InterruptedException e ) { // Ignore } } } }'", "label": "'<p > Creates and writes PNG and HTML imagemap files by executing dot with the following arguments : < / p > <pre > <code > dot - Tcmapx - o [ outputDir / filename ] . map - Tpng - o [ outputDir / filename ] . png < / code > < / pre > <p > The { @code diagram } string is fed to the dot process . < / p >'"}
{"text": "'public List < XProperty > getOrderedProperties ( ) { final List < XProperty > result = Introspector . getProperties ( clazz ) ; Collections . sort ( result , new XProperty . NaturalOrder ( ) ) ; return result ; }'", "label": "'Returns properties in natural order i . e . &quot ; ORDER BY VERSION DECLARING CLASS NAME&quot ;'"}
{"text": "'public short getVersionModelHashCode ( int version ) { List < XProperty > classFields = getOrderedProperties ( ) ; StringBuilder builder = new StringBuilder ( ) ; for ( XProperty field : classFields ) { if ( version == - 1 || version >= field . getPropertyVersion ( ) ) { builder . append ( field . getType ( ) ) . append ( field . getName ( ) ) ; } } int hashCode = builder . toString ( ) . hashCode ( ) ; return ( short ) ( ( hashCode & 0xFFFF ) ^ ( ( hashCode & 0xFFFF0000 ) >> 16 ) ) ; }'", "label": "'Returns a hash code of class model for specified bean version based on fields that this model contains .'"}
{"text": "'public int getTotalNumberOfPages ( ) throws QueryException { prepareResultData ( false ) ; if ( isEmpty ( ) ) { return 1 ; } int total = totalNumberOfEntries / this . pageSize ; if ( totalNumberOfEntries % this . pageSize > 0 ) { total += 1 ; } return total ; }'", "label": "'Returns a total number of query pages .'"}
{"text": "'public List < V > page ( int pageNumber ) throws QueryException { List < Object > pageKeys = null ; boolean firstTry = true ; while ( pageKeys == null ) { prepareResultData ( ! firstTry ) ; if ( ! pageExists ( pageNumber ) ) { throw new IndexOutOfBoundsException ( \"The page \" + pageNumber + \"does not exists. \" + + getTotalNumberOfPages ( ) + \" pages available.\" ) ; } PageKey pageKey = newKey ( pageNumber ) ; pageKeys = paginatedQueryInfoRegion . get ( pageKey ) ; if ( pageKeys == null && firstTry ) { firstTry = false ; } else { break ; } } if ( pageKeys != null ) { return getValues ( pageKeys ) ; } else { throw new RuntimeException ( \"Unable to load keys from cache. Too aggressive expiration policy?\" ) ; } }'", "label": "'Returns entries for a specified page number . Use getTotalNumberOfPages () method to know how many pages this query has .'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) private List < V > getValues ( List < Object > entriesKeysForPage ) { if ( entriesKeysForPage . isEmpty ( ) ) { return Collections . emptyList ( ) ; } Map < Object , V > entriesMap = queryRegion . getAll ( entriesKeysForPage ) ; List < V > entries = new ArrayList < V > ( entriesKeysForPage . size ( ) ) ; for ( Object key : entriesKeysForPage ) { entries . add ( entriesMap . get ( key ) ) ; } return entries ; }'", "label": "'Returns values for given keys .'"}
{"text": "'@ SuppressWarnings ( { \"unchecked\" } ) private void prepareResultData ( boolean force ) throws QueryException { if ( this . infoLoaded && ! force ) { return ; } PageKey pageKey = newKey ( PAGE_NUMBER_FOR_GENERAL_INFO ) ; List < Object > queryInfo = null ; if ( ! force ) { queryInfo = paginatedQueryInfoRegion . get ( pageKey ) ; } if ( queryInfo == null ) { Query query = queryService . newQuery ( this . queryString ) ; SelectResults < Object > results = null ; try { results = ( SelectResults < Object > ) query . execute ( pageKey . getQueryParameters ( ) ) ; } catch ( FunctionDomainException e ) { handleException ( e ) ; } catch ( TypeMismatchException e ) { handleException ( e ) ; } catch ( NameResolutionException e ) { handleException ( e ) ; } catch ( QueryInvocationTargetException e ) { handleException ( e ) ; } if ( results . size ( ) > queryLimit ) { this . limitExceeded = true ; this . totalNumberOfEntries = queryLimit ; String msg = \"Size of query results has exceeded limit (\" + queryLimit + \"). Truncated.\" ; logger . warn ( msg ) ; } else { limitExceeded = false ; this . totalNumberOfEntries = results . size ( ) ; } queryInfo = Arrays . asList ( new Object [ ] { results . size ( ) , limitExceeded } ) ; storePage ( PAGE_NUMBER_FOR_GENERAL_INFO , queryInfo ) ; List < Object > keys = extractKeys ( results ) ; storeResults ( keys ) ; } else { this . totalNumberOfEntries = ( Integer ) queryInfo . get ( 0 ) ; this . limitExceeded = ( Boolean ) queryInfo . get ( 1 ) ; } this . infoLoaded = true ; }'", "label": "'Stores paginated query info if it has not been stored yet .'"}
{"text": "'private void storeResults ( List < Object > resultKeys ) { if ( resultKeys . size ( ) > queryLimit ) { resultKeys = resultKeys . subList ( 0 , queryLimit ) ; } int keyNumber = 0 ; int pageNumber = 0 ; List < Object > page = new ArrayList < Object > ( ) ; for ( Object key : resultKeys ) { if ( keyNumber % getPageSize ( ) == 0 && keyNumber != 0 ) { storePage ( ++ pageNumber , page ) ; page . clear ( ) ; } page . add ( key ) ; keyNumber ++ ; } if ( page . size ( ) > 0 || pageNumber == 0 ) { storePage ( ++ pageNumber , page ) ; } }'", "label": "'Stores paginated query pages and general info .'"}
{"text": "'@ Override protected String doRender ( final RenderConfiguration config , final Port entity ) { final String prefix = entity . getId ( ) != null && ! entity . getId ( ) . isEmpty ( ) ? \": \" + quote ( entity . getId ( ) ) + \" \" : \"\" ; // ALl Done. return prefix + \": \" + entity . getCompassPoint ( ) . getDotToken ( ) ; }'", "label": "'{'"}
{"text": "'public T create ( Object ... attributes ) { // build T object = build ( attributes ) ; // excute beforeCreate callback executeCallbacks ( BeforeFactoryCreate . class , object ) ; // persist persist ( object ) ; // execute after create callback executeCallbacks ( AfterFactoryCreate . class , object ) ; // return return object ; }'", "label": "'Create an object with the given attributes . First builds the object than persists it .'"}
{"text": "'@ Override public int compare ( final TagToCategory o1 , final TagToCategory o2 ) { if ( o1 == null && o2 == null ) return 0 ; if ( o1 == null ) return lessThan ; if ( o2 == null ) return greaterThan ; if ( o1 . getSorting ( ) == null && o2 . getSorting ( ) == null ) return compareSecondLevel ( o1 , o2 ) ; if ( o1 . getSorting ( ) == null ) return greaterThan ; if ( o2 . getSorting ( ) == null ) return lessThan ; if ( o1 . getSorting ( ) . equals ( o2 . getSorting ( ) ) ) return compareSecondLevel ( o1 , o2 ) ; return o1 . getSorting ( ) . compareTo ( o2 . getSorting ( ) ) * greaterThan ; }'", "label": "'Sorting order is preferentially used to sort TagToCategory s or the name of the Tag that the TagToCategory s point to are used if both TagToCategory s sorting orders are null .'"}
{"text": "'public String process ( XProperty field ) { String fieldName = field . getName ( ) ; return \"if (in.readByte() != 0) {\\\\n\" + tab ( \"result.set\" + firstLetterToUpperCase ( fieldName ) + \"(new java.util.Date(in.readLong()));\\\\n\" ) + \"}\\\\n\" ; }'", "label": "'todo : LocalGregorianCalendar'"}
{"text": "'private void migrateBrokenLocales ( final PreparedStatement preparedStmt , final Map < String , Integer > localeMap ) throws SQLException { final Integer enUSLocaleID = localeMap . get ( \"en-US\" ) ; if ( enUSLocaleID != null && enUSLocaleID > 0 ) { migrateBrokenLocale ( preparedStmt , localeMap , \"es_US\" , enUSLocaleID ) ; migrateBrokenLocale ( preparedStmt , localeMap , \"en_AU\" , enUSLocaleID ) ; migrateBrokenLocale ( preparedStmt , localeMap , \"ar\" , enUSLocaleID ) ; migrateBrokenLocale ( preparedStmt , localeMap , \"as\" , enUSLocaleID ) ; } }'", "label": "'Migrates locales from a very early version of PressGang that was using the wrong locale value .'"}
{"text": "'public static boolean recalculateMinHash ( final Topic topic , final List < MinHashXOR > minHashXORs ) { boolean retValue = false ; final Set < MinHash > existingMinHashes = topic . getMinHashes ( ) ; final Map < Integer , Integer > minHashes = getMinHashes ( topic . getTopicXML ( ) , minHashXORs ) ; for ( final Integer funcId : minHashes . keySet ( ) ) { boolean found = false ; for ( final MinHash minHash : existingMinHashes ) { if ( minHash . getMinHashFuncID ( ) . equals ( funcId ) ) { if ( ! minHash . getMinHash ( ) . equals ( minHashes . get ( funcId ) ) ) { minHash . setMinHash ( minHashes . get ( funcId ) ) ; retValue = true ; } found = true ; break ; } } if ( ! found ) { retValue = true ; final MinHash minHash = new MinHash ( ) ; minHash . setMinHashFuncID ( funcId ) ; minHash . setMinHash ( minHashes . get ( funcId ) ) ; topic . addMinHash ( minHash ) ; } } return retValue ; }'", "label": "'Recalculate the min hash signature for a topic .'"}
{"text": "'public static Map < Integer , Integer > getMinHashes ( final String xml , final List < MinHashXOR > minHashXORs ) { final Map < Integer , Integer > retValue = new HashMap < Integer , Integer > ( ) ; // Clean the XML to remove element names and other useless data final String cleanedXML = cleanXMLForMinHash ( xml ) ; // the first minhash uses the builtin hashcode only final Integer baseMinHash = getMinHashInternal ( cleanedXML , null ) ; if ( baseMinHash != null ) { retValue . put ( 0 , baseMinHash ) ; } for ( int funcId = 1 ; funcId < org . jboss . pressgang . ccms . model . constants . Constants . NUM_MIN_HASHES ; ++ funcId ) { boolean foundMinHash = false ; for ( final MinHashXOR minHashXOR : minHashXORs ) { if ( minHashXOR . getMinHashXORFuncId ( ) == funcId ) { final Integer minHash = getMinHashInternal ( cleanedXML , minHashXOR . getMinHashXOR ( ) ) ; if ( minHash != null ) { retValue . put ( funcId , minHash ) ; } foundMinHash = true ; break ; } } if ( ! foundMinHash ) { throw new IllegalStateException ( \"Did not find a minhash xor int for function \" + funcId ) ; } } return retValue ; }'", "label": "'Generate the min hashes'"}
{"text": "'public static Integer getMinHash ( final String xml , final Integer xor ) { return getMinHashInternal ( cleanXMLForMinHash ( xml ) , xor ) ; }'", "label": "'Returns the minimum hash of the sentences in an XML file .'"}
{"text": "'protected static String cleanXMLForMinHash ( final String xml ) { // Treat null and empty strings the same final String fixedXML = xml == null ? \"\" : xml ; String text = null ; try { final Document doc = XMLUtilities . convertStringToDocument ( fixedXML ) ; if ( doc != null ) { text = doc . getDocumentElement ( ) . getTextContent ( ) ; } } catch ( final Exception ex ) { // Do nothing } // the xml was invalid, so just strip out xml elements manually if ( text == null ) { text = fixedXML . replaceAll ( \"</?.*?/?>\" , \" \" ) ; } return text ; }'", "label": "'Cleans the provided XML by removing element names and other useless data .'"}
{"text": "'protected static Integer getMinHashInternal ( final String cleanedXML , final Integer xor ) { // now generate the minhashes String [ ] words = cleanedXML . replaceAll ( \"\\\\\\\\p{Punct}\" , \" \" ) . split ( \"\\\\\\\\s+\" ) ; if ( words . length == 0 ) { words = new String [ ] { \"\" } ; } final List < String > shingles = new ArrayList < String > ( ) ; if ( words . length < SHINGLE_WORD_COUNT ) { final StringBuilder shingle = new StringBuilder ( ) ; for ( int i = 0 ; i < words . length ; ++ i ) { if ( shingle . length ( ) != 0 ) { shingle . append ( \" \" ) ; } shingle . append ( words [ i ] ) ; } final int hash = shingle . toString ( ) . hashCode ( ) ; if ( xor != null ) { return hash ^ xor ; } else { return hash ; } } else { for ( int i = 0 ; i < words . length - SHINGLE_WORD_COUNT + 1 ; ++ i ) { final StringBuilder shingle = new StringBuilder ( ) ; for ( int j = i ; j < words . length && j < i + SHINGLE_WORD_COUNT ; ++ j ) { if ( shingle . length ( ) != 0 ) { shingle . append ( \" \" ) ; } shingle . append ( words [ j ] ) ; } shingles . add ( shingle . toString ( ) ) ; } Integer minHash = null ; for ( final String string : shingles ) { final int hash = string . hashCode ( ) ; final int finalHash = xor != null ? hash ^ xor : hash ; if ( minHash == null || finalHash < minHash ) { minHash = finalHash ; } } return minHash ; } }'", "label": "'Returns the minimum hash of the sentences in an XML file .'"}
{"text": "'public static List < Integer > getMatchingMinHash ( final EntityManager entityManager , final Map < Integer , Integer > minhashes , final Float threshold ) { try { if ( minhashes . size ( ) == 0 ) { /*\\n                    If the source does not have a minhash signature, force the search query to\\n                    match a non existent topic id so no results are returned.\\n                 */ return new ArrayList < Integer > ( ) { { add ( - 1 ) ; } } ; } Float fixedThreshold = Constants . MIN_DOCUMENT_SIMILARITY ; if ( threshold > Constants . MAX_DOCUMENT_SIMILARITY ) { fixedThreshold = Constants . MAX_DOCUMENT_SIMILARITY ; } else if ( threshold >= Constants . MIN_DOCUMENT_SIMILARITY ) { fixedThreshold = threshold ; } final CriteriaBuilder criteriaBuilder = entityManager . getCriteriaBuilder ( ) ; final CriteriaQuery < Integer > criteriaQuery = criteriaBuilder . createQuery ( Integer . class ) ; final Root < MinHash > minHashRoot = criteriaQuery . from ( MinHash . class ) ; final Set < Integer > candidates = new HashSet < Integer > ( ) ; /*\\n                Note to self - It may be possible to perform these band queries as one big query through something like\\n                cb.having(cb.equal(cb.toInteger(cb.prod(minHashRoot.<Integer>get(\"minHashFuncID\"), 1.0/lhsRows), band).\\n                However, unless lhsRows * bands exactly equals Constants.NUM_MIN_HASHES there needs to be some additional\\n                logic for the last band, which will have less than lhsRows rows in it.\\n             */ for ( int band = 0 ; band < Constants . MIN_HASH_BANDS ; ++ band ) { final List < Predicate > rowMatches = new ArrayList < Predicate > ( ) ; for ( int row = band * Constants . MIN_HASH_ROWS ; row < ( band * Constants . MIN_HASH_ROWS ) + Constants . MIN_HASH_ROWS ; ++ row ) { Integer sourceMinHash = null ; if ( minhashes . containsKey ( row ) ) { sourceMinHash = minhashes . get ( row ) ; } else { throw new IllegalArgumentException ( \"minhashes did not contain a minhash for function \" + row ) ; } rowMatches . add ( criteriaBuilder . and ( criteriaBuilder . equal ( minHashRoot . < Integer > get ( \"minHashFuncID\" ) , row ) , criteriaBuilder . equal ( minHashRoot . < Integer > get ( \"minHash\" ) , sourceMinHash ) ) ) ; } final Predicate minHashOrs = criteriaBuilder . or ( rowMatches . toArray ( new Predicate [ ] { } ) ) ; final CriteriaQuery < Integer > query = criteriaQuery . select ( minHashRoot . < Topic > get ( \"topic\" ) . < Integer > get ( \"topicId\" ) ) . distinct ( true ) . where ( minHashOrs ) . groupBy ( minHashRoot . < Integer > get ( \"topic\" ) . < Integer > get ( \"topicId\" ) ) . having ( criteriaBuilder . equal ( criteriaBuilder . count ( minHashRoot . < Integer > get ( \"topic\" ) . < Integer > get ( \"topicId\" ) ) , rowMatches . size ( ) ) ) ; candidates . addAll ( entityManager . createQuery ( query ) . getResultList ( ) ) ; } final List < Integer > matchingTopics = new ArrayList < Integer > ( ) ; if ( candidates . size ( ) != 0 ) { // at this point candidates should now list topic ids that are a potential match to the source topic. final CriteriaQuery < Topic > topicCQ = criteriaBuilder . createQuery ( Topic . class ) ; final Root < Topic > topicRoot = topicCQ . from ( Topic . class ) ; final CriteriaBuilder . In < Integer > in = criteriaBuilder . in ( topicRoot . < Integer > get ( \"topicId\" ) ) ; for ( final Integer candidate : candidates ) { in . value ( candidate ) ; } final CriteriaQuery < Topic > topicQuery = topicCQ . select ( topicRoot ) . where ( in ) ; final List < Topic > topics = entityManager . createQuery ( topicQuery ) . getResultList ( ) ; // we now have a list of topics that are possible candidates for a match. Now we compare the minhash values // to see what the similarity actually is. for ( final Topic topic : topics ) { int matches = 0 ; for ( final MinHash otherMinHash : topic . getMinHashes ( ) ) { if ( minhashes . containsKey ( otherMinHash . getMinHashFuncID ( ) ) ) { if ( minhashes . get ( otherMinHash . getMinHashFuncID ( ) ) . equals ( otherMinHash . getMinHash ( ) ) ) { ++ matches ; } } else { throw new IllegalArgumentException ( \"minhashes did not contain a minhash for function \" + otherMinHash . getMinHashFuncID ( ) ) ; } } if ( ( float ) matches / Constants . NUM_MIN_HASHES >= fixedThreshold ) { matchingTopics . add ( topic . getId ( ) ) ; } } if ( matchingTopics . size ( ) != 0 ) { return matchingTopics ; } } return Arrays . asList ( - 1 ) ; } catch ( final Exception ex ) { return null ; } }'", "label": "'Matching the minhash signature of a document relies on a process known as locality sensitive hashing . A good explaination of this process can be found at http : // infolab . stanford . edu / ~ullman / mmds / ch3 . pdf .'"}
{"text": "'public static void validateAndFixRelationships ( final Topic topic ) { /* remove relationships to this topic in the parent collection */ final ArrayList < TopicToTopic > removeList = new ArrayList < TopicToTopic > ( ) ; for ( final TopicToTopic topicToTopic : topic . getParentTopicToTopics ( ) ) if ( topicToTopic . getRelatedTopic ( ) . getTopicId ( ) . equals ( topic . getTopicId ( ) ) ) removeList . add ( topicToTopic ) ; for ( final TopicToTopic topicToTopic : removeList ) topic . getParentTopicToTopics ( ) . remove ( topicToTopic ) ; /* remove relationships to this topic in the child collection */ final ArrayList < TopicToTopic > removeChildList = new ArrayList < TopicToTopic > ( ) ; for ( final TopicToTopic topicToTopic : topic . getChildTopicToTopics ( ) ) if ( topicToTopic . getMainTopic ( ) . getTopicId ( ) . equals ( topic . getTopicId ( ) ) ) removeChildList . add ( topicToTopic ) ; for ( final TopicToTopic topicToTopic : removeChildList ) topic . getChildTopicToTopics ( ) . remove ( topicToTopic ) ; }'", "label": "'Validate and Fix a topics relationships to ensure that the topics related topics are still matched by the Related Topics themselves .'"}
{"text": "'public static void updateContentHash ( final Topic topic ) { if ( topic . getTopicXML ( ) != null ) { topic . setTopicContentHash ( HashUtilities . generateSHA256 ( topic . getTopicXML ( ) ) . toCharArray ( ) ) ; } }'", "label": "'Set the content hash on the topic .'"}
{"text": "'public static void validateAndFixTags ( final Topic topic ) { /*\\n         * validate the tags that are applied to this topic. generally the gui should enforce these rules, with the exception of\\n         * the bulk tag apply function\\n         */ // Create a collection of Categories mapped to TagToCategories, sorted by the Category sorting order final TreeMap < Category , ArrayList < TagToCategory > > tagDB = new TreeMap < Category , ArrayList < TagToCategory > > ( Collections . reverseOrder ( ) ) ; for ( final TopicToTag topicToTag : topic . getTopicToTags ( ) ) { final Tag tag = topicToTag . getTag ( ) ; for ( final TagToCategory tagToCategory : tag . getTagToCategories ( ) ) { final Category category = tagToCategory . getCategory ( ) ; if ( ! tagDB . containsKey ( category ) ) tagDB . put ( category , new ArrayList < TagToCategory > ( ) ) ; tagDB . get ( category ) . add ( tagToCategory ) ; } } // now remove conflicting tags for ( final Category category : tagDB . keySet ( ) ) { /* sort by the tags position in the category */ Collections . sort ( tagDB . get ( category ) , new TagToCategorySortingComparator ( false ) ) ; /*\\n             * because of the way we have ordered the tagDB collections, and the ArrayLists it contains, this process will\\n             * remove those tags that belong to lower priority categories, and lower priority tags in those categories\\n             */ final ArrayList < TagToCategory > tagToCategories = tagDB . get ( category ) ; // remove tags in the same mutually exclusive categories if ( category . isMutuallyExclusive ( ) && tagToCategories . size ( ) > 1 ) { while ( tagToCategories . size ( ) > 1 ) { final TagToCategory tagToCategory = tagToCategories . get ( 1 ) ; /* get the lower priority tag */ final Tag removeTag = tagToCategory . getTag ( ) ; /* remove it from the tagDB collection */ tagToCategories . remove ( tagToCategory ) ; /* and remove it from the tag collection */ final ArrayList < TopicToTag > removeTopicToTagList = new ArrayList < TopicToTag > ( ) ; for ( final TopicToTag topicToTag : topic . getTopicToTags ( ) ) { if ( topicToTag . getTag ( ) . equals ( removeTag ) ) removeTopicToTagList . add ( topicToTag ) ; } for ( final TopicToTag removeTopicToTag : removeTopicToTagList ) { topic . getTopicToTags ( ) . remove ( removeTopicToTag ) ; } } } /* remove tags that are explicitly defined as mutually exclusive */ for ( final TagToCategory tagToCategory : tagToCategories ) { final Tag tag = tagToCategory . getTag ( ) ; for ( final Tag exclusionTag : tag . getExcludedTags ( ) ) { if ( filter ( having ( on ( TopicToTag . class ) . getTag ( ) , equalTo ( tagToCategory . getTag ( ) ) ) , topic . getTopicToTags ( ) ) . size ( ) != 0 && // make /*\\n                             * sure that we have not removed this tag already\\n                             */ filter ( having ( on ( TopicToTag . class ) . getTag ( ) , equalTo ( exclusionTag ) ) , topic . getTopicToTags ( ) ) . size ( ) != 0 && // make /*\\n                             * sure the exclusion tag exists\\n                             */ ! exclusionTag . equals ( tagToCategory . getTag ( ) ) ) // make /*\\n                     * sure we are not trying to remove ourselves\\n                     */ { with ( topic . getTopicToTags ( ) ) . remove ( having ( on ( TopicToTag . class ) . getTag ( ) , equalTo ( exclusionTag ) ) ) ; } } } } }'", "label": "'Validate and Fix a topics tags so that mutually exclusive tags are enforced and also remove any tags that may have been duplicated .'"}
{"text": "'public static SortedMap < PackageDoc , SortedSet < ClassDoc > > sortClassesPerPackage ( final ClassDoc ... classDocs ) { final SortedMap < PackageDoc , SortedSet < ClassDoc > > toReturn = new TreeMap <> ( Comparators . PACKAGE_NAME_COMPARATOR ) ; if ( classDocs != null ) { Arrays . stream ( classDocs ) . forEach ( current -> { // Retrieve (or create) the SortedSet of ClassDocs for the current PackageDocs. final SortedSet < ClassDoc > classDocsForCurrentPackage = toReturn . computeIfAbsent ( current . containingPackage ( ) , k -> new TreeSet <> ( Comparators . CLASS_NAME_COMPARATOR ) ) ; // Add the current ClassDoc to the SortedSet. classDocsForCurrentPackage . add ( current ) ; } ) ; } // All Done. return toReturn ; }'", "label": "'Sorts all given ClassDocs into a SortedMap keyed by their respective PackageDocs .'"}
{"text": "'@ Override @ SuppressWarnings ( \"PMD.PreserveStackTrace\" ) public final void execute ( final EnforcerRuleHelper helper ) throws EnforcerRuleException { final MavenProject project ; try { project = ( MavenProject ) helper . evaluate ( \"${project}\" ) ; } catch ( final ExpressionEvaluationException e ) { // Whoops. final String msg = \"Could not acquire MavenProject. (Expression lookup failure for: \" + e . getLocalizedMessage ( ) + \")\" ; throw new EnforcerRuleException ( msg , e ) ; } // Delegate. try { performValidation ( project , helper ) ; } catch ( RuleFailureException e ) { // Create a somewhat verbose failure message. String message = \"\\\\n\" + \"\\\\n#\" + \"\\\\n# Structure rule failure:\" + \"\\\\n# \" + getShortRuleDescription ( ) + \"\\\\n# \" + \"\\\\n# Message: \" + e . getLocalizedMessage ( ) + \"\\\\n# \" + \"\\\\n# Offending project [\" + project . getGroupId ( ) + \":\" + project . getArtifactId ( ) + \":\" + project . getVersion ( ) + \"]\" + \"\\\\n#\" ; final Artifact art = e . getOffendingArtifact ( ) ; if ( art != null ) { message += \"\\\\n# Offending artifact [\" + art . getGroupId ( ) + \":\" + art . getArtifactId ( ) + \":\" + art . getVersion ( ) + \"]\" + \"\\\\n#\" ; } message += \"\\\\n\" ; // Re-throw for pretty print throw new EnforcerRuleException ( message ) ; } }'", "label": "'This is the interface into the rule . This method should throw an exception containing a reason message if the rule fails the check . The plugin will then decide based on the fail flag if it should stop or just log the message as a warning .'"}
{"text": "'protected static List < String > splice ( final String toSplice ) { final List < String > toReturn = new ArrayList < String > ( ) ; final StringTokenizer tok = new StringTokenizer ( toSplice , \",\" , false ) ; while ( tok . hasMoreTokens ( ) ) { toReturn . add ( tok . nextToken ( ) ) ; } return toReturn ; }'", "label": "'Helper method which splices the provided string into a List separating on commas .'"}
{"text": "'protected static List < Pattern > splice2Pattern ( final String toSplice ) throws PatternSyntaxException { final List < Pattern > toReturn = new ArrayList < Pattern > ( ) ; for ( final String current : splice ( toSplice ) ) { toReturn . add ( Pattern . compile ( current ) ) ; } return toReturn ; }'", "label": "'Helper method which splices the provided String into a List of Pattern instances .'"}
{"text": "'protected static boolean matches ( final String toMatch , final List < Pattern > patternList ) { for ( final Pattern current : patternList ) { if ( current . matcher ( toMatch ) . matches ( ) ) { return true ; } } return false ; }'", "label": "'Matches the provided { @code toMatch } string with all Patterns in the patternList . If one pattern matches this method returns { @code true } .'"}
{"text": "'protected static boolean containsPrefix ( final List < String > source , final String toCheck ) { if ( source != null ) { for ( final String current : source ) { if ( toCheck . startsWith ( current ) ) { return true ; } } } // The prefix was not found within the provided string toCheck. return false ; }'", "label": "'Checks if any element within source startsWith the provided toCheck string .'"}
{"text": "'private static Class < ? extends ObjectFactory > getFactoryClass ( Class < ? > factoryClass ) { if ( factoryPackages . size ( ) == 0 ) throw new IllegalArgumentException ( \"No package provide to look for factories.\" ) ; if ( factoryClasses == null ) { factoryClasses = new HashMap < Class < ? > , Class < ? extends ObjectFactory > > ( ) ; Set < Class < ? extends ObjectFactory > > classes = ReflectionUtils . getSubclassesOf ( ObjectFactory . class , factoryPackages ) ; for ( Class < ? extends ObjectFactory > clazz : classes ) { if ( ! Modifier . isAbstract ( clazz . getModifiers ( ) ) ) { try { Constructor constructor = clazz . getConstructor ( ) ; ObjectFactory factory = ( ObjectFactory ) constructor . newInstance ( ) ; factoryClasses . put ( factory . getFactoryClass ( ) , factory . getClass ( ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; //should not happen, compiler forces factory classes to implement correct constructor. } } } } return factoryClasses . get ( factoryClass ) ; }'", "label": "'Get the class of the Factory for the given factoryClass .'"}
{"text": "'@ Override protected String doRender ( final RenderConfiguration config , final Graph graph ) { // First, configure the RenderConfiguration for directed-ness. config . setDirectedGraph ( graph . isDigraph ( ) ) ; // We should use a 3-step rendering strategy. final String prologue = config . getIndent ( ) + ( graph . isStrict ( ) ? \"strict \" : \"\" ) + ( graph . isDigraph ( ) ? \"digraph\" : \"graph\" ) + \" \" + quote ( graph . getId ( ) ) + \" {\" + config . getNewline ( ) ; // Render all the statements within the supplied Graph. // Increase the indentation level to achieve pretty printing. // // Also, note that the render() method appends a NEWLINE to the result. final String renderedStatements = statementsRenderer . render ( config . cloneAndChangeIndentation ( 1 ) , graph . getStatements ( ) ) ; // Render the epilogue. final String epilogue = config . getIndent ( ) + \"}\" ; // All Done. return prologue + renderedStatements + epilogue ; }'", "label": "'{'"}
{"text": "'public void send ( String subject , String content ) throws MessagingException { MimeMessage message = compose ( subject , content , propertiesHelper . getStringProperty ( \"mail.to\" ) ) ; transport ( message ) ; }'", "label": "'Sends email with subject and content to receivers specified in property file after key mail . to'"}
{"text": "'public void send ( String subject , String content , String to ) throws MessagingException { MimeMessage message = compose ( subject , content , to ) ; transport ( message ) ; }'", "label": "'Sends email with subject and content to receivers specified by argument to'"}
{"text": "'private int executeZeroFunction ( Pool pool ) throws FunctionException , InterruptedException { int result = - 1 ; ResultCollector < ? , ? > collector = FunctionService . onServer ( pool ) . execute ( new ZeroFunction ( ) ) ; List < ? > functionResult = ( List < ? > ) collector . getResult ( ) ; if ( ( functionResult != null ) && ( functionResult . size ( ) == 1 ) && ( functionResult . get ( 0 ) instanceof Integer ) ) { result = ( Integer ) functionResult . get ( 0 ) ; } return result ; }'", "label": "'Executes the zero function using pool for the concrete server .'"}
{"text": "'@ Override protected String doRender ( final RenderConfiguration config , final RightSideEdge entity ) { final String prefix = RightSideEdge . getEdgeSeparator ( config . isDirectedGraph ( ) ) + \" \" + ( entity . getNodeID ( ) != null ? nodeIdRenderer . doRender ( config , entity . getNodeID ( ) ) : entity . getSubgraph ( ) . getId ( ) ) ; // Recurse if this RightSideEdge has a RightSideEdge in turn. String renderedRightSideOfThisEdge = \"\" ; if ( entity . getRightSideEdge ( ) != null ) { renderedRightSideOfThisEdge = \" \" + doRender ( config , entity . getRightSideEdge ( ) ) ; } // All Done. return prefix + renderedRightSideOfThisEdge ; }'", "label": "'<p > Renders this { @link RightSideEdge } according to the structure : < / p > <pre > edgeop ( node_id | subgraph ) [ edgeRHS ] < / pre >'"}
{"text": "'@ Override @ SuppressWarnings ( { \"ThrowableInstanceNeverThrown\" , \"unchecked\" } ) public void execute ( FunctionContext functionContext ) { ResultSender < Serializable > resultSender = functionContext . getResultSender ( ) ; RegionFunctionContext regionFunctionContext = ( RegionFunctionContext ) functionContext ; if ( functionContext . getArguments ( ) == null ) { handleException ( new FunctionException ( \"You must specify function argument for query execution.\" ) , resultSender , null ) ; return ; } if ( ! ( functionContext . getArguments ( ) instanceof BucketOrientedQueryFunctionArgument ) ) { handleException ( new FunctionException ( \"Function arguments must be of type \" + BucketOrientedQueryFunctionArgument . class . getName ( ) + \".\" ) , resultSender , null ) ; return ; } BucketOrientedQueryFunctionArgument argument = ( BucketOrientedQueryFunctionArgument ) functionContext . getArguments ( ) ; LocalDataSet localData = ( LocalDataSet ) PartitionRegionHelper . getLocalDataForContext ( regionFunctionContext ) ; QueryService queryService = localData . getCache ( ) . getQueryService ( ) ; String queryStr = argument . getQueryString ( ) ; try { Query query = queryService . newQuery ( queryStr ) ; SelectResults < ? > result = ( SelectResults < ? > ) localData . executeQuery ( ( DefaultQuery ) query , argument . getQueryParameters ( ) , localData . getBucketSet ( ) ) ; resultSender . lastResult ( ( Serializable ) formatResults ( result ) ) ; } catch ( Exception e ) { handleException ( e , resultSender , queryStr ) ; } }'", "label": "'Executes query using arguments query string and query parameters .'"}
{"text": "'@ SuppressWarnings ( { \"ThrowableInstanceNeverThrown\" } ) private void handleException ( Throwable e , ResultSender < Serializable > resultSender , String queryString ) { logger . error ( \"Failed to execute bucket oriented query\" + ( queryString != null ? \": \" + queryString : \".\" ) , e ) ; resultSender . sendException ( new FunctionException ( e . getMessage ( ) ) ) ; }'", "label": "'Handles exceptions during query execution .'"}
{"text": "'private List < Object > formatResults ( SelectResults < ? > selectResults ) { List < Object > results = new ArrayList < Object > ( selectResults . size ( ) + 1 ) ; results . addAll ( selectResults . asList ( ) ) ; results . add ( selectResults . getCollectionType ( ) . getElementType ( ) ) ; return results ; }'", "label": "'Formats results of query execution .'"}
{"text": "'@ Override public final void addErrorMessage ( final String message ) { if ( message == null || \"\" . equals ( message ) ) { return ; } // All done. errorMessages . add ( message ) ; }'", "label": "'Adds the provided error message to this ErrorMessageContainer .'"}
{"text": "'@ Override public String getMessage ( ) { final StringBuilder builder = new StringBuilder ( ) ; for ( final String current : errorMessages ) { builder . append ( current ) . append ( \"\\\\n\" ) ; } // All done. return builder . toString ( ) ; }'", "label": "'Returns the detail message string of this throwable .'"}
{"text": "'@ Override protected String doRender ( final RenderConfiguration config , final Statements statements ) { final StringBuilder builder = new StringBuilder ( config . getIndent ( ) ) ; // #1) Render the AttributeStatements plus comment, if they exist. final boolean hasAttributeStatements = statements . getCommonGraphAttributes ( ) != null || statements . getCommonNodeAttributes ( ) != null || statements . getCommonEdgeAttributes ( ) != null ; if ( hasAttributeStatements ) { // Add the comment first. builder . append ( commentRenderer . render ( config , statements . getCommonAttributesComment ( ) ) ) ; // Add the attributes in order if ( statements . getCommonGraphAttributes ( ) != null ) { builder . append ( commonGraphAttributesRenderer . render ( config , statements . getCommonGraphAttributes ( ) ) ) ; } if ( statements . getCommonNodeAttributes ( ) != null ) { builder . append ( commonNodeAttributesRenderer . render ( config , statements . getCommonNodeAttributes ( ) ) ) ; } if ( statements . getCommonEdgeAttributes ( ) != null ) { builder . append ( commonEdgeAttributesRenderer . render ( config , statements . getCommonEdgeAttributes ( ) ) ) ; } } // #2) Render the other Statements in order, namely // //     Node statements //     Identifier statements //     Edge statements //     Subgraph statements final List < Node > nodes = statements . getNodes ( ) ; if ( ! nodes . isEmpty ( ) ) { builder . append ( commentRenderer . render ( config , statements . getNodesComment ( ) ) ) ; // Render all Nodes in order. nodes . forEach ( n -> builder . append ( nodeRenderer . render ( config , n ) ) ) ; } final List < Identifier > identifiers = statements . getIdentifiers ( ) ; if ( ! identifiers . isEmpty ( ) ) { builder . append ( commentRenderer . render ( config , statements . getIdentifiersComment ( ) ) ) ; // Render all Identifiers in order. identifiers . forEach ( i -> builder . append ( identifierRenderer . render ( config , i ) ) ) ; } final List < Edge > edges = statements . getEdges ( ) ; if ( edges != null && ! edges . isEmpty ( ) ) { builder . append ( commentRenderer . render ( config , statements . getEdgesComment ( ) ) ) ; // Render all Edges in order. edges . forEach ( i -> builder . append ( edgeRenderer . render ( config , i ) ) ) ; } final List < Subgraph > subgraphs = statements . getSubgraphs ( ) ; if ( ! subgraphs . isEmpty ( ) ) { builder . append ( commentRenderer . render ( config , statements . getSubgraphComment ( ) ) ) ; // Render all Subgraphs in order. subgraphs . forEach ( s -> builder . append ( subgraphRenderer . render ( config , s ) ) ) ; } // All Done. return builder . toString ( ) ; }'", "label": "'{'"}
{"text": "'public String process ( XProperty field ) { String fieldName = field . getName ( ) ; String getter = \"get\" + firstLetterToUpperCase ( fieldName ) + \"()\" ; return \"if (concrete.\" + getter + \" == null) {\\\\n\" + \"    out.writeByte(0);\\\\n\" + \"} else {\\\\n\" + \"    out.writeByte(1);\\\\n\" + \"    out.writeUTF(concrete.\" + getter + \".getClass().getName());\\\\n\" + \"    com.gemstone.gemfire.DataSerializer.writeEnum(concrete.\" + getter + \", out);\\\\n\" + \"}\\\\n\" ; }'", "label": "'todo : warn if enum contains mutable fields?'"}
{"text": "'@ Override protected String doRender ( final RenderConfiguration config , final Node node ) { // Do we have a non-empty NodeAttributes within the supplied Node? // Don\\'t add the extra newline after the attributes - so call doRender directly. final NodeAttributes nodeAttributes = node . getAttributes ( ) ; final String renderedNodeAttributes = attributeRenderer . doRender ( config , nodeAttributes ) ; // All Done. return config . getIndent ( ) + nodeIdRenderer . doRender ( config , node . getNodeID ( ) ) + ( renderedNodeAttributes . isEmpty ( ) ? \"\" : \" \" + renderedNodeAttributes ) ; }'", "label": "'{'"}
{"text": "'public Edge addEdge ( final String fromId , final String toId ) { return getStatements ( ) . addEdge ( fromId , toId , this ) ; }'", "label": "'Convenience method to add and return an Edge between a Node / Subgraph and another Node / Subgraph within the immediate Statements in this Graph .'"}
{"text": "'public static boolean isSocketAlive ( String host , int port ) { boolean socketAlive = false ; Socket socket = null ; try { socket = new Socket ( host , port ) ; socketAlive = socket . isConnected ( ) ; } catch ( Throwable t ) { // do nothing } finally { if ( socket != null ) { try { socket . close ( ) ; } catch ( IOException e ) { // do nothing } } } return socketAlive ; }'", "label": "'Checks if the socket of specified host and port is alive .'"}
{"text": "'public static void execute ( Thread thread , long timeout ) { thread . start ( ) ; try { thread . join ( timeout ) ; } catch ( InterruptedException e ) { // Should not be interrupted normally. } if ( thread . isAlive ( ) ) { thread . interrupt ( ) ; } }'", "label": "'Executes the thread with specified timeout .'"}
{"text": "'public static RightSideEdge to ( final String id , final Graph withinGraph ) { // Check sanity if ( id == null ) { throw new IllegalArgumentException ( \"Cannot handle null \\'id\\' argument.\" ) ; } if ( withinGraph == null ) { throw new IllegalArgumentException ( \"Cannot handle null \\'withinGraph\\' argument.\" ) ; } // First, assume that the ID is a NodeID. // final Statements statements = immediateParent.getStatements(); final Node node = withinGraph . getStatements ( ) . findNode ( id , true ) ; if ( node != null ) { return new RightSideEdge ( node . getNodeID ( ) ) ; } // Next, assume that the ID is a Subgraph. final Subgraph subgraph = withinGraph . getStatements ( ) . findSubgraph ( id , true ) ; if ( subgraph != null ) { return new RightSideEdge ( subgraph ) ; } // All Done. return null ; }'", "label": "'Factory method creating a { @link RightSideEdge } which terminates in the Node or Subgraph with the supplied ID and within the supplied Graph .'"}
{"text": "'public static SimpleDoclet createSimpleDoclet ( final String className ) { final String effectiveClassName = className != null && ! className . isEmpty ( ) ? className : VisualizationDoclet . class . getName ( ) ; final ClassLoader [ ] classLoaders = new ClassLoader [ ] { Thread . currentThread ( ) . getContextClassLoader ( ) , DelegatingDoclet . class . getClassLoader ( ) } ; SimpleDoclet toReturn = null ; for ( ClassLoader current : classLoaders ) { try { final Class < ? > loadedClass = current . loadClass ( effectiveClassName ) ; if ( SimpleDoclet . class . isAssignableFrom ( loadedClass ) ) { toReturn = ( SimpleDoclet ) loadedClass . newInstance ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } // All Done. return toReturn == null ? new VisualizationDoclet ( ) : toReturn ; }'", "label": "'Creates a SimpleDoclet instance by calling a no - argument constructor within the Class of the supplied ClassName . Falls back to { @link VisualizationDoclet } .'"}
{"text": "'public final void add ( final String ... lines ) { if ( lines != null ) { for ( String current : lines ) { commentLines . add ( current . replace ( NEWLINE , \"\" ) ) ; } } }'", "label": "'If non - null adds one or more lines to this comment . Also { @link #NEWLINE } strings are removed from each line .'"}
{"text": "'public static DotParser . GraphContext validate ( final InputStream dotDiagramData ) throws DotDiagramSyntaxException { // Check sanity if ( dotDiagramData == null ) { throw new IllegalArgumentException ( \"Cannot handle null \\'dotDiagramData\\' argument.\" ) ; } // Create the parser final DotLexer lexer = createLexer ( dotDiagramData ) ; final DotParser parser = createParser ( lexer ) ; // Ensure we can harvest all syntax errors. final DotSyntaxErrorListener errorListener = new DotSyntaxErrorListener ( ) ; parser . addErrorListener ( errorListener ) ; final DotParser . GraphContext toReturn = parser . graph ( ) ; // Check sanity if ( errorListener . isErrorState ( ) ) { throw new DotDiagramSyntaxException ( errorListener . getErrorDataList ( ) ) ; } // All Done. return toReturn ; }'", "label": "'Validates that the supplied InputStream contains well - formed Graph data complying to the <a href = http : // www . graphviz . org / content / dot - language > DOT language specification< / a > . If the'"}
{"text": "'public static DotLexer createLexer ( final InputStream dotDiagramData ) { // Check sanity if ( dotDiagramData == null ) { throw new IllegalArgumentException ( \"Cannot handle null \\'dotDiagramData\\' argument.\" ) ; } try { // All Done. return new DotLexer ( new ANTLRInputStream ( dotDiagramData ) ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( \"Could not create DotLexer\" , e ) ; } }'", "label": "'Factory method creating a DotLexer from the supplied InputStream assumed to contain Graphviz / DOT diagram data .'"}
{"text": "'public static DotParser createParser ( final DotLexer lexer ) { // Check sanity if ( lexer == null ) { throw new IllegalArgumentException ( \"Cannot handle null \\'lexer\\' argument.\" ) ; } // All Done. return new DotParser ( new CommonTokenStream ( lexer ) ) ; }'", "label": "'Creates a { @link DotParser } reading data from the supplied { @link DotLexer } .'"}
{"text": "'protected CheckstyleExecutorRequest createRequest ( ) throws MavenReportException { CheckstyleExecutorRequest request = new CheckstyleExecutorRequest ( ) ; request . setAggregate ( true ) . setReactorProjects ( reactorProjects ) . setConsoleListener ( getConsoleListener ( ) ) . setConsoleOutput ( consoleOutput ) . setExcludes ( excludes ) . setFailsOnError ( failsOnError ) . setIncludes ( includes ) . setIncludeResources ( includeResources ) . setIncludeTestResources ( includeTestResources ) . setResourceIncludes ( resourceIncludes ) . setResourceExcludes ( resourceExcludes ) . setIncludeTestSourceDirectory ( includeTestSourceDirectory ) . setListener ( getListener ( ) ) . setProject ( project ) . setSourceDirectories ( getSourceDirectories ( ) ) . setResources ( resources ) . setTestResources ( testResources ) . setStringOutputStream ( stringOutputStream ) . setSuppressionsLocation ( suppressionsLocation ) . setTestSourceDirectories ( getTestSourceDirectories ( ) ) . setConfigLocation ( configLocation ) . setPropertyExpansion ( propertyExpansion ) . setHeaderLocation ( headerLocation ) . setCacheFile ( cacheFile ) . setSuppressionsFileExpression ( suppressionsFileExpression ) . setEncoding ( encoding ) . setPropertiesLocation ( propertiesLocation ) ; return request ; }'", "label": "'{'"}
{"text": "'@ Override protected String doRender ( final RenderConfiguration config , final NodeID entity ) { final Port port = entity . getPort ( ) ; final String renderedPort = port == null ? \"\" : portRenderer . doRender ( config , entity . getPort ( ) ) ; return quote ( entity . getId ( ) ) + renderedPort ; }'", "label": "'{'"}
{"text": "'public boolean canGenerateReport ( ) { if ( skip ) { return false ; } // TODO: would be good to scan the files here for ( File sourceDirectory : getSourceDirectories ( ) ) { if ( sourceDirectory . exists ( ) ) { return true ; } } if ( includeTestSourceDirectory ) { for ( File testSourceDirectory : getTestSourceDirectories ( ) ) { if ( testSourceDirectory . exists ( ) ) { return true ; } } } return ( ( includeResources && hasResources ( resources ) ) || ( includeTestResources && hasResources ( testResources ) ) ) ; }'", "label": "'{'"}
{"text": "'private boolean hasResources ( List < Resource > resources ) { for ( Resource resource : resources ) { if ( new File ( resource . getDirectory ( ) ) . exists ( ) ) { return true ; } } return false ; }'", "label": "'Check if any of the resources exist .'"}
{"text": "'private void mergeDeprecatedInfo ( ) throws MavenReportException { if ( \"sun_checks.xml\" . equals ( configLocation ) && ! \"sun\" . equals ( format ) ) { configLocation = FORMAT_TO_CONFIG_LOCATION . get ( format ) ; throw new MavenReportException ( \"\\'format\\' parameter is deprecated: please replace with <configLocation>\" + configLocation + \"</configLocation>.\" ) ; } if ( StringUtils . isEmpty ( propertiesLocation ) ) { if ( propertiesFile != null ) { propertiesLocation = propertiesFile . getPath ( ) ; throw new MavenReportException ( \"\\'propertiesFile\\' parameter is deprecated: please replace with \" + \"<propertiesLocation>\" + propertiesLocation + \"</propertiesLocation>.\" ) ; } else if ( propertiesURL != null ) { propertiesLocation = propertiesURL . toExternalForm ( ) ; throw new MavenReportException ( \"\\'propertiesURL\\' parameter is deprecated: please replace with \" + \"<propertiesLocation>\" + propertiesLocation + \"</propertiesLocation>.\" ) ; } } if ( \"LICENSE.txt\" . equals ( headerLocation ) ) { File defaultHeaderFile = new File ( project . getBasedir ( ) , \"LICENSE.txt\" ) ; if ( ! defaultHeaderFile . equals ( headerFile ) ) { headerLocation = headerFile . getPath ( ) ; } } if ( StringUtils . isEmpty ( suppressionsLocation ) ) { suppressionsLocation = suppressionsFile ; if ( StringUtils . isNotEmpty ( suppressionsFile ) ) { throw new MavenReportException ( \"\\'suppressionsFile\\' parameter is deprecated: please replace with \" + \"<suppressionsLocation>\" + suppressionsLocation + \"</suppressionsLocation>.\" ) ; } } if ( StringUtils . isEmpty ( packageNamesLocation ) ) { packageNamesLocation = packageNamesFile ; if ( StringUtils . isNotEmpty ( packageNamesFile ) ) { throw new MavenReportException ( \"\\'packageNamesFile\\' parameter is deprecated: please replace with \" + \"<packageNamesFile>\" + suppressionsLocation + \"</packageNamesFile>.\" ) ; } } }'", "label": "'Merge in the deprecated parameters to the new ones unless the new parameters have values .'"}
{"text": "'public static String addQueryLimit ( String queryString , int queryLimit ) { int limitIndex = queryString . lastIndexOf ( \"limit\" ) ; if ( limitIndex == - 1 ) { limitIndex = queryString . lastIndexOf ( \"LIMIT\" ) ; } if ( limitIndex == - 1 ) { return queryString + \" LIMIT \" + ( queryLimit + 1 ) ; } int limitNumber = Integer . parseInt ( queryString . substring ( limitIndex + 5 ) . trim ( ) ) ; return ( limitNumber > queryLimit ) ? queryString . substring ( 0 , limitIndex ) + \" LIMIT \" + ( queryLimit + 1 ) : queryString ; }'", "label": "'Limits query results .'"}
{"text": "'public static void clearRegion ( Region < ? , ? > region , boolean wanCompatible , boolean cleanLocal ) { ClearRegionFunction cleaner = new ClearRegionFunction ( ) ; FunctionService . registerFunction ( cleaner ) ; FunctionService . onRegion ( region ) . withArgs ( wanCompatible ) . execute ( cleaner ) . getResult ( ) ; if ( cleanLocal && isGemFireClient ( ) ) { region . localClear ( ) ; } }'", "label": "'Clears all types of regions . This method can clean both types of regions ( REPLICATED PARTITIONED ) . It can be used both on client and server side .'"}
{"text": "\"public static String [ ] getFirstLocatorFromLocatorsString ( String locatorsString ) { if ( locatorsString == null || locatorsString . length ( ) == 0 ) { return new String [ 2 ] ; } String [ ] firstLocator = new String [ 2 ] ; firstLocator [ 0 ] = locatorsString . substring ( 0 , locatorsString . indexOf ( ' ' ) ) . trim ( ) ; locatorsString = locatorsString . substring ( locatorsString . indexOf ( ' ' ) + 1 ) ; firstLocator [ 1 ] = locatorsString . substring ( 0 , locatorsString . indexOf ( ' ' ) ) ; return firstLocator ; }\"", "label": "'Returns first locator host and port from locators string .'"}
{"text": "'public static int getRegionSize ( Region < ? , ? > region ) { Function function = new RegionSizeFunction ( ) ; FunctionService . registerFunction ( function ) ; ResultCollector < ? , ? > rc = FunctionService . onRegion ( region ) . withCollector ( new RegionSizeResultCollector ( ) ) . execute ( function ) ; return ( Integer ) rc . getResult ( ) ; }'", "label": "'Returns approximate number of entries in the region . As the function counts number of entries on different nodes in parallel per node values may be captured on different moments . So the value may never be valid .'"}
{"text": "'public static boolean isGemFireClient ( ) { GemFireCacheImpl impl = ( GemFireCacheImpl ) CacheFactory . getAnyInstance ( ) ; return impl != null && impl . isClient ( ) ; }'", "label": "'Checks if the current GemFire is a client instance .'"}
{"text": "'public static < K > void removeAll ( Region < K , ? > region , Set < K > keys ) { if ( keys == null ) { throw new NullPointerException ( ) ; } if ( keys . isEmpty ( ) ) { // Nothing to do return ; } Function function = new RemoveAllFunction ( ) ; FunctionService . registerFunction ( function ) ; ResultCollector < ? , ? > rc = FunctionService . onRegion ( region ) . withFilter ( keys ) . withArgs ( region . getName ( ) ) . execute ( function ) ; // Obtain result from the collector to return // only after everything is done. rc . getResult ( ) ; }'", "label": "'Removes several entries from region in a single hop . On partitioned region execution is done simultaneously on all partitions .'"}
{"text": "'public static < T > T retryWithExponentialBackoff ( Retryable < T > runnable , int maxRetries ) throws InterruptedException , OperationRetryFailedException { int retry = 0 ; while ( retry < maxRetries ) { retry ++ ; try { return runnable . execute ( ) ; } catch ( OperationRequireRetryException e ) { // No-op. } catch ( InterruptedException e ) { throw e ; } if ( retry > 1 ) { long delay = ( long ) ( ( BACKOFF_BASE << retry ) * Math . random ( ) ) ; log . debug ( \"Operation requested retry. Sleep for {} millis\" , delay ) ; Thread . sleep ( delay ) ; } } throw new OperationRetryFailedException ( \"Maximum number of operation retries reached\" ) ; }'", "label": "'Retries passed operation with random exponential back off delay .'"}
{"text": "'protected void generateBufferedImage ( TranscoderInput in , int w , int h ) throws TranscoderException { BufferedImageTranscoder t = new BufferedImageTranscoder ( ) ; if ( w != 0 && h != 0 ) { t . setDimensions ( w , h ) ; } t . transcode ( in , null ) ; bufferedImage = t . getBufferedImage ( ) ; width = bufferedImage . getWidth ( ) ; height = bufferedImage . getHeight ( ) ; }'", "label": "'Generate the BufferedImage .'"}
{"text": "'@ Override public void paintIcon ( Component c , Graphics g , int x , int y ) { if ( backgroundColour == null ) g . drawImage ( bufferedImage , x , y , null ) ; else g . drawImage ( bufferedImage , x , y , backgroundColour , null ) ; }'", "label": "'Draw the icon at the specified location .'"}
{"text": "'@ SuppressWarnings ( { \"unchecked\" } ) @ Override protected void performValidation ( final MavenProject project , final EnforcerRuleHelper helper ) throws RuleFailureException { // Acquire the ProjectType final ProjectType projectType ; try { projectType = ProjectType . getProjectType ( project ) ; } catch ( IllegalArgumentException e ) { throw new RuleFailureException ( \"Incorrect project definition for \" + project , e ) ; } // Don\\'t evaluate for ignored project types. if ( IGNORED_PROJECT_TYPES . contains ( projectType ) ) { return ; } // Don\\'t evaluate if told not to. if ( matches ( project . getGroupId ( ) , dontEvaluateGroupIds ) ) { // Log somewhat helper . getLog ( ) . debug ( \"Ignored [\" + project . getGroupId ( ) + \":\" + project . getArtifactId ( ) + \"] since its groupId was excluded from enforcement.\" ) ; return ; } // Don\\'t evaluate if not told to. if ( ! matches ( project . getGroupId ( ) , evaluateGroupIds ) ) { // Log somewhat helper . getLog ( ) . debug ( \"Ignored [\" + project . getGroupId ( ) + \":\" + project . getArtifactId ( ) + \"] since its groupId was not included in enforcement.\" ) ; return ; } // Acquire all project dependencies. for ( final Artifact current : project . getDependencyArtifacts ( ) ) { // Don\\'t evaluate for test-scope dependencies. if ( Artifact . SCOPE_TEST . equalsIgnoreCase ( current . getScope ( ) ) ) { continue ; } // Should this Artifact be evaluated? final boolean isIncludedInEvaluation = matches ( current . getGroupId ( ) , evaluateGroupIds ) ; final boolean isNotExplicitlyExcludedFromEvaluation = ! matches ( current . getGroupId ( ) , dontEvaluateGroupIds ) ; if ( isIncludedInEvaluation && isNotExplicitlyExcludedFromEvaluation ) { final ProjectType artifactProjectType = ProjectType . getProjectType ( current ) ; final String prefix = \"Don\\'t use \" + artifactProjectType + \" dependencies \" ; if ( artifactProjectType == ProjectType . IMPLEMENTATION ) { throw new RuleFailureException ( prefix + \"outside of application projects.\" , current ) ; } if ( artifactProjectType == ProjectType . TEST ) { throw new RuleFailureException ( prefix + \"in compile scope for non-test artifacts.\" , current ) ; } if ( artifactProjectType == ProjectType . JEE_APPLICATION || artifactProjectType == ProjectType . PROOF_OF_CONCEPT ) { throw new RuleFailureException ( prefix + \"in bundles.\" , current ) ; } } } }'", "label": "'Delegate method implemented by concrete subclasses .'"}
{"text": "'private static BufferedReader getReader ( ) { if ( bufferedReader == null ) { bufferedReader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } return bufferedReader ; }'", "label": "'Method getReader returns the reader of this ConsoleUtils object .'"}
{"text": "'public static void waitForEnter ( String message ) { System . out . println ( message ) ; try { getReader ( ) . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; //To change body of catch statement use File | Settings | File Templates. } }'", "label": "'Waits for enter with specified message .'"}
{"text": "'public void execute ( String [ ] args , boolean debugEnabled , boolean quiet ) { try { this . debugEnabled = debugEnabled ; debug ( \"CheckReplicationTool#execute(String[]): args = \" + Arrays . asList ( args ) ) ; parseCommandLineArguments ( args ) ; System . out . println ( \"Connecting...\" ) ; debug ( \"CheckReplicationTool#execute(String[]): Creating CheckReplicationTool.ProcessorTask with parameters: clustersProperties = \" + clustersProperties + \", timeout = \" + timeout + \", regionName = \" + regionName ) ; ProcessorTask task = new ProcessorTask ( clustersProperties , timeout , regionName , debugEnabled , quiet ) ; debug ( \"CheckReplicationTool#execute(String[]): Starting CheckReplicationTool.ProcessorTask\" ) ; Utils . execute ( task , timeout + DELTA_TIMEOUT ) ; int exitCode = task . getExitCode ( ) ; debug ( \"CheckReplicationTool#execute(String[]): CheckReplicationTool.ProcessorTask finished with exitCode = \" + exitCode ) ; if ( exitCode == 0 ) { Utils . exitWithSuccess ( ) ; } Utils . exitWithFailure ( ) ; } catch ( Throwable t ) { debug ( \"CheckReplicationTool#execute(String[]): Throwable caught with message = \" + t . getMessage ( ) , t ) ; Utils . exitWithFailure ( \"Unexpected throwable\" , t ) ; } }'", "label": "'Runs the tool . All the tools run in this way .'"}
{"text": "'protected void parseCommandLineArguments ( String [ ] commandLineArguments ) { Options options = constructGnuOptions ( ) ; if ( commandLineArguments . length < 1 ) { printHelp ( options ) ; } CommandLineParser parser = new GnuParser ( ) ; try { CommandLine line = parser . parse ( options , commandLineArguments ) ; if ( line . hasOption ( HELP_OPTION ) ) { printHelp ( options ) ; } if ( line . hasOption ( REGION_OPTION ) ) { regionName = line . getOptionValue ( REGION_OPTION ) ; } if ( line . hasOption ( TIMEOUT_OPTION ) ) { String timeoutString = line . getOptionValue ( TIMEOUT_OPTION ) ; timeout = Long . parseLong ( timeoutString ) ; } if ( line . hasOption ( CLUSTER_OPTION ) ) { clustersProperties = line . getOptionProperties ( CLUSTER_OPTION ) ; if ( clustersProperties . keySet ( ) . size ( ) < 2 ) { Utils . exitWithFailure ( \"At least two clusters should be defined\" ) ; } } else { Utils . exitWithFailure ( \"No clusters defined\" ) ; } } catch ( Throwable t ) { Utils . exitWithFailure ( \"Throwable caught during the command-line arguments parsing\" , t ) ; } }'", "label": "'Parses command - line arguments and sets the local variables'"}
{"text": "'protected void printHelp ( final Options options ) { HelpFormatter formatter = new HelpFormatter ( ) ; formatter . printHelp ( \"check-replication [options]\" , options ) ; Utils . exitWithFailure ( ) ; }'", "label": "'Prints help if requested or in case of any misconfiguration'"}
{"text": "'protected Options constructGnuOptions ( ) { final Options gnuOptions = new Options ( ) ; gnuOptions . addOption ( \"t\" , TIMEOUT_OPTION , true , \"Timeout, ms. Default timeout is \" + DEFAULT_TIMEOUT ) . addOption ( \"r\" , REGION_OPTION , true , \"The name of region for this test. Default name is \\\\\"\" + DEFAULT_REGION_NAME + \"\\\\\"\" ) . addOption ( \"h\" , HELP_OPTION , false , \"Print usage information\" ) ; @ SuppressWarnings ( \"static-access\" ) Option locatorsOption = OptionBuilder . hasArgs ( ) . withDescription ( \"Cluster name and list of its locators. \" + \"There should be at least two clusters. \" + \"Example: -c cluster1=host1[port1],host2[port2] -c cluster2=host3[port3]\" ) . withValueSeparator ( ) . withArgName ( \"cluster=locators\" ) . withLongOpt ( CLUSTER_OPTION ) . create ( \"c\" ) ; gnuOptions . addOption ( locatorsOption ) ; return gnuOptions ; }'", "label": "'Constructs the set of GNU options'"}
{"text": "'public static void main ( String [ ] args ) throws AdminException { AdminDistributedSystem adminDs = AdminDistributedSystemFactory . getDistributedSystem ( AdminDistributedSystemFactory . defineDistributedSystem ( ) ) ; adminDs . connect ( ) ; //connect to different clusters. test data                             todo: insert cli usage Pool poolForCluster1 = PoolManager . createFactory ( ) . addLocator ( \"localhost\" , 10330 ) . create ( \"cluster1\" ) ; Pool poolForCluster2 = PoolManager . createFactory ( ) . addLocator ( \"localhost\" , 10332 ) . create ( \"cluster2\" ) ; //Pool poolForServer =  PoolManager.createFactory().addServer(\"localhost\", 40405).create(\"node\"); List < Pool > poolList = new ArrayList < Pool > ( ) ; poolList . add ( poolForCluster1 ) ; poolList . add ( poolForCluster2 ) ; //poolList.add(poolForServer); //todo: insert checking that each cluster contains region and one\\'s type is equal (Partitioned, Replicated) boolean partitioned = true ; //todo: insert CLI usage  + throw exception if real region has another type List < ServerLocation > serverFromPool = new ArrayList < ServerLocation > ( ) ; List < Pool > emptyPools = new ArrayList < Pool > ( ) ; //contains pool with no available servers for ( Pool pool : poolList ) { List < ServerLocation > allServers = null ; if ( ! pool . getLocators ( ) . isEmpty ( ) ) allServers = ( ( AutoConnectionSourceImpl ) ( ( PoolImpl ) pool ) . getConnectionSource ( ) ) . findAllServers ( ) ; else if ( ! pool . getServers ( ) . isEmpty ( ) ) allServers = Arrays . asList ( ( ( ( PoolImpl ) pool ) . getConnectionSource ( ) ) . findServer ( Collections . emptySet ( ) ) ) ; if ( allServers != null ) serverFromPool . addAll ( allServers ) ; else { logger . info ( \"not found servers on locator {}\" , pool ) ; emptyPools . add ( pool ) ; } } poolList . removeAll ( emptyPools ) ; if ( serverFromPool . size ( ) == 0 ) { logger . info ( \"no servers available\" ) ; return ; } for ( ServerLocation server : serverFromPool ) { System . out . println ( \"host: \" + server . getHostName ( ) ) ; System . out . println ( \"port: \" + server . getPort ( ) ) ; System . out . println ( \"----------------------\" ) ; } //source for comparison //todo: if this node doesn\\'t contain region! it\\'s problem Pool sourcePool ; if ( ! partitioned ) { int randomServerLocation = new Random ( ) . nextInt ( serverFromPool . size ( ) ) ; sourcePool = PoolManager . createFactory ( ) . addServer ( serverFromPool . get ( randomServerLocation ) . getHostName ( ) , serverFromPool . get ( randomServerLocation ) . getPort ( ) ) . create ( \"target\" ) ; } else { sourcePool = poolList . get ( 0 ) ; poolList . remove ( 0 ) ; } FunctionService . registerFunction ( new RegionInfoFunction ( ) ) ; ResultCollector regionInfoResult = FunctionService . onServers ( sourcePool ) . withArgs ( REGION_NAME ) . execute ( new RegionInfoFunction ( ) ) ; Map regionInfo = ( HashMap ) ( ( ArrayList ) regionInfoResult . getResult ( ) ) . get ( 0 ) ; System . out . println ( \"region info: \" + regionInfo ) ; int totalNumBuckets = ( Integer ) regionInfo . get ( \"totalNumBuckets\" ) ; //logger.debug(\"total keys\\' batch counts is \", totalNumBuckets); System . out . println ( \"total keys\\' batch counts is \" + totalNumBuckets ) ; KeyExtractor keyExtractor = new KeyExtractor ( REGION_NAME , sourcePool , partitioned , totalNumBuckets ) ; Map < String , Map < String , Set > > clusterDifference = new HashMap < String , Map < String , Set > > ( ) ; //key: memeberId list: absent keys, diff values //List<ResultCollector> taskResults = new ArrayList<ResultCollector>(); List < PoolResult > taskResults = new ArrayList < PoolResult > ( ) ; //List<Future<ResultCollector>> collectTasks = new ArrayList<Future<ResultCollector>>(poolList.size()); List < Future < PoolResult > > collectTasks = new ArrayList < Future < PoolResult > > ( poolList . size ( ) ) ; ExecutorService executorService = Executors . newFixedThreadPool ( poolList . size ( ) ) ; while ( keyExtractor . hasKeys ( ) ) { Set keys = keyExtractor . getNextKeysBatch ( ) ; System . out . println ( \"keys to check: \" + keys ) ; for ( Pool nextPool : poolList ) collectTasks . ( executorService . submit ( new CollectorTask ( keys , nextPool , REGION_NAME ) ) ) ; System . out . println ( \"active tasks: \" + collectTasks . size ( ) ) ; try { //for (Future<ResultCollector> futureTask : collectTasks) { for ( Future < PoolResult > futureTask : collectTasks ) { taskResults . add ( futureTask . get ( ) ) ; } } catch ( InterruptedException ie ) { ie . printStackTrace ( ) ; } catch ( ExecutionException ee ) { ee . printStackTrace ( ) ; } collectTasks . clear ( ) ; System . out . println ( \"compare contents..\" ) ; //getting original contents Map originalData = new HashMap ( ) ; /*           for (ResultCollector taskResultFromPool : taskResults) {\\n                List memberResult = (ArrayList) taskResultFromPool.getResult();\\n                if (!partitioned)\\n                    for (Object result : memberResult) {                        //if cluster has several nodes with replicated region... todo: adopt for partitioned\\n                        if (regionInfo.get(\"id\").equals(((HashMap) result).get(\"memberId\"))) {\\n                            originalData = (HashMap) ((HashMap) result).get(\"map\");\\n                            break;\\n                        }\\n                    }\\n                else {\\n                    FutureTask<ResultCollector> ft = new FutureTask<ResultCollector>(new CollectorTask(keys, sourcePool, REGION_NAME));\\n                    try {\\n                        ResultCollector rc = ft.get();\\n                    } catch (Exception e) {\\n                        throw new RuntimeException(\"error getting key-hashcode from pool: \" + sourcePool, e);\\n                    }\\n                }\\n            }*/ //FutureTask<ResultCollector> ft = new FutureTask<ResultCollector>(new CollectorTask(keys, sourcePool, REGION_NAME)); FutureTask < PoolResult > ft = new FutureTask < PoolResult > ( new CollectorTask ( keys , sourcePool , REGION_NAME ) ) ; ft . run ( ) ; try { //ResultCollector rc = ft.get(); PoolResult rc = ft . get ( ) ; List poolResult = ( List ) rc . getResultCollector ( ) . getResult ( ) ; for ( Object singleResult : poolResult ) { originalData . putAll ( ( Map ) ( ( HashMap ) singleResult ) . get ( \"map\" ) ) ; } } catch ( Exception e ) { throw new RuntimeException ( \"error getting key-hash from pool: \" + sourcePool , e ) ; } /*    if (true)\\n            return;\\n\\n        //todo: aggregate members\\' data from one cluster\\n        if (partitioned)\\n            aggregateSingleClusterMemberData(taskResults);*/ System . out . println ( \"original data is: \" + originalData ) ; //for (ResultCollector taskResultFromPool : taskResults) { for ( PoolResult taskResultFromPool : taskResults ) { List poolResult = ( ArrayList ) taskResultFromPool . getResultCollector ( ) . getResult ( ) ; if ( ! partitioned ) { for ( Object resultFromMember : poolResult ) { Map result = ( HashMap ) resultFromMember ; if ( regionInfo . get ( \"id\" ) . equals ( result . get ( \"memberId\" ) ) ) //for replicated region continue ; /*  System.out.println(\"member id: \" + result.get(\"memberId\"));\\n                        System.out.println(\"absent keys is \" + result.get(\"absentKeys\"));\\n                        System.out.println(\"it\\'s data is: \" + result.get(\"map\"));*/ String memberId = ( String ) result . get ( \"memberId\" ) ; Map memberData = ( HashMap ) result . get ( \"map\" ) ; Map memberDataCopy = new HashMap ( ) ; memberDataCopy . putAll ( memberData ) ; memberDataCopy . keySet ( ) . retainAll ( originalData . keySet ( ) ) ; Map < String , Set > aggregationInfo = new HashMap < String , Set > ( ) ; //contains aggregation info for a member //keys witch values are different Set keysForDiffValues = new HashSet ( ) ; Set absentKeys = new HashSet ( ) ; for ( Object regionKey : memberDataCopy . keySet ( ) ) if ( ! memberDataCopy . get ( regionKey ) . equals ( originalData . get ( regionKey ) ) ) //we compare not original values, but it\\'s hash code keysForDiffValues . add ( regionKey ) ; aggregationInfo . put ( \"diffValues\" , keysForDiffValues ) ; //absent keys memberData . keySet ( ) . removeAll ( memberDataCopy . keySet ( ) ) ; absentKeys . addAll ( memberData . keySet ( ) ) ; absentKeys . addAll ( ( HashSet ) result . get ( \"absentKeys\" ) ) ; aggregationInfo . put ( \"absentKeys\" , absentKeys ) ; /* if (!clusterDifference.containsKey(memberId)) {\\n                            clusterDifference.put(memberId, aggregationInfo);\\n                        } else {\\n                            Map<String, Set> difference = clusterDifference.get(memberId);\\n                            difference.get(\"absentKeys\").addAll(aggregationInfo.get(\"absentKeys\"));\\n                            difference.get(\"diffValues\").addAll(aggregationInfo.get(\"diffValues\"));\\n                            clusterDifference.put(memberId, difference);\\n                        }*/ if ( ! clusterDifference . containsKey ( memberId ) ) { clusterDifference . put ( memberId , aggregationInfo ) ; } else { Map < String , Set > difference = clusterDifference . get ( memberId ) ; difference . get ( \"absentKeys\" ) . addAll ( aggregationInfo . get ( \"absentKeys\" ) ) ; difference . get ( \"diffValues\" ) . addAll ( aggregationInfo . get ( \"diffValues\" ) ) ; clusterDifference . put ( memberId , difference ) ; } } } else { Map targetMap = new HashMap ( ) ; Set absentPoolKeys = new HashSet ( ) ; //aggregate absent keys from pool members for ( Object memberResult : poolResult ) { targetMap . putAll ( ( Map ) ( ( HashMap ) memberResult ) . get ( \"map\" ) ) ; absentPoolKeys . addAll ( ( Set ) ( ( ( HashMap ) memberResult ) . get ( \"absentKeys\" ) ) ) ; } Map memberDataCopy = new HashMap ( ) ; memberDataCopy . putAll ( targetMap ) ; memberDataCopy . keySet ( ) . retainAll ( originalData . keySet ( ) ) ; Map < String , Set > aggregationInfo = new HashMap < String , Set > ( ) ; //contains aggregation info for a member //keys witch values are different Set keysForDiffValues = new HashSet ( ) ; Set absentKeys = new HashSet ( ) ; for ( Object regionKey : memberDataCopy . keySet ( ) ) if ( ! memberDataCopy . get ( regionKey ) . equals ( originalData . get ( regionKey ) ) ) //we compare not original values, but it\\'s hash code keysForDiffValues . add ( regionKey ) ; aggregationInfo . put ( \"diffValues\" , keysForDiffValues ) ; //absent keys targetMap . keySet ( ) . removeAll ( memberDataCopy . keySet ( ) ) ; absentKeys . addAll ( targetMap . keySet ( ) ) ; absentKeys . addAll ( absentPoolKeys ) ; //aggregationInfo.put(\"absentKeys\", absentKeys); if ( ! clusterDifference . containsKey ( taskResultFromPool . getPool ( ) . toString ( ) ) ) { clusterDifference . put ( taskResultFromPool . getPool ( ) . toString ( ) , aggregationInfo ) ; } else { Map < String , Set > difference = clusterDifference . get ( taskResultFromPool . getPool ( ) . toString ( ) ) ; //  difference.get(\"absentKeys\").addAll(aggregationInfo.get(\"absentKeys\")); difference . get ( \"diffValues\" ) . addAll ( aggregationInfo . get ( \"diffValues\" ) ) ; clusterDifference . put ( taskResultFromPool . getPool ( ) . toString ( ) , difference ) ; } } } taskResults . clear ( ) ; } System . out . println ( \"____________________________\" ) ; System . out . println ( \"difference: \" ) ; System . out . println ( clusterDifference ) ; executorService . shutdown ( ) ; adminDs . disconnect ( ) ; }'", "label": "'todo : insert from cli'"}
{"text": "'private static void aggregateSingleClusterMemberData ( List < ResultCollector > taskResults ) { for ( ResultCollector singleCluster : taskResults ) { List membersResult = ( List ) singleCluster . getResult ( ) ; for ( Object resultFromNode : membersResult ) { System . out . print ( ( ( HashMap ) resultFromNode ) . get ( \"ds\" ) + \":\" ) ; } System . out . println ( ) ; } }'", "label": "'only for partitioned region!'"}
{"text": "'public void validate ( ) throws CustomConstraintViolationException { final String extension = getExtension ( ) ; if ( extension != null ) { for ( final LanguageImage langImg : languageImages ) { if ( langImg . getOriginalFileName ( ) != null && ! langImg . getOriginalFileName ( ) . isEmpty ( ) ) { final String thisExtension = FileUtilities . getFileExtension ( langImg . getOriginalFileName ( ) ) ; if ( ! thisExtension . toLowerCase ( ) . equals ( extension . toLowerCase ( ) ) ) throw new CustomConstraintViolationException ( \"All LanguageImages contained by an ImageFile need to have the same file extension\" ) ; } } } }'", "label": "'An image file can be represented by multiple translated images . These images can all be from originally differently names files and can have different dimensions . However all translated images need to be of the same file file . The getDocbookFileName () method needs to be able to append a fixed extension to the file name when the image is included in a Docbook XML file . <p / > This method will throw an exception if there are inconsistent file extensions on any of the original file names assigned to the translated images .'"}
{"text": "'public ExpressionBuilder notNull ( final Object property , final String name ) { if ( property == null ) { messageContainer . addErrorMessage ( \"Property \\'\" + name + \"\\' cannot be null\" ) ; } return this ; }'", "label": "'Adds a description for a null property .'"}
{"text": "'public ExpressionBuilder notNullOrEmpty ( final Object property , final String name ) { notNull ( property , name ) ; if ( property instanceof String && ( ( String ) property ) . isEmpty ( ) ) { messageContainer . addErrorMessage ( \"Property \\'\" + name + \"\\' cannot be empty.\" ) ; } if ( property instanceof Collection && ( ( Collection < ? > ) property ) . isEmpty ( ) ) { messageContainer . addErrorMessage ( \"Collection \\'\" + name + \"\\' must contain elements.\" ) ; } if ( property instanceof Map && ( ( Map < ? , ? > ) property ) . isEmpty ( ) ) { messageContainer . addErrorMessage ( \"Map \\'\" + name + \"\\' must contain elements.\" ) ; } return this ; }'", "label": "'Adds a description for a null or empty property ( Strings Collections and Maps are checked for emptyness as well as null - ness ) .'"}
{"text": "'private static void parseCommandLineArguments ( String [ ] commandLineArguments ) { Options options = constructGnuOptions ( ) ; CommandLineParser parser = new GnuParser ( ) ; try { CommandLine line = parser . parse ( options , commandLineArguments ) ; if ( line . hasOption ( HELP_OPTION ) ) { printHelp ( options ) ; } if ( line . hasOption ( DEBUG_OPTION ) ) { debugEnabled = true ; } if ( ! debugEnabled && line . hasOption ( QUIET_OPTION ) ) { quiet = true ; } } catch ( Throwable t ) { printHelp ( options ) ; } }'", "label": "'Parses command line arguments .'"}
{"text": "'private static void printHelp ( final Options options ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( \"java -jar icegem-cache-utils-<version>.jar [options] <\" ) ; Command [ ] commands = Command . values ( ) ; for ( int i = 0 ; i < commands . length ; i ++ ) { sb . append ( commands [ i ] . getName ( ) ) ; if ( i < ( commands . length - 1 ) ) { sb . append ( \" | \" ) ; } } sb . append ( \"> [command_specific_options]\" ) ; HelpFormatter formatter = new HelpFormatter ( ) ; formatter . printHelp ( sb . toString ( ) , options ) ; Utils . exitWithFailure ( ) ; }'", "label": "'Prints help if requested .'"}
{"text": "'private static Options constructGnuOptions ( ) { final Options gnuOptions = new Options ( ) ; gnuOptions . addOption ( \"d\" , DEBUG_OPTION , false , \"Print debug information\" ) . addOption ( \"q\" , QUIET_OPTION , false , \"Quiet output. Doesn\\'t work if --\" + DEBUG_OPTION + \" specified.\" ) . addOption ( \"h\" , HELP_OPTION , false , \"Print usage information\" ) ; return gnuOptions ; }'", "label": "'Constructs the set of GNU options .'"}
{"text": "'private static int findCommandIndex ( String [ ] args ) { int commandIndex = - 1 ; for ( int i = 0 ; i < args . length ; i ++ ) { for ( Command command : Command . values ( ) ) { if ( command . getName ( ) . equals ( args [ i ] . trim ( ) ) ) { commandIndex = i ; break ; } } } return commandIndex ; }'", "label": "'Looks for the index of command in the specified array .'"}
{"text": "'private static String [ ] extractLauncherArgs ( String [ ] args , int commandIndex ) { String [ ] launcherArgs = new String [ commandIndex ] ; System . arraycopy ( args , 0 , launcherArgs , 0 , commandIndex ) ; return launcherArgs ; }'", "label": "'Extracts the launcher arguments from the all arguments array .'"}
{"text": "'private static String [ ] extractCommandArgs ( String [ ] args , int commandIndex ) { String [ ] commandArgs = new String [ args . length - commandIndex - 1 ] ; System . arraycopy ( args , commandIndex + 1 , commandArgs , 0 , args . length - commandIndex - 1 ) ; return commandArgs ; }'", "label": "'Extracts the command - specific arguments from the all arguments array .'"}
{"text": "'public static void main ( String [ ] args ) { try { int commandIndex = findCommandIndex ( args ) ; if ( commandIndex < 0 ) { printHelp ( ) ; } String [ ] launcherArgs = extractLauncherArgs ( args , commandIndex ) ; String [ ] commandArgs = extractCommandArgs ( args , commandIndex ) ; parseCommandLineArguments ( launcherArgs ) ; debug ( \"Launcher#main(): args = \" + Arrays . asList ( args ) ) ; debug ( \"Launcher#main(): launcherArgs = \" + Arrays . asList ( launcherArgs ) ) ; debug ( \"Launcher#main(): commandArgs = \" + Arrays . asList ( commandArgs ) ) ; String commandName = args [ commandIndex ] ; Executable tool = Command . getUtil ( commandName ) ; if ( tool != null ) { tool . execute ( commandArgs , debugEnabled , quiet ) ; } else { debug ( \"Launcher#main(): Command \\\\\"\" + commandName + \"\\\\\" not found\" ) ; printHelp ( ) ; } } catch ( Throwable t ) { debug ( \"Launcher#main(): Throwable caught with message = \" + t . getMessage ( ) , t ) ; Utils . exitWithFailure ( \"Unexpected throwable\" , t ) ; } }'", "label": "'The entry point of the application .'"}
{"text": "'private static void debug ( String message , Throwable t ) { if ( debugEnabled ) { System . err . println ( \"0 [Launcher] \" + message ) ; if ( t != null ) { t . printStackTrace ( System . err ) ; } } }'", "label": "'Prints debug information if debug is enabled .'"}
{"text": "'@ Override protected String doRender ( final RenderConfiguration config , final Edge edge ) { // Edges can be from/to Nodes and Subgraphs. Pick the correct ID source. final String edgeID = edge . getNodeID ( ) != null ? nodeIdRenderer . doRender ( config , edge . getNodeID ( ) ) : quote ( edge . getSubgraph ( ) . getId ( ) ) ; // Render the attributes after the RightSideEdge. final RightSideEdge rightSideEdge = edge . getRightSideEdge ( ) ; return config . getIndent ( ) + edgeID + \" \" + rightSideEdgeRenderer . doRender ( config , rightSideEdge ) + \" \" + attributeRenderer . doRender ( config , edge . getAttributes ( ) ) ; }'", "label": "'<p > Renders the supplied Edge according to the following structure : < / p > <pre > ( node_id | subgraph ) edgeRHS [ attr_list ] < / pre > <p > ... where ... < / p > <pre > edgeRHS : edgeop ( node_id | subgraph ) [ edgeRHS ] < / pre >'"}
{"text": "'private void init ( ) { try { log . info ( Utils . currentDate ( ) + \"\" ) ; log . info ( Utils . currentDate ( ) + \"  --------------------------------------------------\" ) ; log . info ( Utils . currentDate ( ) + \"  Monitoring tool started\" ) ; log . info ( Utils . currentDate ( ) + \"  --------------------------------------------------\" ) ; propertiesHelper = new PropertiesHelper ( \"/monitoring.properties\" ) ; nodesController = new NodesController ( propertiesHelper , locators , timeout ) ; nodesController . addNodeEventHandler ( new LoggerNodeEventHandler ( ) ) ; for ( NodeEventHandler handler : customEventHandlersList ) { nodesController . addNodeEventHandler ( handler ) ; } timer = new Timer ( ) ; } catch ( Throwable t ) { Utils . exitWithFailure ( \"Throwable caught during the initialization\" , t ) ; } }'", "label": "'configuration'"}
{"text": "'private void start ( ) { try { timer . schedule ( new IsAliveTimerTask ( ) , 0 , period ) ; } catch ( Throwable t ) { Utils . exitWithFailure ( \"Throwable caught during the startup\" , t ) ; } }'", "label": "'Starts the checking task'"}
{"text": "'public Set < Region < ? , ? > > createRegions ( Map < String , String > regionNames ) { Set < Region < ? , ? > > regions = new HashSet < Region < ? , ? > > ( ) ; proxyRegionFactory = cache . createClientRegionFactory ( ClientRegionShortcut . PROXY ) ; for ( String regionPath : regionNames . keySet ( ) ) { Region region = createRegion ( regionPath , regionNames . get ( regionPath ) ) ; regions . add ( region ) ; } return regions ; }'", "label": "'Creates regions structure similar to server region structure .'"}
{"text": "'@ Override protected String doRender ( final RenderConfiguration config , final Comment comment ) { // Check sanity final StringBuilder builder = new StringBuilder ( config . getNewline ( ) + config . getIndent ( ) ) ; final List < String > commentLines = comment . getCommentLines ( ) ; if ( commentLines . size ( ) == 1 ) { // Use a \\'//\\' single-line comment builder . append ( \"// \" ) . append ( commentLines . get ( 0 ) ) ; } else if ( commentLines . size ( ) > 1 ) { // Use a \\'/*\\' ... \\'*/\\' multi-line comment builder . append ( \"/* \" ) . append ( config . getNewline ( ) ) ; for ( String current : commentLines ) { builder . append ( config . getIndent ( ) ) . append ( \" * \" ) . append ( current ) . append ( config . getNewline ( ) ) ; } builder . append ( config . getIndent ( ) ) . append ( \" */\" ) ; } // All Done. return builder . toString ( ) + config . getNewline ( ) ; }'", "label": "'{'"}
{"text": "'public long process ( Region < ? , ? > region , ExpirationPolicy policy ) { long destroyedEntriesNumber = 0 ; try { if ( region == null ) { throw new IllegalStateException ( \"The Region cannot be null\" ) ; } if ( policy == null ) { throw new IllegalArgumentException ( \"The ExpirationPolicy cannot be null\" ) ; } logger . info ( \"Running ExpirationController process with parameters region = \" + region + \", policy = \" + policy + \", packetSize = \" + packetSize + \", packetDelay = \" + packetDelay ) ; DestroyedEntriesCountCollector collector = ( DestroyedEntriesCountCollector ) FunctionService . onRegion ( region ) . withArgs ( new ExpirationFunctionArguments ( packetSize , packetDelay ) ) . withCollector ( new DestroyedEntriesCountCollector ( ) ) . execute ( new ExpirationFunction ( policy ) ) ; Object result = collector . getResult ( ) ; if ( result instanceof Long ) { destroyedEntriesNumber = ( Long ) result ; } logger . info ( \"ExpirationController process with parameters region = \" + region + \", policy = \" + policy + \", packetSize = \" + packetSize + \", packetDelay = \" + packetDelay + \" has destroyed \" + destroyedEntriesNumber + \" entries\" ) ; } catch ( RuntimeException re ) { logger . error ( \"RuntimeException during processing\" , re ) ; throw re ; } return destroyedEntriesNumber ; }'", "label": "'Applies the specified policy on the specified region and returns number of destroyed entries .'"}
{"text": "'public final void setIndentationToken ( final String indentationToken ) { // Check sanity if ( indentationToken == null || indentationToken . isEmpty ( ) ) { throw new IllegalArgumentException ( \"Cannot handle null or empty \\'indentationToken\\' argument.\" ) ; } // Assign internal state this . indentationToken = indentationToken ; }'", "label": "'Assigns the indentationToken of this RenderConfiguration .'"}
{"text": "'public final RenderConfiguration cloneAndChangeIndentation ( final int indentationChange ) throws IllegalArgumentException { // Check sanity final int newIndentationLevel = getIndentationLevel ( ) + indentationChange ; final RenderConfiguration toReturn = new RenderConfiguration ( newIndentationLevel , indentationToken , isDirectedGraph ) ; toReturn . getExtraConfiguration ( ) . putAll ( getExtraConfiguration ( ) ) ; // All Done. return toReturn ; }'", "label": "'Clones this RenderConfiguration and changes the indentation level ( of the returned RenderConfiguration ) as indicated .'"}
{"text": "'public String getIndent ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < getIndentationLevel ( ) ; i ++ ) { builder . append ( indentationToken ) ; } // All Done. return builder . toString ( ) ; }'", "label": "'Retrieves a full indent given the { @link #indentationToken } and { @link #indentationLevel } .'"}
{"text": "'@ Override public String getPackage ( final File sourceFile ) { String aLine = getPackage ( sourceFile , PACKAGE_STATEMENT ) ; if ( aLine != null ) return aLine ; // No package statement found. // Return default package. return \"\" ; }'", "label": "'Retrieves the package definition from the supplied sourceFile .'"}
{"text": "'public static boolean start ( final RootDoc root ) { // Perform some reflective investigation of the RootDoc final boolean toReturn = Standard . start ( root ) ; eventSequence . add ( \"start (root): \" + toReturn ) ; // We should emit the eventSequence here. for ( int i = 0 ; i < eventSequence . size ( ) ; i ++ ) { System . out . println ( \" event [\" + i + \" / \" + eventSequence . size ( ) + \"]: \" + eventSequence . get ( i ) ) ; } // All Done. return toReturn ; }'", "label": "'Generate documentation here . This method is required for all doclets .'"}
{"text": "'public static int optionLength ( final String option ) { final int standardOptionLength = Standard . optionLength ( option ) ; eventSequence . add ( \"optionLength (\" + option + \"): \" + standardOptionLength ) ; return standardOptionLength ; }'", "label": "'<p > Check for doclet - added options . Returns the number of arguments you must specify on the command line for the given option . For example - d docs would return 2 . < / p > <p > This method is required if the doclet contains any options . If this method is missing Javadoc will print an invalid flag error for every option . < / p >'"}
{"text": "'public static boolean validOptions ( final String options [ ] [ ] , DocErrorReporter reporter ) { final boolean toReturn = Standard . validOptions ( options , reporter ) ; if ( options == null || options . length == 0 ) { eventSequence . add ( \"validOptions (none supplied): \" + toReturn ) ; } else { for ( int i = 0 ; i < options . length ; i ++ ) { final String thisOption = Arrays . stream ( options [ i ] ) . reduce ( ( l , r ) -> l + \" \" + r ) . orElse ( \"<none>\" ) ; eventSequence . add ( \"validOptions [\" + i + \" / \" + options . length + \"] (\" + thisOption + \"): \" + toReturn ) ; } } // All Done. return toReturn ; }'", "label": "'Check that options have the correct arguments . <p > This method is not required but is recommended as every option will be considered valid if this method is not present . It will default gracefully ( to true ) if absent . <p > Printing option related error messages ( using the provided DocErrorReporter ) is the responsibility of this method .'"}
{"text": "'private Set < Integer > extractPortsSet ( SystemMember member ) throws AdminException { Set < Integer > portsSet = new HashSet < Integer > ( ) ; SystemMemberCache cache = member . getCache ( ) ; if ( cache != null ) { SystemMemberCacheServer [ ] cacheServers = cache . getCacheServers ( ) ; if ( cacheServers != null ) { for ( SystemMemberCacheServer cacheServer : cacheServers ) { portsSet . add ( cacheServer . getPort ( ) ) ; } } } return portsSet ; }'", "label": "'Extracts port from the SystemMember object .'"}
{"text": "'private Pool findOrCreatePool ( String host , int port ) { String poolName = Utils . toKey ( host , port ) ; Pool pool = PoolManager . find ( poolName ) ; if ( pool == null ) { poolFactory . reset ( ) ; poolFactory . addServer ( host , port ) ; pool = poolFactory . create ( poolName ) ; } return pool ; }'", "label": "'Looks for the existing pool with name poolFactory . If there is no such pool creates new one .'"}
{"text": "'public static String getName ( String eventSrcName ) { if ( eventSrcName == null ) { return null ; } if ( eventSrcName . endsWith ( \"Check\" ) ) { eventSrcName = eventSrcName . substring ( 0 , eventSrcName . length ( ) - 5 ) ; } return eventSrcName . substring ( eventSrcName . lastIndexOf ( \\' \\' ) + 1 ) ; }'", "label": "'Get the rule name from an audit event source name .'"}
{"text": "'public static String getCategory ( String eventSrcName ) { if ( eventSrcName == null ) { return null ; } int end = eventSrcName . lastIndexOf ( \\' \\' ) ; eventSrcName = eventSrcName . substring ( 0 , end ) ; if ( CHECKSTYLE_PACKAGE . equals ( eventSrcName ) ) { return \"misc\" ; } else if ( ! eventSrcName . startsWith ( CHECKSTYLE_PACKAGE ) ) { return \"extension\" ; } return eventSrcName . substring ( eventSrcName . lastIndexOf ( \\' \\' ) + 1 ) ; }'", "label": "'Get the rule category from an audit event source name .'"}
{"text": "'@ Override public void printError ( final SourcePosition pos , final String msg ) { wrappedRootDoc . printError ( pos , msg ) ; }'", "label": "'{'"}
{"text": "'@ Override public void printWarning ( final SourcePosition pos , final String msg ) { wrappedRootDoc . printWarning ( pos , msg ) ; }'", "label": "'{'"}
{"text": "'@ Override public void printNotice ( final SourcePosition pos , final String msg ) { wrappedRootDoc . printNotice ( pos , msg ) ; }'", "label": "'{'"}
{"text": "'public static void enterFrame ( String className ) { int counter = local . get ( ) . incrementAndGet ( ) ; classNames . get ( ) . add ( className ) ; if ( counter == MAX_STACK_DEPTH ) { throw new RuntimeException ( STACK_OVERFLOW_MSG + getClassNames ( ) ) ; } }'", "label": "'Increment the counter .'"}
{"text": "'public static void exitFrame ( String className ) { int counter = local . get ( ) . decrementAndGet ( ) ; if ( counter < 0 ) { String errorMessage = \"Method frame counter is less then 0. Some programming error: count(exitFrame) > count(enterFrame).\" + getClassNames ( ) ; clearCounter ( ) ; throw new RuntimeException ( errorMessage ) ; } String frameToExit = classNames . get ( ) . remove ( classNames . get ( ) . size ( ) - 1 ) ; if ( ! className . equals ( frameToExit ) ) { throw new RuntimeException ( \"Method frame counter try to exit from the class \\'\" + className + \"\\' but must exit from the class \\'\" + frameToExit + \"\\' first.\" + getClassNames ( ) ) ; } }'", "label": "'Decrement the counter and remove class name from the list .'"}
{"text": "'private static String getClassNames ( ) { StringBuilder result = new StringBuilder ( \"\\\\nMethod frame counter enter to the following classes:\\\\n\" ) ; for ( String className : classNames . get ( ) ) { result . append ( className ) . append ( \"\\\\n\" ) ; } return result . toString ( ) ; }'", "label": "'Creates string with all classes that have been entered by method frame counter .'"}
{"text": "'public String process ( XProperty field ) { String fieldName = field . getName ( ) ; String fullClassName = CodeGenUtils . className ( field . getType ( ) ) ; return \"if (in.readByte() != 0) {\\\\n\" + CodeGenUtils . tab ( \"result.set\" + CodeGenUtils . firstLetterToUpperCase ( fieldName ) + \"(\" + \"(\" + fullClassName + \") \" + \"com.gemstone.gemfire.DataSerializer.readObject(in)\" + \");\\\\n\" ) + \"}\\\\n\" ; }'", "label": "'}'"}
{"text": "'@ Override @ SuppressWarnings ( \"unchecked\" ) protected void performValidation ( final MavenProject project , final EnforcerRuleHelper helper ) throws RuleFailureException { // Find all java source files, and map their packages to their names. final List < String > compileSourceRoots = ( List < String > ) project . getCompileSourceRoots ( ) ; if ( compileSourceRoots . size ( ) == 0 ) { return ; } final SortedMap < String , SortedSet < String > > packageName2SourceFileNameMap = new TreeMap < String , SortedSet < String > > ( ) ; for ( String current : compileSourceRoots ) { addPackages ( new File ( current ) , packageName2SourceFileNameMap ) ; } // Retrieve the groupId of this project final String groupId = project . getGroupId ( ) ; if ( groupId == null || groupId . equals ( \"\" ) ) { // Don\\'t accept empty groupIds throw new RuleFailureException ( \"Maven groupId cannot be null or empty.\" , project . getArtifact ( ) ) ; } else { // Correct packaging everywhere? final SortedSet < String > incorrectPackages = new TreeSet < String > ( ) ; for ( Map . Entry < String , SortedSet < String > > currentPackage : packageName2SourceFileNameMap . entrySet ( ) ) { final String candidate = currentPackage . getKey ( ) ; if ( ! candidate . startsWith ( groupId ) ) { incorrectPackages . add ( candidate ) ; } } if ( incorrectPackages . size ( ) > 0 ) { final SortedMap < String , SortedSet < String > > result = new TreeMap < String , SortedSet < String > > ( ) ; for ( String current : incorrectPackages ) { result . put ( current , packageName2SourceFileNameMap . get ( current ) ) ; } throw new RuleFailureException ( \"Incorrect packaging detected; required [\" + groupId + \"] but found package to file names: \" + result , project . getArtifact ( ) ) ; } } }'", "label": "'Delegate method implemented by concrete subclasses .'"}
{"text": "'public final void setPackageExtractors ( final String packageExtractorImplementations ) throws IllegalArgumentException { // Check sanity if ( packageExtractorImplementations == null ) { throw new NullPointerException ( \"Cannot handle empty packageExtractorImplementations argument.\" ) ; } // Instantiate the PackageExtractor instances. List < PackageExtractor > extractors = new ArrayList < PackageExtractor > ( ) ; for ( String current : splice ( packageExtractorImplementations ) ) { try { // Load the current PackageExtractor implementation class final Class < ? > aClass = getClass ( ) . getClassLoader ( ) . loadClass ( current ) ; // The PackageExtractor implementation must have a default constructor. // Fire, and handle any exceptions. extractors . add ( ( PackageExtractor ) aClass . newInstance ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( \"Could not instantiate PackageExtractor from class [\" + current + \"]. Validate that implementation has a default constructor, and implements the\" + PackageExtractor . class . getSimpleName ( ) + \" interface.\" ) ; } } // Assign if non-null. if ( extractors . size ( ) > 0 ) { this . packageExtractors = extractors ; } }'", "label": "'Splices the supplied packageExtractorImplementations argument which is assumed to be a comma - separated string holding fully qualified class names of the PackageExtractor implementations which should be used by this CorrectPackagingRule .'"}
{"text": "'private void addPackages ( final File fileOrDirectory , final SortedMap < String , SortedSet < String > > package2FileNamesMap ) { for ( PackageExtractor current : packageExtractors ) { final FileFilter sourceFileDefinitionFilter = current . getSourceFileFilter ( ) ; if ( fileOrDirectory . isFile ( ) && sourceFileDefinitionFilter . accept ( fileOrDirectory ) ) { // Single source file to add. final String thePackage = current . getPackage ( fileOrDirectory ) ; SortedSet < String > sourceFileNames = package2FileNamesMap . get ( thePackage ) ; if ( sourceFileNames == null ) { sourceFileNames = new TreeSet < String > ( ) ; package2FileNamesMap . put ( thePackage , sourceFileNames ) ; } // Done. sourceFileNames . add ( fileOrDirectory . getName ( ) ) ; } else if ( fileOrDirectory . isDirectory ( ) ) { // Add the immediate source files for ( File currentChild : fileOrDirectory . listFiles ( sourceFileDefinitionFilter ) ) { addPackages ( currentChild , package2FileNamesMap ) ; } // Recurse into subdirectories for ( File currentSubdirectory : fileOrDirectory . listFiles ( DIRECTORY_FILTER ) ) { addPackages ( currentSubdirectory , package2FileNamesMap ) ; } } } }'", "label": "'Adds all source file found by recursive search under sourceRoot to the toPopulate List using a width - first approach .'"}
{"text": "'@ PrePersist @ PreUpdate private void updateImageData ( ) throws CustomConstraintViolationException { thumbnail = createImage ( true ) ; imageFile . validate ( ) ; if ( imageData != null ) { imageContentHash = HashUtilities . generateSHA256 ( imageData ) . toCharArray ( ) ; } }'", "label": "'Create the thumbnails and make sure the parent imagefile is valid .'"}
{"text": "'public void setUiOriginalFileName ( final String uiOriginalFileName ) { this . uiOriginalFileName = uiOriginalFileName ; if ( this . uiOriginalFileName != null && ! this . uiOriginalFileName . isEmpty ( ) ) originalFileName = this . uiOriginalFileName ; }'", "label": "'The UI will attempt to assign an empty value if the file upload box does not have a file selected . This method is used to ignore any empty values while passing through any legitimate file uploads . This means that the absence of a file in the upload box does not indicate that no file should be assigned to the entity .'"}
{"text": "'@ SuppressWarnings ( { \"unchecked\" } ) public static SelectResults < Object > executeOnBuckets ( String queryString , Region region , Set < Object > keys ) throws QueryException { return executeOnBuckets ( queryString , null , region , keys ) ; }'", "label": "'Executes a particular query on specified region using a set of keys that represents buckets . The set of buckets is determined by keys of entries that are stored in such buckets : - real and fake keys can be used ( such key should have the same routing object as bucket s keys have ) ; - it will be enough to specify one key for each bucket . Work of this method is based on execution of function .'"}
{"text": "'@ SuppressWarnings ( { \"unchecked\" } ) public static SelectResults < Object > executeOnBuckets ( String queryString , Object [ ] queryParameters , Region region , Set < Object > keys ) throws QueryException { if ( ( queryString == null ) || ( queryString . length ( ) == 0 ) ) { throw new QueryException ( \"You must specify query string for execution.\" ) ; } int limit = extractLimit ( queryString ) ; BucketOrientedQueryFunctionArgument functionArgument = new BucketOrientedQueryFunctionArgument ( queryString , queryParameters ) ; BucketOrientedQueryFunction function = new BucketOrientedQueryFunction ( ) ; FunctionService . registerFunction ( function ) ; List < List < Object > > queryResults ; try { queryResults = ( List < List < Object > > ) FunctionService . onRegion ( region ) . withFilter ( keys ) . withArgs ( functionArgument ) . execute ( function ) . getResult ( ) ; } catch ( FunctionException e ) { logger . error ( \"Failed to execute bucket oriented query function: \" + function , e ) ; throw new QueryException ( e . getMessage ( ) ) ; } return formatSelectResults ( queryResults , limit ) ; }'", "label": "'Executes a particular query with parameters on specified region using a set of keys that represents buckets . The set of buckets is determined by keys of entries that are stored in such buckets : - real and fake keys can be used ( such key should have the same routing object as bucket s keys have ) ; - it will be enough to specify one key for each bucket . Work of this method is based on execution of function .'"}
{"text": "'private static int extractLimit ( String queryString ) { int limitIndex = queryString . lastIndexOf ( \"limit\" ) ; if ( limitIndex == - 1 ) { limitIndex = queryString . lastIndexOf ( \"LIMIT\" ) ; } if ( limitIndex == - 1 ) { return limitIndex ; } String limitValue = queryString . substring ( limitIndex + 5 ) ; return Integer . parseInt ( limitValue . trim ( ) ) ; }'", "label": "'Extracts limit value from query string .'"}
{"text": "'@ SuppressWarnings ( { \"unchecked\" } ) private static SelectResults < Object > formatSelectResults ( List < List < Object > > queryResults , int limit ) { List < Object > list = new ArrayList < Object > ( ) ; ObjectType baseElementType = null ; for ( List < Object > queryResult : queryResults ) { ObjectType elementType = ( ObjectType ) queryResult . remove ( queryResult . size ( ) - 1 ) ; if ( baseElementType == null ) { baseElementType = elementType ; } else if ( ! baseElementType . equals ( elementType ) ) { throw new IllegalStateException ( \"Collection types for query result are different.\" ) ; } list . addAll ( queryResult ) ; if ( limit != - 1 && list . size ( ) >= limit ) { break ; } } return limit == - 1 ? new ResultsCollectionWrapper ( baseElementType , list ) : new ResultsCollectionWrapper ( baseElementType , list , limit ) ; }'", "label": "'Collects and formats query results into SelectResults . Limits query results based on limit value .'"}
{"text": "'private static void checkAllowedInRealTime0 ( Object obj , int depth ) throws InvalidClassException { if ( depth >= MethodFrameCounter . MAX_STACK_DEPTH ) { //todo: correct >? or >=? throw new RuntimeException ( ) ; } Class < ? > clazz = obj . getClass ( ) ; if ( clazz . getName ( ) . startsWith ( \"java.\" ) || clazz . getName ( ) . startsWith ( \"javax.\" ) ) { checkAllowedInCompileTimeJdkType ( clazz ) ; } else { checkAllowedInCompileTimeCustomType ( clazz ) ; } // array if ( clazz . isArray ( ) ) { final int length = Array . getLength ( obj ) ; for ( int k = 0 ; k < length ; k ++ ) { Object elem = Array . get ( obj , k ) ; checkAllowedInRealTime0 ( elem , depth + 1 ) ; } } // Collection if ( Collection . class . isAssignableFrom ( clazz ) ) { for ( Object elem : ( ( Collection ) obj ) ) { checkAllowedInRealTime0 ( elem , depth + 1 ) ; } } // Map if ( Map . class . isAssignableFrom ( clazz ) ) { for ( Map . Entry < Object , Object > elem : ( ( Map < Object , Object > ) obj ) . entrySet ( ) ) { checkAllowedInRealTime0 ( elem . getKey ( ) , depth + 1 ) ; checkAllowedInRealTime0 ( elem . getValue ( ) , depth + 1 ) ; } } }'", "label": "'With stack counter'"}
{"text": "'public int runAndWaitProcessExitCode ( String id , Class < ? > klass , String [ ] javaArguments , String [ ] processArguments ) throws IOException , InterruptedException { Process process = startProcess ( id , klass , javaArguments , processArguments , false ) ; process . waitFor ( ) ; return process . exitValue ( ) ; }'", "label": "'Runs process with arguments based on a specified class in a separate VM . Waits while process is working and returns exit code after process finished . @param id TODO @param klass of type Class @param javaArguments arguments for java @param processArguments arguments for process'"}
{"text": "'public Process runWithoutConfirmation ( String id , Class < ? > clazz , String [ ] javaArguments , String [ ] processArguments ) throws IOException , InterruptedException { return startProcess ( id , clazz , javaArguments , processArguments , false ) ; }'", "label": "'Runs a process and returns the Process object . @param id TODO @param clazz - the class to run @param javaArguments arguments for java @param processArguments arguments for process'"}
{"text": "'public Process runWithConfirmation ( String id , Class < ? > klass , String [ ] javaArguments , String [ ] processArguments ) throws IOException , InterruptedException { Process process = startProcess ( id , klass , javaArguments , processArguments , true ) ; waitConfirmation ( klass . getSimpleName ( ) , process ) ; new StreamRedirector ( process . getInputStream ( ) , klass . getSimpleName ( ) + PROCESS_STDOUT_STREAM_PREFIX , redirectProcessInputStreamToParentProcessStdOut ) . start ( ) ; return process ; }'", "label": "'Runs process based on a specified class in a separate VM using array of arguments . To confirm that process completes startup it should write a startup completed string into it s standard output .'"}
{"text": "'public Process runWithStartupDelay ( Class < ? > klass , String [ ] javaArguments , String [ ] processArguments ) throws IOException , InterruptedException , TimeoutException { return runWithStartupDelay ( klass , javaArguments , processArguments , DEFAULT_PROCESS_STARTUP_SHUTDOWN_TIME ) ; }'", "label": "'Runs process with arguments based on a specified class in a separate VM . Waits DEFAULT_PROCESS_STARTUP_TIME before returns the created process to a caller .'"}
{"text": "'public Process runWithStartupDelay ( Class < ? > klass , String [ ] javaArguments , String [ ] processArguments , long processStartupTime ) throws IOException , InterruptedException , TimeoutException { Process process = runWithConfirmation ( \"\" , klass , javaArguments , processArguments ) ; if ( processStartupTime > 0 ) { Thread . sleep ( processStartupTime ) ; } return process ; }'", "label": "'Runs process with arguments based on a specified class in a separate VM . Waits processStartupTime before returns the created process to a caller .'"}
{"text": "'public void stopBySendingNewLineIntoProcess ( Process process ) throws IOException , InterruptedException { if ( process != null ) { BufferedWriter writer = new BufferedWriter ( new OutputStreamWriter ( process . getOutputStream ( ) ) ) ; writer . newLine ( ) ; writer . flush ( ) ; process . waitFor ( ) ; } }'", "label": "'Stops process by sending new line to it s output stream .'"}
{"text": "'private Process startProcess ( String id , Class < ? > klass , String [ ] javaArguments , String [ ] processArguments , boolean withConfirmation ) throws IOException , InterruptedException { List < String > arguments = createCommandLineForProcess ( klass , javaArguments , processArguments ) ; Process process = new ProcessBuilder ( arguments ) . start ( ) ; redirectProcessStreams ( id , klass , process , ! withConfirmation ) ; return process ; }'", "label": "'Starts process based on specified class using command line arguments . This process inherits a classpath from parent VM that starts it .'"}
{"text": "'private void redirectProcessStreams ( String id , Class < ? > klass , Process process , boolean redirectProcessStdOut ) { String errorStreamType = ( printType ? klass . getSimpleName ( ) + id + PROCESS_ERROR_STREAM_PREFIX : \"\" ) ; new StreamRedirector ( process . getErrorStream ( ) , errorStreamType , redirectProcessErrorStreamToParentProcessStdOut , System . err ) . start ( ) ; if ( redirectProcessStdOut ) { String outputStreamType = ( printType ? klass . getSimpleName ( ) + id + PROCESS_STDOUT_STREAM_PREFIX : \"\" ) ; new StreamRedirector ( process . getInputStream ( ) , outputStreamType , redirectProcessInputStreamToParentProcessStdOut , System . out ) . start ( ) ; } }'", "label": "'Redirects process standard output and error streams into parent process standard output .'"}
{"text": "'private List < String > createCommandLineForProcess ( Class < ? > klazz , String [ ] processArguments ) { return createCommandLineForProcess ( klazz , null , processArguments ) ; }'", "label": "'Builds command line for starting java process based on specified arguments .'"}
{"text": "'private List < String > createCommandLineForProcess ( Class < ? > klazz , String [ ] javaArguments , String [ ] processArguments ) { String javaHome = System . getProperty ( \"java.home\" ) ; String javaBin = javaHome + File . separator + \"bin\" + File . separator + \"java\" ; String classpath = System . getProperty ( \"java.class.path\" ) ; List < String > argumentsList = new ArrayList < String > ( ) ; argumentsList . add ( javaBin ) ; argumentsList . add ( \"-cp\" ) ; argumentsList . add ( classpath ) ; if ( javaArguments != null && javaArguments . length > 0 ) { argumentsList . addAll ( Arrays . asList ( javaArguments ) ) ; } argumentsList . add ( klazz . getCanonicalName ( ) ) ; if ( processArguments != null && processArguments . length > 0 ) { argumentsList . addAll ( Arrays . asList ( processArguments ) ) ; } return argumentsList ; }'", "label": "'Builds command line for starting java process based on specified arguments .'"}
{"text": "'private void waitConfirmation ( String className , Process process ) throws IOException , InterruptedException { System . out . println ( \"Waiting startup complete confirmation for a process (\" + className + \")...\" ) ; BufferedReader bufferedReader = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; String line ; while ( ( line = bufferedReader . readLine ( ) ) != null ) { if ( line . equals ( PROCESS_STARTUP_COMPLETED ) ) { System . out . println ( \"The process (\" + className + \") has been started successfully\" ) ; return ; } else if ( redirectProcessInputStreamToParentProcessStdOut ) { System . out . println ( className + PROCESS_STDOUT_STREAM_PREFIX + line ) ; } } throw new InterruptedException ( \"Process (\" + className + \") \" + \"has been already finished without startup complete confirmation\" ) ; }'", "label": "'Waits startup complete confirmation from process .'"}
{"text": "'@ Override protected Graph doConvert ( final VisualizationWrappedRootDoc toConvert ) { final Graph toReturn = new Graph ( ) ; // Create subgraphs for each package and add them to the returned Graph. toConvert . sortClassesPerPackage ( ) . forEach ( ( packageDoc , classDocs ) -> toReturn . add ( convertPackage ( packageDoc , classDocs ) ) ) ; // All Done. return toReturn ; }'", "label": "'{'"}
{"text": "'public void generate ( String outputFilename , String template , Context context ) throws VelocityException , MojoExecutionException , IOException { Writer writer = null ; try { File f = new File ( outputFilename ) ; if ( ! f . getParentFile ( ) . exists ( ) ) { f . getParentFile ( ) . mkdirs ( ) ; } writer = new FileWriter ( f ) ; getVelocity ( ) . getEngine ( ) . mergeTemplate ( templateDirectory + \"/\" + template , context , writer ) ; } catch ( ResourceNotFoundException e ) { throw new ResourceNotFoundException ( \"Template not found: \" + templateDirectory + \"/\" + template , e ) ; } catch ( VelocityException | IOException e ) { throw e ; // to get past generic catch for Exception. } catch ( Exception e ) { throw new MojoExecutionException ( e . getMessage ( ) , e ) ; } finally { if ( writer != null ) { writer . flush ( ) ; writer . close ( ) ; getLog ( ) . debug ( \"File \" + outputFilename + \" created...\" ) ; } } }'", "label": "'Using a specified Velocity Template and provided context create the outputFilename .'"}
{"text": "'public void fileStarted ( AuditEvent event ) { final String fileName = StringUtils . replace ( event . getFileName ( ) , \"\\\\\\\\\" , \"/\" ) ; for ( File sourceDirectory : sourceDirectories ) { String sourceDirectoryPath = StringUtils . replace ( sourceDirectory . getPath ( ) , \"\\\\\\\\\" , \"/\" ) ; if ( fileName . startsWith ( sourceDirectoryPath + \"/\" ) ) { currentFile = StringUtils . substring ( fileName , sourceDirectoryPath . length ( ) + 1 ) ; events = getResults ( ) . getFileViolations ( currentFile ) ; break ; } } if ( events == null ) { events = new ArrayList <> ( ) ; } }'", "label": "'{'"}
{"text": "'public void addError ( AuditEvent event ) { if ( SeverityLevel . IGNORE . equals ( event . getSeverityLevel ( ) ) ) { return ; } if ( severityLevel == null || severityLevel . equals ( event . getSeverityLevel ( ) ) ) { events . add ( event ) ; } }'", "label": "'{'"}
{"text": "'public int process ( ) throws IOException , InterruptedException { debug ( \"ReplicationProcessor#process(): Processing start\" ) ; Properties gemfireProperties = PropertiesHelper . filterProperties ( System . getProperties ( ) , \"gemfire.\" ) ; String [ ] vmOptions = PropertiesHelper . propertiesToVMOptions ( gemfireProperties ) ; debug ( \"ReplicationProcessor#process(): vmOptions = \" + Arrays . asList ( vmOptions ) ) ; List < Process > processesList = new ArrayList < Process > ( ) ; for ( Object keyObject : clustersProperties . keySet ( ) ) { String cluster = ( String ) keyObject ; String clustersPropertiesString = PropertiesHelper . propertiesToString ( clustersProperties ) ; debug ( \"ReplicationProcessor#process(): Starting GuestNode with parameters: cluster = \" + cluster + \", clustersPropertiesString = \" + clustersPropertiesString + \", timeout = \" + timeout + \", regionName = \" + regionName ) ; Process process = javaProcessLauncher . runWithoutConfirmation ( \"\" , GuestNode . class , vmOptions , new String [ ] { cluster , clustersPropertiesString , String . valueOf ( timeout ) , regionName , String . valueOf ( debugEnabled ) , String . valueOf ( quiet ) , String . valueOf ( processingStartedAt ) } ) ; debug ( \"ReplicationProcessor#process(): Adding GuestNode to processList\" ) ; processesList . add ( process ) ; } debug ( \"ReplicationProcessor#process(): Waiting for processes finish\" ) ; int mainExitCode = 0 ; int processNumber = 0 ; for ( Process process : processesList ) { debug ( \"ReplicationProcessor#process(): Waiting for process #\" + processNumber ) ; int exitCode = process . waitFor ( ) ; if ( exitCode != 0 ) { mainExitCode = 1 ; } debug ( \"ReplicationProcessor#process(): Process #\" + processNumber + \" finished with exitCode = \" + exitCode ) ; processNumber ++ ; } debug ( \"ReplicationProcessor#process(): Processing finished with mainExitCode = \" + mainExitCode ) ; return mainExitCode ; }'", "label": "'Creates configures and runs the guest nodes and collects information form them'"}
{"text": "'private void debug ( String message ) { if ( debugEnabled ) { long currentTime = System . currentTimeMillis ( ) ; long timeSinceProcessingStart = currentTime - processingStartedAt ; System . err . println ( timeSinceProcessingStart + \" [ReplicationProcessor] \" + message ) ; } }'", "label": "'Prints debug information if the debug is enabled'"}
{"text": "'@ Pointcut ( value = \"initialization(se.jguru.nazgul.tools.validation.api.Validatable+.new(..)) && if()\" , argNames = \"joinPoint\" ) public static boolean anyNonDefaultConstructor ( final JoinPoint joinPoint ) { // Extract the JoinPoint signature. final Signature signature = joinPoint . getSignature ( ) ; final boolean isConstructorSignature = signature instanceof ConstructorSignature ; if ( isConstructorSignature ) { final Constructor constructor = ( ( ConstructorSignature ) signature ) . getConstructor ( ) ; final boolean isNonDefaultConstructor = constructor != null && constructor . getParameters ( ) . length > 0 ; log . trace ( \"Non-Default Constructor signature [\" + signature . toString ( ) + \"] for [\" + ( constructor == null ? \"<null>\" : constructor . toString ( ) ) + \"]: \" + isNonDefaultConstructor ) ; // All Done. return isNonDefaultConstructor ; } else { log . debug ( \"Found non-constructor signature: \" + signature ) ; } // Nopes. return false ; }'", "label": "'Defines a Pointcut for any constructor to a class implementing Validatable . The Pointcut will return { @code true } for all non - default Constructors i . e . when the signature of the JoinPoint has more than 0 arguments .'"}
{"text": "'@ AfterReturning ( value = \"anyNonDefaultConstructor(joinPoint) && target(aValidatable)\" , argNames = \"joinPoint, aValidatable\" ) public void performValidationAfterCompoundConstructor ( final JoinPoint joinPoint , final Validatable aValidatable ) throws InternalStateValidationException { if ( log . isDebugEnabled ( ) ) { log . debug ( \"Validating instance of type [\" + aValidatable . getClass ( ) . getName ( ) + \"]\" ) ; } if ( joinPoint . getStaticPart ( ) == null ) { log . warn ( \"Static part of join point was null for validatable of type: \" + aValidatable . getClass ( ) . getName ( ) , new IllegalStateException ( ) ) ; return ; } // Ignore calling validateInternalState when we execute constructors in // any class but the concrete Validatable class. final ConstructorSignature sig = ( ConstructorSignature ) joinPoint . getSignature ( ) ; final Class < ? > constructorDefinitionClass = sig . getConstructor ( ) . getDeclaringClass ( ) ; if ( aValidatable . getClass ( ) == constructorDefinitionClass ) { // Now fire the validateInternalState method. aValidatable . validateInternalState ( ) ; } else { log . debug ( \"Ignored firing validatable for constructor defined in [\" + constructorDefinitionClass . getName ( ) + \"] and Validatable of type [\" + aValidatable . getClass ( ) . getName ( ) + \"]\" ) ; } }'", "label": "'Aspect invoking the { @link Validatable#validateInternalState () } method before returning from any non - default constructor within a class implementing { @link Validatable } .'"}
{"text": "'public static void example1 ( String ... args ) { /* Synchronous service. */ final TodoManager todoManagerImpl = new TodoManager ( ) ; /*\\n        Create the service which manages async calls to todoManagerImpl.\\n         */ final ServiceQueue serviceQueue = serviceBuilder ( ) . setServiceObject ( todoManagerImpl ) . build ( ) . startServiceQueue ( ) ; /* Create Asynchronous proxy over Synchronous service. */ final TodoManagerClientInterface todoManager = serviceQueue . createProxy ( TodoManagerClientInterface . class ) ; serviceQueue . startCallBackHandler ( ) ; System . out . println ( \"This is an async call\" ) ; /* Asynchronous method call. */ todoManager . add ( new Todo ( \"Call Mom\" , \"Give Mom a call\" ) ) ; AtomicInteger countTracker = new AtomicInteger ( ) ; //Hold count from async call to service System . out . println ( \"This is an async call to count\" ) ; todoManager . count ( count -> { System . out . println ( \"This lambda expression is the callbackWithTimeout \" + count ) ; countTracker . set ( count ) ; } ) ; todoManager . clientProxyFlush ( ) ; //Flush all methods. It batches calls. Sys . sleep ( 100 ) ; System . out . printf ( \"This is the count back from the server %d\\\\n\" , countTracker . get ( ) ) ; System . out . printf ( \"END EXAMPLE 1 %s \\\\n\" , countTracker . get ( ) ) ; System . out . printf ( \"END EXAMPLE 1 %s \\\\n\" , countTracker . get ( ) ) ; System . out . printf ( \"END EXAMPLE 1 %s \\\\n\" , countTracker . get ( ) ) ; System . out . printf ( \"END EXAMPLE 1 %s \\\\n\" , countTracker . get ( ) ) ; }'", "label": "'You can use services in process'"}
{"text": "'public static void example2 ( String ... args ) { /* Synchronous service. */ final TodoManager todoManagerImpl = new TodoManager ( ) ; /*\\n        Create the service which manages async calls to todoManagerImpl.\\n\\n        You can control the batch size of methods.\\n        After it hits so many, it sends those methods to the service.\\n        This allows threads to handle many method calls with on access of the queue.\\n        Here we set it to 1 so it will flush with every call.\\n        Setting invoke dynamic false turns off auto type conversion which is mainly for JSON REST calls\\n        and WebSocket calls.\\n        This means that you can execute the service more efficiently when it is in proc.\\n         */ final ServiceQueue serviceQueue = serviceBuilder ( ) . setRequestQueueBuilder ( queueBuilder ( ) . setBatchSize ( 1 ) ) . setServiceObject ( todoManagerImpl ) . setInvokeDynamic ( false ) . build ( ) . startServiceQueue ( ) ; /* Create Asynchronous proxy over Synchronous service. */ final TodoManagerClientInterface todoManager = serviceQueue . createProxy ( TodoManagerClientInterface . class ) ; serviceQueue . startCallBackHandler ( ) ; System . out . println ( \"This is an async call\" ) ; /* Asynchronous method call. */ todoManager . add ( new Todo ( \"Call Mom\" , \"Give Mom a call\" ) ) ; AtomicInteger countTracker = new AtomicInteger ( ) ; //Hold count from async call to service System . out . println ( \"This is an async call to count\" ) ; todoManager . count ( count -> { System . out . println ( \"This lambda expression is the callbackWithTimeout \" + count ) ; countTracker . set ( count ) ; } ) ; /*\\n        We don\\'t need this now.\\n         */ //todoManager.clientProxyFlush(); //Flush all methods. It batches calls. Sys . sleep ( 100 ) ; System . out . printf ( \"This is the count back from the service %d\\\\n\" , countTracker . get ( ) ) ; todoManager . list ( todos -> todos . forEach ( System . out :: println ) ) ; }'", "label": "'You can use services in process'"}
{"text": "'public static boolean isA ( Class clazz , ParameterizedType pType ) { return clazz . isAssignableFrom ( ( Class ) pType . getRawType ( ) ) ; }'", "label": "'Is the genericType of a certain class?'"}
{"text": "'public static boolean isCompatible ( Method method , Method intfMethod ) { if ( method == intfMethod ) return true ; if ( ! method . getName ( ) . equals ( intfMethod . getName ( ) ) ) return false ; if ( method . getParameterTypes ( ) . length != intfMethod . getParameterTypes ( ) . length ) return false ; for ( int i = 0 ; i < method . getParameterTypes ( ) . length ; i ++ ) { Class rootParam = method . getParameterTypes ( ) [ i ] ; Class intfParam = intfMethod . getParameterTypes ( ) [ i ] ; if ( ! intfParam . isAssignableFrom ( rootParam ) ) return false ; } return true ; }'", "label": "'See if the two methods are compatible that is they have the same relative signature'"}
{"text": "'public static Method getImplementingMethod ( Class clazz , Method intfMethod ) { Class < ? > declaringClass = intfMethod . getDeclaringClass ( ) ; if ( declaringClass . equals ( clazz ) ) return intfMethod ; Class [ ] paramTypes = intfMethod . getParameterTypes ( ) ; if ( declaringClass . getTypeParameters ( ) . length > 0 && paramTypes . length > 0 ) { Type [ ] intfTypes = findParameterizedTypes ( clazz , declaringClass ) ; Map < String , Type > typeVarMap = new HashMap < String , Type > ( ) ; TypeVariable < ? extends Class < ? > > [ ] vars = declaringClass . getTypeParameters ( ) ; for ( int i = 0 ; i < vars . length ; i ++ ) { if ( intfTypes != null && i < intfTypes . length ) { typeVarMap . put ( vars [ i ] . getName ( ) , intfTypes [ i ] ) ; } else { // Interface type parameters may not have been filled out\\r typeVarMap . put ( vars [ i ] . getName ( ) , vars [ i ] . getGenericDeclaration ( ) ) ; } } Type [ ] paramGenericTypes = intfMethod . getGenericParameterTypes ( ) ; paramTypes = new Class [ paramTypes . length ] ; for ( int i = 0 ; i < paramTypes . length ; i ++ ) { if ( paramGenericTypes [ i ] instanceof TypeVariable ) { TypeVariable tv = ( TypeVariable ) paramGenericTypes [ i ] ; Type t = typeVarMap . get ( tv . getName ( ) ) ; if ( t == null ) { throw new RuntimeException ( \"Unable to resolve type variable\" ) ; } paramTypes [ i ] = getRawType ( t ) ; } else { paramTypes [ i ] = getRawType ( paramGenericTypes [ i ] ) ; } } } try { return clazz . getMethod ( intfMethod . getName ( ) , paramTypes ) ; } catch ( NoSuchMethodException e ) { } try { Method tmp = clazz . getMethod ( intfMethod . getName ( ) , intfMethod . getParameterTypes ( ) ) ; return tmp ; } catch ( NoSuchMethodException e ) { } return intfMethod ; }'", "label": "'Given a method and a root class find the actual method declared in the root that implements the method .'"}
{"text": "'public static Class < ? > getTypeArgument ( Type genericType ) { if ( ! ( genericType instanceof ParameterizedType ) ) return null ; ParameterizedType parameterizedType = ( ParameterizedType ) genericType ; Class < ? > typeArg = ( Class < ? > ) parameterizedType . getActualTypeArguments ( ) [ 0 ] ; return typeArg ; }'", "label": "'Returns the type argument from a parameterized type'"}
{"text": "'public static Type resolveTypeVariable ( Class < ? > root , TypeVariable < ? > typeVariable ) { if ( typeVariable . getGenericDeclaration ( ) instanceof Class < ? > ) { Class < ? > classDeclaringTypeVariable = ( Class < ? > ) typeVariable . getGenericDeclaration ( ) ; Type [ ] types = findParameterizedTypes ( root , classDeclaringTypeVariable ) ; if ( types == null ) return null ; for ( int i = 0 ; i < types . length ; i ++ ) { TypeVariable < ? > tv = classDeclaringTypeVariable . getTypeParameters ( ) [ i ] ; if ( tv . equals ( typeVariable ) ) { return types [ i ] ; } } } return null ; }'", "label": "'Finds an actual value of a type variable . The method looks in a class hierarchy for a class defining the variable and returns the value if present .'"}
{"text": "'public static Type [ ] getActualTypeArgumentsOfAnInterface ( Class < ? > classToSearch , Class < ? > interfaceToFind ) { Type [ ] types = findParameterizedTypes ( classToSearch , interfaceToFind ) ; if ( types == null ) throw new RuntimeException ( \"Unable to find type arguments of \" + interfaceToFind ) ; return types ; }'", "label": "'Given a class and an interfaces go through the class hierarchy to find the interface and return its type arguments .'"}
{"text": "'public static Type [ ] findParameterizedTypes ( Class < ? > root , Class < ? > searchedFor ) { if ( searchedFor . isInterface ( ) ) { return findInterfaceParameterizedTypes ( root , null , searchedFor ) ; } return findClassParameterizedTypes ( root , null , searchedFor ) ; }'", "label": "'Search for the given interface or class within the root s class / interface hierarchy . If the searched for class / interface is a generic return an array of real types that fill it out .'"}
{"text": "'public RedisKeyValueStoreBuilder setRedisUri ( final URI uri ) { getRedisOptions ( ) . setPort ( uri . getPort ( ) ) ; getRedisOptions ( ) . setHost ( uri . getHost ( ) ) ; final String userInfo = uri . getUserInfo ( ) ; final String [ ] split = Str . split ( userInfo ) ; if ( split . length == 2 ) { getRedisOptions ( ) . setAuth ( split [ 1 ] ) ; } else if ( split . length == 1 ) { getRedisOptions ( ) . setAuth ( split [ 0 ] ) ; } return this ; }'", "label": "'RedisKeyValueStoreBuilder redis : // redisdb : <password > @<host > : <port > / 0'"}
{"text": "'private void populate ( ) throws Exception { List < T > initializer = new ArrayList < T > ( this . getMinIdle ( ) ) ; for ( int idx = 0 ; idx < this . getMinIdle ( ) && ( this . getMaxIdle ( ) == DISABLED || idx < this . getMaxIdle ( ) ) && ( this . getMaxActive ( ) == DISABLED || idx < this . getMaxActive ( ) ) ; idx ++ ) { initializer . add ( this . borrowObject ( ) ) ; } for ( int idx = 0 ; idx < this . getMinIdle ( ) && ( this . getMaxIdle ( ) == DISABLED || idx < this . getMaxIdle ( ) ) && ( this . getMaxActive ( ) == DISABLED || idx < this . getMaxActive ( ) ) ; idx ++ ) { this . returnObject ( initializer . get ( idx ) ) ; } }'", "label": "'Populate the pool up to minIdle instances . Is limited to maxIdle and maxActive .'"}
{"text": "'@ Override public double [ ] score ( Object [ ] scorable ) throws FOSException { return WekaUtils . score ( classifier , scorable , instanceSetters , instances , attributes ) ; }'", "label": "'The the given <code > Object [] < / code > with this scorer ( thread safe! ) . <p / > The score in bound by the configuration <code > minScore< / code > and <code > maxScore< / code > .'"}
{"text": "'private void addReturnOptionDescription ( Method method , Return . ReturnBuilder returnBuilder ) { DocReturn returnAnno = getNonExceptionDocReturn ( method ) ; String returnOptionDesc = ( returnAnno == null ) ? null : returnAnno . description ( ) ; returnBuilder . description ( StringUtils . isEmpty ( returnOptionDesc ) ? null : returnAnno . description ( ) ) ; }'", "label": "'Used for non exception return option'"}
{"text": "'@ Override public double [ ] score ( Object [ ] scorable ) throws FOSException { /* the pool can change while this is processing (reload) so assign a local variable */ final ObjectPool < Classifier > localPool = pool ; Classifier classifier = null ; try { classifier = localPool . borrowObject ( ) ; return WekaUtils . score ( classifier , scorable , instanceSetters , instances , attributes ) ; } catch ( Exception e ) { throw new FOSException ( e ) ; } finally { returnObject ( localPool , classifier ) ; } }'", "label": "'The the given <code > Object [] < / code > with this scorer ( thread safe! ) . <p / > The score in bound by the configuration <code > minScore< / code > and <code > maxScore< / code > .'"}
{"text": "'private void returnObject ( ObjectPool < Classifier > pool , Classifier object ) { try { pool . returnObject ( object ) ; } catch ( Exception e ) { logger . error ( \"Could not return object to pool\" , e ) ; } }'", "label": "'Returns the given object to the pool .'"}
{"text": "'private Destination getDestination ( final String destinationName ) { if ( ! destinations . containsKey ( destinationName ) ) { Destination destination = destinationSupplier . apply ( destinationName ) ; destinations . put ( destinationName , destination ) ; } return destinations . get ( destinationName ) ; }'", "label": "'Get the destination .'"}
{"text": "'private MessageConsumer getConsumer ( final String destinationName ) { if ( ! consumers . containsKey ( destinationName ) ) { Session session = getSession ( ) ; Destination destination = getDestination ( destinationName ) ; try { MessageConsumer consumer = session . createConsumer ( destination ) ; consumers . put ( destinationName , consumer ) ; } catch ( JMSException e ) { throw new JmsException ( \"Unable to create consumer for destination \" + destinationName , e ) ; } } return consumers . get ( destinationName ) ; }'", "label": "'Get the MessageConsumer .'"}
{"text": "'private MessageProducer getProducer ( final String destinationName ) { if ( ! producers . containsKey ( destinationName ) ) { Session session = getSession ( ) ; Destination destination = getDestination ( destinationName ) ; MessageProducer producer ; try { producer = session . createProducer ( destination ) ; } catch ( JMSException e ) { throw new JmsException ( \"Unable to create producer for destination \" + destinationName , e ) ; } producers . put ( destinationName , producer ) ; } return producers . get ( destinationName ) ; }'", "label": "'Get the MessageProducer or create one from the JMS session .'"}
{"text": "'private Session getSession ( ) { if ( ! sessionOption . isPresent ( ) ) { try { sessionOption = Optional . of ( getConnection ( ) . createSession ( transacted , acknowledgeMode ) ) ; } catch ( JMSException e ) { throw new JmsException ( \"Unable to get JMS session\" , e ) ; } } return sessionOption . get ( ) ; }'", "label": "'Get the current session or create one from the JMS connection .'"}
{"text": "'private Connection getConnection ( ) { if ( ! connectionOption . isPresent ( ) ) { final Connection connection = connectionSupplier . get ( ) ; if ( connection instanceof ActiveMQConnection ) { ( ( ActiveMQConnection ) connection ) . addTransportListener ( new TransportListener ( ) { @ Override public void onCommand ( Object command ) { } @ Override public void onException ( IOException error ) { } @ Override public void transportInterupted ( ) { connected . set ( false ) ; } @ Override public void transportResumed ( ) { connected . set ( true ) ; } } ) ; } connected . set ( true ) ; if ( startConnection ) { try { connection . start ( ) ; } catch ( JMSException e ) { throw new JmsException ( \"Unable to start JMS connection\" , e ) ; } } connectionOption = Optional . of ( connection ) ; } return connectionOption . get ( ) ; }'", "label": "'Get the current connection or create one using the connectionSupplier .'"}
{"text": "'public void sendTextMessageWithDestination ( final String destinationName , final String messageContent ) { if ( ! this . isConnected ( ) ) { throw new JmsNotConnectedException ( \"JMS connection is down \" + destinationName ) ; } final Session session = getSession ( ) ; final MessageProducer producer = getProducer ( destinationName ) ; try { TextMessage message = session . createTextMessage ( messageContent ) ; producer . send ( message ) ; } catch ( JMSException e ) { throw new JmsException ( \"Unable to send message to \" + destinationName , e ) ; } }'", "label": "'Send a text message given a queue or topic name and a text message .'"}
{"text": "'public void listenTextMessagesWithDestination ( final String destinationName , final Consumer < String > messageListener ) { final MessageConsumer consumer = getConsumer ( destinationName ) ; try { consumer . setMessageListener ( message -> { try { messageListener . accept ( ( ( TextMessage ) message ) . getText ( ) ) ; if ( acknowledgeMode == Session . CLIENT_ACKNOWLEDGE ) { message . acknowledge ( ) ; } } catch ( JMSException e ) { throw new JmsException ( \"Unable to register get text from message in listener \" + destinationName , e ) ; } catch ( Exception ex ) { throw new IllegalStateException ( \"Unable handle JMS Consumer  \" + destinationName , ex ) ; } } ) ; } catch ( JMSException e ) { throw new JmsException ( \"Unable to register message listener \" + destinationName , e ) ; } }'", "label": "'Listen to a message from JMS from a given destination by name .'"}
{"text": "'public String receiveTextMessageFromDestinationWithTimeout ( final String destinationName , final int timeout ) { if ( ! this . isConnected ( ) ) { throw new JmsNotConnectedException ( \"Not connected\" ) ; } MessageConsumer consumer = getConsumer ( destinationName ) ; TextMessage message ; try { if ( timeout == 0 ) { message = ( TextMessage ) consumer . receiveNoWait ( ) ; } else { message = ( TextMessage ) consumer . receive ( timeout ) ; } if ( message != null ) { if ( acknowledgeMode == Session . CLIENT_ACKNOWLEDGE ) { message . acknowledge ( ) ; } return message . getText ( ) ; } else { return null ; } } catch ( JMSException e ) { throw new JmsException ( \"Unable to receive message from \" + destinationName , e ) ; } }'", "label": "'Receive a message from destination with timeout .'"}
{"text": "'@ Override public void stop ( ) { if ( connectionOption . isPresent ( ) ) { try { if ( startConnection ) connectionOption . get ( ) . close ( ) ; } catch ( JMSException e ) { throw new JmsException ( \"Unable to stop \" , e ) ; } connectionOption = Optional . empty ( ) ; sessionOption = Optional . empty ( ) ; producers . clear ( ) ; consumers . clear ( ) ; destinations . clear ( ) ; } }'", "label": "'Stop the service'"}
{"text": "'public static void produce ( Classifier classifier , File file , boolean compress ) throws PMMLConversionException { Algorithm algorithm = Algorithm . fromClassifier ( classifier ) ; PMML pmml = algorithm . getPMMLProducer ( ) . produce ( classifier ) ; addAlgorithm ( pmml , algorithm ) ; try { if ( compress ) { String finalPath = file . getAbsolutePath ( ) ; logger . debug ( \"Saving compressed file to \\'{}\\'.\" , finalPath ) ; try ( FileOutputStream fileOutputStream = new FileOutputStream ( finalPath ) ; GZIPOutputStream gzipOutputStream = new GZIPOutputStream ( fileOutputStream ) ; ) { JAXBUtil . marshalPMML ( pmml , new StreamResult ( gzipOutputStream ) ) ; } } else { logger . debug ( \"Saving file to \\'{}\\'.\" , file . getAbsolutePath ( ) ) ; try ( FileOutputStream fos = new FileOutputStream ( file ) ) { JAXBUtil . marshalPMML ( pmml , new StreamResult ( file ) ) ; } } logger . debug ( \"File successfully saved.\" ) ; } catch ( Exception e ) { logger . error ( \"Failed to marshal the PMML to file.\" , e ) ; throw new PMMLConversionException ( \"Failed to marshal the PMML to file.\" , e ) ; } }'", "label": "'Converts the given { @link weka . classifiers . Classifier } to PMML and saves it to the given file .'"}
{"text": "'private static void addAlgorithm ( PMML pmml , Algorithm algorithm ) { Extension extension = new Extension ( ) ; extension . withName ( ALGORITHM_EXTENSION_ELEMENT ) ; extension . withValue ( algorithm . name ( ) ) ; pmml . withExtensions ( extension ) ; }'", "label": "'Adds a { @link org . dmg . pmml . Extension } element to the { @link org . dmg . pmml . PMML } with the algorithm used to build the classifier . <p / > The name of the extension is { @link com . feedzai . fos . impl . weka . utils . pmml . PMMLConversionCommons#ALGORITHM_EXTENSION_ELEMENT } .'"}
{"text": "'private void handleLoadFromUserDataService ( final User loadedUser , final Callback < List < Recommendation > > recommendationsCallback ) { /** Add a runnable to the callbacks list. */ callbacks . add ( ( ) -> { List < Recommendation > recommendations = runRulesEngineAgainstUser ( loadedUser ) ; recommendationsCallback . accept ( recommendations ) ; } ) ; //        callbacks.add(new Runnable() { //            @Override //            public void run() { //                List<Recommendation> recommendations = runRulesEngineAgainstUser(loadedUser); //                recommendationsCallback.accept(recommendations); //            } //        }); }'", "label": "'Handle defered recommendations based on user loads .'"}
{"text": "'public static void main ( final String ... args ) { final ManagedServiceBuilder managedServiceBuilder = managedServiceBuilder ( ) ; managedServiceBuilder . getHttpServerBuilder ( ) . addResponseDecorator ( new HttpResponseDecorator ( ) { @ Override public boolean decorateTextResponse ( HttpTextResponseHolder responseHolder , String requestPath , String method , int code , String contentType , String payload , MultiMap < String , String > responseHeaders , MultiMap < String , String > requestHeaders , MultiMap < String , String > requestParams ) { final HttpResponseBuilder responseBuilder = HttpResponseBuilder . httpResponseBuilder ( ) . setCode ( code ) . setContentType ( contentType ) . setBody ( payload ) ; if ( responseHeaders != null && ! responseHeaders . isEmpty ( ) ) { responseBuilder . setHeaders ( responseHeaders ) ; } responseBuilder . addHeader ( \"Cache-Control\" , \"no-cache, no-store, must-revalidate\" ) . addHeader ( \"Pragma\" , \"no-cache\" ) . addHeader ( \"Expires\" , \"0\" ) . addHeader ( \"X-MyHeader-Hostname\" , \"foo\" ) ; responseHolder . setHttpTextResponse ( ( HttpTextResponse ) responseBuilder . build ( ) ) ; return true ; } @ Override public boolean decorateBinaryResponse ( HttpBinaryResponseHolder responseHolder , String requestPath , String method , int code , String contentType , byte [ ] payload , MultiMap < String , String > responseHeaders , MultiMap < String , String > requestHeaders , MultiMap < String , String > requestParams ) { final HttpResponseBuilder responseBuilder = HttpResponseBuilder . httpResponseBuilder ( ) . setCode ( code ) . setContentType ( contentType ) . setBody ( payload ) ; if ( responseHeaders != null && ! responseHeaders . isEmpty ( ) ) { responseBuilder . setHeaders ( responseHeaders ) ; } responseBuilder . addHeader ( \"Cache-Control\" , \"no-cache, no-store, must-revalidate\" ) . addHeader ( \"Pragma\" , \"no-cache\" ) . addHeader ( \"Expires\" , \"0\" ) . addHeader ( \"X-Calypso-Hostname\" , \"foo\" ) ; responseHolder . setHttpBinaryResponse ( ( HttpBinaryResponse ) responseBuilder . build ( ) ) ; return true ; } } ) ; managedServiceBuilder . setRootURI ( \"/\" ) . addEndpointService ( new NoCacheService ( ) ) . startApplication ( ) ; }'", "label": "'}'"}
{"text": "'public static Classifier consume ( File file ) throws PMMLConversionException { PMML pmml = null ; try { if ( isGzipped ( file ) ) { logger . debug ( \"Consuming GZipped PMML file \\'{}\\'.\" , file . getAbsolutePath ( ) ) ; try ( FileInputStream fis = new FileInputStream ( file ) ; GZIPInputStream gzipInputStream = new GZIPInputStream ( fis ) ) { pmml = JAXBUtil . unmarshalPMML ( new StreamSource ( gzipInputStream ) ) ; } } else { logger . debug ( \"Consuming PMML file \\'{}\\'.\" , file . getAbsolutePath ( ) ) ; try ( FileInputStream fis = new FileInputStream ( file ) ) { pmml = JAXBUtil . unmarshalPMML ( new StreamSource ( fis ) ) ; } } } catch ( Exception e ) { throw new PMMLConversionException ( \"Failed to unmarshal PMML file \\'\" + file + \"\\'. Make sure the file is a valid PMML.\" , e ) ; } Algorithm algorithm = getAlgorithm ( pmml ) ; logger . debug ( \"Consumed PMML file using algorithm {}.\" , algorithm ) ; return algorithm . getPMMLConsumer ( ) . consume ( pmml ) ; }'", "label": "'Consumes the PMML in the given file and converts it to a Weka { @link Classifier } .'"}
{"text": "'private static boolean isGzipped ( File file ) throws IOException { FileInputStream fileInputStream = new FileInputStream ( file ) ; int head = ( fileInputStream . read ( ) & 0xff ) | ( ( fileInputStream . read ( ) << 8 ) & 0xff00 ) ; return GZIPInputStream . GZIP_MAGIC == head ; }'", "label": "'Checks if the given file is in GZIP format . <p / > It checks this by checking the head for the { @link java . util . zip . GZIPInputStream#GZIP_MAGIC } number .'"}
{"text": "'private static Algorithm getAlgorithm ( PMML pmml ) throws PMMLConversionException { for ( Extension extension : pmml . getExtensions ( ) ) { if ( ALGORITHM_EXTENSION_ELEMENT . equals ( extension . getName ( ) ) ) { return Algorithm . valueOf ( extension . getValue ( ) ) ; } } throw new PMMLConversionException ( \"Couldn\\'t find \\'\" + ALGORITHM_EXTENSION_ELEMENT + \"\\' extension element in PMML.\" ) ; }'", "label": "'Retrieves the { @link com . feedzai . fos . impl . weka . utils . pmml . PMMLConversionCommons . Algorithm } represented as a PMML extension named { @link com . feedzai . fos . impl . weka . utils . pmml . PMMLConversionCommons#ALGORITHM_EXTENSION_ELEMENT } .'"}
{"text": "'public static Constructor pickSingletonConstructor ( Class clazz ) { Constructor < ? > [ ] constructors = clazz . getConstructors ( ) ; Constructor < ? > constructor = null ; // prefer a no-arg constructor int numParameters = 0 ; Constructor pick = null ; boolean potentialConflict = false ; // https://issues.jboss.org/browse/RESTEASY-645 for ( Constructor con : constructors ) { if ( Modifier . isPublic ( con . getModifiers ( ) ) == false ) { continue ; } if ( con . getParameterTypes ( ) . length >= numParameters ) { if ( con . getParameterTypes ( ) . length > numParameters ) { potentialConflict = false ; } boolean noContextAnnotation = false ; if ( con . getParameterAnnotations ( ) != null ) { for ( Annotation [ ] ann : con . getParameterAnnotations ( ) ) { if ( FindAnnotation . findAnnotation ( ann , Context . class ) == null ) { noContextAnnotation = true ; } } } if ( noContextAnnotation ) continue ; if ( con . getParameterTypes ( ) . length == numParameters && numParameters != 0 ) { potentialConflict = true ; } numParameters = con . getParameterTypes ( ) . length ; pick = con ; } } if ( potentialConflict ) { // TODO logger.warn(\"Ambiguity constructors are found in \" + clazz + // \". More details please refer to http://jsr311.java.net/nonav/releases/1.1/spec/spec.html\"); } return pick ; }'", "label": "'Pick best constructor for a provider or resource class <p / > Picks constructor with most parameters . Will ignore constructors that have parameters with no @Context annotation'"}
{"text": "'public static Constructor pickPerRequestConstructor ( Class clazz ) { Constructor < ? > [ ] constructors = clazz . getConstructors ( ) ; Constructor < ? > [ ] declaredConstructors = clazz . getDeclaredConstructors ( ) ; Constructor < ? > constructor = null ; // prefer a no-arg constructor int numParameters = 0 ; Constructor pick = null ; boolean potentialConflict = false ; // https://issues.jboss.org/browse/RESTEASY-645 for ( Constructor con : constructors ) { if ( Modifier . isPublic ( con . getModifiers ( ) ) == false ) { continue ; } if ( con . getParameterTypes ( ) . length >= numParameters ) { if ( con . getParameterTypes ( ) . length > numParameters ) { potentialConflict = false ; } boolean noContextAnnotation = false ; if ( con . getParameterAnnotations ( ) != null ) { for ( Annotation [ ] ann : con . getParameterAnnotations ( ) ) { if ( FindAnnotation . findJaxRSAnnotations ( ann ) . length == 0 ) { noContextAnnotation = true ; } } } if ( noContextAnnotation ) continue ; if ( con . getParameterTypes ( ) . length == numParameters && numParameters != 0 ) { potentialConflict = true ; } numParameters = con . getParameterTypes ( ) . length ; pick = con ; } } if ( potentialConflict ) { // todo logger.warn(\"Ambiguity constructors are found in \" + clazz + // \". More details please refer to http://jsr311.java.net/nonav/releases/1.1/spec/spec.html\"); } return pick ; }'", "label": "'Pick best constructor for a provider or resource class <p / > Picks constructor with most parameters . Will ignore constructors that have parameters with no @Context annotation'"}
{"text": "'@ NotNull public Map < Object , Object > getPoolConfiguration ( ) { return ConfigurationConverter . getMap ( configuration . subset ( GenericObjectPoolConfig . class . getName ( ) ) ) ; }'", "label": "'Returns the pool configuration of the scorer .'"}
{"text": "'public void setId ( UUID id ) { this . dirty = true ; this . id = id ; this . modelConfig . setProperty ( ID , id . toString ( ) ) ; }'", "label": "'Sets the ID of the model .'"}
{"text": "'public void setModel ( File model ) { this . dirty = true ; this . model = model ; this . modelConfig . setProperty ( MODEL_FILE , model . getAbsolutePath ( ) ) ; }'", "label": "'Sets the model file of the serialized classifier .'"}
{"text": "'public void setModelDescriptor ( ModelDescriptor modelDescriptor ) { this . modelDescriptor = modelDescriptor ; setModel ( new File ( modelDescriptor . getModelFilePath ( ) ) ) ; this . modelConfig . setProperty ( CLASSIFIER_FORMAT , modelDescriptor . getFormat ( ) . toString ( ) ) ; }'", "label": "'Sets the { @link com . feedzai . fos . api . ModelDescriptor } of the model .'"}
{"text": "'public void update ( ModelConfig modelConfig ) throws FOSException { checkNotNull ( modelConfig ) ; this . dirty = true ; // The class index should be reset everytime a model config is updated. // TODO: Refactor the classIndex to be in ModelConfig. this . modelConfig . getProperties ( ) . remove ( CLASS_INDEX ) ; this . modelConfig . update ( modelConfig ) ; parseModelConfig ( ) ; }'", "label": "'Updates the underlying <code > ModelConfig< / code > using <code > ModelConfig . update< / code > .'"}
{"text": "'@ Override @ NotNull public List < double [ ] > score ( List < UUID > modelIds , Object [ ] scorable ) throws FOSException { checkNotNull ( modelIds , \"Models to score cannot be null\" ) ; checkNotNull ( scorable , \"Instance cannot be null\" ) ; List < double [ ] > scores = new ArrayList <> ( modelIds . size ( ) ) ; try { reloadModelsLock . readLock ( ) . lock ( ) ; if ( modelIds . size ( ) == 1 ) { // if only one model, then don\\'t parallelize scoring WekaThreadSafeScorer wekaThreadSafeScorer = getScorer ( modelIds . get ( 0 ) ) ; scores . add ( wekaThreadSafeScorer . score ( scorable ) ) ; } else { Map < UUID , Future < double [ ] > > futureScores = new HashMap <> ( modelIds . size ( ) ) ; // scatter for ( UUID modelId : modelIds ) { WekaThreadSafeScorer wekaThreadSafeScorer = getScorer ( modelId ) ; futureScores . put ( modelId , executorService . submit ( new AsyncScoringTask ( wekaThreadSafeScorer , scorable ) ) ) ; } // gather for ( UUID modelId : modelIds ) { scores . add ( getFuture ( futureScores . get ( modelId ) , modelId ) ) ; } } } finally { reloadModelsLock . readLock ( ) . unlock ( ) ; } return scores ; }'", "label": "'Score the <code > scorable< / code > for each model ID identified by <code > modelIds< / code > .'"}
{"text": "'@ Override @ NotNull public List < double [ ] > score ( UUID modelId , List < Object [ ] > scorables ) throws FOSException { checkNotNull ( scorables , \"List of scorables cannot be null\" ) ; List < double [ ] > scores = new ArrayList <> ( scorables . size ( ) ) ; try { reloadModelsLock . readLock ( ) . lock ( ) ; if ( scorables . size ( ) == 1 ) { // if only one model, then don\\'t parallelize scoring WekaThreadSafeScorer wekaThreadSafeScorer = getScorer ( modelId ) ; scores . add ( wekaThreadSafeScorer . score ( scorables . get ( 0 ) ) ) ; } else { Map < Object [ ] , Future < double [ ] > > futureScores = new HashMap <> ( scorables . size ( ) ) ; // scatter for ( Object [ ] scorable : scorables ) { WekaThreadSafeScorer wekaThreadSafeScorer = wekaThreadSafeScorers . get ( modelId ) ; futureScores . put ( scorable , executorService . submit ( new AsyncScoringTask ( wekaThreadSafeScorer , scorable ) ) ) ; } // gather for ( Object [ ] scorable : scorables ) { scores . add ( getFuture ( futureScores . get ( scorable ) , modelId ) ) ; } } } finally { reloadModelsLock . readLock ( ) . unlock ( ) ; } return scores ; }'", "label": "'Score each <code > scorable< / code > with the given <code > modelId< / code > .'"}
{"text": "'@ Override @ NotNull public double [ ] score ( UUID modelId , Object [ ] scorable ) throws FOSException { checkNotNull ( scorable , \"The scorable cannot be null\" ) ; try { reloadModelsLock . readLock ( ) . lock ( ) ; WekaThreadSafeScorer wekaThreadSafeScorer = getScorer ( modelId ) ; return wekaThreadSafeScorer . score ( scorable ) ; } finally { reloadModelsLock . readLock ( ) . unlock ( ) ; } }'", "label": "'Score a single <code > scorable< / code > with the given <code > modelId< / code > .'"}
{"text": "'public void addOrUpdate ( WekaModelConfig wekaModelConfig ) throws FOSException { checkNotNull ( wekaModelConfig , \"Model config cannot be null\" ) ; WekaThreadSafeScorer newWekaThreadSafeScorer = new WekaThreadSafeScorerPool ( wekaModelConfig , wekaManagerConfig ) ; WekaThreadSafeScorer oldWekaThreadSafeScorer = quickSwitch ( wekaModelConfig . getId ( ) , newWekaThreadSafeScorer ) ; WekaUtils . closeSilently ( oldWekaThreadSafeScorer ) ; }'", "label": "'Adds the given model to the managed models .'"}
{"text": "'public void removeModel ( UUID modelId ) { WekaThreadSafeScorer newWekaThreadSafeScorer = null ; WekaThreadSafeScorer oldWekaThreadSafeScorer = quickSwitch ( modelId , newWekaThreadSafeScorer ) ; WekaUtils . closeSilently ( oldWekaThreadSafeScorer ) ; }'", "label": "'Removes the given model from the managed models .'"}
{"text": "'private WekaThreadSafeScorer quickSwitch ( UUID modelId , WekaThreadSafeScorer newWekaThreadSafeScorer ) { try { // quick switch - do not do anything inside for performance reasons!! reloadModelsLock . writeLock ( ) . lock ( ) ; return wekaThreadSafeScorers . put ( modelId , newWekaThreadSafeScorer ) ; } finally { reloadModelsLock . writeLock ( ) . unlock ( ) ; } }'", "label": "'Switches the { @link com . feedzai . fos . impl . weka . WekaScorer } used for the model with the given UUID .'"}
{"text": "'private static RandomTree buildRandomTree ( RandomTree root , Instances instances , TreeModel treeModel ) { Instances treeInstances = new Instances ( instances ) ; treeInstances . setClassIndex ( getClassIndex ( instances , treeModel ) ) ; root . m_Info = treeInstances ; root . m_Tree = buildRandomTreeNode ( root , treeModel . getNode ( ) ) ; return root ; }'", "label": "'Builds a new { @link weka . classifiers . trees . RandomTree Weka RandomTree } from the given { @link org . dmg . pmml . TreeModel PMML TreeModel } .'"}
{"text": "'private static RandomTree . Tree buildRandomTreeNode ( RandomTree tree , Node pmmlNode ) { RandomTree . Tree treeNode = tree . new Tree ( ) ; //Set the class distribution. treeNode . m_ClassDistribution = getClassDistribution ( pmmlNode ) ; Instances instances = tree . m_Info ; boolean isLeaf = pmmlNode . getNodes ( ) . size ( ) == 0 ; if ( ! isLeaf ) { List < Node > children = pmmlNode . getNodes ( ) ; String attributeName = ( ( SimplePredicate ) children . get ( 0 ) . getPredicate ( ) ) . getField ( ) . getValue ( ) ; Attribute attribute = instances . attribute ( attributeName ) ; treeNode . m_Attribute = attribute . index ( ) ; if ( attribute . isNumeric ( ) ) { /*\\n                  If the node is numeric, get its two child nodes and covert them into a new RandomTree.Tree node.\\n                  For example, consider the following PPML Node:\\n\\n                     <Node id=\"2\">\\n                       <SimplePredicate field=\"petal_length\" operator=\"lessThan\" value=\"5.05\"/>\\n                       <Node id=\"3\" score=\"Iris-setosa\">\\n                         <SimplePredicate field=\"petal_length\" operator=\"lessThan\" value=\"2.95\"/>\\n                       </Node>\\n                       <Node id=\"4\" score=\"Iris-versicolor\">\\n                         <SimplePredicate field=\"petal_length\" operator=\"greaterOrEqual\" value=\"2.95\"/>\\n                       </Node>\\n                     </Node>\\n\\n                  We\\'ll grab the two child nodes and their value will be the split point of the current RandomTree.Tree node.\\n                */ assert children . size ( ) == 2 : \"Numeric attributes must have exactly 2 children\" ; Node left = children . get ( 0 ) ; Node right = children . get ( 1 ) ; Predicate leftPredicate = left . getPredicate ( ) ; Predicate rightPredicate = right . getPredicate ( ) ; assert leftPredicate instanceof SimplePredicate && leftPredicate . getClass ( ) . equals ( rightPredicate . getClass ( ) ) : \"Numeric attribute\\'s nodes must have the same simple predicate.\" ; double splitPoint = Double . valueOf ( ( ( SimplePredicate ) leftPredicate ) . getValue ( ) ) ; treeNode . m_SplitPoint = splitPoint ; treeNode . m_Successors = new RandomTree . Tree [ ] { buildRandomTreeNode ( tree , left ) , buildRandomTreeNode ( tree , right ) } ; treeNode . m_Prop = new double [ ] { getNodeTrainingProportion ( left ) , getNodeTrainingProportion ( right ) } ; } else if ( attribute . isNominal ( ) ) { treeNode . m_Successors = new RandomTree . Tree [ children . size ( ) ] ; treeNode . m_Prop = new double [ treeNode . m_Successors . length ] ; for ( int i = 0 ; i < children . size ( ) ; i ++ ) { Node child = children . get ( i ) ; SimplePredicate predicate = ( SimplePredicate ) child . getPredicate ( ) ; int valueIndex = attribute . indexOfValue ( predicate . getValue ( ) ) ; treeNode . m_Successors [ valueIndex ] = buildRandomTreeNode ( tree , child ) ; treeNode . m_Prop [ valueIndex ] = getNodeTrainingProportion ( child ) ; } } else { throw new RuntimeException ( \"Attribute type not supported: \" + attribute ) ; } } return treeNode ; }'", "label": "'Builds a { @link weka . classifiers . trees . RandomTree . Tree Weka RandomTree } node represented by the given { @link org . dmg . pmml . Node PMML node } .'"}
{"text": "'@ Bean public ServiceQueue clusteredEventManagerServiceQueue ( final @ Qualifier ( \"eventBusCluster\" ) EventBusCluster eventBusCluster ) { if ( eventBusCluster == null ) { return null ; } return eventBusCluster . eventServiceQueue ( ) ; }'", "label": "'The actual service queue for the clustered event bus . All events are sent to this queue first .'"}
{"text": "'@ Bean public EventManager clusteredEventManagerImpl ( final EventConnectorHub eventConnectorHub ) { return EventManagerBuilder . eventManagerBuilder ( ) . setEventConnector ( eventConnectorHub ) . setName ( \"CLUSTERED_EVENT_MANAGER\" ) . build ( ) ; }'", "label": "'Wraps factory method call so we can provide another implementation of interface if needed .'"}
{"text": "'@ NotNull public static FastVector instanceFields2Attributes ( int classIndex , List < ? extends Attribute > instanceFields ) throws FOSException { checkNotNull ( instanceFields , \"Instance fields cannot be null\" ) ; FastVector result = new FastVector ( instanceFields . size ( ) ) ; classIndex = classIndex == - 1 ? instanceFields . size ( ) - 1 : classIndex ; int idx = 0 ; for ( Attribute instanceField : instanceFields ) { weka . core . Attribute attribute ; Class < ? > type = instanceField . getClass ( ) ; if ( type == CategoricalAttribute . class ) { CategoricalAttribute categorical = ( CategoricalAttribute ) instanceField ; List < String > instances = categorical . getCategoricalInstances ( ) ; FastVector categoricalInstances = new FastVector ( instances . size ( ) ) ; for ( String categoricalInstance : instances ) { categoricalInstances . addElement ( categoricalInstance ) ; } attribute = new weka . core . Attribute ( instanceField . getName ( ) , categoricalInstances , idx ) ; } else if ( type == NumericAttribute . class ) { attribute = new weka . core . Attribute ( instanceField . getName ( ) , idx ) ; } else { throw new FOSException ( \"Unknown instance class\" ) ; } result . addElement ( attribute ) ; idx ++ ; } return result ; }'", "label": "'Converts the given instance fields into a fast vector with <code > Attributes< / code > .'"}
{"text": "'public static Instance objectArray2Instance ( Object [ ] data , InstanceSetter [ ] setters , FastVector attributes ) throws FOSException { checkNotNull ( data , \"Instance cannot be null\" ) ; checkNotNull ( attributes , \"Attributes cannot be null\" ) ; checkNotNull ( setters , \"Setters cannot be null\" ) ; Instance instance = new Instance ( attributes . size ( ) ) ; if ( data . length == setters . length ) { for ( int idx = 0 ; idx < data . length ; idx ++ ) { if ( data [ idx ] != null ) { setters [ idx ] . set ( instance , ( weka . core . Attribute ) attributes . elementAt ( idx ) , data [ idx ] . toString ( ) ) ; } else { instance . setMissing ( idx ) ; } } } else { throw new Data2ConfigurationMismatch ( String . format ( \"Data is not the same size as configured attributes (expected data size \\'%s\\' but was \\'%s\\')\" , setters . length , data . length ) ) ; } return instance ; }'", "label": "'Converts from the received Object [] to a weka <code > Instance< / code > .'"}
{"text": "'@ NotNull public static InstanceSetter [ ] instanceFields2ValueSetters ( final List < ? extends Attribute > instanceFields , final InstanceType type ) throws FOSException { InstanceSetter [ ] instanceSetters = new InstanceSetter [ instanceFields . size ( ) ] ; for ( int idx = 0 ; idx < instanceFields . size ( ) ; idx ++ ) { final Attribute att = instanceFields . get ( idx ) ; instanceSetters [ idx ] = new InstanceSetter ( ) { @ Override public void set ( Instance instance , weka . core . Attribute attribute , Object value ) throws FOSException { instance . setValue ( attribute , att . parseOrMissing ( value ) ) ; } } ; } return instanceSetters ; }'", "label": "'Converts from <code > InstanceFields< / code > to <code > InstanceSetters< / code > ( required for scorable manipulation ) .'"}
{"text": "'protected void execute ( DatabaseOperation operation , DataSetSource dataSetSource ) { IDatabaseConnection dbconn = null ; try { dbconn = connectionCreator . create ( ) ; operation . execute ( dbconn , findDataSet ( dataSetSource ) ) ; } catch ( Exception e ) { throw new IllegalStateException ( \"It\\'s not possible to execute DbUnit operation: \" + e . getMessage ( ) , e ) ; } finally { connectionCreator . close ( dbconn ) ; } }'", "label": "'Executes DbUnit <code > operation< / code > on dataset <code > dataSetSource< / code > .'"}
{"text": "'public static String encodeNonCodes ( String string ) { Matcher matcher = nonCodes . matcher ( string ) ; StringBuffer buf = new StringBuffer ( ) ; // FYI: we do not use the no-arg matcher.find()\\r // coupled with matcher.appendReplacement()\\r // because the matched text may contain\\r // a second % and we must make sure we\\r // encode it (if necessary).\\r int idx = 0 ; while ( matcher . find ( idx ) ) { int start = matcher . start ( ) ; buf . append ( string . substring ( idx , start ) ) ; buf . append ( \"%25\" ) ; idx = start + 1 ; } buf . append ( string . substring ( idx ) ) ; return buf . toString ( ) ; }'", "label": "'Encode % if it is not an encoding sequence'"}
{"text": "'public static String encodeValue ( String segment , String [ ] encoding ) { ArrayList < String > params = new ArrayList < String > ( ) ; boolean foundParam = false ; StringBuffer newSegment = new StringBuffer ( ) ; if ( savePathParams ( segment , newSegment , params ) ) { foundParam = true ; segment = newSegment . toString ( ) ; } String result = encodeFromArray ( segment , encoding , false ) ; result = encodeNonCodes ( result ) ; segment = result ; if ( foundParam ) { segment = pathParamReplacement ( segment , params ) ; } return segment ; }'", "label": "'Keep encoded values % ... and template parameters intact i . e . { x }'"}
{"text": "'public static String encodePathSaveEncodings ( String segment ) { String result = encodeFromArray ( segment , pathEncoding , false ) ; result = encodeNonCodes ( result ) ; return result ; }'", "label": "'Keep any valid encodings from string i . e . keep %2D but don t keep %p'"}
{"text": "'public static String encodePathSegmentSaveEncodings ( String segment ) { String result = encodeFromArray ( segment , pathSegmentEncoding , false ) ; result = encodeNonCodes ( result ) ; return result ; }'", "label": "'Keep any valid encodings from string i . e . keep %2D but don t keep %p'"}
{"text": "'public static String encodeQueryParamSaveEncodings ( String segment ) { String result = encodeFromArray ( segment , queryNameValueEncoding , false ) ; result = encodeNonCodes ( result ) ; return result ; }'", "label": "'Keep any valid encodings from string i . e . keep %2D but don t keep %p'"}
{"text": "'public static MultivaluedMap < String , String > decode ( MultivaluedMap < String , String > map ) { MultivaluedMapImpl < String , String > decoded = new MultivaluedMapImpl < String , String > ( ) ; for ( Map . Entry < String , List < String > > entry : map . entrySet ( ) ) { List < String > values = entry . getValue ( ) ; for ( String value : values ) { try { decoded . add ( URLDecoder . decode ( entry . getKey ( ) , UTF_8 ) , URLDecoder . decode ( value , UTF_8 ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } } return decoded ; }'", "label": "'decode an encoded map'"}
{"text": "'private static int buildTreeNode ( FastRandomTree node , int nodeId , Node parentPMMLNode ) { Instances instance = node . m_MotherForest . m_Info ; addScoreDistribution ( parentPMMLNode , node . m_ClassProbs , instance ) ; if ( node . m_Attribute == - 1 ) { // Leaf: Add the node\\'s score. parentPMMLNode . withScore ( leafScoreFromDistribution ( node . m_ClassProbs , instance ) ) ; return nodeId ; } Attribute attribute = instance . attribute ( node . m_Attribute ) ; if ( attribute . isNominal ( ) ) { return buildNominalNode ( attribute , node , nodeId , parentPMMLNode ) ; } else if ( attribute . isNumeric ( ) ) { return buildNumericNode ( attribute , node , nodeId , parentPMMLNode ) ; } else { throw new RuntimeException ( \"Unsupported attribute type for: \" + attribute ) ; } }'", "label": "'Builds a new { @link org . dmg . pmml . Node PMML Node } from the given { @link weka . classifiers . trees . RandomTree . Tree Weka Tree Node } .'"}
{"text": "'public ServiceGroup createServiceGroup ( Set < ResourceClass > resourceClasses , ServiceGroup . ServiceGroupBuilder serviceGroupBuilder ) { for ( ResourceClass resourceClass : resourceClasses ) { Logger . info ( \"{0} processing started\" , resourceClass . getClazz ( ) . getCanonicalName ( ) ) ; Service service = createResource ( resourceClass ) ; serviceGroupBuilder . service ( service ) ; Logger . info ( \"{0} processing finished\" , resourceClass . getClazz ( ) . getCanonicalName ( ) ) ; } return serviceGroupBuilder . build ( ) ; }'", "label": "'Main method creates API model from metadata'"}
{"text": "'@ PUT ( value = \"/todo/\" , code = 202 ) public boolean send ( final Todo todo ) { if ( ! sendQueue . isPresent ( ) ) { initSendQueue ( ) ; } try { sendQueue . ifPresent ( todoSendQueue -> todoSendQueue . send ( todo ) ) ; } catch ( JmsException ex ) { queue = Optional . empty ( ) ; sendQueue = Optional . empty ( ) ; initSendQueue ( ) ; sendQueue . ifPresent ( todoSendQueue -> todoSendQueue . send ( todo ) ) ; } return true ; }'", "label": "'curl - X PUT - H Content - Type : application / json - d { name : deploy app done : true } http : // localhost : 8080 / jms / todo /'"}
{"text": "'private synchronized void saveConfiguration ( ) { for ( WekaModelConfig wekaModelConfig : modelConfigs . values ( ) ) { if ( wekaModelConfig . isDirty ( ) && wekaModelConfig . getModelConfig ( ) . isStoreModel ( ) ) { try { String modelConfigJson = mapper . writeValueAsString ( wekaModelConfig . getModelConfig ( ) ) ; // create a new file because this model has never been written if ( wekaModelConfig . getHeader ( ) == null ) { File file = File . createTempFile ( wekaModelConfig . getId ( ) . toString ( ) , \".\" + WekaManagerConfig . HEADER_EXTENSION , wekaManagerConfig . getHeaderLocation ( ) ) ; wekaModelConfig . setHeader ( file ) ; } FileUtils . write ( ( wekaModelConfig ) . getHeader ( ) , modelConfigJson ) ; wekaModelConfig . setDirty ( false /* contents have been updated so the model is no longer dirty*/ ) ; } catch ( IOException e ) { logger . error ( \"Could not store configuration for model \\'{}\\' (will continue to save others)\" , wekaModelConfig . getId ( ) , e ) ; } } } }'", "label": "'Save dirty configurations to disk . <p / > If saving configuration was not possible a log is produced but no exception is thrown .'"}
{"text": "'@ Override public synchronized void close ( ) throws FOSException { acceptThreadRunning = false ; if ( scorerHandler != null ) { scorerHandler . close ( ) ; } IOUtils . closeQuietly ( serverSocket ) ; saveConfiguration ( ) ; }'", "label": "'Will save the configuration to file .'"}
{"text": "'private ModelDescriptor getModelDescriptor ( Model model , File modelFile ) throws FOSException { if ( model instanceof ModelBinary ) { return new ModelDescriptor ( ModelDescriptor . Format . BINARY , modelFile . getAbsolutePath ( ) ) ; } else if ( model instanceof ModelPMML ) { return new ModelDescriptor ( ModelDescriptor . Format . PMML , modelFile . getAbsolutePath ( ) ) ; } else { throw new FOSException ( \"Unsupported Model type \\'\" + model . getClass ( ) . getSimpleName ( ) + \"\\'.\" ) ; } }'", "label": "'Returns a new { @link com . feedzai . fos . api . ModelDescriptor } for the given { @code model } and { @code file } .'"}
{"text": "'private void trainClassifier ( int classIndex , Classifier classifier , Instances wekaInstances ) throws FOSException { wekaInstances . setClassIndex ( classIndex == - 1 ? wekaInstances . numAttributes ( ) - 1 : classIndex ) ; try { classifier . buildClassifier ( wekaInstances ) ; } catch ( Exception e ) { throw new FOSException ( e . getMessage ( ) , e ) ; } }'", "label": "'Trains the given { @code classifier } using the given { @link com . feedzai . fos . impl . weka . config . WekaModelConfig modelConfig } and { @link weka . core . Instances wekaInstances } .'"}
{"text": "'@ Override @ NotNull public Classifier makeObject ( ) throws WekaClassifierException { logger . debug ( \"Creating classifier\" ) ; File file = new File ( modelDescriptor . getModelFilePath ( ) ) ; checkArgument ( file . exists ( ) , \"Source file \\'\" + file . getAbsolutePath ( ) + \"\\' must exist\" ) ; long time = System . currentTimeMillis ( ) ; switch ( modelDescriptor . getFormat ( ) ) { case BINARY : try ( FileInputStream fileInputStream = new FileInputStream ( file ) ; BufferedInputStream bufferedInputStream = new BufferedInputStream ( fileInputStream , 1024 * 1024 ) ; ObjectInputStream objectInputStream = new ObjectInputStream ( bufferedInputStream ) ) { Classifier classifier = ( Classifier ) objectInputStream . readObject ( ) ; logger . debug ( \"Loaded binary model {} in {} ms.\" , file . getPath ( ) , ( System . currentTimeMillis ( ) - time ) ) ; return classifier ; } catch ( IOException | ClassNotFoundException e ) { throw new WekaClassifierException ( e ) ; } case PMML : try { Classifier classifier = PMMLConsumers . consume ( file ) ; logger . debug ( \"Loaded PMML model {} in {} ms.\" , file . getPath ( ) , ( System . currentTimeMillis ( ) - time ) ) ; return classifier ; } catch ( FOSException e ) { throw new WekaClassifierException ( \"Failed to consume PMML file \" + file . getAbsolutePath ( ) + \".\" , e ) ; } default : throw new WekaClassifierException ( \"Unknown model type \" + modelDescriptor . getFormat ( ) ) ; } }'", "label": "'Make on object of the factory type . <p > Reads the { @link Classifier } from file .'"}
{"text": "'@ Override public void forwardEvent ( final EventTransferObject < Object > event ) { eventConnector . forwardEvent ( new EventTransferObject < Object > ( ) { @ Override public String channel ( ) { return event . channel ( ) ; } @ Override public long id ( ) { return event . id ( ) ; } @ Override public Object body ( ) { return event . body ( ) ; } @ Override public boolean isSingleton ( ) { return true ; } @ Override public MultiMap < String , String > params ( ) { return event . params ( ) ; } @ Override public MultiMap < String , String > headers ( ) { return event . headers ( ) ; } /* Save a map lookup or building a header map. */ @ Override public boolean wasReplicated ( ) { return true ; } @ SuppressWarnings ( \"EqualsWhichDoesntCheckParameterClass\" ) @ Override public boolean equals ( Object obj ) { //noinspection EqualsBetweenInconvertibleTypes return event . equals ( obj ) ; } @ Override public int hashCode ( ) { return event . hashCode ( ) ; } } ) ; }'", "label": "'This message receives an event from a remote call .'"}
{"text": "'public static Annotation [ ] getResourcesAnnotations ( Method method ) { Map < Class < ? > , Annotation > annotations = new HashMap < Class < ? > , Annotation > ( ) ; for ( Annotation annotation : method . getDeclaringClass ( ) . getAnnotations ( ) ) { annotations . put ( annotation . getClass ( ) , annotation ) ; } for ( Annotation annotation : method . getAnnotations ( ) ) { annotations . put ( annotation . getClass ( ) , annotation ) ; } return annotations . values ( ) . toArray ( new Annotation [ annotations . size ( ) ] ) ; }'", "label": "'Returns an array of annotations the specified method of a resource class .'"}
{"text": "'public static < T extends Annotation > T findAnnotation ( Class < ? > type , Annotation [ ] annotations , Class < T > annotation ) { T config = FindAnnotation . findAnnotation ( annotations , annotation ) ; if ( config == null ) { config = type . getAnnotation ( annotation ) ; } return config ; }'", "label": "'Look for an annotation in a list of annotations . If not there see if it is on the type provided'"}
{"text": "'public static void mainArrayBlockingQueue ( String ... args ) throws Exception { final int runs = 20 ; final int tradeCount = 5_000_000 ; final int batchSize = 125 ; int currentBatchSize = batchSize ; run ( runs , tradeCount , 1 ) ; run ( runs , tradeCount , batchSize ) ; for ( int index = 0 ; index < 10 ; index ++ ) { run ( runs , tradeCount , currentBatchSize ) ; currentBatchSize *= 2 ; } }'", "label": "'public static void mainArrayBlockingQueue ( String ... args ) throws Exception {'"}
{"text": "'public static void mainTransferQueue ( String ... args ) throws Exception { final int runs = 20 ; final int tradeCount = 5_000_000 ; final int batchSize = 50_000 ; final int checkEvery = 1000 ; int currentCheckEvery = checkEvery ; run ( runs , tradeCount , batchSize , 10 ) ; for ( int index = 0 ; index < 10 ; index ++ ) { run ( runs , tradeCount , batchSize , currentCheckEvery ) ; currentCheckEvery *= 2 ; } }'", "label": "'public static void main ( String ... args ) throws Exception {'"}
{"text": "'public static ResourceConstructor constructor ( Class < ? > annotatedResourceClass ) { Constructor constructor = PickConstructor . pickPerRequestConstructor ( annotatedResourceClass ) ; if ( constructor == null ) { throw new RuntimeException ( \"Could not find constructor for class: \" + annotatedResourceClass . getName ( ) ) ; } ResourceConstructorBuilder builder = rootResource ( annotatedResourceClass ) . constructor ( constructor ) ; if ( constructor . getParameterTypes ( ) != null ) { for ( int i = 0 ; i < constructor . getParameterTypes ( ) . length ; i ++ ) builder . param ( i ) . fromAnnotations ( ) ; } return builder . buildConstructor ( ) . buildClass ( ) . getConstructor ( ) ; }'", "label": "'Picks a constructor from an annotated resource class based on spec rules'"}
{"text": "'public static ResourceClass rootResourceFromAnnotations ( Class < ? > clazz ) { ResourceClass resourceClass = fromAnnotations ( false , clazz ) ; return resourceClass ; }'", "label": "'Build metadata from annotations on classes and methods'"}
{"text": "'private static boolean isWeldProxy ( Class < ? > clazz ) { for ( Class < ? > implementedInterface : clazz . getInterfaces ( ) ) { if ( implementedInterface . getName ( ) . equals ( WELD_PROXY_INTERFACE_NAME ) ) { return true ; } } return false ; }'", "label": "'Whether the given class is a proxy created by Weld or not . This is the case if the given class implements the interface { @code org . jboss . weld . bean . proxy . ProxyObject } .'"}
{"text": "'@ PUT ( value = \"/todo/\" , code = 202 ) public Todo get ( ) { if ( ! consumeQueue . isPresent ( ) ) { initConsumeQueue ( ) ; } Todo todo ; try { todo = consumeQueue . get ( ) . poll ( ) ; } catch ( JmsException ex ) { queue = Optional . empty ( ) ; consumeQueue = Optional . empty ( ) ; initConsumeQueue ( ) ; todo = consumeQueue . get ( ) . poll ( ) ; } return todo ; }'", "label": "'curl - X PUT http : // localhost : 9090 / jms / todo /'"}
{"text": "'public static void setupBaggingClassifiers ( IteratedSingleClassifierEnhancer bagging ) throws Exception { bagging . m_Classifiers = Classifier . makeCopies ( bagging . m_Classifier , bagging . m_NumIterations ) ; }'", "label": "'Sets the classifiers in a bagging .'"}
{"text": "'protected List < Selector > groups ( ) throws ParserException { List < Selector > groups = new ArrayList < Selector > ( ) ; int groupNumber = 0 ; while ( ! end ( ) ) { ignoreWhitespaces ( ) ; parserListener . beginGroup ( groupNumber , pos ) ; Selector selector = selector ( ) ; groups . add ( selector ) ; parserListener . endGroup ( selector ) ; groupNumber ++ ; ignoreWhitespaces ( ) ; if ( ! end ( ) && current != \\' \\' ) { throw new ParserException ( \"There is something left in the selector at position \" + pos ) ; } next ( ) ; } return groups ; }'", "label": "'selectors_group : selector [ COMMA S * selector ] *'"}
{"text": "'protected Selector selector ( ) throws ParserException { int initialPosition = pos ; StringBuilder sb = new StringBuilder ( ) ; List < SimpleSelectorSequence > simpleSelectors = new ArrayList < SimpleSelectorSequence > ( ) ; List < Combinator > combinators = new ArrayList < Combinator > ( ) ; int lastChar = pos ; while ( ! end ( ) ) { //finds combinator, but not in the first iteration\\r Combinator combinator = null ; if ( ! simpleSelectors . isEmpty ( ) ) { //stores if it has spaces until the next token\\r boolean hasWhitespace = false ; if ( ! end ( ) && Character . isWhitespace ( current ) ) { hasWhitespace = true ; ignoreWhitespaces ( ) ; } if ( ! end ( ) ) { //implements \"combinator\" rule\\r if ( current == \\' \\' ) combinator = Combinator . ADJASCENT_SIBLING ; else if ( current == \\' \\' ) combinator = Combinator . CHILD ; else if ( current == \\' \\' ) combinator = Combinator . GENERAL_SIBLING ; //if hasn\\'t any but spaces\\r else if ( hasWhitespace ) combinator = Combinator . DESCENDANT ; //is it the end?\\r if ( combinator == null || current == \\' \\' ) { break ; } //don\\'t advance because spaces were just advanced\\r if ( combinator != Combinator . DESCENDANT ) { sb . append ( current ) ; next ( ) ; } else { sb . append ( \\' \\' ) ; } ignoreWhitespaces ( ) ; if ( end ( ) ) { throw new ParserException ( \"Unexpected end of selector at position \" + pos ) ; } } else { break ; } combinators . add ( combinator ) ; } //get next sequence\\r SimpleSelectorSequence simpleSelectorSequence = simpleSelectorSequence ( ) ; sb . append ( simpleSelectorSequence ) ; //sends combinator here (the first case it\\'s null)\\r simpleSelectors . add ( simpleSelectorSequence ) ; parserListener . selectorSequence ( simpleSelectorSequence , combinator ) ; lastChar = pos ; } return new Selector ( simpleSelectors , combinators , new Context ( content , sb . toString ( ) , initialPosition , lastChar ) ) ; }'", "label": "'selector : simple_selector_sequence [ combinator simple_selector_sequence ] * ;'"}
{"text": "'protected SimpleSelectorSequence simpleSelectorSequence ( ) throws ParserException { List < SimpleSelector > simpleSelectorList = new ArrayList < SimpleSelector > ( ) ; StringBuilder sb = new StringBuilder ( ) ; boolean hasSimpleSelector = false ; int initialPos = pos ; if ( current == \\' \\' ) { //universal selector\\r sb . append ( current ) ; hasSimpleSelector = true ; TypeSelector ts = new TypeSelector ( \"*\" , new Context ( content , \"*\" , initialPos , pos + 1 ) ) ; parserListener . typeSelector ( ts ) ; simpleSelectorList . add ( ts ) ; next ( ) ; } else if ( Character . isLetter ( current ) ) { //type selector\\r String type = identifier ( ) ; sb . append ( type ) ; hasSimpleSelector = true ; TypeSelector ts = new TypeSelector ( type , new Context ( content , type , initialPos , pos ) ) ; parserListener . typeSelector ( ts ) ; simpleSelectorList . add ( ts ) ; } int selectorCount = 0 ; boolean hasPseudoElement = false ; while ( ! end ( ) ) { int initialLoopPos = pos ; if ( current == \\' \\' ) { //class selector\\r sb . append ( current ) ; next ( ) ; String className = ! end ( ) ? identifier ( ) : null ; if ( className == null || className . isEmpty ( ) ) { throw new ParserException ( \"Expected className at position \" + pos ) ; } sb . append ( className ) ; ClassSelector cs = new ClassSelector ( className , new Context ( content , \".\" + className , initialLoopPos , pos ) ) ; simpleSelectorList . add ( cs ) ; parserListener . classSelector ( cs ) ; } else if ( current == \\' \\' ) { //hash selector\\r sb . append ( current ) ; next ( ) ; String id = ! end ( ) ? identifier ( ) : null ; if ( id == null || id . isEmpty ( ) ) { throw new ParserException ( \"Expected id at position \" + pos ) ; } HashSelector hs = new HashSelector ( id , new Context ( content , \"#\" + id , initialLoopPos , pos ) ) ; simpleSelectorList . add ( hs ) ; parserListener . idSelector ( hs ) ; sb . append ( id ) ; } else if ( current == \\' \\' ) { //attribute selectors\\r sb . append ( current ) ; next ( ) ; AttributeSelector as = attribute ( ) ; simpleSelectorList . add ( as ) ; parserListener . attributeSelector ( as ) ; sb . append ( as ) ; sb . append ( \\' \\' ) ; } else if ( current == \\' \\' ) { //pseudo-element, pseudo-class or negation\\r sb . append ( current ) ; next ( ) ; if ( end ( ) ) { throw new ParserException ( \"Expected pseudo-element or pseudo-class at \" + pos ) ; } boolean doubleColon = false ; if ( current == \\' \\' ) { doubleColon = true ; sb . append ( current ) ; next ( ) ; } String ident = ! end ( ) ? identifier ( ) : null ; if ( ident == null || ident . isEmpty ( ) ) { throw new ParserException ( \"Expected identifier at position \" + pos ) ; } boolean special = isPseudoSpecialCase ( ident ) ; if ( special || doubleColon ) { //pseudo-element (double colon or special cases)\\r //allow just one\\r if ( hasPseudoElement ) { throw new ParserException ( \"Only one pseudo-element is allowed for each simple selector and a second one was found at position \" + pos ) ; } PseudoSelector ps = pseudo ( ident , PseudoType . PSEUDO_ELEMENT , doubleColon ) ; simpleSelectorList . add ( ps ) ; parserListener . pseudoSelector ( ps ) ; sb . append ( ps ) ; hasPseudoElement = true ; } else if ( \"not\" . equalsIgnoreCase ( ident ) ) { //negation\\r NegationSelector n = negation ( selectorCount ) ; simpleSelectorList . add ( n ) ; sb . append ( ident ) ; sb . append ( \\' \\' ) ; sb . append ( n ) ; sb . append ( \\' \\' ) ; } else { //pseudo-class\\r PseudoSelector ps = pseudo ( ident , PseudoType . PSEUDO_CLASS , false ) ; simpleSelectorList . add ( ps ) ; parserListener . pseudoSelector ( ps ) ; sb . append ( ps ) ; } } else { break ; } selectorCount ++ ; } if ( ! hasSimpleSelector && selectorCount == 0 ) { throw new ParserException ( \"No real selector found at position \" + pos ) ; } return new SimpleSelectorSequence ( simpleSelectorList , new Context ( content , sb . toString ( ) , initialPos , pos ) ) ; }'", "label": "'simple_selector_sequence : [ type_selector | universal ] [ HASH | class | attrib | pseudo | negation ] * | [ HASH | class | attrib | pseudo | negation ] +'"}
{"text": "'protected AttributeSelector attribute ( ) throws ParserException { int initialPos = pos ; StringBuilder sb = new StringBuilder ( ) ; ignoreWhitespaces ( ) ; String name = ! end ( ) ? identifier ( ) : null ; if ( name == null || name . isEmpty ( ) ) { throw new ParserException ( \"Expected attribute name at position \" + pos ) ; } sb . append ( name ) ; ignoreWhitespaces ( ) ; if ( end ( ) ) { throw new ParserException ( \"Unexpected end of selector selector at position \" + pos ) ; } AttributeOperator operator = null ; if ( current == \\' \\' ) { operator = AttributeOperator . EQUALS ; next ( ) ; } else if ( current != \\' \\' ) { if ( current == \\' \\' ) operator = AttributeOperator . INCLUDES ; else if ( current == \\' \\' ) operator = AttributeOperator . DASH_MATCH ; else if ( current == \\' \\' ) operator = AttributeOperator . PREFIX_MATCH ; else if ( current == \\' \\' ) operator = AttributeOperator . SUFFIX_MATCH ; else if ( current == \\' \\' ) operator = AttributeOperator . SUBSTRING_MATCH ; else throw new ParserException ( \"Invalid operator (\\'\" + current + \"\\') at position \" + pos ) ; next ( ) ; if ( end ( ) || current != \\' \\' ) { throw new ParserException ( \"Expected \\'=\\' sign at position \" + pos ) ; } next ( ) ; } ignoreWhitespaces ( ) ; if ( end ( ) ) { throw new ParserException ( \"Unexpected end of attribute selector at position \" + pos ) ; } //value\\r StringValue value = null ; if ( operator != null ) { sb . append ( operator . getSign ( ) ) ; if ( current == \\' \\' || current == \\' \\' ) { char quote = current ; value = string ( ) ; sb . append ( quote ) ; sb . append ( value . getContext ( ) . toString ( ) ) ; sb . append ( quote ) ; } else { int identPos = pos ; String ident = identifier ( ) ; value = new StringValue ( new Context ( content , ident , identPos , pos ) , ident ) ; sb . append ( value ) ; } } ignoreWhitespaces ( ) ; //end of attribute\\r if ( end ( ) || current != \\' \\' ) { throw new ParserException ( \"Token \\']\\' expected at position \" + pos ) ; } int endPos = pos ; next ( ) ; return new AttributeSelector ( name , operator , value , new Context ( content , sb . toString ( ) , initialPos , endPos ) ) ; }'", "label": "'attrib : [ S * [ namespace_prefix ] ? IDENT S * [ [ PREFIXMATCH | SUFFIXMATCH | SUBSTRINGMATCH | = | INCLUDES | DASHMATCH ] S * [ IDENT | STRING ] S * ] ? ]'"}
{"text": "'protected StringValue string ( ) throws ParserException { Character openQuote = current ; int initialPosition = pos ; boolean escape = false ; next ( ) ; StringBuilder value = new StringBuilder ( ) ; StringBuilder string = new StringBuilder ( ) ; while ( ! end ( ) ) { if ( escape ) { //TODO implement UNICODE\\r if ( current == openQuote || current == \\' \\' ) { value . append ( current ) ; string . append ( current ) ; escape = false ; } else { throw new ParserException ( \"Invalid escape character at position \" + pos ) ; } } else { if ( current == openQuote ) break ; string . append ( current ) ; if ( current == \\' \\' ) { escape = true ; } else { value . append ( current ) ; } } next ( ) ; } if ( current != openQuote ) { throw new ParserException ( \"String not closed!\" ) ; } next ( ) ; return new StringValue ( new Context ( content , string . toString ( ) , initialPosition , pos ) , value . toString ( ) ) ; }'", "label": "'string { string1 } | { string2 } string1 \\\\ ( [ ^ \\\\ n \\\\ r \\\\ f \\\\\\\\ ] | \\\\\\\\ { nl } | { nonascii } | { escape } ) * \\\\ string2 \\\\ ( [ ^ \\\\ n \\\\ r \\\\ f \\\\\\\\ ] | \\\\\\\\ { nl } | { nonascii } | { escape } ) * \\\\ nonascii [ ^ \\\\ 0 - \\\\ 177 ] escape { unicode } | \\\\\\\\ [ ^ \\\\ n \\\\ r \\\\ f0 - 9a - f ] unicode \\\\\\\\ [ 0 - 9a - f ] { 1 6 } ( \\\\ r \\\\ n| [ \\\\ n \\\\ r \\\\ t \\\\ f ] ) ? nl \\\\ n| \\\\ r \\\\ n| \\\\ r| \\\\ f'"}
{"text": "'protected String number ( ) throws ParserException { StringBuilder sb = new StringBuilder ( ) ; sb . append ( current ) ; next ( ) ; boolean hasDot = false ; while ( ! end ( ) && ( Character . isDigit ( current ) || current == \\' \\' ) ) { if ( current == \\' \\' ) { if ( hasDot ) { throw new ParserException ( \"Unexpected \\'.\\' at position \" + pos ) ; } hasDot = true ; } sb . append ( current ) ; next ( ) ; } return sb . toString ( ) ; }'", "label": "'num [ 0 - 9 ] + | [ 0 - 9 ] * \\\\ . [ 0 - 9 ] +'"}
{"text": "'protected NegationSelector negation ( int number ) throws ParserException { StringBuilder sb = new StringBuilder ( ) ; ignoreWhitespaces ( ) ; if ( end ( ) || current != \\' \\' ) { throw new ParserException ( \"Expected \\'(\\' at position \" + pos ) ; } //sb.append(current);\\r int parenthesisPos = pos ; next ( ) ; ignoreWhitespaces ( ) ; if ( end ( ) ) { throw new ParserException ( \"Selector expected at position \" + pos ) ; } int initialPos = pos ; SimpleSelector simpleSelector = null ; if ( current == \\' \\' ) { //universal selector\\r sb . append ( current ) ; TypeSelector ts = new TypeSelector ( \"*\" , new Context ( content , \"*\" , initialPos , pos + 1 ) ) ; parserListener . negationTypeSelector ( ts ) ; simpleSelector = ts ; next ( ) ; } else if ( Character . isLetter ( current ) ) { //type selector\\r String type = identifier ( ) ; sb . append ( type ) ; TypeSelector ts = new TypeSelector ( type , new Context ( content , type , initialPos , pos ) ) ; parserListener . negationTypeSelector ( ts ) ; simpleSelector = ts ; } else if ( current == \\' \\' ) { //class selector\\r sb . append ( current ) ; next ( ) ; String className = ! end ( ) ? identifier ( ) : null ; if ( className == null || className . isEmpty ( ) ) { throw new ParserException ( \"Expected className at position \" + pos ) ; } ClassSelector cs = new ClassSelector ( className , new Context ( content , \".\" + className , initialPos , pos ) ) ; simpleSelector = cs ; parserListener . negationClassSelector ( cs ) ; sb . append ( className ) ; } else if ( current == \\' \\' ) { //hash selector\\r sb . append ( current ) ; next ( ) ; String id = ! end ( ) ? identifier ( ) : null ; if ( id == null || id . isEmpty ( ) ) { throw new ParserException ( \"Expected id at position \" + pos ) ; } HashSelector hs = new HashSelector ( id , new Context ( content , \"#\" + id , initialPos , pos ) ) ; simpleSelector = hs ; parserListener . negationIdSelector ( hs ) ; sb . append ( id ) ; } else if ( current == \\' \\' ) { //attribute selectors\\r sb . append ( current ) ; next ( ) ; AttributeSelector as = attribute ( ) ; simpleSelector = as ; parserListener . negationAttributeSelector ( as ) ; sb . append ( as . getContext ( ) ) ; sb . append ( \\' \\' ) ; } else if ( current == \\' \\' ) { //pseudo-class only\\r sb . append ( current ) ; next ( ) ; if ( end ( ) ) { throw new ParserException ( \"Expected pseudo-element or pseudo-class at \" + pos ) ; } boolean doubleColon = false ; if ( current == \\' \\' ) { doubleColon = true ; sb . append ( current ) ; next ( ) ; } String ident = ! end ( ) ? identifier ( ) : null ; if ( ident == null || ident . isEmpty ( ) ) { throw new ParserException ( \"Expected identifier at position \" + pos ) ; } if ( \"not\" . equalsIgnoreCase ( ident ) || isPseudoSpecialCase ( ident ) || doubleColon ) { throw new ParserException ( \"Expected pseudo-class (starting with \\':\\', except \\':not\\', \\':first-line\\', \\':first-letter\\', \\':before\\' and \\':after\\') at position \" + pos ) ; } PseudoSelector ps = pseudo ( ident , PseudoType . PSEUDO_CLASS , doubleColon ) ; simpleSelector = ps ; parserListener . negationPseudoSelector ( ps ) ; sb . append ( ps . getContext ( ) ) ; } else { throw new ParserException ( \"Selector expected at position \" + pos ) ; } ignoreWhitespaces ( ) ; if ( end ( ) || current != \\' \\' ) { throw new ParserException ( \"Expected \\')\\' at position \" + pos ) ; } //sb.append(current);\\r next ( ) ; return new NegationSelector ( simpleSelector , new Context ( content , sb . toString ( ) , parenthesisPos , pos ) ) ; }'", "label": "'negation : NOT S * negation_arg S * )'"}
{"text": "'protected PseudoSelector pseudo ( String ident , PseudoType type , boolean doubleColon ) throws ParserException { int initialPos = pos ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( ident ) ; PseudoExpression expression = null ; if ( ! end ( ) && current == \\' \\' ) { sb . append ( current ) ; next ( ) ; ignoreWhitespaces ( ) ; if ( end ( ) ) { throw new ParserException ( \"Expected expression at position \" + pos ) ; } //expression\\r expression = expression ( ) ; sb . append ( expression . getContext ( ) ) ; //close parenthesis\\r ignoreWhitespaces ( ) ; if ( end ( ) || current != \\' \\' ) { throw new ParserException ( \"Expected \\')\\' at position \" + pos ) ; } sb . append ( current ) ; next ( ) ; } return new PseudoSelector ( ident , type , doubleColon , expression , new Context ( content , sb . toString ( ) , initialPos , pos ) ) ; }'", "label": "'pseudo // :: starts a pseudo - element : a pseudo - class // Exceptions : : first - line : first - letter : before and : after . // Note that pseudo - elements are restricted to one per selector and // occur only in the last simple_selector_sequence . : : : ? [ IDENT | functional_pseudo ] ;'"}
{"text": "'protected PseudoExpression expression ( ) throws ParserException { List < Item > items = new ArrayList < Item > ( ) ; StringBuilder sb = new StringBuilder ( ) ; int initialPos = pos ; if ( current == \\' \\' || current == \\' \\' ) { //string\\r Character quote = current ; StringValue s = string ( ) ; sb . append ( quote ) ; sb . append ( s . getContext ( ) . toString ( ) ) ; sb . append ( quote ) ; items . add ( new Item ( Type . STRING , s . getActualValue ( ) ) ) ; return new PseudoExpression ( items , null , s . getActualValue ( ) , new Context ( content , sb . toString ( ) , initialPos , pos ) ) ; } else { while ( ! end ( ) ) { if ( current == \\' \\' ) { items . add ( new Item ( Type . SIGNAL , \"+\" ) ) ; sb . append ( current ) ; next ( ) ; } else if ( current == \\' \\' ) { items . add ( new Item ( Type . SIGNAL , \"-\" ) ) ; sb . append ( current ) ; next ( ) ; } else if ( Character . isLetter ( current ) ) { //identifier\\r String ident = simpleIdentifier ( ) ; sb . append ( ident ) ; items . add ( new Item ( Type . IDENTIFIER , ident ) ) ; } else if ( Character . isDigit ( current ) ) { //number or dimension\\r String number = number ( ) ; sb . append ( number ) ; items . add ( new Item ( Type . NUMBER , number ) ) ; } else { break ; } ignoreWhitespaces ( ) ; } } return new PseudoExpression ( items , PseudoExpressionEvaluator . evaluate ( items ) , sb . toString ( ) , new Context ( content , sb . toString ( ) , initialPos , pos ) ) ; }'", "label": "'expression // In CSS3 the expressions are identifiers strings // or of the form an + b : [ [ PLUS | - | DIMENSION | NUMBER | STRING | IDENT ] S * ] +'"}
{"text": "'protected String identifier ( ) throws ParserException { //TODO implement unicode, escape, [-], nonascii\\r StringBuilder sb = new StringBuilder ( ) ; //validates first character\\r if ( ! end ( ) && ! Character . isLetter ( current ) && current != \\' \\' ) { return \"\" ; } while ( ! end ( ) && ( Character . isLetterOrDigit ( current ) || current == \\' \\' || current == \\' \\' ) ) { sb . append ( current ) ; next ( ) ; } return sb . toString ( ) ; }'", "label": "'ident [ - ] ? { nmstart } { nmchar } * name { nmchar } + nmstart [ _a - z ] | { nonascii } | { escape } nonascii [ ^ \\\\ 0 - \\\\ 177 ] unicode \\\\\\\\ [ 0 - 9a - f ] { 1 6 } ( \\\\ r \\\\ n| [ \\\\ n \\\\ r \\\\ t \\\\ f ] ) ? escape { unicode } | \\\\\\\\ [ ^ \\\\ n \\\\ r \\\\ f0 - 9a - f ] nmchar [ _a - z0 - 9 - ] | { nonascii } | { escape } num [ 0 - 9 ] + | [ 0 - 9 ] * \\\\ . [ 0 - 9 ] +'"}
{"text": "'protected boolean isPseudoSpecialCase ( String identifier ) { return \"first-line\" . equalsIgnoreCase ( identifier ) || \"first-letter\" . equalsIgnoreCase ( identifier ) || \"before\" . equalsIgnoreCase ( identifier ) || \"after\" . equalsIgnoreCase ( identifier ) ; }'", "label": "'pseudo ( Special cases ) // :: starts a pseudo - element : a pseudo - class // Exceptions : : first - line : first - letter : before and : after .'"}
{"text": "'@ NotNull public T get ( ) throws IOException , ClassNotFoundException { /* cannot be pre-instantiated to enable thread concurrency*/ ByteArrayInputStream byteArrayInputStream = null ; ObjectInputStream objectInputStream = null ; try { byteArrayInputStream = new ByteArrayInputStream ( this . serializedObject ) ; objectInputStream = new ObjectInputStream ( byteArrayInputStream ) ; return ( T ) objectInputStream . readObject ( ) ; } finally { IOUtils . closeQuietly ( byteArrayInputStream ) ; IOUtils . closeQuietly ( objectInputStream ) ; } }'", "label": "'Gets a fresh clone of the object .'"}
{"text": "'@ NotNull public byte [ ] getSerialized ( ) { byte [ ] result = new byte [ serializedObject . length ] ; System . arraycopy ( serializedObject , 0 , result , 0 , serializedObject . length ) ; return result ; }'", "label": "'Returns a copy of the serialized object .'"}
{"text": "'public void write ( File file ) throws IOException { checkNotNull ( file , \"Output file cannot be null\" ) ; FileUtils . writeByteArrayToFile ( file , serializedObject ) ; }'", "label": "'Writes the serialized object to file .'"}
{"text": "'private static Segment buildSegment ( MiningSchema miningSchema , int segmentId , RandomTree randomTree ) { int rootNodeId = 1 ; Node rootNode = new Node ( ) . withId ( String . valueOf ( rootNodeId ) ) . withPredicate ( new True ( ) ) ; TreeModel treeModel = new TreeModel ( miningSchema , rootNode , MiningFunctionType . CLASSIFICATION ) . withAlgorithmName ( ALGORITHM_NAME ) . withModelName ( MODEL_NAME ) . withSplitCharacteristic ( TreeModel . SplitCharacteristic . MULTI_SPLIT ) ; buildTreeNode ( randomTree , randomTree . m_Tree , rootNodeId , rootNode ) ; Segment segment = new Segment ( ) ; segment . withId ( String . valueOf ( segmentId ) ) ; segment . withModel ( treeModel ) ; return segment ; }'", "label": "'Builds a { @link org . dmg . pmml . Segment PMML Segment } that contains the { @link org . dmg . pmml . TreeModel PMML TreeModel } representing the given { @link weka . classifiers . trees . RandomTree Weka RandomTree } .'"}
{"text": "'private static int buildTreeNode ( RandomTree tree , RandomTree . Tree node , int nodeId , Node parentPMMLNode ) { addScoreDistribution ( parentPMMLNode , node . m_ClassDistribution , tree . m_Info ) ; if ( node . m_Attribute == - 1 ) { // Leaf: Add the node\\'s score. parentPMMLNode . withScore ( leafScoreFromDistribution ( node . m_ClassDistribution , tree . m_Info ) ) ; return nodeId ; } Attribute attribute = tree . m_Info . attribute ( node . m_Attribute ) ; if ( attribute . isNominal ( ) ) { return buildNominalNode ( tree , attribute , node , nodeId , parentPMMLNode ) ; } else if ( attribute . isNumeric ( ) ) { return buildNumericNode ( tree , attribute , node , nodeId , parentPMMLNode ) ; } else { throw new RuntimeException ( \"Unsupported attribute type for: \" + attribute ) ; } }'", "label": "'Builds a new { @link org . dmg . pmml . Node PMML Node } from the given { @link RandomTree . Tree Weka Tree Node } .'"}
{"text": "'private static int buildNominalNode ( RandomTree tree , Attribute attribute , RandomTree . Tree node , int nodeId , Node parentPMMLNode ) { List < Object > values = new ArrayList <> ( ) ; Enumeration enumeration = attribute . enumerateValues ( ) ; while ( enumeration . hasMoreElements ( ) ) { values . add ( enumeration . nextElement ( ) ) ; } assert values . size ( ) == node . m_Successors . length : \"Number of successors expected to be the same as the number of attribute values\" ; List < Node > children = new ArrayList <> ( ) ; for ( int i = 0 ; i < values . size ( ) ; i ++ ) { Object value = values . get ( i ) ; SimplePredicate predicate = new SimplePredicate ( new FieldName ( attribute . name ( ) ) , SimplePredicate . Operator . EQUAL ) . withValue ( String . valueOf ( value ) ) ; Node child = new Node ( ) . withId ( String . valueOf ( ++ nodeId ) ) . withPredicate ( predicate ) ; nodeId = buildTreeNode ( tree , node . m_Successors [ i ] , nodeId , child ) ; // Training proportion extension. child . withExtensions ( new Extension ( ) . withName ( TRAINING_PROPORTION_ELEMENT ) . withValue ( String . valueOf ( node . m_Prop [ i ] ) ) ) ; children . add ( child ) ; } parentPMMLNode . withNodes ( children ) ; return nodeId ; }'", "label": "'Builds the { @link org . dmg . pmml . Node PMML Node } for a nominal attribute . <p / > In PMML these nodes are represented with multiple children one for each of the attribute s values . <p / > For example consider a nominal attribute named nominalAttribute with values cold hot and warm . In PMML this translates to : <pre > { @code <Node id = 2 score = 1 > <SimplePredicate field = nominalAttribute operator = equal value = cold / > < / Node > <Node id = 3 score = 0 > <SimplePredicate field = nominalAttribute operator = equal value = hot / > < / Node > <Node id = 4 score = 1 . 5 > <SimplePredicate field = nominalAttribute operator = equal value = warm / > < / Node > } < / pre >'"}
{"text": "'private static int buildNumericNode ( RandomTree tree , Attribute attribute , RandomTree . Tree node , int nodeId , Node parentPMMLNode ) { SimplePredicate predicateLo = new SimplePredicate ( new FieldName ( attribute . name ( ) ) , SimplePredicate . Operator . LESS_THAN ) . withValue ( String . valueOf ( node . m_SplitPoint ) ) ; SimplePredicate predicateHi = new SimplePredicate ( new FieldName ( attribute . name ( ) ) , SimplePredicate . Operator . GREATER_OR_EQUAL ) . withValue ( String . valueOf ( node . m_SplitPoint ) ) ; Node nodeLo = new Node ( ) . withId ( String . valueOf ( ++ nodeId ) ) ; nodeLo . withPredicate ( predicateLo ) ; nodeId = buildTreeNode ( tree , node . m_Successors [ 0 ] , nodeId , nodeLo ) ; Node nodeHi = new Node ( ) . withId ( String . valueOf ( ++ nodeId ) ) ; nodeHi . withPredicate ( predicateHi ) ; nodeId = buildTreeNode ( tree , node . m_Successors [ 1 ] , nodeId , nodeHi ) ; // Training proportion extension. nodeLo . withExtensions ( new Extension ( ) . withName ( TRAINING_PROPORTION_ELEMENT ) . withValue ( String . valueOf ( node . m_Prop [ 0 ] ) ) ) ; nodeHi . withExtensions ( new Extension ( ) . withName ( TRAINING_PROPORTION_ELEMENT ) . withValue ( String . valueOf ( node . m_Prop [ 1 ] ) ) ) ; parentPMMLNode . withNodes ( nodeLo , nodeHi ) ; return nodeId ; }'", "label": "'Builds the { @link org . dmg . pmml . Node PMML Node } for a numeric attribute . <p / > In PMML these nodes are represented having two children each with a predicate that checks the node s split point . <p / > For example consider a numeric attribute named numericAttribute with a split point of 2 . 5 and two leaf nodes . In PMML this translates to : <pre > { @code <Node id = 2 score = 1 > <SimplePredicate field = numericAttribute operator = lessThan value = 2 . 5 / > < / Node > <Node id = 3 score = 0 > <SimplePredicate field = numericAttribute operator = greaterOrEqual value = 2 . 5 / > < / Node > } < / pre >'"}
{"text": "'@ Bean public CommandLineRunner runner ( final RandomNumberServiceAsync randomNumberServiceAsync ) { return args -> { for ( int i = 0 ; i < 100 ; i ++ ) { randomNumberServiceAsync . getRandom ( CallbackBuilder . newCallbackBuilder ( ) . withCallback ( n -> logger . info ( \"Here\\'s a random number: \" + n ) ) . withErrorHandler ( e -> logger . error ( \"blew up: \" + e . getMessage ( ) ) ) . < Integer > build ( ) , 0 , 100 ) ; } } ; }'", "label": "'This is the main class of the example client . I m using a { @link CommandLineRunner CommandLineRunner } here to keep the example simple but this could be any spring bean that needs a QBit proxy injected .'"}
{"text": "'public static Header buildPMMLHeader ( String description ) { return new Header ( ) . withCopyright ( \"www.dmg.org\" ) . withDescription ( description ) . withApplication ( new Application ( \"Feedzai FOS-Weka\" ) . withVersion ( \"1.0.4\" ) ) ; }'", "label": "'Creates a new { @link org . dmg . pmml . Header } element .'"}
{"text": "'public static void addScoreDistribution ( Node pmmlNode , double [ ] classDistribution , Instances instances ) { if ( classDistribution != null ) { double sum = 0.0 ; for ( int i = 0 ; i < classDistribution . length ; i ++ ) { sum += classDistribution [ i ] ; } for ( int i = 0 ; i < classDistribution . length ; i ++ ) { String value = instances . classAttribute ( ) . value ( i ) ; double probability ; if ( sum != 0.0 ) { probability = classDistribution [ i ] / sum ; } else { probability = 1.0 / classDistribution . length ; } ScoreDistribution scoreDistribution = new ScoreDistribution ( value , 0 ) ; scoreDistribution . withConfidence ( classDistribution [ i ] ) ; scoreDistribution . withProbability ( probability ) ; pmmlNode . withScoreDistributions ( scoreDistribution ) ; } } }'", "label": "'Adds a { @link org . dmg . pmml . ScoreDistribution PMML ScoreDistribution element } to the given { @link org . dmg . pmml . Node PMML Node } with the confidence from the given { @code classDistribution } .'"}
{"text": "'public static String leafScoreFromDistribution ( double [ ] classDistribution , Instances instances ) { double sum = 0 , maxCount = 0 ; int maxIndex = 0 ; if ( classDistribution != null ) { sum = Utils . sum ( classDistribution ) ; maxIndex = Utils . maxIndex ( classDistribution ) ; maxCount = classDistribution [ maxIndex ] ; } return instances . classAttribute ( ) . value ( maxIndex ) ; }'", "label": "'Retrieves a String representing the score of the given class distribution .'"}
{"text": "'public static double [ ] getClassDistribution ( Node node ) { List < ScoreDistribution > scoreDistributions = node . getScoreDistributions ( ) ; double [ ] classDistribution = null ; if ( ! scoreDistributions . isEmpty ( ) ) { classDistribution = new double [ scoreDistributions . size ( ) ] ; for ( int i = 0 ; i < scoreDistributions . size ( ) ; i ++ ) { classDistribution [ i ] = scoreDistributions . get ( i ) . getConfidence ( ) ; } } return classDistribution ; }'", "label": "'Retrieves the class distribution for the given node . <p / > We represent this in PMML as the confidence of a list of { @link org . dmg . pmml . ScoreDistribution } elements .'"}
{"text": "'public static double getNodeTrainingProportion ( Node node ) { for ( Extension extension : node . getExtensions ( ) ) { if ( TRAINING_PROPORTION_ELEMENT . equals ( extension . getName ( ) ) ) { return Double . valueOf ( extension . getValue ( ) ) ; } } return 0 ; }'", "label": "'Retrieves the training proportion of the given node . <p / > We represent this value in PMML as an { @link org . dmg . pmml . Extension } element of the node .'"}
{"text": "'public static int getClassIndex ( Instances instances , TreeModel treeModel ) { MiningSchema miningModel = treeModel . getMiningSchema ( ) ; String className = null ; for ( MiningField miningField : miningModel . getMiningFields ( ) ) { if ( miningField . getUsageType ( ) == FieldUsageType . PREDICTED ) { className = miningField . getName ( ) . getValue ( ) ; break ; } } return instances . attribute ( className ) . index ( ) ; }'", "label": "'Retrieves the index of the class attribute . This is the attribute to be predicted .'"}
{"text": "'public static int getClassIndex ( Instances instances , MiningSchema miningSchema ) { String className = null ; for ( MiningField miningField : miningSchema . getMiningFields ( ) ) { if ( miningField . getUsageType ( ) == FieldUsageType . PREDICTED ) { className = miningField . getName ( ) . getValue ( ) ; break ; } } return instances . attribute ( className ) . index ( ) ; }'", "label": "'Retrieves the index of the class attribute . This is the attribute to be predicted .'"}
{"text": "'public static Instances buildInstances ( DataDictionary dataDict ) { List < weka . core . Attribute > attributes = buildAttributes ( dataDict ) ; FastVector fastVector = new FastVector ( attributes . size ( ) ) ; for ( weka . core . Attribute attribute : attributes ) { fastVector . addElement ( attribute ) ; } return new Instances ( \"instances\" , fastVector , attributes . size ( ) ) ; }'", "label": "'Creates a new { @link weka . core . Instances } instance from the attributes in a { @link org . dmg . pmml . DataDictionary PMML DataDictionary } .'"}
{"text": "'public static List < weka . core . Attribute > buildAttributes ( DataDictionary dataDict ) { ImmutableList . Builder < weka . core . Attribute > attribuesBuilder = ImmutableList . builder ( ) ; for ( DataField dataField : dataDict . getDataFields ( ) ) { attribuesBuilder . add ( buildAttribute ( dataField ) ) ; } return attribuesBuilder . build ( ) ; }'", "label": "'Creates and returns { @link weka . core . Attribute attributes } from a { @link org . dmg . pmml . DataDictionary PMML DataDictionary } .'"}
{"text": "'public static weka . core . Attribute buildAttribute ( DataField dataField ) { switch ( dataField . getOptype ( ) ) { case CONTINUOUS : return new weka . core . Attribute ( dataField . getName ( ) . getValue ( ) ) ; case CATEGORICAL : List < Value > values = dataField . getValues ( ) ; FastVector nominalValues = new FastVector ( ) ; for ( Value value : values ) { nominalValues . addElement ( value . getValue ( ) ) ; } return new weka . core . Attribute ( dataField . getName ( ) . getValue ( ) , nominalValues ) ; default : throw new RuntimeException ( \"PMML DataField OPTYPE \" + dataField . getOptype ( ) + \" not supported.\" ) ; } }'", "label": "'Creates a new { @link weka . core . Attribute } from a { @link org . dmg . pmml . DataField PMML DataField } .'"}
{"text": "'public static MiningModel getMiningModel ( PMML pmml ) { for ( Model model : pmml . getModels ( ) ) { if ( model instanceof MiningModel ) { return ( MiningModel ) model ; } } throw new RuntimeException ( \"PMML MiningModel not found.\" ) ; }'", "label": "'Retrieves the { @link org . dmg . pmml . MiningModel PMML MiningModel } element in a { @link org . dmg . pmml . PMML } .'"}
{"text": "'public String getProviderURL ( ) { if ( providerURL == null ) { providerURL = getProviderURLPattern ( ) . replace ( \"#host#\" , getHost ( ) ) . replace ( \"#port#\" , Integer . toString ( getPort ( ) ) ) ; } return providerURL ; }'", "label": "'If null will build based on host port and provider url pattern .'"}
{"text": "'public Context getContext ( ) { if ( context == null ) { try { context = new InitialContext ( createProperties ( ) ) ; } catch ( NamingException e ) { throw new IllegalStateException ( \"Unable to create context\" , e ) ; } } return context ; }'", "label": "'Gets the initial JNDI context if not set uses the jndi settings and initialContextFactory to create a JNDI initial context .'"}
{"text": "'public Supplier < Connection > getConnectionSupplier ( ) { final boolean startConnection = isStartConnection ( ) ; if ( connectionSupplier == null ) { if ( getUserName ( ) == null ) { connectionSupplier = ( ) -> { try { final Connection connection = getConnectionFactory ( ) . createConnection ( ) ; if ( startConnection ) { connection . start ( ) ; } return connection ; } catch ( JMSException e ) { throw new JmsNotConnectedException ( \"Unable to create context\" , e ) ; } } ; } else { final String userName = getUserName ( ) ; final String password = getPassword ( ) ; connectionSupplier = ( ) -> { try { final Connection connection = getConnectionFactory ( ) . createConnection ( userName , password ) ; if ( startConnection ) { connection . start ( ) ; } return connection ; } catch ( JMSException e ) { throw new JmsNotConnectedException ( \"Unable to create context for user \" + userName , e ) ; } } ; } } return connectionSupplier ; }'", "label": "'If the user name is set use the user name and password to create the JMS connection .'"}
{"text": "'private Hashtable < Object , Object > createProperties ( ) { Hashtable < Object , Object > properties = new Hashtable <> ( ) ; properties . put ( Context . INITIAL_CONTEXT_FACTORY , getInitialContextFactory ( ) ) ; properties . put ( Context . PROVIDER_URL , getProviderURL ( ) ) ; if ( getJndiSettings ( ) != null ) { getJndiSettings ( ) . entrySet ( ) . forEach ( entry -> properties . put ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } return properties ; }'", "label": "'Used to construct properties for JMS JNDI context . Populates with <p > properties . put ( Context . INITIAL_CONTEXT_FACTORY getInitialContextFactory () ) ; properties . put ( Context . PROVIDER_URL getProviderURL () ) ; Then adds all of the setting in jndi settings .'"}
{"text": "'public JmsService build ( ) { return new JmsService ( getConnectionSupplier ( ) , getDestinationSupplier ( ) , isTransacted ( ) , getAcknowledgeMode ( ) , isStartConnection ( ) , getDefaultDestination ( ) , getDefaultTimeout ( ) ) ; }'", "label": "'Build JMS Service'"}
{"text": "'private static FastRandomTree buildRandomTree ( FastRandomForest motherForest , TreeModel treeModel ) { return buildRandomTreeNode ( motherForest , treeModel . getNode ( ) ) ; }'", "label": "'Builds a new { @link weka . classifiers . trees . RandomTree Weka RandomTree } from the given { @link org . dmg . pmml . TreeModel PMML TreeModel } .'"}
{"text": "'public Type getType ( SimpleType jacksonType ) { try { String signature = JacksonSignature . createSignature ( jacksonType ) ; CustomType type = new CustomType ( jacksonType . getRawClass ( ) . getName ( ) , signature , jacksonType . getRawClass ( ) ) ; if ( cache . containsKey ( signature ) ) { return cache . get ( signature ) ; } cache . put ( signature , type ) ; ObjectWriter objectWriter = objectMapper . writerFor ( jacksonType ) ; Field prefetchField = objectWriter . getClass ( ) . getDeclaredField ( \"_prefetch\" ) ; prefetchField . setAccessible ( true ) ; ObjectWriter . Prefetch prefetch = ( ObjectWriter . Prefetch ) prefetchField . get ( objectWriter ) ; doIntrospection ( prefetch . valueSerializer , type ) ; return type ; } catch ( NoSuchFieldException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } return null ; }'", "label": "'From Jackson type creates a JRAPIDoc type type is stored in cache'"}
{"text": "'public Type getType ( CollectionLikeType jacksonType ) { // try { String signature = JacksonSignature . createSignature ( jacksonType ) ; JavaType contentType = jacksonType . getContentType ( ) ; String contentSignature = JacksonSignature . createSignature ( contentType ) ; Class < ? > containerClass = jacksonType . getRawClass ( ) ; CollectionTypeJrapidoc type = new CollectionTypeJrapidoc ( containerClass . getName ( ) , signature , contentType . getRawClass ( ) . getName ( ) , contentSignature ) ; if ( cache . containsKey ( signature ) ) { return cache . get ( signature ) ; } cache . put ( signature , type ) ; getType ( jacksonType . getContentType ( ) ) ; return type ; }'", "label": "'Same as { @link #getType ( com . fasterxml . jackson . databind . type . SimpleType ) }'"}
{"text": "'public Type getType ( MapLikeType jacksonType ) { String signature = JacksonSignature . createSignature ( jacksonType ) ; JavaType keyType = jacksonType . getKeyType ( ) ; JavaType valueType = jacksonType . getContentType ( ) ; Class < ? > containerClass = jacksonType . getRawClass ( ) ; String keySignature = JacksonSignature . createSignature ( keyType ) ; String valSignature = JacksonSignature . createSignature ( valueType ) ; MapTypeJrapidoc type = new MapTypeJrapidoc ( containerClass . getName ( ) , signature , keyType . getRawClass ( ) . getName ( ) , keySignature , valueType . getRawClass ( ) . getName ( ) , valSignature ) ; if ( cache . containsKey ( signature ) ) { return cache . get ( signature ) ; } cache . put ( signature , type ) ; getType ( keyType ) ; getType ( valueType ) ; return type ; }'", "label": "'Same as { @link #getType ( com . fasterxml . jackson . databind . type . SimpleType ) }'"}
{"text": "'public Type getType ( JavaType type ) { if ( type instanceof SimpleType ) { return getType ( ( SimpleType ) type ) ; } else if ( type instanceof CollectionType ) { return getType ( ( CollectionLikeType ) type ) ; } else if ( type instanceof ArrayType ) { return getType ( ( ArrayType ) type ) ; } else if ( type instanceof MapLikeType ) { return getType ( ( MapLikeType ) type ) ; } throw new RuntimeException ( \"Unimplemented Jackson type: \" + type ) ; }'", "label": "'Do redirection from general Jackson type to the concrete one'"}
{"text": "'private void doIntrospection ( JsonSerializer serializer , Type type ) { if ( serializer == null ) { return ; } if ( EnumSerializer . class . isAssignableFrom ( serializer . getClass ( ) ) ) { introspectSerializer ( ( EnumSerializer ) serializer , ( CustomType ) type ) ; } else if ( BeanSerializerBase . class . isAssignableFrom ( serializer . getClass ( ) ) ) { introspectSerializer ( ( BeanSerializerBase ) serializer , ( CustomType ) type ) ; } else if ( StdScalarSerializer . class . isAssignableFrom ( serializer . getClass ( ) ) ) { introspectSerializer ( ( StdScalarSerializer ) serializer , ( CustomType ) type ) ; } else if ( AsArraySerializerBase . class . isAssignableFrom ( serializer . getClass ( ) ) ) { introspectSerializer ( ( AsArraySerializerBase ) serializer , ( CollectionTypeJrapidoc ) type ) ; } else if ( MapSerializer . class . isAssignableFrom ( serializer . getClass ( ) ) ) { introspectSerializer ( ( MapSerializer ) serializer , ( MapTypeJrapidoc ) type ) ; } }'", "label": "'Do redirection from general Jackson serializer to the concrete one'"}
{"text": "'private void introspectSerializer ( BeanSerializerBase beanSerializer , CustomType type ) { try { Field propsField = beanSerializer . getClass ( ) . getSuperclass ( ) . getDeclaredField ( \"_props\" ) ; propsField . setAccessible ( true ) ; BeanPropertyWriter [ ] props = ( BeanPropertyWriter [ ] ) propsField . get ( beanSerializer ) ; for ( BeanPropertyWriter prop : props ) { JavaType propType = prop . getType ( ) ; getType ( propType ) ; String signature = JacksonSignature . createSignature ( propType ) ; type . addBeanProperty ( new BeanProperty ( prop . getName ( ) , signature , prop . getPropertyType ( ) , prop . getMetadata ( ) . getDescription ( ) , prop . getMetadata ( ) . isRequired ( ) ) ) ; } } catch ( NoSuchFieldException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } }'", "label": "'Introspect serializer for java beans'"}
{"text": "'private void introspectSerializer ( EnumSerializer enumSerializer , CustomType type ) { for ( SerializableString value : enumSerializer . getEnumValues ( ) . values ( ) ) { type . addEnumeration ( value . getValue ( ) ) ; } }'", "label": "'Introspect serializer for enumerations'"}
{"text": "'private void introspectSerializer ( MapSerializer mapSerializer , MapTypeJrapidoc type ) { try { Field keyTypeField = mapSerializer . getClass ( ) . getDeclaredField ( \"_keyType\" ) ; keyTypeField . setAccessible ( true ) ; JavaType keyType = ( JavaType ) keyTypeField . get ( mapSerializer ) ; JavaType valueType = mapSerializer . getContentType ( ) ; getType ( keyType ) ; getType ( valueType ) ; } catch ( NoSuchFieldException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } }'", "label": "'Introspect serializer for map'"}
{"text": "'protected void startNewSmppServerTransactionActivity ( SmppTransactionImpl txImpl ) throws ActivityAlreadyExistsException , NullPointerException , IllegalStateException , SLEEException , StartActivityException { sleeEndpoint . startActivity ( txImpl . getActivityHandle ( ) , txImpl , ActivityFlags . REQUEST_ENDED_CALLBACK ) ; DelayedActivityEndTask activityEndTask = new DelayedActivityEndTask ( tracer , this , txImpl , raContext . getTimer ( ) ) ; activityEndTasks . put ( txImpl , activityEndTask ) ; SmppManagement smppManagemet = SmppManagement . getInstance ( ) ; int delay = smppManagemet . getSmppServerManagement ( ) . getSmppActivityTimeout ( ) ; activityEndTask . schedule ( delay , TimeUnit . SECONDS ) ; }'", "label": "'Protected'"}
{"text": "'protected void fireEvent ( String eventName , ActivityHandle handle , Object event ) { FireableEventType eventID = eventIdCache . getEventId ( this . eventLookup , eventName ) ; if ( eventID == null ) { tracer . severe ( \"Event id for \" + eventID + \" is unknown, cant fire!!!\" ) ; } else { try { sleeEndpoint . fireEvent ( handle , eventID , event , address , null ) ; } catch ( UnrecognizedActivityHandleException e ) { this . tracer . severe ( \"Error while firing event\" , e ) ; } catch ( IllegalEventException e ) { this . tracer . severe ( \"Error while firing event\" , e ) ; } catch ( ActivityIsEndingException e ) { this . tracer . severe ( \"Error while firing event\" , e ) ; } catch ( NullPointerException e ) { this . tracer . severe ( \"Error while firing event\" , e ) ; } catch ( SLEEException e ) { this . tracer . severe ( \"Error while firing event\" , e ) ; } catch ( FireEventException e ) { this . tracer . severe ( \"Error while firing event\" , e ) ; } } }'", "label": "'Private methods'"}
{"text": "'private void frame1 ( ) { // SELECT acct_name = ca_name, broker_id = ca_b_id, \\r // cust_id = ca_c_id, tax_status = ca_tax_st FROM\\r // customer_account WHERE ca_id = acct_id\\r String sql = \"SELECT ca_name, ca_b_id, ca_c_id, ca_tax_st FROM customer_account\" + \" WHERE ca_id = \" + paramHelper . getAcctId ( ) ; Scan s = executeQuery ( sql ) ; acctName = ( String ) s . getVal ( \"ca_name\" ) . asJavaVal ( ) ; brokerId = ( Long ) s . getVal ( \"ca_b_id\" ) . asJavaVal ( ) ; custId = ( Long ) s . getVal ( \"ca_c_id\" ) . asJavaVal ( ) ; taxStatus = ( Integer ) s . getVal ( \"ca_tax_st\" ) . asJavaVal ( ) ; // TODO: Add this\\r // num_found = row_count\\r // SELECT cust_f_name = c_f_name, cust_l_name = c_l_name, \\r // cust_tier = c_tier, tax_id = c_tax_id FROM\\r // customer WHERE c_id = cust_id\\r sql = \"SELECT c_f_name, c_l_name, c_tier, c_tax_id FROM customer\" + \" WHERE c_id = \" + custId ; s = executeQuery ( sql ) ; custFName = ( String ) s . getVal ( \"c_f_name\" ) . asJavaVal ( ) ; custLName = ( String ) s . getVal ( \"c_l_name\" ) . asJavaVal ( ) ; custTier = ( Integer ) s . getVal ( \"c_tier\" ) . asJavaVal ( ) ; taxId = ( String ) s . getVal ( \"c_tax_id\" ) . asJavaVal ( ) ; // SELECT broker_name = b_name FROM broker WHERE b_id = broker_id\\r sql = \"SELECT b_name FROM broker WHERE b_id = \" + brokerId ; s = executeQuery ( sql ) ; brokerName = ( String ) s . getVal ( \"b_name\" ) . asJavaVal ( ) ; }'", "label": "'Get customer customer account and broker information'"}
{"text": "'private void frame3 ( ) { // ===== Simplified Version =====\\r // SELECT co_id = s_co_id, exch_id = s_ex_id, s_name = s_name\\r // FROM security WHERE s_symb = symbol\\r String sql = \"SELECT s_co_id, s_ex_id, s_name FROM security WHERE \" + \"s_symb = \" + paramHelper . getSymbol ( ) ; Scan s = executeQuery ( sql ) ; coId = ( Long ) s . getVal ( \"s_co_id\" ) . asJavaVal ( ) ; exchId = ( String ) s . getVal ( \"s_ex_id\" ) . asJavaVal ( ) ; sName = ( String ) s . getVal ( \"s_name\" ) . asJavaVal ( ) ; // SELECT market_price = lt_price FROM last_trade\\r // WHERE lt_s_symb = symbol\\r sql = \"SELECT lt_price FROM last_trade WHERE \" + \"lt_s_symb = \" + paramHelper . getSymbol ( ) ; s = executeQuery ( sql ) ; marketPrice = ( Double ) s . getVal ( \"lt_price\" ) . asJavaVal ( ) ; // SELECT type_is_market = tt_is_mrkt, type_is_sell = tt_is_sell\\r // FROM trade_type WHERE tt_id = trade_type_id\\r sql = \"SELECT tt_is_mrkt, tt_is_sell FROM trade_type WHERE \" + \"tt_id = \" + paramHelper . getTradeTypeId ( ) ; s = executeQuery ( sql ) ; typeIsMarket = ( Integer ) s . getVal ( \"tt_is_mrkt\" ) . asJavaVal ( ) ; typeIsSell = ( Integer ) s . getVal ( \"tt_is_sell\" ) . asJavaVal ( ) ; if ( typeIsMarket == 1 ) { statusId = \"A\" ; } else { statusId = \"B\" ; } // TODO: Implement this version\\r // ===== Full Version =====\\r // Get information on the security\\r if ( true ) { // SELECT co_id = co_id FROM company WHERE co_name = co_name\\r // SELECT exch_id = s_ex_id, s_name = s_name, symbol = s_symb\\r // FROM security WHERE s_co_id = co_id AND s_issue = issue\\r } else { // SELECT co_id = s_co_id, exch_id = s_ex_id, s_name = s_name\\r // FROM security WHERE s_symb = symbol\\r // SELECT co_name = co_name FROM company WHERE co_id = co_id\\r } // Get current pricing information for the security\\r // SELECT market_price = lt_price FROM last_trade\\r // WHERE lt_s_symb = symbol\\r // Set trade characteristics based on the type of trade\\r // SELECT type_is_market = tt_is_mrkt, type_is_sell = tt_is_sell\\r // FROM trade_type WHERE tt_id = trade_type_id\\r // If this is a limit-order, then the requested_price was passed in to the frame,\\r // but if this a market-order, then the requested_price needs to be set to the\\r // current market price.\\r //\\t\\tif( type_is_market ) then {\\r //\\t\\t\\trequested_price = market_price\\r //\\t\\t}\\r // TODO: Estimation\\r }'", "label": "'Estimate overall effects of the trade'"}
{"text": "'private void frame4 ( ) { long currentTime = System . currentTimeMillis ( ) ; // XXX: Lots of dummy value\\r // Record trade information in TRADE table.\\r // INSERT INTO trade (t_id, t_dts, t_st_id, t_tt_id, t_is_cash,\\r // t_s_symb, t_qty, t_bid_price, t_ca_id, t_exec_name, t_trade_price,\\r // t_chrg, t_comm, t_tax, t_lifo) VALUES (...)\\r String sql = String . format ( \"INSERT INTO trade (t_id, t_dts, t_st_id, t_tt_id, \" + \"t_is_cash, t_s_symb, t_qty, t_bid_price, t_ca_id, t_exec_name, \" + \"t_trade_price, t_chrg, t_comm, t_tax, t_lifo) VALUES (%d, %d, \\'%s\\', \" + \"\\'%s\\', %d, \\'%s\\', %d, %f, %d, \\'%s\\', %f, %f, %f, %f, %d)\" , paramHelper . getTradeId ( ) , currentTime , statusId , paramHelper . getTradeTypeId ( ) , 1 , paramHelper . getSymbol ( ) , paramHelper . getTradeQty ( ) , marketPrice , paramHelper . getAcctId ( ) , \"exec_name\" , paramHelper . getTradePrice ( ) , 0.0 , 0.0 , 0.0 , 1 ) ; executeUpdate ( sql ) ; // TODO: Implement this (not in the simplified version)\\r // Record pending trade information in TRADE_REQUEST table \\r // if this trade is a limit trade\\r // INSERT INTO trade_request (tr_t_id, tr_tt_id, tr_s_symb, tr_qty,\\r // tr_bid_price, tr_b_id) VALUES (...)\\r // Record trade information in TRADE_HISTORY table\\r // INSERT INTO trade_history (th_t_id, th_dts, th_st_id) VALUES (...)\\r sql = String . format ( \"INSERT INTO trade_history (th_t_id, th_dts, th_st_id) VALUES \" + \"(%d, %d, \\'%s\\')\" , paramHelper . getTradeId ( ) , currentTime , statusId ) ; executeUpdate ( sql ) ; }'", "label": "'Record the trade request by making all related updates'"}
{"text": "'public void next ( ) { for ( int k = a . length - 1 ; k > 0 ; k -- ) { int w = ( int ) Math . floor ( Math . random ( ) * ( k + 1 ) ) ; int temp = a [ w ] ; a [ w ] = a [ k ] ; a [ k ] = temp ; } }'", "label": "'It produces the next random permutation'"}
{"text": "'public int next ( ) { //\\t\\tint rndIndex = (int) ((array.length - 1 - curIndex) * rg.nextDouble()) //\\t\\t\\t\\t+ curIndex; //\\t\\tint tmp = array[rndIndex]; //\\t\\tarray[rndIndex] = array[curIndex]; //\\t\\tarray[curIndex] = tmp; //\\t\\tcurIndex++; // //\\t\\treturn tmp; int number ; do { number = rg . nextInt ( size ) + 1 ; } while ( ! numberSet . add ( number ) ) ; return number ; }'", "label": "'Not repeat randomly choose a number from 1 to the initinalized size'"}
{"text": "'public static void main ( String [ ] args ) { MicrobenchmarkParamGen executor = new MicrobenchmarkParamGen ( ) ; System . out . println ( \"Parameters:\" ) ; System . out . println ( \"Read Write Tx Rate: \" + RW_TX_RATE ) ; System . out . println ( \"Long Read Tx Rate: \" + LONG_READ_TX_RATE ) ; System . out . println ( \"Total Read Count: \" + TOTAL_READ_COUNT ) ; System . out . println ( \"Local Hot Count: \" + LOCAL_HOT_COUNT ) ; System . out . println ( \"Write Ratio in RW Tx: \" + WRITE_RATIO_IN_RW_TX ) ; System . out . println ( \"Hot Conflict Rate: \" + HOT_CONFLICT_RATE ) ; System . out . println ( \"# of items: \" + DATA_SIZE ) ; System . out . println ( \"# of hot items: \" + HOT_DATA_SIZE ) ; System . out . println ( \"# of cold items: \" + COLD_DATA_SIZE ) ; System . out . println ( ) ; for ( int i = 0 ; i < 1000 ; i ++ ) { Object [ ] params = executor . generateParameter ( ) ; System . out . println ( Arrays . toString ( params ) ) ; } }'", "label": "'a main application for debugging'"}
{"text": "'public int number ( int min , int max ) { if ( min > max ) throw new IllegalArgumentException ( ) ; int value = rng . nextInt ( max - min + 1 ) ; value += min ; return value ; }'", "label": "'Return an integer in the ( inclusive ) range [ min max ] .'"}
{"text": "'public int numberExcluding ( int min , int max , int exclusivedVal ) { if ( min > max ) throw new IllegalArgumentException ( ) ; if ( min > exclusivedVal || exclusivedVal > max ) throw new IllegalArgumentException ( ) ; int value = number ( min , max - 1 ) ; if ( value >= exclusivedVal ) value ++ ; return value ; }'", "label": "'Return an integer in the ( inclusive ) range [ minimum maximum ] excluding exclusivedVal .'"}
{"text": "'public double fixedDecimalNumber ( int decimal , double min , double max ) { if ( min > max ) throw new IllegalArgumentException ( ) ; if ( decimal < 0 ) throw new IllegalArgumentException ( ) ; int multiplier = 1 ; for ( int i = 0 ; i < decimal ; ++ i ) { multiplier *= 10 ; } int top = ( int ) ( min * multiplier ) ; int bottom = ( int ) ( max * multiplier ) ; return ( double ) number ( top , bottom ) / ( double ) multiplier ; }'", "label": "'Return an fixed decimal double value in the ( inclusive ) range [ minimum maximum ] . For example [ 0 . 01 .. 100 . 00 ] with decimal 2 has 10 000 unique values .'"}
{"text": "'public String makeLastName ( int number ) { if ( number < 0 && number > TpccConstants . NUM_DISTINCT_CLAST - 1 ) throw new IllegalArgumentException ( ) ; int indicies [ ] = { number / 100 , ( number / 10 ) % 10 , number % 10 } ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < indicies . length ; ++ i ) { sb . append ( TOKENS [ indicies [ i ] ] ) ; } return sb . toString ( ) ; }'", "label": "'Return a last name as defined by TPC - C 4 . 3 . 2 . 3 .'"}
{"text": "'public String randomAString ( int minLength , int maxLength ) { int length = number ( minLength , maxLength ) ; return randomAString ( length ) ; }'", "label": "'Return a string of random alphanumeric characters of a random length between [ minLength maxLength ] .'"}
{"text": "'public int randomChooseFromDistribution ( double ... probs ) { int result = - 1 ; int [ ] range = new int [ probs . length ] ; double accuracy = 1000 ; int total = 0 ; for ( int i = 0 ; i < probs . length ; i ++ ) { range [ i ] = ( int ) ( probs [ i ] * accuracy ) ; total += range [ i ] ; } int randNum = ( int ) ( rng . nextDouble ( ) * total ) ; for ( int i = 0 ; i < range . length ; i ++ ) { randNum -= range [ i ] ; if ( randNum <= 0 ) { result = i ; break ; } } return result ; }'", "label": "'Return the result of a random choose from a given distribution .'"}
{"text": "'public long randomLongRange ( long min , long max ) { if ( max <= min ) return min ; long width = max - min ; return ( long ) ( rng . nextDouble ( ) * width ) + min ; }'", "label": "'Return a long in the ( inclusive ) range [ min max ] .'"}
{"text": "'public double randomDoubleIncrRange ( double min , double max , double incr ) { long width = ( long ) ( ( max - min ) / incr ) ; return randomLongRange ( 0 , width ) * incr + min ; }'", "label": "'Return a double in the ( inclusive ) range [ min max ] with the increase precision .'"}
{"text": "'@ Override public void inject ( Class < ? > klass ) throws DataException { Method [ ] classMethods = klass . getMethods ( ) ; for ( Method method : classMethods ) { Filter annotation = ( Filter ) method . getAnnotation ( Filter . class ) ; if ( annotation != null ) { injectFilterMethod ( method , annotation ) ; } } }'", "label": "'{'"}
{"text": "'public static File getRelativePath ( File in , File repositoryPath ) throws JavaGitException { String path = in . getPath ( ) ; String absolutePath = in . getAbsolutePath ( ) ; //check if the path is relative or absolute if ( path . equals ( absolutePath ) ) { //if absolute, make sure it belongs to working tree String workingTreePath = repositoryPath . getAbsolutePath ( ) ; if ( ! path . startsWith ( workingTreePath ) ) { throw new JavaGitException ( 999 , \"Invalid path :\" + path + \". Does not belong to the git working tree/ repository: \" + workingTreePath ) ; } //make path relative if ( ! path . equals ( workingTreePath ) ) { path = path . substring ( workingTreePath . length ( ) + 1 ) ; } } return new File ( path ) ; }'", "label": "'Returns a file with path relative to git working tree'"}
{"text": "'public GitDirectory getParent ( ) { // NOTE: file.getParentFile() returns null if there is no parent. if ( file . getParentFile ( ) == null ) { return null ; } try { return new GitDirectory ( file . getParentFile ( ) , workingTree ) ; } catch ( JavaGitException e ) { //invalid git parent return null ; } }'", "label": "'Gets parent directory of this <code > GitFileSystemObject< / code > object'"}
{"text": "'public GitAddResponse add ( ) throws IOException , JavaGitException { GitAdd gitAdd = new GitAdd ( ) ; // create a list of filenames and add yourself to it List < File > list = new ArrayList < File > ( ) ; File relativeFilePath ; if ( relativePath . isDirectory ( ) ) { for ( File f : relativePath . listFiles ( ) ) { if ( ! f . isHidden ( ) && ! f . getName ( ) . startsWith ( \".\" ) ) { relativeFilePath = this . getRelativePath ( f , this . getWorkingTree ( ) . getPath ( ) ) ; list . add ( relativeFilePath ) ; } } } else { list . add ( relativePath ) ; } // run git-add command return gitAdd . add ( workingTree . getPath ( ) , null , list ) ; }'", "label": "'Adds the object to the git index'"}
{"text": "'public GitCommitResponse commit ( String comment ) throws IOException , JavaGitException { // first add the file add ( ) ; // create a list of filenames and add yourself to it List < File > list = new ArrayList < File > ( ) ; list . add ( relativePath ) ; GitCommit gitCommit = new GitCommit ( ) ; return gitCommit . commitOnly ( workingTree . getPath ( ) , comment , list ) ; }'", "label": "'Commits the file system object'"}
{"text": "'public GitMvResponse mv ( File dest ) throws IOException , JavaGitException { // source; current location (relative) File source = relativePath ; //get relative path for destination File relativeDest = getRelativePath ( dest , workingTree . getPath ( ) ) ; // perform git-mv GitMv gitMv = new GitMv ( ) ; GitMvResponse response = gitMv . mv ( workingTree . getPath ( ) , source , relativeDest ) ; // file has changed; update file = dest ; relativePath = relativeDest ; return response ; }'", "label": "'Moves or renames the object'"}
{"text": "'public GitRmResponse rm ( ) throws IOException , JavaGitException { GitRm gitRm = new GitRm ( ) ; // run git rm command return gitRm . rm ( workingTree . getPath ( ) , relativePath ) ; }'", "label": "'Removes the file system object from the working tree and the index'"}
{"text": "'public GitStatusResponse status ( File repositoryPath , GitStatusOptions options , List < File > paths ) throws JavaGitException , IOException { CheckUtilities . checkFileValidity ( repositoryPath ) ; IClient client = ClientManager . getInstance ( ) . getPreferredClient ( ) ; IGitStatus gitStatus = client . getGitStatusInstance ( ) ; return gitStatus . status ( repositoryPath , options , paths ) ; }'", "label": "'It returns a <code > GitStatusResponse< / code > object that contains all the details of the output of &lt ; git - status&gt ; command .'"}
{"text": "'public GitStatusResponse getSingleFileStatus ( File repositoryPath , File path ) throws JavaGitException , IOException { CheckUtilities . checkFileValidity ( repositoryPath ) ; IClient client = ClientManager . getInstance ( ) . getPreferredClient ( ) ; IGitStatus gitStatus = client . getGitStatusInstance ( ) ; return gitStatus . getSingleFileStatus ( repositoryPath , null , path ) ; }'", "label": "'It returns a <code > GitStatusResonse< / code > object that contains all the details of the output of &lt ; git - status&gt ; command but filters output for a single file'"}
{"text": "'public GitFileSystemObject . Status getFileStatus ( File repositoryPath , File path ) throws JavaGitException , IOException { //check validity of a repository path CheckUtilities . checkFileValidity ( repositoryPath ) ; //run git status IClient client = ClientManager . getInstance ( ) . getPreferredClient ( ) ; IGitStatus gitStatus = client . getGitStatusInstance ( ) ; GitStatusResponse response = gitStatus . status ( repositoryPath ) ; return response . getFileStatus ( path ) ; /*\\n     * TODO: quote from Michael Schidlowsky: \"this block of if statements is a little smelly... I\\'d\\n     * prefer to see something like return response.asStatus()...\\n     */ /*\\n    if (response.getUntrackedFilesSize() > 0) {\\n      return Status.UNTRACKED;\\n    }\\n\\n    if (response.getNewFilesToCommitSize() > 0) {\\n      return Status.NEW_TO_COMMIT;\\n    }\\n\\n    if (response.getDeletedFilesNotUpdatedSize() > 0) {\\n      return Status.DELETED;\\n    }\\n\\n    if (response.getDeletedFilesToCommitSize() > 0) {\\n      return Status.DELETED_TO_COMMIT;\\n    }\\n\\n    if (response.getModifiedFilesNotUpdatedSize() > 0) {\\n      return Status.MODIFIED;\\n    }\\n\\n    if (response.getModifiedFilesToCommitSize() > 0) {\\n      return Status.MODIFIED_TO_COMMIT;\\n    }\\n\\n    // default\\n    return Status.IN_REPOSITORY;\\n    */ }'", "label": "'It returns a <code > GitFileSystemObject . Status< / code > for a single file'"}
{"text": "'public void setOptAll ( boolean all ) { if ( all && ( optOnly || optInclude ) ) { throw new IllegalArgumentException ( ExceptionMessageMap . getMessage ( \"000100\" ) + \"  The \\\\\"all\\\\\" option can not be set when the \\\\\"only\\\\\" or \\\\\"include\\\\\" option is set.\" ) ; } this . optAll = all ; }'", "label": "'Sets the - a options to &lt ; git - status&gt ; command . If any one of the optOnly or OptInclude options are set then optAll should not be set . While setting optAll to true if optOnly or optInclude is set set then <code > IllegalArgumentException< / code > is thrown .'"}
{"text": "'public static void checkFileValidity ( String filename ) throws IOException { File file = new File ( filename ) ; if ( ! file . exists ( ) ) { throw new IOException ( ExceptionMessageMap . getMessage ( \"020001\" ) + \"  { filename=[\" + filename + \"] }\" ) ; } }'", "label": "'Checks that the specified filename exists . This assumes that the above check for string validity has already been run and the path / filename is neither null or of size 0 .'"}
{"text": "'public static void checkFileValidity ( File file ) throws IOException { if ( ! file . exists ( ) ) { throw new IOException ( ExceptionMessageMap . getMessage ( \"020001\" ) + \"  { filename=[\" + file . getName ( ) + \"] }\" ) ; } }'", "label": "'Checks that the specified file exists .'"}
{"text": "'public static void checkIntArgumentGreaterThan ( int toCheck , int lowerBound , String variableName ) { if ( lowerBound >= toCheck ) { throw new IllegalArgumentException ( ExceptionMessageMap . getMessage ( \"000004\" ) + \"  { toCheck=[\" + toCheck + \"], lowerBound=[\" + lowerBound + \"], variableName=[\" + variableName + \"] }\" ) ; } }'", "label": "'Checks that the int to check is greater than <code > lowerBound< / code > . If the int to check is not greater than <code > lowerBound< / code > an <code > IllegalArgumentException< / code > is thrown .'"}
{"text": "'public static void checkNullArgument ( Object obj , String variableName ) { if ( null == obj ) { throw new NullPointerException ( ExceptionMessageMap . getMessage ( \"000003\" ) + \"  { variableName=[\" + variableName + \"] }\" ) ; } }'", "label": "'Performs a null check on the specified object . If the object is null a <code > NullPointerException< / code > is thrown .'"}
{"text": "'public static void checkNullListArgument ( List < ? > list , String variableName ) { // TODO (jhl388): Write a unit test for this method. if ( null == list ) { throw new NullPointerException ( ExceptionMessageMap . getMessage ( \"000005\" ) + \"  { variableName=[\" + variableName + \"] }\" ) ; } if ( list . size ( ) == 0 ) { throw new IllegalArgumentException ( ExceptionMessageMap . getMessage ( \"000005\" ) + \"  { variableName=[\" + variableName + \"] }\" ) ; } for ( int i = 0 ; i < list . size ( ) ; i ++ ) { checkNullArgument ( list . get ( i ) , variableName ) ; } }'", "label": "'Checks a <code > List&lt ; ?&gt ; < / code > argument to make sure it is not null has length > 0 and none of its elements are null . If the <code > List&lt ; ?&gt ; < / code > or any contained instance is null a <code > NullPointerException< / code > is thrown . If the <code > List&lt ; ?&gt ; < / code > or any contained instance has length zero an <code > IllegalArgumentException< / code > is thrown .'"}
{"text": "'public static boolean checkListsEqual ( List < ? > l1 , List < ? > l2 ) { // TODO (jhl388): write a test case for this method. if ( null != l1 && null == l2 ) { return false ; } if ( null == l1 && null != l2 ) { return false ; } if ( null != l1 ) { for ( Object e : l1 ) { if ( ! l2 . contains ( e ) ) { return false ; } } for ( Object e : l2 ) { if ( ! l1 . contains ( e ) ) { return false ; } } } return true ; }'", "label": "'Checks that two lists are equal specifically : they are both null or the both contain the same elements .'"}
{"text": "'public static boolean checkObjectsEqual ( Object o1 , Object o2 ) { if ( null != o1 && ! o1 . equals ( o2 ) ) { return false ; } if ( null == o1 && null != o2 ) { return false ; } return true ; }'", "label": "'Checks to see if two objects are equal . The Object . equal () method is used to check for equality .'"}
{"text": "'public static void checkStringArgument ( String str , String variableName ) { if ( null == str ) { throw new NullPointerException ( ExceptionMessageMap . getMessage ( \"000001\" ) + \"  { variableName=[\" + variableName + \"] }\" ) ; } if ( str . length ( ) == 0 ) { throw new IllegalArgumentException ( ExceptionMessageMap . getMessage ( \"000001\" ) + \"  { variableName=[\" + variableName + \"] }\" ) ; } }'", "label": "'Checks a <code > String< / code > argument to make sure it is not null and contains one or more characters . If the <code > String< / code > is null a <code > NullPointerException< / code > is thrown . If the <code > String< / code > has length zero an <code > IllegalArgumentException< / code > is thrown .'"}
{"text": "'public static void checkStringListArgument ( List < String > str , String variableName ) { if ( null == str ) { throw new NullPointerException ( ExceptionMessageMap . getMessage ( \"000002\" ) + \"  { variableName=[\" + variableName + \"] }\" ) ; } if ( str . size ( ) == 0 ) { throw new IllegalArgumentException ( ExceptionMessageMap . getMessage ( \"000002\" ) + \"  { variableName=[\" + variableName + \"] }\" ) ; } for ( int i = 0 ; i < str . size ( ) ; i ++ ) { checkStringArgument ( str . get ( i ) , variableName ) ; } }'", "label": "'Checks a <code > List&lt ; String&gt ; < / code > argument to make sure it is not null none of its elements are null and all its elements contain one or more characters . If the <code > List&lt ; String&gt ; < / code > or a contained <code > String< / code > is null a <code > NullPointerException< / code > is thrown . If the <code > List&lt ; String&gt ; < / code > or a contained <code > String< / code > has length zero an <code > IllegalArgumentException< / code > is thrown .'"}
{"text": "'public static boolean checkUnorderedListsEqual ( List < ? > l1 , List < ? > l2 ) { if ( null == l1 && null != l2 ) { return false ; } if ( null != l1 && null == l2 ) { return false ; } if ( l1 . size ( ) != l2 . size ( ) ) { return false ; } for ( Object o : l1 ) { if ( ! l2 . contains ( o ) ) { return false ; } } for ( Object o : l2 ) { if ( ! l1 . contains ( o ) ) { return false ; } } return true ; }'", "label": "'Checks if two unordered lists are equal .'"}
{"text": "'public static void checkIntInRange ( int index , int start , int end ) { if ( index < start ) { throw new IndexOutOfBoundsException ( ExceptionMessageMap . getMessage ( \"000006\" ) + \"  { index=[\" + index + \"], start=[\" + start + \"], end=[\" + end + \"] }\" ) ; } if ( index >= end ) { throw new IndexOutOfBoundsException ( ExceptionMessageMap . getMessage ( \"000006\" ) + \"  { index=[\" + index + \"], start=[\" + start + \"], end=[\" + end + \"] }\" ) ; } }'", "label": "'A general range check utility for checking whether a given &lt ; integer&gt ; value is between a given start and end indexes . This is a helper method for other methods such as checkIntIndexInListRange or can also be used independently by external objects .'"}
{"text": "'public static void validateListRefType ( List < Ref > list , Ref . RefType type , String variableName ) { // TODO (ns1344): Write a unit test for this method. checkNullListArgument ( list , variableName ) ; for ( Ref ref : list ) { validateArgumentRefType ( ref , type , variableName ) ; } }'", "label": "'Checks a <code > List< / code > argument to make sure that all the <code > Ref< / code > in the list are of same <code > refType< / code > type . If there is a mismatch <code > IllegalArgumentException< / code > is thrown .'"}
{"text": "'public static void validateArgumentRefType ( Ref name , Ref . RefType type , String variableName ) { checkNullArgument ( name , variableName ) ; if ( name . getRefType ( ) != type ) { throw new IllegalArgumentException ( ExceptionMessageMap . getMessage ( \"100000\" ) + \"  { variableName=[\" + variableName + \"] }\" ) ; } }'", "label": "'Checks a <code > Ref< / code > argument to make sure that it is of given <code > refType< / code > type . If not <code > IllegalArgumentException< / code > is thrown .'"}
{"text": "'public static void checkDirectoryArgument ( File fileName , String variableName ) { checkNullArgument ( fileName , variableName ) ; if ( ! fileName . isDirectory ( ) ) { throw new IllegalArgumentException ( ExceptionMessageMap . getMessage ( \"000007\" ) + \"  { variableName=[\" + variableName + \"] }\" ) ; } }'", "label": "'Checks a <code > File< / code > argument to make sure that it is a directory . If not <code > IllegalArgumentException< / code > is thrown .'"}
{"text": "'public IClient getClientInstance ( ClientType clientType ) { IClient clientInstance = clientImpls . get ( clientType ) ; if ( null == clientInstance ) { if ( ClientType . CLI == clientType ) { clientInstance = new CliClient ( ) ; } if ( null != clientInstance ) { clientImpls . put ( clientType , clientInstance ) ; } } return clientInstance ; }'", "label": "'Gets an instance of the specified client type .'"}
{"text": "'public void setPreferredClientType ( ClientType preferredClientType ) { if ( null == preferredClientType ) { this . preferredClientType = ClientType . CLI ; } else { this . preferredClientType = preferredClientType ; } }'", "label": "'Sets the preferred client type .'"}
{"text": "'public GitAddResponse add ( File repositoryPath , GitAddOptions options , List < File > paths ) throws JavaGitException , IOException { CheckUtilities . checkFileValidity ( repositoryPath ) ; GitAddParser parser = new GitAddParser ( ) ; List < String > command = buildCommand ( repositoryPath , options , paths ) ; GitAddResponseImpl response = ( GitAddResponseImpl ) ProcessUtilities . runCommand ( repositoryPath , command , parser ) ; if ( options != null ) { addDryRun ( options , response ) ; } return ( GitAddResponse ) response ; }'", "label": "'Implementations of &lt ; git - add&gt ; with options and list of files provided .'"}
{"text": "'public GitAddResponse add ( File repositoryPath , List < File > files ) throws JavaGitException , IOException { GitAddOptions options = null ; return add ( repositoryPath , options , files ) ; }'", "label": "'Adds a list of files with no GitAddOptions .'"}
{"text": "'public GitAddResponse add ( File repositoryPath , File file ) throws JavaGitException , IOException { List < File > filePaths = new ArrayList < File > ( ) ; filePaths . add ( file ) ; GitAddOptions options = null ; return add ( repositoryPath , options , filePaths ) ; }'", "label": "'Adds one file to the index with no GitAddOptions .'"}
{"text": "'public GitAddResponse add ( File repositoryPath , GitAddOptions options , File file ) throws JavaGitException , IOException { List < File > paths = new ArrayList < File > ( ) ; paths . add ( file ) ; return add ( repositoryPath , options , paths ) ; }'", "label": "'Implementations of &lt ; git - add&gt ; with options and one file to be added to index .'"}
{"text": "'public GitAddResponse addDryRun ( File repositoryPath , List < File > paths ) throws JavaGitException , IOException { GitAddOptions options = new GitAddOptions ( ) ; options . setDryRun ( true ) ; return add ( repositoryPath , options , paths ) ; }'", "label": "'Implementation of &lt ; git - add&gt ; dry run .'"}
{"text": "'public GitAddResponse addVerbose ( File repositoryPath , List < File > paths ) throws JavaGitException , IOException { GitAddOptions options = new GitAddOptions ( ) ; options . setVerbose ( true ) ; return add ( repositoryPath , options , paths ) ; }'", "label": "'Implementations of &lt ; git - add&gt ; in verbose mode .'"}
{"text": "'public GitAddResponse addWithForce ( File repositoryPath , List < File > paths ) throws JavaGitException , IOException { GitAddOptions options = new GitAddOptions ( ) ; options . setForce ( true ) ; return add ( repositoryPath , options , paths ) ; }'", "label": "'Implementations of &lt ; git - add&gt ; with force option set .'"}
{"text": "'private void addDryRun ( GitAddOptions options , GitAddResponseImpl response ) { if ( options . dryRun ( ) ) { response . setDryRun ( true ) ; } }'", "label": "'if the dry run option was selected then set the flag in response .'"}
{"text": "'private int compareToReleaseMinor ( GitVersion that ) { if ( this . containsReleaseMinor ( ) && that . containsReleaseMinor ( ) ) return compareToInt ( this . getReleaseMinor ( ) , that . getReleaseMinor ( ) ) ; else if ( ! this . containsReleaseMinor ( ) && ! that . containsReleaseMinor ( ) ) return SAME ; else if ( this . containsReleaseMinor ( ) && ! that . containsReleaseMinor ( ) ) return LATER ; else return PREVIOUS ; }'", "label": "'Compares minor releases values given that git version contains no tag for none of GitVersion objects'"}
{"text": "'private int compareToTag ( GitVersion that ) { if ( this . containsTag ( ) && that . containsTag ( ) ) return this . getTag ( ) . compareTo ( that . getTag ( ) ) ; else if ( ! this . containsTag ( ) && ! that . containsTag ( ) ) return SAME ; else if ( this . containsTag ( ) && ! that . containsTag ( ) ) return PREVIOUS ; else return LATER ; }'", "label": "'Compares tag values given that git version contains no minor release for none of GitVersion objects <p / > When both contain a tag or not contain it the comparison is easy but if only one of them contains it the release that doesn t contains it is the one released earlier <p / > e . g . v1 . 8 . 0 - rc0 is previous to v1 . 8 . 0'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public static < T > ObjectCursor < T > getObjectCursor ( final Cursor cursor ) { if ( cursor == null ) { throw new NullPointerException ( \"The given cursor is null\" ) ; } if ( ! ( cursor instanceof CursorWrapper ) ) { throw new IllegalArgumentException ( \"The given cursor is not of type \" + CursorWrapper . class . getCanonicalName ( ) + \". It has type \" + cursor . getClass ( ) . getCanonicalName ( ) + \". Was it queried with a ContentResolver?\" ) ; } CursorWrapper wrapper = ( CursorWrapper ) cursor ; Cursor wrappedCursor = wrapper . getWrappedCursor ( ) ; if ( ! ( wrappedCursor instanceof ObjectCursor ) ) { throw new IllegalStateException ( \"The wrapped cursor of the given CursorWrapper is not of type \" + ObjectCursor . class . getCanonicalName ( ) + \". It has type \" + wrappedCursor . getClass ( ) . getCanonicalName ( ) + \". Was it queried over a ContentResolver from BaseContentProvider derived ContentProvider?\" ) ; } return ( ObjectCursor < T > ) wrappedCursor ; }'", "label": "'Convert a standard Android { @link Cursor } into a { @link org . droitateddb . cursor . ObjectCursor } . <br > This is only possible for { @link Cursor } s that where queried over a { @link ContentResolver } from a { @link ContentProvider } derived by { @link BaseContentProvider } .'"}
{"text": "'public GitAddResponse add ( File repositoryPath , GitAddOptions options , List < File > paths ) throws IOException , JavaGitException { CheckUtilities . checkFileValidity ( repositoryPath . getAbsoluteFile ( ) ) ; IClient client = ClientManager . getInstance ( ) . getPreferredClient ( ) ; IGitAdd gitAdd = client . getGitAddInstance ( ) ; return gitAdd . add ( repositoryPath , options , paths ) ; }'", "label": "'This command adds the current content of new or modified files to the index thus staging that content for inclusion in the next commit .'"}
{"text": "'public GitAddResponse addVerbose ( File repositoryPath , List < File > paths ) throws IOException , JavaGitException { IClient client = ClientManager . getInstance ( ) . getPreferredClient ( ) ; IGitAdd gitAdd = client . getGitAddInstance ( ) ; return gitAdd . addVerbose ( repositoryPath , paths ) ; }'", "label": "'This command adds the current content of new or modified files to the index with verbose option set .'"}
{"text": "'protected GitCommitResponseImpl commitProcessor ( File repository , GitCommitOptions options , String message , List < File > paths ) throws IOException , JavaGitException { CheckUtilities . checkNullArgument ( repository , \"repository\" ) ; CheckUtilities . checkStringArgument ( message , \"message\" ) ; List < String > commandLine = buildCommand ( options , message , paths ) ; GitCommitParser parser = new GitCommitParser ( repository . getAbsolutePath ( ) ) ; return ( GitCommitResponseImpl ) ProcessUtilities . runCommand ( repository , commandLine , parser ) ; }'", "label": "'Processes the commit .'"}
{"text": "'protected List < String > buildCommand ( GitCommitOptions options , String message , List < File > paths ) { // TODO (jhl388): Add a unit test for this method (CliGitCommit.buildCommand()). List < String > cmd = new ArrayList < String > ( ) ; cmd . add ( JavaGitConfiguration . getGitCommand ( ) ) ; cmd . add ( \"commit\" ) ; if ( null != options ) { if ( options . isOptAll ( ) ) { cmd . add ( \"-a\" ) ; } if ( options . isOptInclude ( ) ) { cmd . add ( \"-i\" ) ; } if ( options . isOptNoVerify ( ) ) { cmd . add ( \"--no-verify\" ) ; } if ( options . isOptOnly ( ) ) { cmd . add ( \"-o\" ) ; } if ( options . isOptSignoff ( ) ) { cmd . add ( \"-s\" ) ; } String author = options . getAuthor ( ) ; if ( null != author && author . length ( ) > 0 ) { cmd . add ( \"--author\" ) ; cmd . add ( options . getAuthor ( ) ) ; } } cmd . add ( \"-m\" ) ; cmd . add ( message ) ; if ( null != paths ) { cmd . add ( \"--\" ) ; for ( File f : paths ) { cmd . add ( f . getPath ( ) ) ; } } return cmd ; }'", "label": "'Builds a list of command arguments to pass to <code > ProcessBuilder< / code > .'"}
{"text": "'private static void determineGitVersion ( File path ) throws JavaGitException { /*\\n     * If they already set the path explicitly, or are in the process of doing so (via the path\\n     * argument), make sure to prefix the git call with it. If they didn\\'t, assume it\\'s blank.\\n     */ String gitPrefix = \"\" ; if ( path != null ) { // We got a path passed in as an argument. gitPrefix = path . getAbsolutePath ( ) + File . separator ; } else if ( gitPath != null ) { // They didn\\'t pass in a path, but previously set it explicitly via setGitPath. gitPrefix = getGitCommandPrefix ( ) ; } String gitCommand = gitPrefix + \"git\" ; if ( ! ( gitPrefix . equals ( \"\" ) ) ) { // If we\\'ve got a full path to the git binary here, ensure it actually exists. if ( ! ( new File ( gitCommand ) . exists ( ) ) ) { throw new JavaGitException ( 100002 , ExceptionMessageMap . getMessage ( \"100002\" ) ) ; } } List < String > commandLine = new ArrayList < String > ( ) ; commandLine . add ( gitCommand ) ; commandLine . add ( \"--version\" ) ; // Now run the actual git version command. try { // We\\'re passing in a working directory of null, which is \"don\\'t care\" to runCommand gitVersion = ( GitVersion ) ProcessUtilities . runCommand ( null , commandLine , new GitVersionParser ( ) ) ; } catch ( Exception e ) { throw new JavaGitException ( 100001 , ExceptionMessageMap . getMessage ( \"100001\" ) ) ; } String version = gitVersion . toString ( ) ; if ( ! ( isValidVersionString ( version ) ) ) { throw new JavaGitException ( 100001 , ExceptionMessageMap . getMessage ( \"100001\" ) ) ; } }'", "label": "'Sets the { @link #gitVersion } field . <br / > This function gets called in one of two ways : <br / > 1 ) When client code sets the path to the git binaries explicitly by calling { @link #setGitPath ( java . io . File ) } this function is used to determine if the path is usable or not . In this case the <code > File< / code > path argument will be the new path to the git binaries . <br / > 2 ) When client code calls { @link #getGitVersion () } and the path has not been set explicitly we call this function to figure out the version . In this case the <code > File< / code > path argument will be null .'"}
{"text": "'private static boolean isValidVersionString ( String version ) { /*\\n     * Git version strings can vary, so let\\'s do a minimal sanity check for two things: 1. The first\\n     * character in the version is a number. 2. There\\'s at least one period in the version string.\\n     * \\n     * TODO (rs2705): Make this more sophisticated by parsing out a major/minor version number, and\\n     * ensuring it\\'s >= some minimally-required version.\\n     */ try { Integer . parseInt ( version . substring ( 0 , 1 ) ) ; } catch ( NumberFormatException e ) { // First character in the version string was not a valid number! return false ; } if ( version . indexOf ( \".\" ) == - 1 ) { // The version string doesn\\'t contain a period! return false ; } return true ; }'", "label": "'Judge the validity of a given git version string . This can be difficult to do as there seems to be no deliberately - defined git version format . So here we do a minimal sanity check for two things : 1 . The first character in the version is a number . 2 . There s at least one period in the version string .'"}
{"text": "'public static void setGitPath ( File path ) throws IOException , JavaGitException { if ( path != null ) { CheckUtilities . checkFileValidity ( path ) ; if ( ! ( path . isDirectory ( ) ) ) { throw new JavaGitException ( 020002 , ExceptionMessageMap . getMessage ( \"020002\" ) + \" { path=[\" + path . getPath ( ) + \"] }\" ) ; } } try { determineGitVersion ( path ) ; } catch ( Exception e ) { // The path that was passed in doesn\\'t work. Catch any errors and throw this one instead. throw new JavaGitException ( 100002 , ExceptionMessageMap . getMessage ( \"100002\" ) + \" { path=[\" + path . getPath ( ) + \"] }\" , e ) ; } // Make sure we\\'re hanging onto an absolute path. gitPath = ( path != null ) ? path . getAbsoluteFile ( ) : null ; }'", "label": "'Called when client code wants to explicitly tell us where to find git on their filesystem . If never called we assume that git is in a directory in the PATH environment variable for this process . Passing null as the path argument will unset an explicitly - set path and revert to looking for git in the PATH .'"}
{"text": "'public static void setGitPath ( String path ) throws IOException , JavaGitException { CheckUtilities . checkStringArgument ( path , \"path\" ) ; setGitPath ( new File ( path ) ) ; }'", "label": "'Convenience method for setting the path with a <code > String< / code > instead of a <code > File< / code > .'"}
{"text": "'private static List < IParameter > createList ( Method method ) { List < IParameter > parameters = new ArrayList < IParameter > ( ) ; Class < ? > paramTypes [ ] = method . getParameterTypes ( ) ; Annotation [ ] [ ] methodAnnotations = method . getParameterAnnotations ( ) ; for ( int i = 0 ; i < methodAnnotations . length ; i ++ ) { // defaults boolean paramRequired = true ; String paramName = \"\" ; Class < ? > paramClass = paramTypes [ i ] ; for ( Annotation a : methodAnnotations [ i ] ) { if ( a instanceof Binder ) { paramName = ( ( Binder ) a ) . name ( ) ; paramRequired = ( ( Binder ) a ) . required ( ) ; break ; } //        else if (a instanceof Environment) { //          paramName = ((Environment) a).name(); //          paramRequired = ((Environment) a).required(); //          break; //        } } parameters . add ( Parameter . create ( paramName , paramClass , paramRequired ) ) ; } return parameters ; }'", "label": "'Creates the list of BinderVariables given a method obtained through reflection .'"}
{"text": "'public Class < ? > [ ] getTypeArray ( ) { Class < ? > [ ] typeArray = new Class [ this . parameters . size ( ) ] ; for ( int i = 0 ; i < this . parameters . size ( ) ; i ++ ) { typeArray [ i ] = this . parameters . get ( i ) . getType ( ) ; } return typeArray ; }'", "label": "'Returns an array of types for use with reflection method . invoke () .'"}
{"text": "'public int [ ] getFunctionDefinitionArray ( int functionOffset , int maxParams , int returnType ) { int [ ] definition = new int [ maxParams + EXTRA_FUNC_DEF_VALUES ] ; int paramCount = getParameterCount ( false ) ; int fullParamCount = getParameterCount ( true ) ; definition [ 0 ] = functionOffset ; if ( paramCount > maxParams ) { throw new IllegalStateException ( \"Attempted to get function definition table when supplied \" + \"max parameter count \" + maxParams + \" is smaller than real param count \" + paramCount ) ; } definition [ 1 ] = paramCount ; int j = 2 ; for ( int i = 0 ; i < fullParamCount ; i ++ ) { // add grammar element if it is NOT an injected type if ( ( this . parameters . get ( i ) instanceof InjectedParameter ) == false ) { definition [ j ] = this . parameters . get ( i ) . getGrammarElementType ( ) ; j ++ ; } } // pad out unspecified param types for ( ; j < definition . length - 1 ; j ++ ) { definition [ j ] = Parameter . GRAMMAR_ELEMENT_UNSPECIFIED ; } // return type as last value definition [ definition . length - 1 ] = returnType ; return definition ; }'", "label": "'Return the m_functionDefinition compatible array .'"}
{"text": "'public Object [ ] getValueArray ( Object [ ] arguments , Service service ) { Object [ ] paramArray = new Object [ this . parameters . size ( ) ] ; int argumentIndex = 0 ; for ( int i = 0 ; i < this . parameters . size ( ) ; i ++ ) { // inject params if needed IParameter p = this . parameters . get ( i ) ; try { if ( p instanceof InjectedParameter ) { paramArray [ i ] = p . getArgumentValue ( null , service ) ; } else { paramArray [ i ] = p . getArgumentValue ( arguments [ argumentIndex ] , service ) ; argumentIndex ++ ; } } catch ( ClassCastException e ) { SystemUtils . trace ( \"twine\" , \"getArgumentValue failed on parameter \" + ( i + 1 ) + \": \" + e . getMessage ( ) ) ; } } return paramArray ; }'", "label": "'Returns an array of values given an array of script arguments for use with the reflection method . invoke () injecting known service / user / context data .'"}
{"text": "'public Object [ ] getValueArray ( Workspace ws , DataBinder binder , ExecutionContext ctx ) { Object [ ] paramArray = new Object [ this . parameters . size ( ) ] ; for ( int i = 0 ; i < this . parameters . size ( ) ; i ++ ) { // inject params if needed IParameter p = this . parameters . get ( i ) ; try { if ( p . getType ( ) == Workspace . class ) { paramArray [ i ] = ws ; } else if ( p . getType ( ) == DataBinder . class ) { paramArray [ i ] = binder ; } else if ( p . getType ( ) . isAssignableFrom ( ExecutionContext . class ) ) { paramArray [ i ] = ctx ; } else { paramArray [ i ] = null ; } } catch ( ClassCastException e ) { SystemUtils . trace ( \"twine\" , \"getArgumentValue failed on parameter \" + ( i + 1 ) + \": \" + e . getMessage ( ) ) ; } } return paramArray ; }'", "label": "'Returns an array of values given a filter execution context'"}
{"text": "'public Object [ ] getValueArray ( Service service ) { Object [ ] paramArray = new Object [ this . parameters . size ( ) ] ; for ( int i = 0 ; i < this . parameters . size ( ) ; i ++ ) { IParameter p = this . parameters . get ( i ) ; try { paramArray [ i ] = p . getBinderValue ( service ) ; } catch ( IllegalAccessException e ) { SystemUtils . trace ( \"twine\" , \"getValue failed on parameter \" + ( i + 1 ) + \": \" + e . getMessage ( ) ) ; } } return paramArray ; }'", "label": "'Returns an array of values for use with the reflection method . invoke () injecting known service / user / context data .'"}
{"text": "'public static synchronized boolean existsInstance ( File path ) { String canonicalPath = \"\" ; try { canonicalPath = path . getCanonicalPath ( ) ; } catch ( IOException e ) { //obviously, the answer is NO return false ; } return INSTANCES . containsKey ( canonicalPath ) ; }'", "label": "'Checks if there is a DotGit instance for a given path'"}
{"text": "'public static synchronized DotGit getInstance ( File path ) { DotGit dotGit ; // TODO (rs2705): make sure that path is valid /*\\n     * We want to make sure we\\'re dealing with the canonical path here, since there are multiple\\n     * ways to refer to the same dir with different strings.\\n     */ String canonicalPath = \"\" ; try { canonicalPath = path . getCanonicalPath ( ) ; } catch ( Exception e ) { /*\\n       * TODO (rs2705): Figure out which exception to throw here, and throw it - or should we simply\\n       * let it propogate up as-is?\\n       */ // Temporary placeholder return null ; } if ( ! ( INSTANCES . containsKey ( canonicalPath ) ) ) { dotGit = new DotGit ( path , canonicalPath ) ; INSTANCES . put ( canonicalPath , dotGit ) ; } else { dotGit = INSTANCES . get ( canonicalPath ) ; } return dotGit ; }'", "label": "'Static factory method for retrieving an instance of this class .'"}
{"text": "'public Ref createBranch ( String name ) throws IOException , JavaGitException { Ref newBranch = Ref . createBranchRef ( name ) ; GitBranch gitBranch = new GitBranch ( ) ; gitBranch . createBranch ( path , newBranch ) ; return newBranch ; }'", "label": "'Creates a new branch'"}
{"text": "'public void deleteBranch ( Ref branch , boolean forceDelete ) throws IOException , JavaGitException { GitBranch gitBranch = new GitBranch ( ) ; gitBranch . deleteBranch ( path , forceDelete , false , branch ) ; branch = null ; }'", "label": "'Deletes a branch'"}
{"text": "'public Ref renameBranch ( Ref branchFrom , String nameTo , boolean forceRename ) throws IOException , JavaGitException { Ref newBranch = Ref . createBranchRef ( nameTo ) ; GitBranch gitBranch = new GitBranch ( ) ; gitBranch . renameBranch ( path , forceRename , branchFrom , newBranch ) ; return newBranch ; }'", "label": "'Renames a branch'"}
{"text": "'public Iterator < Ref > getBranches ( ) throws IOException , JavaGitException { GitBranch gitBranch = new GitBranch ( ) ; GitBranchOptions options = new GitBranchOptions ( ) ; GitBranchResponse response = gitBranch . branch ( path , options ) ; return response . getBranchListIterator ( ) ; }'", "label": "'Gets a list of the branches in the repository .'"}
{"text": "'public List < Commit > getLog ( ) throws JavaGitException , IOException { GitLog gitLog = new GitLog ( ) ; return gitLog . log ( this . getPath ( ) ) ; }'", "label": "'Show commit logs'"}
{"text": "'public GitCommitResponseImpl commitAll ( File repository , String message ) throws IOException , JavaGitException { CheckUtilities . checkNullArgument ( repository , \"repository\" ) ; CheckUtilities . checkStringArgument ( message , \"message\" ) ; IClient client = ClientManager . getInstance ( ) . getPreferredClient ( ) ; IGitCommit gitCommit = client . getGitCommitInstance ( ) ; return gitCommit . commitAll ( repository , message ) ; }'", "label": "'Automatically stage all tracked files that have been changed and then commit all files staged in the git repository s index .'"}
{"text": "'@ Override public Object getBinderValue ( Service service ) { String binderValue = getStringValue ( service . getBinder ( ) ) ; return parseStringValue ( binderValue ) ; }'", "label": "'{'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public static < T > T convert ( Object from , Class < T > to ) { // Null is just null. if ( from == null ) { return null ; } // Can we cast? Then just do it. if ( to . isAssignableFrom ( from . getClass ( ) ) ) { return to . cast ( from ) ; } // Lookup the suitable converter. String converterId = from . getClass ( ) . getName ( ) + \"_\" + to . getName ( ) ; Method converter = CONVERTERS . get ( converterId ) ; if ( converter == null ) { throw new UnsupportedOperationException ( \"Cannot convert from \" + from . getClass ( ) . getName ( ) + \" to \" + to . getName ( ) + \". Requested converter does not exist.\" ) ; } // Convert the value. try { // primitives don\\'t appear to have a .cast() method, which causes a null // pointer exception if ( to . isPrimitive ( ) ) { return ( T ) converter . invoke ( to , from ) ; } return to . cast ( converter . invoke ( to , from ) ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Cannot convert from \" + from . getClass ( ) . getName ( ) + \" to \" + to . getName ( ) + \". Conversion failed with \" + e . getMessage ( ) , e ) ; } }'", "label": "'Convert the given object value to the given class .'"}
{"text": "'public static Boolean integerToBoolean ( Integer value ) { return value . intValue ( ) == 0 ? Boolean . FALSE : Boolean . TRUE ; }'", "label": "'Converts Integer to Boolean . If integer value is 0 then return FALSE else return TRUE .'"}
{"text": "'public static Integer booleanToInteger ( Boolean value ) { return value . booleanValue ( ) ? Integer . valueOf ( 1 ) : Integer . valueOf ( 0 ) ; }'", "label": "'Converts Boolean to Integer . If boolean value is TRUE then return 1 else return 0 .'"}
{"text": "'public static String longToString ( Date value ) { if ( value == null ) { return null ; } SimpleDateFormat sdf = new SimpleDateFormat ( ) ; return sdf . format ( value ) ; }'", "label": "'Converts Date to String .'"}
{"text": "'public static Uri uriForItem ( final String tableName , final long id ) { return REGISTRY . getItemUri ( tableName , Long . toString ( id ) ) ; }'", "label": "'Returns a { @link Uri } for the using it with a { @link ContentResolver } to access this { @link ContentProvider } . The { @link Uri } allows CRUD operations on a single { @link Entity } element qualified by its primary key .'"}
{"text": "'public static String getMessage ( String code ) { String str = MESSAGE_MAP . get ( code ) ; if ( null == str ) { return \"NO MESSAGE FOR ERROR CODE. { code=[\" + code + \"] }\" ; } return str ; }'", "label": "'Gets the error message for the specified code .'"}
{"text": "'public File getFileNeedingUpdate ( int index ) { CheckUtilities . checkIntIndexInListRange ( filesNeedingUpdate , index ) ; return filesNeedingUpdate . get ( index ) ; }'", "label": "'Gets the file at the specified index from the list of files needing update .'"}
{"text": "'public void addToDeletedFilesToCommit ( File file ) { deletedFilesToCommit . add ( file ) ; fileToStatus . put ( file , Status . DELETED_TO_COMMIT ) ; }'", "label": "'Adds a file to list of files that are deleted and will be committed next time &lt ; git - commit&gt ; is run .'"}
{"text": "'public void addToDeletedFilesNotUpdated ( File file ) { deletedFilesNotUpdated . add ( file ) ; fileToStatus . put ( file , Status . DELETED ) ; }'", "label": "'Adds a file to the list of files that are deleted locally but not yet deleted from index using &lt ; git - rm&gt ; command .'"}
{"text": "'public void addToModifiedFilesToCommit ( File file ) { modifiedFilesToCommit . add ( file ) ; fileToStatus . put ( file , Status . MODIFIED_TO_COMMIT ) ; }'", "label": "'Adds a file to list of files that are modified and will be committed next time &lt ; git - commit&gt ; is run .'"}
{"text": "'public void addToModifiedFilesNotUpdated ( File file ) { modifiedFilesNotUpdated . add ( file ) ; fileToStatus . put ( file , Status . MODIFIED ) ; }'", "label": "'Adds a file to the list of files that are modified files but not yet updated .'"}
{"text": "'public void addToNewFilesToCommit ( File file ) { newFilesToCommit . add ( file ) ; fileToStatus . put ( file , Status . NEW_TO_COMMIT ) ; }'", "label": "'Adds a file to the list of new files that are ready to be committed next time &lt ; git - commit&gt ; command is run .'"}
{"text": "'public void addToRenamedFilesToCommit ( File file ) { renamedFilesToCommit . add ( file ) ; fileToStatus . put ( file , Status . RENAMED_TO_COMMIT ) ; }'", "label": "'Adds a file to the list of renamed files that are ready to be committed next time &lt ; git - commit&gt ; command is run .'"}
{"text": "'public void addToUntrackedFiles ( File file ) { untrackedFiles . add ( file ) ; fileToStatus . put ( file , Status . UNTRACKED ) ; }'", "label": "'Adds a file to list of files that have been added locally but not yet added to the index .'"}
{"text": "'public static Parameter create ( String name , Class < ? > type , boolean required ) throws IllegalArgumentException { if ( InjectedParameter . isValidType ( type ) ) { return new InjectedParameter ( name , type ) ; } if ( type . isPrimitive ( ) && ! required ) { String msg = \"Parameter [\" + name + \"] found with non-nullable type. Use a wrapper type or change to required\" ; throw new IllegalArgumentException ( msg ) ; } Parameter p ; if ( type == String . class ) { p = new StringParameter ( name , type ) ; } else if ( type == Integer . class || type == int . class ) { p = new IntegerParameter ( name , type ) ; } else if ( type == Long . class || type == long . class ) { p = new LongParameter ( name , type ) ; } else if ( type == Float . class || type == float . class ) { p = new FloatParameter ( name , type ) ; } else if ( type == Double . class || type == double . class ) { p = new DoubleParameter ( name , type ) ; } else if ( type == Date . class ) { p = new DateParameter ( name , type ) ; } else if ( type == ResultSet . class || type == DataResultSet . class ) { p = new ResultSetParameter ( name , type ) ; } else if ( type == Boolean . class || type == boolean . class ) { p = new BooleanParameter ( name , type ) ; } else if ( type == Provider . class ) { p = new ProviderParameter ( name ) ; } else { throw new IllegalArgumentException ( \"Parameter type \" + type . getName ( ) + \" is not valid\" ) ; } p . setRequired ( required ) ; return p ; }'", "label": "'Factory method to create the concrete variable type .'"}
{"text": "'public String getStringValue ( DataBinder binder ) { // binder can\\'t get a non existent param if ( this . name == null || this . name . equals ( \"\" ) ) { return null ; } String value = ( String ) binder . getLocal ( this . name ) ; if ( value == null && this . required ) { throw new IllegalArgumentException ( \"Parameter \" + name + \" is required\" ) ; } return value ; }'", "label": "'Get the string value from binder .'"}
{"text": "'public Object getArgumentValue ( Object object , Service service ) throws ClassCastException { return ObjectConverter . convert ( object , type ) ; }'", "label": "'{'"}
{"text": "'public void setOptVerbose ( boolean optVerbose ) { checkCanSetNoArgOption ( \"--verbose\" ) ; if ( ( false == optVerbose ) && ( optAbbrev || optNoAbbrev ) ) { throw new IllegalArgumentException ( ExceptionMessageMap . getMessage ( \"000120\" ) + \"  --no-abbrev or --abbrev can only be used with --verbose.\" ) ; } this . optVerbose = optVerbose ; }'", "label": "'Checks whether the verbose option should be set and sets it .'"}
{"text": "'public void setOptAbbrev ( boolean optAbbrev ) { if ( optVerbose ) { if ( optAbbrev && optNoAbbrev ) { throw new IllegalArgumentException ( ExceptionMessageMap . getMessage ( \"000120\" ) + \"  --abbrev cannot be used with --no-abbrev.\" ) ; } this . optAbbrev = optAbbrev ; } }'", "label": "'Checks whether the -- abbrev option should be set and sets it .'"}
{"text": "'public void setOptNoAbbrev ( boolean optNoAbbrev ) { if ( optVerbose ) { if ( optAbbrev && optNoAbbrev ) { throw new IllegalArgumentException ( ExceptionMessageMap . getMessage ( \"000120\" ) + \"  --no-abbrev cannot be used with --abbrev.\" ) ; } this . optNoAbbrev = optNoAbbrev ; } }'", "label": "'Checks whether the -- no - abbrev option should be set and sets it .'"}
{"text": "'public void setOptTrack ( boolean optTrack ) { checkCanSetCreateOption ( \"--track\" ) ; if ( optNoTrack && optTrack ) { throw new IllegalArgumentException ( ExceptionMessageMap . getMessage ( \"000120\" ) + \"  --track cannot be used with --no-track.\" ) ; } this . optTrack = optTrack ; }'", "label": "'Checks whether the -- track option should be set and sets it .'"}
{"text": "'public void setOptNoTrack ( boolean optNoTrack ) { checkCanSetNoArgOption ( \"--no-track\" ) ; if ( optNoTrack && optTrack ) { throw new IllegalArgumentException ( ExceptionMessageMap . getMessage ( \"000120\" ) + \"  --no-track cannot be used with --track.\" ) ; } this . optNoTrack = optNoTrack ; }'", "label": "'Checks whether the -- no - track option should be set and sets it .'"}
{"text": "'public void setOptColor ( boolean optColor ) { checkCanSetNoArgOption ( \"--color\" ) ; if ( optNoColor && optColor ) { throw new IllegalArgumentException ( ExceptionMessageMap . getMessage ( \"000120\" ) + \"  --color cannot be used with --no-color.\" ) ; } this . optColor = optColor ; }'", "label": "'Checks whether the -- color option should be set and sets it .'"}
{"text": "'public void setOptNoColor ( boolean optNoColor ) { checkCanSetNoArgOption ( \"--no-color\" ) ; if ( optNoColor && optColor ) { throw new IllegalArgumentException ( ExceptionMessageMap . getMessage ( \"000120\" ) + \"  --no-color cannot be used with --color.\" ) ; } this . optNoColor = optNoColor ; }'", "label": "'Checks whether the -- no - color option should be set and sets it .'"}
{"text": "'public void setOptMerged ( boolean optMerged ) { checkCanSetNoArgOption ( \"--merged\" ) ; if ( optNoMerged && optMerged ) { throw new IllegalArgumentException ( ExceptionMessageMap . getMessage ( \"000120\" ) + \"  --merged cannot be used with --no-merged.\" ) ; } this . optMerged = optMerged ; }'", "label": "'Checks whether the -- merged option should be set and sets it .'"}
{"text": "'public void setOptNoMerged ( boolean optNoMerged ) { checkCanSetNoArgOption ( \"--no-merged\" ) ; if ( optNoMerged && optMerged ) { throw new IllegalArgumentException ( ExceptionMessageMap . getMessage ( \"000120\" ) + \"  --no-merged cannot be used with --merged.\" ) ; } this . optNoMerged = optNoMerged ; }'", "label": "'Checks whether the -- no - merged option should be set and sets it .'"}
{"text": "'public void setOptDLower ( boolean optDLower ) { checkCanSetDeleteOption ( \"-d\" ) ; if ( optDLower && optDUpper ) { throw new IllegalArgumentException ( ExceptionMessageMap . getMessage ( \"000120\" ) + \"  -d cannot be used with -D.\" ) ; } this . optDLower = optDLower ; }'", "label": "'Checks whether the - d option should be set and sets it .'"}
{"text": "'public void setOptDUpper ( boolean optDUpper ) { checkCanSetDeleteOption ( \"-D\" ) ; if ( optDLower && optDUpper ) { throw new IllegalArgumentException ( ExceptionMessageMap . getMessage ( \"000120\" ) + \"  -D cannot be used with -d.\" ) ; } this . optDUpper = optDUpper ; }'", "label": "'Checks whether the - D option should be set and sets it .'"}
{"text": "'public void setOptMLower ( boolean optMLower ) { checkCanSetRenameOption ( \"-m\" ) ; if ( optMLower && optMUpper ) { throw new IllegalArgumentException ( ExceptionMessageMap . getMessage ( \"000120\" ) + \"  -m cannot be used with -M.\" ) ; } this . optMLower = optMLower ; }'", "label": "'Checks whether the - m option should be set and sets it .'"}
{"text": "'public void setOptMUpper ( boolean optMUpper ) { checkCanSetRenameOption ( \"-M\" ) ; if ( optMLower && optMUpper ) { throw new IllegalArgumentException ( ExceptionMessageMap . getMessage ( \"000120\" ) + \"  -M cannot be used with -m.\" ) ; } this . optMUpper = optMUpper ; }'", "label": "'Checks whether the - M option should be set and sets it .'"}
{"text": "'public void checkCanSetNoArgOption ( String option ) { if ( isOptTrack ( ) || isOptNoTrack ( ) || isOptL ( ) || isOptF ( ) || isOptDLower ( ) || isOptDUpper ( ) || isOptMLower ( ) || isOptMUpper ( ) ) { throw new IllegalArgumentException ( ExceptionMessageMap . getMessage ( \"000120\" ) + option + \" should be used without arguments, to display branches\" ) ; } }'", "label": "'Checks whether an option for displaying branches can be set . If not throws an <code > IllegalArgumentException< / code > .'"}
{"text": "'public void checkCanSetCreateOption ( String option ) { if ( isOptColor ( ) || isOptNoColor ( ) || isOptR ( ) || isOptA ( ) || isOptVerbose ( ) || isOptMerged ( ) || isOptNoMerged ( ) || ( null != getOptContains ( ) ) || isOptMLower ( ) || isOptMUpper ( ) || isOptDLower ( ) || isOptDUpper ( ) ) { throw new IllegalArgumentException ( ExceptionMessageMap . getMessage ( \"000120\" ) + option + \" should be used with a branch name and optional start point, to create a branch\" ) ; } }'", "label": "'Checks whether an option for creating a branch can be set . If not throws an <code > IllegalArgumentException< / code > .'"}
{"text": "'public void checkCanSetDeleteOption ( String option ) { if ( isOptColor ( ) || isOptNoColor ( ) || isOptA ( ) || isOptVerbose ( ) || isOptMerged ( ) || isOptNoMerged ( ) || ( null != getOptContains ( ) ) || isOptTrack ( ) || isOptNoTrack ( ) || isOptL ( ) || isOptF ( ) || isOptMLower ( ) || isOptMUpper ( ) ) { throw new IllegalArgumentException ( ExceptionMessageMap . getMessage ( \"000120\" ) + option + \" should be used with branch(es), to delete the branch(es).\" ) ; } }'", "label": "'Checks whether an option for deleting a branch or branch list can be set . If not throws an <code > IllegalArgumentException< / code > .'"}
{"text": "'public void checkCanSetRenameOption ( String option ) { if ( isOptColor ( ) || isOptNoColor ( ) || isOptR ( ) || isOptA ( ) || isOptVerbose ( ) || isOptMerged ( ) || isOptNoMerged ( ) || ( null != getOptContains ( ) ) || isOptTrack ( ) || isOptNoTrack ( ) || isOptL ( ) || isOptF ( ) || isOptDLower ( ) || isOptDUpper ( ) ) { throw new IllegalArgumentException ( ExceptionMessageMap . getMessage ( \"000120\" ) + option + \" should be used with optional oldbranch and newbranch, to rename oldbranch/current branch\" + \"to newbranch.\" ) ; } }'", "label": "'Checks whether an option for renaming a branch can be set . If not throws an <code > IllegalArgumentException< / code > .'"}
{"text": "'private void generateDefinitions ( ) { functionParameterTypes = new ArrayList < Class < ? > [ ] > ( ) ; functionMethodNames = new ArrayList < String > ( ) ; variableParameterTypes = new ArrayList < Class < ? > [ ] > ( ) ; variableMethodNames = new ArrayList < String > ( ) ; List < String > functionNames = new ArrayList < String > ( ) ; List < ParameterMarshaller > functionParams = new ArrayList < ParameterMarshaller > ( ) ; List < Integer > functionReturnTypes = new ArrayList < Integer > ( ) ; List < String > variableNames = new ArrayList < String > ( ) ; List < Integer > variableReturnTypes = new ArrayList < Integer > ( ) ; Method ms [ ] = m_class . getDeclaredMethods ( ) ; functionMethods = new Method [ ms . length ] ; Map < String , Method > methods = new TreeMap < String , Method > ( ) ; for ( Method m : ms ) { methods . put ( m . getName ( ) , m ) ; } int functionCounter = 0 ; for ( String methodName : methods . keySet ( ) ) { Method m = methods . get ( methodName ) ; IdocFunction functionInfo = m . getAnnotation ( IdocFunction . class ) ; if ( functionInfo != null ) { if ( functionInfo . name ( ) . equals ( \"\" ) ) { functionNames . add ( m . getName ( ) ) ; } else { functionNames . add ( functionInfo . name ( ) ) ; } functionMethodNames . add ( m . getName ( ) ) ; functionMethods [ functionCounter ] = m ; functionParams . add ( new ParameterMarshaller ( m ) ) ; functionReturnTypes . add ( getFunctionReturnType ( m ) ) ; functionParameterTypes . add ( m . getParameterTypes ( ) ) ; functionCounter ++ ; } else { IdocVariable varInfo = m . getAnnotation ( IdocVariable . class ) ; if ( varInfo != null ) { if ( varInfo . name ( ) . equals ( \"\" ) ) { variableNames . add ( m . getName ( ) ) ; } else { variableNames . add ( varInfo . name ( ) ) ; } variableMethodNames . add ( m . getName ( ) ) ; variableReturnTypes . add ( getVariableReturnType ( m ) ) ; variableParameterTypes . add ( m . getParameterTypes ( ) ) ; } } } writeVariableTables ( variableNames , variableReturnTypes ) ; writeFunctionTables ( functionNames , functionParams , functionReturnTypes ) ; }'", "label": "'Configuration data for functions . This list must align with the m_functionTable list . In order the values are id number Number of arguments First argument type Second argument type Return Type . Return type has the following possible values : 0 generic object ( such as strings ) 1 boolean 2 integer 3 double . The value - 1 means the value is unspecified .'"}
{"text": "'private void writeVariableTables ( List < String > variableNames , List < Integer > variableReturnTypes ) { m_variableTable = variableNames . toArray ( new String [ variableNames . size ( ) ] ) ; m_variableDefinitionTable = new int [ variableNames . size ( ) ] [ 2 ] ; for ( int i = 0 ; i < variableNames . size ( ) ; i ++ ) { m_variableDefinitionTable [ i ] [ 0 ] = i ; m_variableDefinitionTable [ i ] [ 1 ] = variableReturnTypes . get ( i ) ; } }'", "label": "'Build a static int [ m ] [ 2 ] array of variable info where the int array is <code > { variable_index return_type } < / code > .'"}
{"text": "'private void writeFunctionTables ( List < String > functionNames , List < ParameterMarshaller > functionParams , List < Integer > returnTypes ) { m_functionTable = functionNames . toArray ( new String [ functionNames . size ( ) ] ) ; int maxParams = 0 ; // find the max of all parameter counts for ( int i = 0 ; i < functionParams . size ( ) ; i ++ ) { int paramCount = functionParams . get ( i ) . getParameterCount ( false ) ; if ( paramCount > maxParams ) { maxParams = paramCount ; } } m_functionDefinitionTable = new int [ functionParams . size ( ) ] [ maxParams + ParameterMarshaller . EXTRA_FUNC_DEF_VALUES ] ; // output params now for ( int i = 0 ; i < functionParams . size ( ) ; i ++ ) { m_functionDefinitionTable [ i ] = functionParams . get ( i ) . getFunctionDefinitionArray ( i , maxParams , returnTypes . get ( i ) ) ; } }'", "label": "'Build a static int [ m ] [ n ] array of function info from a dynamic array where n changes size . The last parameter will always remain the last parameter but any short rows will pad their parameter types as - 1 ( type not specified )'"}
{"text": "'public Integer getFunctionReturnType ( Method m ) { Class < ? > type = m . getReturnType ( ) ; if ( type == Void . class || type == void . class ) { return RETURN_VOID ; } if ( type == Boolean . class || type == boolean . class ) { return RETURN_BOOLEAN ; } if ( type == Integer . class || type == int . class || type == Long . class || type == long . class ) { return RETURN_INTEGER ; } if ( type == Float . class || type == float . class || type == Double . class || type == double . class ) { return RETURN_FLOAT ; } return RETURN_STRING ; }'", "label": "'Get idoc function return type .'"}
{"text": "'public Integer getVariableReturnType ( Method m ) { if ( m . getReturnType ( ) == Boolean . class || m . getReturnType ( ) == boolean . class ) { return RETURN_BOOLEAN ; } return RETURN_STRING ; }'", "label": "'Get idoc variable type ( limited to string or conditional ) .'"}
{"text": "'public boolean evaluateFunction ( ScriptInfo info , Object [ ] args , ExecutionContext context ) throws ServiceException { /**\\n     * This code below is optimized for speed, not clarity. Do not modify the\\n     * code below when making new IdocScript functions. It is needed to prepare\\n     * the necessary variables for the evaluation and return of the custom\\n     * IdocScript functions. Only customize the switch statement below.\\n     */ int config [ ] = ( int [ ] ) info . m_entry ; String functionCalled = info . m_key ; int functionIndex = config [ 0 ] ; int nargs = args . length - 1 ; int allowedParams = config [ 1 ] ; if ( allowedParams >= 0 && allowedParams != nargs ) { String msg = LocaleUtils . encodeMessage ( \"csScriptEvalNotEnoughArgs\" , null , functionCalled , \"\" + allowedParams ) ; throw new IllegalArgumentException ( msg ) ; } UserData userData = ( UserData ) context . getCachedObject ( \"UserData\" ) ; if ( userData == null ) { String msg = LocaleUtils . encodeMessage ( \"csUserDataNotAvailable\" , null , functionCalled ) ; throw new ServiceException ( msg ) ; } if ( functionIndex > m_functionTable . length ) { SystemUtils . trace ( \"twine\" , \"Unknown function with index\" + functionIndex ) ; return false ; } try { args [ nargs ] = runFunctionMethod ( functionIndex , args , context ) ; } catch ( Exception e ) { String msg = e . getMessage ( ) ; if ( e instanceof InvocationTargetException ) { msg = ( ( InvocationTargetException ) e ) . getTargetException ( ) . getMessage ( ) ; } msg = \"Unable to execute function \\'\" + functionCalled + \"()\\': \" + msg ; SystemUtils . err ( e , msg ) ; SystemUtils . trace ( \"twine\" , msg ) ; throw new ServiceException ( e ) ; } // Handled function. return true ; }'", "label": "'This is where the custom IdocScript function is evaluated .'"}
{"text": "'public Object [ ] getInjectedValueArray ( Method method , Object [ ] args , ExecutionContext ctx ) throws IllegalArgumentException , ServiceException { ParameterMarshaller marshaller = new ParameterMarshaller ( method ) ; if ( ( ctx instanceof Service ) == false ) { throw new ServiceException ( \"Tried to create parameters with injection and not inside a service.\" ) ; } return marshaller . getValueArray ( args , ( Service ) ctx ) ; }'", "label": "'Enumerates the correct parameters for the delegated method . Injects any autowired types if present in the method signature .'"}
{"text": "'public Object runFunctionMethod ( int functionIndex , Object [ ] args , ExecutionContext ctx ) throws SecurityException , NoSuchMethodException , IllegalArgumentException , ServiceException , IllegalAccessException , InvocationTargetException { Method method = functionMethods [ functionIndex ] ; Object params [ ] = getInjectedValueArray ( method , args , ctx ) ; Object result ; try { result = method . invoke ( m_class . newInstance ( ) , params ) ; } catch ( InstantiationException e ) { // TODO catch and re-throw ewwwww throw new ServiceException ( \"Cannot delegate instantiate script context: \" + e . getMessage ( ) ) ; } if ( result == null ) { return result ; } return convertReturnValue ( result ) ; }'", "label": "'Executes the annotated method .'"}
{"text": "'private Object convertReturnValue ( Object result ) { if ( boolean . class . isInstance ( result ) || result instanceof Boolean ) { return ScriptExtensionUtils . computeReturnObject ( 1 , ( ( Boolean ) result ) . booleanValue ( ) , 0 , 0.0 , null ) ; } else if ( long . class . isInstance ( result ) ) { return ( Long ) result ; } else if ( int . class . isInstance ( result ) || result instanceof Integer ) { return new Long ( ( Integer ) result ) ; } else if ( double . class . isInstance ( result ) ) { return ( Double ) result ; } // String/Double/Long/Float return result ; }'", "label": "'Convert the method return value into a PageMerger internal type of String Long or Double'"}
{"text": "'public boolean evaluateValue ( ScriptInfo info , boolean [ ] returnBool , String [ ] returnString , ExecutionContext context , boolean isConditional ) throws ServiceException { /**\\n     * This code, like the beginning block of code in evaluateFunction, is\\n     * required for preparing the data for evaluation. It should not be altered.\\n     * Only customize the switch statement below.\\n     */ int config [ ] = ( int [ ] ) info . m_entry ; String key = info . m_key ; if ( ( context instanceof Service ) == false ) { // Some variables will evaluate trivially instead of throwing an // exception. if ( config [ 1 ] == RETURN_BOOLEAN ) { returnBool [ 0 ] = false ; returnString [ 0 ] = \"\" ; return true ; } throw new ServiceException ( \"Script variable \" + key + \" must have be evaluated in \" + \"context of a Service object.\" ) ; } UserData userData = ( UserData ) context . getCachedObject ( \"UserData\" ) ; if ( userData == null ) { throw new ServiceException ( \"Script variable \" + key + \" must have user data context.\" ) ; } int variableIndex = config [ 0 ] ; String variableRequested = m_variableTable [ variableIndex ] ; if ( variableIndex > m_variableTable . length ) { return false ; // unknown variable } Object result = null ; try { result = runVariableMethod ( variableIndex , context ) ; } catch ( Exception e ) { String msg = \"Unable to handle variable \" + variableRequested + \": \" + e . getMessage ( ) ; SystemUtils . err ( e , msg ) ; SystemUtils . trace ( \"twine\" , msg ) ; throw new ServiceException ( msg ) ; } if ( isConditional ) { returnBool [ 0 ] = ObjectConverter . convert ( result , boolean . class ) ; } else { returnString [ 0 ] = ObjectConverter . convert ( result , String . class ) ; } return true ; }'", "label": "'This is where the custom IdocScript variable is evaluated .'"}
{"text": "'public GitStatusResponse status ( File repositoryPath , GitStatusOptions options , List < File > paths ) throws JavaGitException , IOException { CheckUtilities . checkNullArgument ( repositoryPath , \"RepositoryPath\" ) ; CheckUtilities . checkFileValidity ( repositoryPath ) ; List < String > command = buildCommandLine ( options , paths ) ; GitStatusParser parser ; if ( inputFile != null ) { parser = new GitStatusParser ( repositoryPath . getPath ( ) + File . separator , inputFile ) ; } else { parser = new GitStatusParser ( repositoryPath . getPath ( ) + File . separator ) ; } GitStatusResponse response = ( GitStatusResponseImpl ) ProcessUtilities . runCommand ( repositoryPath , command , parser ) ; return response ; }'", "label": "'Implementation of <code > IGitStatus< / code > method for getting the status of a list of files'"}
{"text": "'public GitStatusResponse status ( File repositoryPath , GitStatusOptions options , File file ) throws JavaGitException , IOException { List < File > paths = new ArrayList < File > ( ) ; paths . add ( file ) ; return status ( repositoryPath , options , paths ) ; }'", "label": "'Implementation of <code > IGitStatus< / code > method for getting the status of a file .'"}
{"text": "'public GitStatusResponse status ( File repositoryPath , GitStatusOptions options ) throws JavaGitException , IOException { List < File > paths = null ; return status ( repositoryPath , options , paths ) ; }'", "label": "'Implementation of <code > IGitStatus< / code > method with only options passed to &lt ; git - status&gt ; command .'"}
{"text": "'public GitStatusResponse statusAll ( File repositoryPath ) throws JavaGitException , IOException { GitStatusOptions options = new GitStatusOptions ( ) ; options . setOptAll ( true ) ; return status ( repositoryPath , options ) ; }'", "label": "'Implementation of <code > IGitStatus< / code > method with options set to all ( - a )'"}
{"text": "'public GitStatusResponse getSingleFileStatus ( File repositoryPath , GitStatusOptions options , File file ) throws JavaGitException , IOException { CheckUtilities . checkNullArgument ( repositoryPath , \"RepositoryPath\" ) ; CheckUtilities . checkFileValidity ( repositoryPath ) ; List < String > command = buildCommandLine ( options , null ) ; GitStatusParser parser = new GitStatusParser ( repositoryPath . getPath ( ) + File . separator , file ) ; return ( GitStatusResponseImpl ) ProcessUtilities . runCommand ( repositoryPath , command , parser ) ; }'", "label": "'Return status for a single <code > File< / code >'"}
{"text": "'private List < String > buildCommandLine ( GitStatusOptions options , List < File > paths ) { List < String > command = new ArrayList < String > ( ) ; command . add ( JavaGitConfiguration . getGitCommand ( ) ) ; command . add ( \"status\" ) ; if ( options != null ) { setOptions ( command , options ) ; } if ( paths != null ) { for ( File file : paths ) { command . add ( file . getPath ( ) ) ; } } return command ; }'", "label": "'Parses options provided by the <code > GitStatusOptions< / code > object and adds them to the command .'"}
{"text": "'public GitBranchResponse branch ( File repositoryPath ) throws IOException , JavaGitException { CheckUtilities . checkNullArgument ( repositoryPath , \"repository path\" ) ; IClient client = ClientManager . getInstance ( ) . getPreferredClient ( ) ; IGitBranch gitBranch = client . getGitBranchInstance ( ) ; return gitBranch . branch ( repositoryPath ) ; }'", "label": "'Does a basic git - branch without any options .'"}
{"text": "'public GitBranchResponse deleteBranch ( File repositoryPath , boolean forceDelete , boolean remote , Ref branchName ) throws IOException , JavaGitException { CheckUtilities . checkNullArgument ( repositoryPath , \"repository path\" ) ; CheckUtilities . checkNullArgument ( branchName , \"branch name\" ) ; CheckUtilities . validateArgumentRefType ( branchName , Ref . RefType . BRANCH , \"branch name\" ) ; IClient client = ClientManager . getInstance ( ) . getPreferredClient ( ) ; IGitBranch gitBranch = client . getGitBranchInstance ( ) ; return gitBranch . deleteBranch ( repositoryPath , forceDelete , remote , branchName ) ; }'", "label": "'This method deletes the specified branch using the - d command line option .'"}
{"text": "'public GitBranchResponse deleteBranch ( File repositoryPath , boolean forceDelete , boolean remote , List < Ref > branchList ) throws IOException , JavaGitException { CheckUtilities . checkNullArgument ( repositoryPath , \"repository path\" ) ; CheckUtilities . checkNullListArgument ( branchList , \"branch list\" ) ; CheckUtilities . validateListRefType ( branchList , Ref . RefType . BRANCH , \"branch list\" ) ; IClient client = ClientManager . getInstance ( ) . getPreferredClient ( ) ; IGitBranch gitBranch = client . getGitBranchInstance ( ) ; return gitBranch . deleteBranches ( repositoryPath , forceDelete , remote , branchList ) ; }'", "label": "'Deletes the specified branches using the - d command line option .'"}
{"text": "'public GitBranchResponse renameBranch ( File repositoryPath , boolean forceRename , Ref newName ) throws IOException , JavaGitException { CheckUtilities . checkNullArgument ( repositoryPath , \"repository path\" ) ; CheckUtilities . checkNullArgument ( newName , \"new name\" ) ; CheckUtilities . validateArgumentRefType ( newName , Ref . RefType . BRANCH , \"new name\" ) ; IClient client = ClientManager . getInstance ( ) . getPreferredClient ( ) ; IGitBranch gitBranch = client . getGitBranchInstance ( ) ; return gitBranch . renameBranch ( repositoryPath , forceRename , newName ) ; }'", "label": "'Renames the current branch to new branch .'"}
{"text": "'public static synchronized WorkingTree getInstance ( File path ) { WorkingTree workingTree ; // TODO (rs2705): make sure that path is valid /*\\n     * We want to make sure we\\'re dealing with the canonical path here, since there are multiple\\n     * ways to refer to the same dir with different strings.\\n     */ String canonicalPath = \"\" ; try { canonicalPath = path . getCanonicalPath ( ) ; } catch ( Exception e ) { /*\\n       * TODO (rs2705): Figure out which exception to throw here, and throw it - or should we simply\\n       * let it propogate up as-is?\\n       */ return null ; // Temporary placeholder } if ( ! ( INSTANCES . containsKey ( canonicalPath ) ) ) { workingTree = new WorkingTree ( path , canonicalPath ) ; INSTANCES . put ( canonicalPath , workingTree ) ; } else { workingTree = INSTANCES . get ( canonicalPath ) ; } return workingTree ; }'", "label": "'Static factory method for retrieving an instance of this class .'"}
{"text": "'public GitCommitResponse commit ( String comment ) throws IOException , JavaGitException { GitCommit gitCommit = new GitCommit ( ) ; return gitCommit . commit ( path , comment ) ; }'", "label": "'Commits the objects specified in the index to the repository .'"}
{"text": "'public Ref getCurrentBranch ( ) throws IOException , JavaGitException { GitBranch gitBranch = new GitBranch ( ) ; GitBranchOptions options = new GitBranchOptions ( ) ; GitBranchResponse response = gitBranch . branch ( path , options ) ; return response . getCurrentBranch ( ) ; }'", "label": "'Gets the currently checked - out branch of the working directory .'"}
{"text": "'public void checkout ( Ref ref ) throws IOException , JavaGitException { GitCheckout gitCheckout = new GitCheckout ( ) ; gitCheckout . checkout ( path , null , ref ) ; /*\\n     * TODO (rs2705): Figure out why this function is setting this.path. When does the WorkingTree\\n     * path change?\\n     */ // this.path = branch.getBranchRoot().getPath(); }'", "label": "'Switches to a new branch'"}
{"text": "'public GitStatusResponse getStatus ( ) throws IOException , JavaGitException { GitStatus gitStatus = new GitStatus ( ) ; return gitStatus . status ( path ) ; }'", "label": "'Gets the status of all files in the working directory'"}
{"text": "'public GitRmResponse rm ( File repository , File path ) throws IOException , JavaGitException { CheckUtilities . checkNullArgument ( repository , \"repository\" ) ; CheckUtilities . checkNullArgument ( path , \"path\" ) ; IClient client = ClientManager . getInstance ( ) . getPreferredClient ( ) ; IGitRm GitRm = client . getGitRmInstance ( ) ; return GitRm . rm ( repository , path ) ; }'", "label": "'Remove files relative to the path within the repository .'"}
{"text": "'public File getFileFromNewFilesToCommit ( int index ) { CheckUtilities . checkIntIndexInListRange ( newFilesToCommit , index ) ; return newFilesToCommit . get ( index ) ; }'", "label": "'Get the name of the file from newFilesToCommit list at a given index .'"}
{"text": "'public File getFileFromDeletedFilesToCommit ( int index ) { CheckUtilities . checkIntIndexInListRange ( deletedFilesToCommit , index ) ; return deletedFilesToCommit . get ( index ) ; }'", "label": "'Get the name of the deleted file that will be committed next time git - commit is executed currently located at the given index in the list .'"}
{"text": "'public File getFileFromModifiedFilesToCommit ( int index ) { CheckUtilities . checkIntIndexInListRange ( modifiedFilesToCommit , index ) ; return modifiedFilesToCommit . get ( index ) ; }'", "label": "'Get the name of the file that is modified and added to the repository by &lt ; git - add&gt ; command and will be committed to repository next time &lt ; git - commit&gt ; is executed . This file is at the given index in the list of the files .'"}
{"text": "'public File getFileFromDeletedFilesNotUpdated ( int index ) { CheckUtilities . checkIntIndexInListRange ( deletedFilesNotUpdated , index ) ; return deletedFilesNotUpdated . get ( index ) ; }'", "label": "'Returns the name of the deleted file that is removed locally but not yet removed from repository .'"}
{"text": "'public File getFileFromModifiedFilesNotUpdated ( int index ) { CheckUtilities . checkIntIndexInListRange ( modifiedFilesNotUpdated , index ) ; return modifiedFilesNotUpdated . get ( index ) ; }'", "label": "'Returns the name of the file that is existing in the repository and has been locally modified . This file is one of the files that has been locally modified and is located at given index in the list .'"}
{"text": "'public File getFileFromUntrackedFiles ( int index ) { CheckUtilities . checkIntIndexInListRange ( untrackedFiles , index ) ; return untrackedFiles . get ( index ) ; }'", "label": "'Returns the name of the file at the specified index that has been created locally but has not yet been added to the repository by &lt ; git - add&gt ; .'"}
{"text": "'public File getFileFromRenamedFiles ( int index ) { CheckUtilities . checkIntIndexInListRange ( renamedFilesToCommit , index ) ; return renamedFilesToCommit . get ( index ) ; }'", "label": "'Returns the file at the specified index in the list of renamed files .'"}
{"text": "'public Iterable < File > getNewFilesToCommit ( ) { Iterator < File > fileIterator = new ArrayList < File > ( newFilesToCommit ) . iterator ( ) ; return ( new IterableIterator < File > ( fileIterator ) ) ; }'", "label": "'Creates a copy of newFilesToCommit list and returns the <code > Iterable< / code > on this new list .'"}
{"text": "'public Iterable < File > getDeletedFilesToCommit ( ) { Iterator < File > fileIterator = new ArrayList < File > ( deletedFilesToCommit ) . iterator ( ) ; return ( new IterableIterator < File > ( fileIterator ) ) ; }'", "label": "'Creates a copy of deletedFilesToCommit list and returns the <code > Iterable< / code > on this new list .'"}
{"text": "'public Iterable < File > getModifiedFilesToCommit ( ) { Iterator < File > fileIterator = new ArrayList < File > ( modifiedFilesToCommit ) . iterator ( ) ; return ( new IterableIterator < File > ( fileIterator ) ) ; }'", "label": "'Creates a copy of modifiedFilesToComit list and returns the <code > Iterable< / code > on this new list .'"}
{"text": "'public Iterable < File > getDeletedFilesNotUpdated ( ) { Iterator < File > fileIterator = new ArrayList < File > ( deletedFilesNotUpdated ) . iterator ( ) ; return ( new IterableIterator < File > ( fileIterator ) ) ; }'", "label": "'Creates a copy of deletedFilesNotUpdated list and returns the <code > Iterable< / code > on this new list .'"}
{"text": "'public Iterable < File > getModifiedFilesNotUpdated ( ) { Iterator < File > fileIterator = new ArrayList < File > ( modifiedFilesNotUpdated ) . iterator ( ) ; return ( new IterableIterator < File > ( fileIterator ) ) ; }'", "label": "'Creates a copy of modifiedFilesNotUpdated list and returns the <code > Iterable< / code > on this new list .'"}
{"text": "'public Iterable < File > getRenamedFilesToCommit ( ) { Iterator < File > fileIterator = new ArrayList < File > ( renamedFilesToCommit ) . iterator ( ) ; return ( new IterableIterator < File > ( fileIterator ) ) ; }'", "label": "'Creates a copy of renamedFiles list and returns the <code > Iterable< / code > to this new list .'"}
{"text": "'public Iterable < File > getUntrackedFiles ( ) { Iterator < File > fileIterator = new ArrayList < File > ( untrackedFiles ) . iterator ( ) ; return ( new IterableIterator < File > ( fileIterator ) ) ; }'", "label": "'Creates a copy of untrackedFiles list and returns the <code > Iterable< / code > on this new list .'"}
{"text": "'public String getError ( int index ) { if ( index < errors . size ( ) ) { ErrorDetails errorDetails = errors . get ( index ) ; return errorDetails . lineNumber + \". \" + errorDetails . error ; } return null ; }'", "label": "'Returns the error message otherwise returns null ;'"}
{"text": "'public String getError ( ) { StringBuilder strBuilder = new StringBuilder ( ) ; for ( int i = 0 ; i < errors . size ( ) ; i ++ ) { strBuilder . append ( getError ( i ) + \" \" ) ; } return strBuilder . toString ( ) ; }'", "label": "'Gets all the errors generated by &lt ; git - status&gt ; command and returns them in String format .'"}
{"text": "'public static GitResetResponse gitReset ( File repository ) throws IOException , JavaGitException { CheckUtilities . checkNullArgument ( repository , \"repository\" ) ; IClient client = ClientManager . getInstance ( ) . getPreferredClient ( ) ; IGitReset gitReset = client . getGitResetInstance ( ) ; return gitReset . gitReset ( repository ) ; }'", "label": "'Perform a reset on the repository . The results of this method are what one would get by running &quote ; git - reset&quote ; against the repository .'"}
{"text": "'public static GitResetResponse gitResetHard ( File repository , Ref commitName ) throws IOException , JavaGitException { CheckUtilities . checkNullArgument ( repository , \"repository\" ) ; CheckUtilities . checkNullArgument ( commitName , \"commitName\" ) ; IClient client = ClientManager . getInstance ( ) . getPreferredClient ( ) ; IGitReset gitReset = client . getGitResetInstance ( ) ; return gitReset . gitResetHard ( repository , commitName ) ; }'", "label": "'Perform a hard reset on the repository to the specified <code > CommitName< / code > .'"}
{"text": "'public boolean addAddedFile ( File pathToFile , String mode ) { if ( null == pathToFile ) { return false ; } return addedFiles . add ( new AddedOrDeletedFile ( pathToFile , mode ) ) ; }'", "label": "'Add the information about a newly added file in the repository for a given commit .'"}
{"text": "'public boolean addCopiedFile ( File sourceFilePath , File destinationFilePath , int percentage ) { if ( null == sourceFilePath || null == destinationFilePath ) { return false ; } return copiedFiles . add ( new CopiedOrMovedFile ( sourceFilePath , destinationFilePath , percentage ) ) ; }'", "label": "'Add the information about a newly copied file in the repository for a given commit .'"}
{"text": "'public boolean addDeletedFile ( File pathToFile , String mode ) { if ( null == pathToFile ) { return false ; } return deletedFiles . add ( new AddedOrDeletedFile ( pathToFile , mode ) ) ; }'", "label": "'Add the information about a file deleted from the repository for a given commit .'"}
{"text": "'public boolean addRenamedFile ( File sourceFilePath , File destinationFilePath , int percentage ) { if ( null == sourceFilePath || null == destinationFilePath ) { return false ; } return renamedFiles . add ( new CopiedOrMovedFile ( sourceFilePath , destinationFilePath , percentage ) ) ; }'", "label": "'Add the information about a moved / renamed file in the repository for a given commit .'"}
{"text": "'public boolean setFilesChanged ( String filesChangedStr ) { try { this . filesChanged = Integer . parseInt ( filesChangedStr ) ; return true ; } catch ( NumberFormatException e ) { return false ; } }'", "label": "'Sets the number of files changed during a commit .'"}
{"text": "'public boolean setLinesDeleted ( String linesDeletedStr ) { try { this . linesDeleted = Integer . parseInt ( linesDeletedStr ) ; return true ; } catch ( NumberFormatException e ) { return false ; } }'", "label": "'Sets the number of lines deleted in a commit .'"}
{"text": "'public boolean setLinesInserted ( String linesInsertedStr ) { try { this . linesInserted = Integer . parseInt ( linesInsertedStr ) ; return true ; } catch ( NumberFormatException e ) { return false ; } }'", "label": "'Sets the number of lines inserted in a commit .'"}
{"text": "'public GitMvResponseImpl mvProcess ( File repoPath , GitMvOptions options , List < File > source , File destination ) throws IOException , JavaGitException { List < String > commandLine = buildCommand ( options , source , destination ) ; GitMvParser parser = new GitMvParser ( ) ; return ( GitMvResponseImpl ) ProcessUtilities . runCommand ( repoPath , commandLine , parser ) ; }'", "label": "'Exec of git - mv command'"}
{"text": "'protected List < String > buildCommand ( GitMvOptions options , List < File > source , File destination ) { List < String > cmd = new ArrayList < String > ( ) ; cmd . add ( JavaGitConfiguration . getGitCommand ( ) ) ; cmd . add ( \"mv\" ) ; if ( null != options ) { if ( options . isOptF ( ) ) { cmd . add ( \"-f\" ) ; } if ( options . isOptK ( ) ) { cmd . add ( \"-k\" ) ; } if ( options . isOptN ( ) ) { cmd . add ( \"-n\" ) ; setDryRun ( true ) ; } } for ( File file : source ) { cmd . add ( file . getPath ( ) ) ; } cmd . add ( destination . getPath ( ) ) ; return cmd ; }'", "label": "'Builds a list of command arguments to pass to <code > ProcessBuilder< / code > .'"}
{"text": "'@ Override public Object getArgumentValue ( Object object , Service service ) throws ClassCastException { return getInjectedValue ( service ) ; }'", "label": "'{'"}
{"text": "'protected Object getInjectedValue ( Service service ) { if ( type == UserData . class ) { return service . getUserData ( ) ; } else if ( type == PageMerger . class ) { return service . getPageMerger ( ) ; } else if ( type == DataBinder . class ) { return service . getBinder ( ) ; } else if ( type == HttpImplementor . class ) { return service . getHttpImplementor ( ) ; } else if ( type == ServiceRequestImplementor . class ) { return service . getRequestImplementor ( ) ; } else if ( type == Workspace . class ) { return service . getWorkspace ( ) ; } else if ( ExecutionContext . class . isAssignableFrom ( type ) ) { return service ; } throw new IllegalStateException ( \"Injectable type \" + type . getName ( ) + \" not known.\" ) ; }'", "label": "'Special case for Injectable type . Injects the required parameter from the ExecutionContext ( service )'"}
{"text": "'public GitMvResponse mv ( File repositoryPath , List < File > sources , File destination ) throws IOException , JavaGitException { CheckUtilities . checkNullArgument ( repositoryPath , \"repository path\" ) ; CheckUtilities . checkNullListArgument ( sources , \"sources\" ) ; CheckUtilities . checkNullArgument ( destination , \"destination\" ) ; //CheckUtilities.checkDirectoryArgument(destination, \"destination\"); IClient client = ClientManager . getInstance ( ) . getPreferredClient ( ) ; IGitMv gitMv = client . getGitMvInstance ( ) ; return gitMv . mv ( repositoryPath , sources , destination ) ; }'", "label": "'Moves the specified source files / symlinks / directories to the destination directory .'"}
{"text": "'public static int indexOfLeft ( String str , int from , char c ) { int pos = - 1 ; int f = from ; while ( f >= 0 && pos == - 1 ) if ( str . charAt ( f -- ) == c ) pos = f + 1 ; return pos ; }'", "label": "'Returns the position for char c in string str starting from position pos and searching towards the string beginning'"}
{"text": "'@ Override public Object getBinderValue ( Service service ) { String providerName = getStringValue ( service . getBinder ( ) ) ; Provider provider = Providers . getProvider ( providerName ) ; if ( this . required && provider == null ) { throw new IllegalArgumentException ( \"Provider \\'\" + providerName + \"\\' could not be found.\" ) ; } // providers that are in error will throw an exception if they are required if ( provider != null && provider . isInError ( ) && this . required ) { throw new IllegalArgumentException ( \"The provider \\'\" + providerName + \"\\' is not configured correctly!\" ) ; } return provider ; }'", "label": "'{'"}
{"text": "'@ Override public Object getArgumentValue ( Object object , Service service ) throws ClassCastException { if ( object instanceof String ) { Provider provider = Providers . getProvider ( ( String ) object ) ; if ( provider != null ) { return provider ; } } return null ; // throw new // ClassCastException(\"Must supply the name of a provider as a string\"); }'", "label": "'Returns a result set found by the passed in string value .'"}
{"text": "'public E get ( final long id ) { SQLiteDatabase database = openDB ( ) ; try { Cursor cursor = database . query ( tableName , null , primaryKey . getName ( ) + \" = ?\" , new String [ ] { Long . toString ( id ) } , null , null , null ) ; if ( cursor . getCount ( ) == 0 ) { return null ; } return CursorOperation . tryOnCursor ( cursor , new CursorOperation < E > ( ) { @ Override public E execute ( final Cursor cursor ) { return CombinedCursorImpl . create ( context , cursor , entityInfo , entityClass ) . getCurrent ( ) ; } } ) ; } finally { closeDB ( database ) ; } }'", "label": "'Gets a specific { @link Entity } according to the given id'"}
{"text": "'public List < E > find ( final String selection , final String [ ] selectionArgs , final String order ) { SQLiteDatabase database = openDB ( ) ; try { Cursor cursor = database . query ( tableName , null , selection , selectionArgs , null , null , order ) ; return CursorOperation . tryOnCursor ( cursor , new CursorOperation < List < E > > ( ) { @ Override public List < E > execute ( final Cursor cursor ) { return new ArrayList < E > ( CombinedCursorImpl . create ( context , cursor , entityInfo , entityClass ) . getAll ( ) ) ; } } ) ; } finally { closeDB ( database ) ; } }'", "label": "'Search for { @link Entity } s in the database with basic SQL WHERE statements .'"}
{"text": "'public void resolveAssociations ( final E data ) { SQLiteDatabase database = openDB ( ) ; try { new DatabaseResolver ( context , database ) . resolve ( data , 0 , Integer . MAX_VALUE ) ; } finally { closeDB ( database ) ; } }'", "label": "'Resolves the associations to a given { @link Entity } object and all underlying associations within the object graph .'"}
{"text": "'public void resolveAssociations ( final E data , final int maxDepth ) { SQLiteDatabase database = openDB ( ) ; try { new DatabaseResolver ( context , database ) . resolve ( data , 0 , maxDepth ) ; } finally { closeDB ( database ) ; } }'", "label": "'Resolves the associations to a given { @link Entity } object . The associations will only be resolved to the given depth within the object graph .'"}
{"text": "'public long save ( final E data , final int maxDepth ) { if ( toggle == ValidationToggle . ON ) { AccumulatedValidationResult validationResult = databaseValidator . validate ( data , maxDepth ) ; if ( ! validationResult . isValid ( ) ) { throw new InvalidEntityException ( validationResult ) ; } } final SQLiteDatabase database = openDB ( ) ; try { return transactional ( database , new DatabaseOperation < Number > ( ) { @ Override public Number execute ( ) { return new DatabaseSaver ( database , maxDepth ) . save ( data ) ; } } ) . longValue ( ) ; } finally { closeDB ( database ) ; } }'", "label": "'Stores the given { @link Entity } to the database . Associated objects will be saved to the given maxDepth . <br > maxDepth of 0 means that only the given { @link Entity } itself will be saved without associations .'"}
{"text": "'public void save ( final Collection < E > data , final int maxDepth ) { if ( toggle == ValidationToggle . ON ) { AccumulatedValidationResult validationResult = databaseValidator . validate ( data , maxDepth ) ; if ( ! validationResult . isValid ( ) ) { throw new InvalidEntityException ( validationResult ) ; } } SQLiteDatabase database = openDB ( ) ; try { final DatabaseSaver databaseSaver = new DatabaseSaver ( database , maxDepth ) ; transactional ( database , new DatabaseOperation < Void > ( ) { @ Override public Void execute ( ) { for ( E object : data ) { databaseSaver . save ( object ) ; } return null ; } } ) ; } finally { closeDB ( database ) ; } }'", "label": "'Stores all given { @link Entity } s in the { @link Collection } to the database . Associated objects will be saved to the given maxDepth . <br > maxDepth of 0 means that only the given { @link Entity } itself will be saved without associations .'"}
{"text": "'public boolean delete ( final E data ) { Number id = getFieldValue ( data , primaryKey ) ; if ( id == null ) { throw new IllegalArgumentException ( \"The @PrimaryKey of the given @Entity can not be null\" ) ; } return delete ( id . longValue ( ) ) ; }'", "label": "'Deletes the given { @link Entity } from the database'"}
{"text": "'public boolean delete ( final long id ) { SQLiteDatabase database = openDB ( ) ; try { int delete = database . delete ( tableName , EntityData . getEntityData ( entityClass ) . primaryKey . getName ( ) + \"= ?\" , new String [ ] { Long . toString ( id ) } ) ; return delete == 1 ; } finally { closeDB ( database ) ; } }'", "label": "'Deletes the data of the { @link Entity } for the given id'"}
{"text": "'@ Override public void inject ( Class < ? > klass ) throws DataException , ServiceException { // loads function def table from annotated class ScriptExtensions extensions = new ScriptProxy ( klass ) ; // load func def table and set parent to the default script context ScriptContext defaultScriptContext = ( ScriptContext ) AppObjectRepository . getObject ( \"DefaultScriptContext\" ) ; extensions . load ( defaultScriptContext ) ; // register these extensions defaultScriptContext . registerExtension ( extensions ) ; }'", "label": "'{'"}
{"text": "'@ Override public Object getBinderValue ( Service service ) { DataResultSet drs = getResultSet ( this . name , service ) ; if ( this . required && drs == null ) { throw new IllegalArgumentException ( \"ResultSet \" + this . name + \" is required.\" ) ; } return drs ; }'", "label": "'{'"}
{"text": "'@ Override public Object getArgumentValue ( Object object , Service service ) throws ClassCastException { if ( object instanceof String ) { DataResultSet drs = getResultSet ( ( String ) object , service ) ; if ( drs != null ) { return drs ; } } return null ; // throw new ClassCastException(\"Must supply the name of a result set as a string\"); }'", "label": "'Returns a result set found by the passed in string value .'"}
{"text": "'private DataResultSet getResultSet ( String name , Service service ) { ResultSet rs = service . getBinder ( ) . getResultSet ( name ) ; DataResultSet drs = new DataResultSet ( ) ; if ( rs != null ) { drs . copy ( rs ) ; return drs ; } return null ; }'", "label": "'Find a result set in the service binder .'"}
{"text": "'public List < Commit > log ( File repositoryPath , GitLogOptions options ) throws JavaGitException , IOException { CheckUtilities . checkFileValidity ( repositoryPath ) ; GitLogParser parser = new GitLogParser ( ) ; List < String > command = buildCommand ( repositoryPath , options ) ; GitLogResponse response = ( GitLogResponse ) ProcessUtilities . runCommand ( repositoryPath , command , parser ) ; if ( response . containsError ( ) ) { int line = response . getError ( 0 ) . getLineNumber ( ) ; String error = response . getError ( 0 ) . error ( ) ; throw new JavaGitException ( 420001 , \"Line \" + line + \", \" + error ) ; } return response . getLog ( ) ; }'", "label": "'Implementations of &lt ; git log&gt ; with options and one file to be added to index .'"}
{"text": "'private List < String > buildCommand ( File repositoryPath , GitLogOptions options ) { List < String > command = new ArrayList < String > ( ) ; command . add ( JavaGitConfiguration . getGitCommand ( ) ) ; command . add ( \"log\" ) ; if ( options != null ) { //General Options /**\\n\\t\\t\\t * Breaks rewrite changes in to pairs of delete and create.\\n\\t\\t\\t */ if ( options . isOptBreakRewriteChanges ( ) ) { command . add ( \"-B\" ) ; } /**\\n\\t\\t\\t * Detects renames\\n\\t\\t\\t */ if ( options . isOptDetectRenames ( ) ) { command . add ( \"-M\" ) ; } /**\\n\\t\\t\\t * Detects copies and renames, of original files\\n\\t\\t\\t */ if ( options . isOptFindCopies ( ) ) { command . add ( \"-C\" ) ; } /**\\n\\t\\t\\t * \\tDetects copies and renames , very expensive operation.\\n\\t\\t\\t */ if ( options . isOptFindCopiesHarder ( ) ) { command . add ( \"--find-copies-harder\" ) ; } /**\\n\\t\\t\\t *  List details about lines modified and files affected in a commit.\\n\\t\\t\\t */ if ( options . isOptFileDetails ( ) ) { command . add ( \"--numstat\" ) ; } /**\\n\\t\\t\\t * \\tList all logs on the relative path.\\n\\t\\t\\t */ if ( options . isOptRelative ( ) ) { command . add ( \"--relative=\" + options . getOptRelativePath ( ) ) ; } /**\\n\\t\\t\\t * \\tList all logs since specified date.\\n\\t\\t\\t */ if ( options . isOptLimitCommitSince ( ) ) { command . add ( \"--since=\" + options . getOptLimitSince ( ) ) ; } /**\\n\\t\\t\\t * \\tList all logs after specified date.\\n\\t\\t\\t */ if ( options . isOptLimitCommitAfter ( ) ) { command . add ( \"--after=\" + options . getOptLimitAfter ( ) ) ; } /**\\n\\t\\t\\t * \\tList all logs after specified date.\\n\\t\\t\\t */ if ( options . isOptLimitCommitUntil ( ) ) { command . add ( \"--until=\" + options . getOptLimitUntil ( ) ) ; } /**\\n\\t\\t\\t * \\tList all logs before specified date.\\n\\t\\t\\t */ if ( options . isOptLimitCommitBefore ( ) ) { command . add ( \"--before=\" + options . getOptLimitBefore ( ) ) ; } /**\\n\\t\\t\\t * \\tList all logs by an author\\n\\t\\t\\t */ if ( options . isOptLimitAuthor ( ) ) { command . add ( \"--author=\" + options . getOptAuthor ( ) ) ; } /**\\n\\t\\t\\t * \\tList all logs by an author/committer header pattern.\\n\\t\\t\\t */ if ( options . isOptLimitCommitterPattern ( ) ) { command . add ( \"--committer=\" + options . getOptLimitPattern ( ) ) ; } /**\\n\\t\\t\\t * \\tList all logs by matching to a grep pattern.\\n\\t\\t\\t */ if ( options . isOptLimitGrep ( ) ) { command . add ( \"--grep=\" + options . getOptLimitGrepPattern ( ) . toString ( ) ) ; } /**\\n\\t\\t\\t * \\tMatch regular expressions with out  regard to letters case.\\n\\t\\t\\t */ if ( options . isOptLimitMatchIgnoreCase ( ) ) { command . add ( \"-i\" ) ; } /**\\n\\t\\t\\t * \\tMatch extended regular expressions.\\n\\t\\t\\t */ if ( options . isOptLimitEnableExtendedRegex ( ) ) { command . add ( \"-E\" ) ; } /**\\n\\t\\t\\t * \\tMatch patterns as fixed strings and not regular expressions.\\n\\t\\t\\t */ if ( options . isOptLimitMatchIgnoreCase ( ) ) { command . add ( \"-F\" ) ; } /**\\n\\t\\t\\t * \\tStop when a path dissapears from the tree.\\n\\t\\t\\t */ if ( options . isOptLimitRemoveEmpty ( ) ) { command . add ( \"--remove-empty\" ) ; } /**\\n\\t\\t\\t * \\tMatch parts of history irrelevant to the current path.\\n\\t\\t\\t */ if ( options . isOptLimitFullHistory ( ) ) { command . add ( \"--full-history\" ) ; } /**\\n\\t\\t\\t * \\tDo not print commits with more than one merges.\\n\\t\\t\\t */ if ( options . isOptLimitNoMerges ( ) ) { command . add ( \"--no-merges\" ) ; } /**\\n\\t\\t\\t * \\tFollow only first parent on seeing a merge.\\n\\t\\t\\t */ if ( options . isOptLimitFirstParent ( ) ) { command . add ( \"--first-parent\" ) ; } /**\\n\\t\\t\\t * \\tOrder commits topologically.\\n\\t\\t\\t */ if ( options . isOptOrderingTopological ( ) ) { command . add ( \"--topo-order\" ) ; } /**\\n\\t\\t\\t * \\tOrder commits in reverse\\n\\t\\t\\t */ if ( options . isOptOrderingReverse ( ) ) { command . add ( \"--reverse\" ) ; } /**\\n\\t\\t\\t * \\tLimits the number of commits to retrieve.\\n\\t\\t\\t */ if ( options . isOptLimitCommitMax ( ) ) { command . add ( \"-n\" ) ; command . add ( String . valueOf ( options . getOptLimitMax ( ) ) ) ; } // Skips the specified number of commit messages if ( options . isOptLimitCommitSkip ( ) ) { command . add ( \"--skip=\" + options . getOptLimitSkip ( ) ) ; } } return command ; }'", "label": "'This function builds the git log commands with necessary options as specified by the user .'"}
{"text": "'public void addCommit ( ) { if ( this . sha != null ) { Commit commit = new Commit ( this . sha , this . mergeDetails , this . author , this . dateString , this . message , this . files ) ; if ( commitList == null ) { commitList = new ArrayList < Commit > ( ) ; } this . commitList . add ( commit ) ; //reset variables for future commits. this . files = null ; this . mergeDetails = null ; this . message = null ; } }'", "label": "'This add a newly created commit object to the list of commits for a log .'"}
{"text": "'public void addFile ( String filename , int linesAdded , int linesDeleted ) { CommitFile commitFile = new CommitFile ( filename , linesAdded , linesDeleted ) ; if ( files == null ) { files = new ArrayList < CommitFile > ( ) ; } this . files . add ( commitFile ) ; }'", "label": "'This adds a file to the list of files affected by a particular commit .'"}
{"text": "'public GitCheckoutResponse checkout ( File repositoryPath , GitCheckoutOptions options , Ref ref ) throws JavaGitException , IOException { CheckUtilities . checkFileValidity ( repositoryPath ) ; checkRefAgainstRefType ( ref , RefType . HEAD ) ; List < String > command = buildCommand ( options , ref ) ; GitCheckoutParser parser = new GitCheckoutParser ( ) ; GitCheckoutResponse response = ( GitCheckoutResponse ) ProcessUtilities . runCommand ( repositoryPath , command , parser ) ; return response ; }'", "label": "'Git checkout with options and base branch information provided to &lt ; git - checkout&gt ; command .'"}
{"text": "'public GitCheckoutResponse checkout ( File repositoryPath ) throws JavaGitException , IOException { GitCheckoutOptions options = null ; return checkout ( repositoryPath , options , null ) ; }'", "label": "'Git checkout without any options and branch information provided . Just a basic checkout command .'"}
{"text": "'public GitCheckoutResponse checkout ( File repositoryPath , Ref branch ) throws JavaGitException , IOException { return checkout ( repositoryPath , null , branch ) ; }'", "label": "'Checks out a branch from the git repository with a given branch name .'"}
{"text": "'public GitCheckoutResponse checkout ( File repositoryPath , List < File > paths ) throws JavaGitException , IOException { CheckUtilities . checkFileValidity ( repositoryPath ) ; CheckUtilities . checkNullListArgument ( paths , \"list of file paths\" ) ; GitCheckoutParser parser = new GitCheckoutParser ( ) ; List < String > command = buildCommand ( null , null , paths ) ; GitCheckoutResponse response = ( GitCheckoutResponse ) ProcessUtilities . runCommand ( repositoryPath , command , parser ) ; return response ; }'", "label": "'Checks out a list of files from repository no checkout options provided .'"}
{"text": "'public GitCheckoutResponse checkout ( File repositoryPath , GitCheckoutOptions options , Ref ref , List < File > paths ) throws JavaGitException , IOException { CheckUtilities . checkFileValidity ( repositoryPath ) ; if ( ref != null && ref . getRefType ( ) == RefType . HEAD ) { throw new IllegalArgumentException ( \"Invalid ref type passed as argument to checkout\" ) ; } GitCheckoutParser parser = new GitCheckoutParser ( ) ; List < String > command = buildCommand ( options , ref , paths ) ; return ( GitCheckoutResponse ) ProcessUtilities . runCommand ( repositoryPath , command , parser ) ; }'", "label": "'Checks out a list of file from repository with &lt ; tree - ish&gt ; options provided .'"}
{"text": "'public GitCheckoutResponse checkout ( File repositoryPath , GitCheckoutOptions options , Ref branch , File path ) throws JavaGitException , IOException { CheckUtilities . checkFileValidity ( repositoryPath ) ; GitCheckoutParser parser = new GitCheckoutParser ( ) ; List < File > paths = new ArrayList < File > ( ) ; paths . add ( path ) ; List < String > command = buildCommand ( options , branch , paths ) ; GitCheckoutResponse response = ( GitCheckoutResponse ) ProcessUtilities . runCommand ( repositoryPath , command , parser ) ; return response ; }'", "label": "'Checks out a file from repository from a particular branch'"}
{"text": "'private void checkRefAgainstRefType ( Ref ref , RefType refType ) { if ( ref != null && ref . getRefType ( ) == refType ) { throw new IllegalArgumentException ( \"Invalid ref type passed as argument to checkout\" ) ; } }'", "label": "'This is just a test method for verifying that a given ref is not of refType provided as one of the parameters .'"}
{"text": "'private List < String > buildCommand ( GitCheckoutOptions options , Ref treeIsh , List < File > paths ) throws JavaGitException { List < String > command = new ArrayList < String > ( ) ; command . add ( JavaGitConfiguration . getGitCommand ( ) ) ; command . add ( \"checkout\" ) ; // Process options if ( options != null ) { processOptions ( command , options ) ; } // Process tree-ish if ( treeIsh != null ) { command . add ( treeIsh . getName ( ) ) ; } // return if no file-paths are provided if ( paths == null ) { return command ; } command . add ( \"--\" ) ; for ( File file : paths ) { command . add ( file . getName ( ) ) ; } return command ; }'", "label": "'builds a &lt ; git - checkout&gt ; command in sth <code > List<String > < / code > format .'"}
{"text": "'public List < GitFileSystemObject > getChildren ( ) throws IOException , JavaGitException { List < GitFileSystemObject > children = new ArrayList < GitFileSystemObject > ( ) ; // get all of the file system objects currently located under this directory for ( File memberFile : file . listFiles ( ) ) { // check if this file is hidden also some times the .git and  //other unix hidden directories are not hidden in Windows if ( memberFile . isHidden ( ) || memberFile . getName ( ) . startsWith ( \".\" ) ) { // ignore (could be .git directory) continue ; } // now, just check for the type of the filesystem object if ( memberFile . isDirectory ( ) ) { children . add ( new GitDirectory ( memberFile , workingTree ) ) ; } else { children . add ( new GitFile ( memberFile , workingTree ) ) ; } } return children ; }'", "label": "'Gets the children of this directory .'"}
{"text": "'public File getRemovedFile ( int index ) { CheckUtilities . checkIntIndexInListRange ( removedFiles , index ) ; return removedFiles . get ( index ) ; }'", "label": "'Gets the file at the specified index from the removed file list .'"}
{"text": "'public GitCheckoutResponse checkout ( File repositoryPath , List < File > paths ) throws IOException , JavaGitException { CheckUtilities . checkFileValidity ( repositoryPath ) ; CheckUtilities . checkNullListArgument ( paths , \"List of Paths\" ) ; IClient client = ClientManager . getInstance ( ) . getPreferredClient ( ) ; IGitCheckout gitCheckout = client . getGitCheckoutInstance ( ) ; return gitCheckout . checkout ( repositoryPath , paths ) ; }'", "label": "'For checking a file or list of files from a branch .'"}
{"text": "'public GitCheckoutResponse checkout ( File repositoryPath , Ref ref , List < File > paths ) throws JavaGitException , IOException { CheckUtilities . checkFileValidity ( repositoryPath ) ; if ( ref != null && ( ref . getRefType ( ) != RefType . BRANCH && ref . getRefType ( ) != RefType . SHA1 ) ) { throw new JavaGitException ( 100000 , ExceptionMessageMap . getMessage ( \"100000\" ) + \" RefType passed: \" + ref . getRefType ( ) ) ; } CheckUtilities . checkNullListArgument ( paths , \"List of files\" ) ; IClient client = ClientManager . getInstance ( ) . getPreferredClient ( ) ; IGitCheckout gitCheckout = client . getGitCheckoutInstance ( ) ; return gitCheckout . checkout ( repositoryPath , ref , paths ) ; }'", "label": "'Checks out files from the repository when a tree - ish object is given as the reference .'"}
{"text": "'public void setComment ( int lineNumber , String commentString ) { ResponseString comment = new ResponseString ( lineNumber , commentString ) ; comments . add ( comment ) ; }'", "label": "'Sets the non - error message generated in the output of the &lt ; git - add&gt ; command .'"}
{"text": "'public GitBranchResponseImpl branchProcess ( File repoPath , GitBranchOptions options , Ref arg1 , Ref arg2 , List < Ref > branchList ) throws IOException , JavaGitException { CheckUtilities . checkNullArgument ( repoPath , \"repository path\" ) ; List < String > commandLine = buildCommand ( options , arg1 , arg2 , branchList ) ; GitBranchParser parser = new GitBranchParser ( ) ; return ( GitBranchResponseImpl ) ProcessUtilities . runCommand ( repoPath , commandLine , parser ) ; }'", "label": "'Process the git - branch command to show / delete / create / rename branches .'"}
{"text": "'protected List < String > buildCommand ( GitBranchOptions options , Ref arg1 , Ref arg2 , List < Ref > branchList ) { List < String > cmd = new ArrayList < String > ( ) ; cmd . add ( JavaGitConfiguration . getGitCommand ( ) ) ; cmd . add ( \"branch\" ) ; if ( null != options ) { Ref commit = options . getOptContains ( ) ; if ( null != commit ) { cmd . add ( \"--contains\" ) ; cmd . add ( commit . getName ( ) ) ; } if ( options . isOptVerbose ( ) ) { cmd . add ( \"--verbose\" ) ; } if ( options . isOptAbbrev ( ) ) { if ( options . getOptAbbrevLen ( ) != GitBranchOptions . DEFAULT_ABBREV_LEN ) { cmd . add ( \"--abbrev=\" + Integer . toString ( options . getOptAbbrevLen ( ) ) ) ; } else { cmd . add ( \"--abbrev\" ) ; } } if ( options . isOptNoAbbrev ( ) ) { cmd . add ( \"--no-abbrev\" ) ; } if ( options . isOptA ( ) ) { cmd . add ( \"-a\" ) ; } if ( options . isOptDLower ( ) ) { cmd . add ( \"-d\" ) ; } if ( options . isOptMLower ( ) ) { cmd . add ( \"-m\" ) ; } if ( options . isOptDUpper ( ) ) { cmd . add ( \"-D\" ) ; } if ( options . isOptMUpper ( ) ) { cmd . add ( \"-M\" ) ; } if ( options . isOptColor ( ) ) { cmd . add ( \"--color\" ) ; } if ( options . isOptNoColor ( ) ) { cmd . add ( \"--no-color\" ) ; } if ( options . isOptF ( ) ) { cmd . add ( \"-f\" ) ; } if ( options . isOptL ( ) ) { cmd . add ( \"-l\" ) ; } if ( options . isOptMerged ( ) ) { cmd . add ( \"--merged\" ) ; } if ( options . isOptNoMerged ( ) ) { cmd . add ( \"--no-merged\" ) ; } if ( options . isOptR ( ) ) { cmd . add ( \"-r\" ) ; } if ( options . isOptTrack ( ) ) { cmd . add ( \"--track\" ) ; } if ( options . isOptNoTrack ( ) ) { cmd . add ( \"--no-track\" ) ; } } if ( null != branchList ) { if ( ( null != arg1 ) || ( null != arg2 ) ) { throw new IllegalArgumentException ( ) ; } for ( Ref branch : branchList ) { cmd . add ( branch . getName ( ) ) ; } } else { if ( null != arg1 ) { cmd . add ( arg1 . getName ( ) ) ; } if ( null != arg2 ) { cmd . add ( arg2 . getName ( ) ) ; } } return cmd ; }'", "label": "'Builds a list of command arguments to pass to <code > ProcessBuilder< / code > .'"}
{"text": "'public void setDeleteOptions ( GitBranchOptions options , boolean forceDelete , boolean remote ) { if ( forceDelete ) { options . setOptDUpper ( true ) ; } else { options . setOptDLower ( true ) ; } if ( remote ) { options . setOptR ( true ) ; } }'", "label": "'Sets the options for delete .'"}
{"text": "'@ Override public void inject ( Class < ? > klass ) throws DataException { Method [ ] classMethods = klass . getMethods ( ) ; for ( Method method : classMethods ) { ServiceMethod annotation = ( ServiceMethod ) method . getAnnotation ( ServiceMethod . class ) ; if ( annotation != null ) { injectServiceMethod ( method , annotation ) ; } } }'", "label": "'Inject a service into the service manager registry .'"}
{"text": "'private static void injectServiceMethod ( Method method , ServiceMethod annotation ) throws DataException { ServiceData serviceData = new ServiceData ( ) ; String template = annotation . template ( ) ; int accessLevel = annotation . accessLevel ( ) ; String serviceType = ( ! annotation . type ( ) . equals ( \"\" ) ) ? annotation . type ( ) : null ; String errorMessage = annotation . errorMessage ( ) ; String subjects = annotation . subjects ( ) ; String serviceName = annotation . name ( ) ; try { serviceData . init ( serviceName , ServiceProxy . class . getName ( ) , accessLevel , template , serviceType , errorMessage , subjects ) ; } catch ( Exception e ) { throw new DataException ( \"Cannot create ServiceData object for \" + serviceName + \" - \" + e . getMessage ( ) ) ; } // action parameters, none by default String controlFlags = \"\" ; String methodHashCode = MethodRegistry . addMethod ( method ) ; if ( methodHashCode == null ) { throw new DataException ( \"Cannot register method \" + method . toString ( ) + \" because it has a null hashCode\" ) ; } try { serviceData . addAction ( Action . CODE_TYPE , \"delegateWithParameters\" , methodHashCode , controlFlags , \"\" ) ; } catch ( DataException e ) { throw new DataException ( \"Cannot add defaut action to service\" + serviceName + \" - \" + e . getMessage ( ) ) ; } // inject service ServiceManager . putService ( serviceName , serviceData ) ; }'", "label": "'Injects a single UCMService annotation into the ServiceManager registry .'"}
{"text": "'public static Ref createBranchRef ( String name ) { CheckUtilities . checkStringArgument ( name , \"name\" ) ; Ref cn = new Ref ( ) ; cn . refType = RefType . BRANCH ; cn . name = name ; return cn ; }'", "label": "'Creates a <code > Ref< / code > of type <code > BRANCH< / code > .'"}
{"text": "'public static Ref createHeadRef ( int headOffset ) { CheckUtilities . checkIntArgumentGreaterThan ( headOffset , - 1 , \"headOffset\" ) ; if ( 0 == headOffset ) { return HEAD ; } else if ( 1 == headOffset ) { return HEAD_1 ; } Ref cn = new Ref ( ) ; cn . refType = RefType . HEAD ; cn . headOffset = headOffset ; return cn ; }'", "label": "'Creates a <code > Ref< / code > of type <code > HEAD< / code > .'"}
{"text": "'public static Ref createRemoteRef ( String repositoryName , String name ) { CheckUtilities . checkStringArgument ( name , \"name\" ) ; Ref cn = new Ref ( ) ; cn . refType = RefType . REMOTE ; cn . name = name ; if ( null != repositoryName && repositoryName . length ( ) > 0 ) { cn . repositoryName = repositoryName ; } return cn ; }'", "label": "'Creates a <code > Ref< / code > of type <code > REMOTE< / code > .'"}
{"text": "'public static Ref createSha1Ref ( String name ) { CheckUtilities . checkStringArgument ( name , \"name\" ) ; Ref cn = new Ref ( ) ; cn . refType = RefType . SHA1 ; cn . name = name ; return cn ; }'", "label": "'Creates a <code > Ref< / code > of type <code > SHA1< / code > .'"}
{"text": "'public static Ref createTagRef ( String name ) { CheckUtilities . checkStringArgument ( name , \"name\" ) ; Ref cn = new Ref ( ) ; cn . refType = RefType . TAG ; cn . name = name ; return cn ; }'", "label": "'Creates a <code > Ref< / code > of type <code > TAG< / code > .'"}
{"text": "'public void setOptB ( Ref newBranch ) { CheckUtilities . validateArgumentRefType ( newBranch , RefType . BRANCH , \"New Branch Name\" ) ; optB = newBranch ; }'", "label": "'Sets the name of the new branch that need to be created from the base branch .'"}
{"text": "'public GitCloneResponseImpl cloneProcess ( File workingDirectoryPath , GitCloneOptions options , URL repository , File directory ) throws IOException , JavaGitException { List < String > commandLine = buildCommand ( options , repository , directory ) ; GitCloneParser parser = new GitCloneParser ( ) ; return ( GitCloneResponseImpl ) ProcessUtilities . runCommand ( workingDirectoryPath , commandLine , parser ) ; }'", "label": "'Process the git - clone command to make a clone of the git repository .'"}
{"text": "'protected List < String > buildCommand ( GitCloneOptions options , URL repository , File directory ) { List < String > cmd = new ArrayList < String > ( ) ; cmd . add ( JavaGitConfiguration . getGitCommand ( ) ) ; cmd . add ( \"clone\" ) ; return cmd ; }'", "label": "'Builds a list of command arguments to pass to <code > ProcessBuilder< / code > .'"}
{"text": "'public int doFilter ( Workspace ws , DataBinder binder , ExecutionContext ctx ) throws DataException , ServiceException { String configFileName = ( String ) ctx . getCachedObject ( \"filterParameter\" ) ; try { ClassLoader cl = getClass ( ) . getClassLoader ( ) ; Enumeration < URL > propFiles = cl . getResources ( configFileName ) ; // There should be at least one entry (TwineLib contains an example file) if ( ! propFiles . hasMoreElements ( ) ) { propFiles = getResources11g ( cl , configFileName ) ; } while ( propFiles . hasMoreElements ( ) ) { URL propFile = propFiles . nextElement ( ) ; if ( SystemUtils . m_verbose ) { SystemUtils . trace ( \"twine\" , \"Loading config file: \" + propFile . toString ( ) ) ; } IClassInjector filterInjector = new FilterInjector ( ) ; filterInjector . injectClasses ( propFile ) ; IClassInjector serviceInjector = new ServiceInjector ( ) ; serviceInjector . injectClasses ( propFile ) ; IClassInjector scriptInjector = new IdocScriptInjector ( ) ; scriptInjector . injectClasses ( propFile ) ; } } catch ( IOException e ) { // TODO Auto-generated catch block e . printStackTrace ( ) ; } return CONTINUE ; }'", "label": "'Begins injection of filters including the Service and IdocScript injectors required to load other ucm entities .'"}
{"text": "'private Enumeration < URL > getResources11g ( ClassLoader classLoader , String configFileName ) { List < URL > newProps = new ArrayList < URL > ( ) ; if ( classLoader . getClass ( ) . getSimpleName ( ) . equalsIgnoreCase ( \"IdcClassLoader\" ) ) { try { Field field = classLoader . getClass ( ) . getField ( \"m_zipfiles\" ) ; @ SuppressWarnings ( \"unchecked\" ) Map < String , IdcZipFile > zipFiles = ( Map < String , IdcZipFile > ) field . get ( classLoader ) ; for ( Entry < String , IdcZipFile > entry : zipFiles . entrySet ( ) ) { if ( entry . getValue ( ) . m_entries . get ( configFileName ) != null ) { String jarFile = entry . getKey ( ) ; // windows needs a slash before the C:/ if ( ! jarFile . startsWith ( \"/\" ) ) { jarFile = \"/\" + jarFile ; } try { URL u = new URL ( \"jar:file:\" + entry . getKey ( ) + \"!/\" + configFileName ) ; newProps . add ( u ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } } } } catch ( Exception e ) { // If there is any exception the ClassLoader is an unrecognised format e . printStackTrace ( ) ; } } return Collections . enumeration ( newProps ) ; }'", "label": "'Replacement for getResources which works on 11g .'"}
{"text": "'private List < String > buildCommand ( File repoDirectory , GitInitOptions options ) { List < String > command = new ArrayList < String > ( ) ; command . add ( JavaGitConfiguration . getGitCommand ( ) ) ; command . add ( \"init\" ) ; if ( options != null ) { if ( options . isOptBare ( ) ) { command . add ( \"--bare\" ) ; } if ( options . isOptTemplate ( ) ) { command . add ( \"--template=\" + options . getOptTemplateDirecory ( ) ) ; } if ( options . isOptSharedUmask ( ) ) { command . add ( \"--shared=\" ) ; } if ( options . isOptSharedGroup ( ) ) { command . add ( \"--shared=\" + options . getOptSharedGroupName ( ) ) ; } if ( options . isOptSharedAll ( ) ) { command . add ( \"--shared=\" ) ; } if ( options . isOptSharedOctal ( ) ) { command . add ( \"--shared=\" + options . getOptSharedOctalValue ( ) ) ; } } return command ; }'", "label": "'/ * Build the command to be executed using the Git Init method'"}
{"text": "'private void setup ( ResetType resetType , Ref commitName ) { CheckUtilities . checkNullArgument ( resetType , \"resetType\" ) ; CheckUtilities . checkNullArgument ( commitName , \"commitName\" ) ; this . resetType = resetType ; this . commitName = commitName ; }'", "label": "'Central instance construction setup method .'"}
{"text": "'public static String addMethod ( Method m ) { if ( methods == null ) { methods = new HashMap < String , Method > ( ) ; } String hashCode = String . valueOf ( m . hashCode ( ) ) ; if ( ! methods . containsKey ( hashCode ) ) { methods . put ( hashCode , m ) ; } return String . valueOf ( m . hashCode ( ) ) ; }'", "label": "'Adds a method to the registry and returns the UUID .'"}
{"text": "'public List < Class < ? > > enumerateClasses ( URL propertiesFile , String prefix ) { // find mapped service classes in service.properties Properties properties = new Properties ( ) ; InputStream is = null ; try { is = propertiesFile . openStream ( ) ; if ( is != null ) { properties . load ( is ) ; } } catch ( IOException e ) { Log . warn ( e . getMessage ( ) ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException ignore ) { } } } List < Class < ? > > classes = new ArrayList < Class < ? > > ( ) ; if ( properties . size ( ) > 0 ) { for ( Object key : properties . keySet ( ) ) { if ( key . toString ( ) . startsWith ( prefix ) ) { try { // does the class resolve? Class < ? > klass = Class . forName ( properties . get ( key ) . toString ( ) ) ; // if so, add it classes . add ( klass ) ; } catch ( ClassNotFoundException e ) { Log . warn ( \"Unable to find class [\" + properties . get ( key ) . toString ( ) + \"]\" ) ; } } } } return classes ; }'", "label": "'{'"}
{"text": "'public void injectClasses ( List < Class < ? > > classes ) { for ( Class < ? > klass : classes ) { try { inject ( klass ) ; } catch ( Exception e ) { String msg = \"Failed to inject: \" + klass . getName ( ) . toString ( ) + \" - \" + e . getMessage ( ) ; Log . warn ( msg ) ; SystemUtils . trace ( \"twine\" , msg ) ; } } }'", "label": "'{'"}
{"text": "'public void injectClasses ( URL propertiesFile , String prefix ) { List < Class < ? > > classes = enumerateClasses ( propertiesFile , prefix ) ; injectClasses ( classes ) ; }'", "label": "'{'"}
{"text": "'public int doFilter ( Workspace ws , DataBinder binder , ExecutionContext ctx ) throws DataException , ServiceException { Object returnVal = null ; try { String methodID = ( String ) ctx . getCachedObject ( \"filterParameter\" ) ; Method m = MethodRegistry . getMethod ( methodID ) ; ParameterMarshaller marshaller = new ParameterMarshaller ( m ) ; Object [ ] params = marshaller . getValueArray ( ws , binder , ctx ) ; Object context = m . getDeclaringClass ( ) . newInstance ( ) ; returnVal = m . invoke ( context , params ) ; } catch ( IllegalArgumentException e ) { throw new DataException ( e . getMessage ( ) , e ) ; } catch ( Exception e ) { throw new ServiceException ( e . getMessage ( ) , e ) ; } if ( returnVal != null && returnVal instanceof Integer ) { return ( ( Integer ) returnVal ) . intValue ( ) ; } return CONTINUE ; }'", "label": "'Main entry point which will delegate to the filter method with dependency injection .'"}
{"text": "'public SQLiteDatabase getDatabaseConnection ( ) { synchronized ( LOCK ) { if ( dbConnection == null ) { OPEN_CONNECTIONS . set ( 0 ) ; dbConnection = super . getWritableDatabase ( ) ; } OPEN_CONNECTIONS . incrementAndGet ( ) ; return dbConnection ; } }'", "label": "'Gives you a database connection you can access the database with . <br > Don t forget to call reduceDatabaseConnection when you are done with the connection .'"}
{"text": "'public void reduceDatabaseConnection ( ) { synchronized ( LOCK ) { int numberOfOpenConnections = OPEN_CONNECTIONS . decrementAndGet ( ) ; if ( numberOfOpenConnections == 0 && dbConnection != null ) { dbConnection . close ( ) ; dbConnection = null ; } } }'", "label": "'Reduce the connection opened . This should always be called after calling getDatabaseConnection and only after that .'"}
{"text": "'public < T > T functionOnDatabase ( DbFunction < T > dbFunction ) { SQLiteDatabase db = getDatabaseConnection ( ) ; try { return dbFunction . apply ( db ) ; } finally { reduceDatabaseConnection ( ) ; } }'", "label": "'Execute a function on the database to return some values . The opening and closing of the database connection is handled for you . <br > Note if you want to query a cursor from the database consider using the { @code DbCreator#query } or { @code DbCreator#rawQuery } method . <br > This can be useful when working with { @code CursorAdapter }'"}
{"text": "'public void consumeDatabase ( DbConsumer dbConsumer ) { SQLiteDatabase db = getDatabaseConnection ( ) ; try { dbConsumer . consume ( db ) ; } finally { reduceDatabaseConnection ( ) ; } }'", "label": "'Execute an action on the database . The opening and closing of the database connection is handled for you .'"}
{"text": "'public Cursor query ( String table , String [ ] columns , String selection , String [ ] selectionArgs , String groupBy , String having , String orderBy ) { SQLiteDatabase db = getDatabaseConnection ( ) ; return new DbClosingCursor ( db . query ( table , columns , selection , selectionArgs , groupBy , having , orderBy ) , this ) ; }'", "label": "'Executes a query on the database . Note that when calling close on the returned cursor the database connection count is reduces as well .'"}
{"text": "'public Cursor rawQuery ( String sql ) { SQLiteDatabase db = getDatabaseConnection ( ) ; return new DbClosingCursor ( db . rawQuery ( sql , null ) , this ) ; }'", "label": "'Executes a raw query on the database . Note that when calling close on the returned cursor the database connection count is reduces as well .'"}
{"text": "'public GitRmResponse rm ( File repository , File path ) throws IOException , JavaGitException { return processRm ( repository , null , path , null ) ; }'", "label": "'TODO ( jhl388 ) : Add test cases for this class .'"}
{"text": "'private GitRmResponse processRm ( File repository , GitRmOptions options , File path , List < File > paths ) throws IOException , JavaGitException { List < String > cmdline = buildCommandLine ( options , path , paths ) ; GitRmParser parser = new GitRmParser ( ) ; return ( GitRmResponse ) ProcessUtilities . runCommand ( repository , cmdline , parser ) ; }'", "label": "'Processes an incoming <code > GitRm< / code > request .'"}
{"text": "'private List < String > buildCommandLine ( GitRmOptions options , File path , List < File > paths ) { List < String > cmdline = new ArrayList < String > ( ) ; cmdline . add ( JavaGitConfiguration . getGitCommand ( ) ) ; cmdline . add ( \"rm\" ) ; if ( null != options ) { if ( options . isOptCached ( ) ) { cmdline . add ( \"--cached\" ) ; } if ( options . isOptF ( ) ) { cmdline . add ( \"-f\" ) ; } if ( options . isOptN ( ) ) { cmdline . add ( \"-n\" ) ; } if ( options . isOptQ ( ) ) { cmdline . add ( \"-q\" ) ; } if ( options . isOptR ( ) ) { cmdline . add ( \"-r\" ) ; } } if ( null != path ) { cmdline . add ( path . getPath ( ) ) ; } else { for ( File f : paths ) { cmdline . add ( f . getPath ( ) ) ; } } return cmdline ; }'", "label": "'Builds the command line .'"}
{"text": "'public File getAddedFile ( int index ) { CheckUtilities . checkIntIndexInListRange ( addedFiles , index ) ; return addedFiles . get ( index ) ; }'", "label": "'Returns the file at a given location in the addedFiles list'"}
{"text": "'public File getDeletedFile ( int index ) { CheckUtilities . checkIntIndexInListRange ( deletedFiles , index ) ; return deletedFiles . get ( index ) ; }'", "label": "'Returns the file at a given location in the deletedFiles list'"}
{"text": "'public File getModifiedFile ( int index ) { CheckUtilities . checkIntIndexInListRange ( modifiedFiles , index ) ; return modifiedFiles . get ( index ) ; }'", "label": "'Returns the file at a given location in the modifiedFiles list .'"}
{"text": "'public Status getStatus ( ) throws IOException , JavaGitException { GitStatus gitStatus = new GitStatus ( ) ; // run git-status command return gitStatus . getFileStatus ( workingTree . getPath ( ) , relativePath ) ; }'", "label": "'Show object s status in the working directory'"}
{"text": "'public List < Commit > getLog ( ) throws JavaGitException , IOException { GitLog gitLog = new GitLog ( ) ; GitLogOptions options = new GitLogOptions ( ) ; options . setOptRelative ( true , this . relativePath . toString ( ) ) ; return gitLog . log ( this . file ) ; }'", "label": "'Show commit logs'"}
{"text": "'protected static HeadElement getHead ( ) { if ( head == null ) { final Element element = Document . get ( ) . getElementsByTagName ( \"head\" ) . getItem ( 0 ) ; assert element != null : \"HTML Head element required\" ; final HeadElement head = HeadElement . as ( element ) ; AbstractInjector . head = head ; } return AbstractInjector . head ; }'", "label": "'Gets the document header .'"}
{"text": "'public static void inject ( String javascript ) { HeadElement head = getHead ( ) ; ScriptElement element = createScriptElement ( ) ; element . setText ( javascript ) ; head . appendChild ( element ) ; }'", "label": "'Injects the JavaScript code into a { @code <script type = text / javascript > ... < / script > } element in the document header .'"}
{"text": "'public void addFile ( String fileName , Integer fileSize , String thumbnailUrl ) { addFileNative ( getElement ( ) , fileName , fileSize , thumbnailUrl ) ; }'", "label": "'Add file information manually to Dropzone . Added file is not uploaded it is just shown in the dropzone . This feature is useful for displaying e . g . files that already exists on the server .'"}
{"text": "'public ArrayList < File > getFiles ( ) { //TODO Why ArrayList, change to list when in a proper IDE final JsArray < FileJS > filesJS = getFilesNative ( getElement ( ) ) ; final ArrayList < File > files = new ArrayList < File > ( ) ; if ( filesJS != null ) { for ( int i = 0 ; i < filesJS . length ( ) ; i ++ ) { files . add ( filesJS . get ( i ) ) ; } } return files ; }'", "label": "'Return array if all files added to dropzone .'"}
{"text": "'public int getFilesCount ( ) { final JsArray < FileJS > files = getFilesNative ( getElement ( ) ) ; return files != null ? files . length ( ) : 0 ; }'", "label": "'Return number of added files .'"}
{"text": "\"public boolean matches ( String string ) { String src = string ; final boolean result ; if ( _compiledPattern . length == 1 ) { // Shortcut for pattern '*', '?' and patterns not containing any wildcard final GlobPattern pattern = _compiledPattern [ 0 ] ; if ( pattern . getType ( ) == GLOB_MULTIPLE ) { result = true ; } else if ( pattern . getType ( ) == GLOB_SINGLE ) { result = src . length ( ) == 1 ; } else { if ( _caseInSensitive ) { result = src . equalsIgnoreCase ( pattern . getText ( ) ) ; } else { result = src . equals ( pattern . getText ( ) ) ; } } } else if ( _compiledPattern . length == 2 ) { // Shortcuts for common patterns '*something' and 'something*' final GlobPattern pattern1 = _compiledPattern [ 0 ] ; final GlobPattern pattern2 = _compiledPattern [ 1 ] ; if ( _caseInSensitive ) { src = src . toLowerCase ( ) ; } if ( pattern1 . getType ( ) == TEXT ) { result = src . startsWith ( pattern1 . getText ( ) ) && ( pattern2 . getType ( ) == GLOB_MULTIPLE || src . length ( ) == pattern1 . getTextLength ( ) + 1 ) ; } else { result = src . endsWith ( pattern2 . getText ( ) ) && ( pattern1 . getType ( ) == GLOB_MULTIPLE || src . length ( ) == pattern2 . getTextLength ( ) + 1 ) ; } } else { result = matches ( src . toCharArray ( ) ) ; } return result ; }\"", "label": "'Match the given string .'"}
{"text": "'private void compilePattern ( ) throws ParseException { StringBuilder sb = new StringBuilder ( ) ; boolean escaped = false ; final List < GlobPattern > patterns = new ArrayList <> ( ) ; for ( int a = 0 ; a < _patternSource . length ( ) ; a ++ ) { final char c = _patternSource . charAt ( a ) ; // Test escape-char if ( c == \\' \\' ) { if ( escaped ) { sb . append ( \\' \\' ) ; escaped = false ; } else { escaped = true ; } } else { if ( escaped ) { if ( c != GLOB_SINGLE && c != GLOB_MULTIPLE ) { sb . append ( \"\\\\\\\\\" ) ; } else { // Globbing chars escaped sb . append ( c ) ; escaped = false ; } } else { // No escape character, test whether it matches on of the globbing characters. if ( c == GLOB_MULTIPLE || c == GLOB_SINGLE ) { if ( sb . length ( ) > 0 ) { patterns . add ( new GlobPattern ( TEXT , sb . toString ( ) ) ) ; sb = new StringBuilder ( ) ; } patterns . add ( new GlobPattern ( c ) ) ; } else { sb . append ( c ) ; } } } } if ( sb . length ( ) > 0 ) { patterns . add ( new GlobPattern ( TEXT , sb . toString ( ) ) ) ; } // Add meta information and correct the elements addMetaInformation ( patterns ) ; _compiledPattern = new GlobPattern [ patterns . size ( ) ] ; patterns . toArray ( _compiledPattern ) ; }'", "label": "'Compile the pattern into the strings [] and wildcard [] arrays .'"}
{"text": "'@ Override @ OverridingMethodsMustInvokeSuper protected void updateListAfterPut ( CacheEntry < K , V > newEntry ) { if ( _last == null ) { _last = newEntry ; _first = newEntry ; } else { _first . setPrevious ( newEntry ) ; newEntry . setNext ( _first ) ; setFirst ( newEntry ) ; } }'", "label": "'Add the new CacheEntry <b > before< / b > the rest .'"}
{"text": "'@ Override protected void updateListAfterHit ( CacheEntry < K , V > entry ) { if ( entry != null && ! entry . equals ( _first ) ) { if ( entry . equals ( _last ) ) { setLast ( entry . getPrevious ( ) ) ; } else { final CacheEntry < K , V > previous = entry . getPrevious ( ) ; final CacheEntry < K , V > next = entry . getNext ( ) ; previous . setNext ( next ) ; next . setPrevious ( previous ) ; } _first . setPrevious ( entry ) ; entry . setNext ( _first ) ; setFirst ( entry ) ; } }'", "label": "'Move the entry to the beginning of the LinkedList .'"}
{"text": "'protected void removeLast ( ) { final CacheEntry < K , V > entry ; synchronized ( _lock ) { if ( _last != null ) { entry = _entries . remove ( _last . getKey ( ) ) ; setLast ( _last . getPrevious ( ) ) ; } else { entry = null ; } if ( size ( ) == 0 ) { _first = null ; _last = null ; } } if ( entry != null ) { handleRemove ( entry ) ; } }'", "label": "'Remove the last element from the cache .'"}
{"text": "'@ SuppressWarnings ( \"UnnecessaryUnboxing\" ) public void cleanUpLifetimeExpired ( ) { final long currentTime = currentTimeMillis ( ) ; // Test whether there could be an element that has to be removed if ( _nearstExpiringTime > 0 && _nearstExpiringTime <= currentTime ) { // Go through all elements and remove elements that are outdated final List < K > keysToRemove = new ArrayList <> ( ) ; synchronized ( _lock ) { _nearstExpiringTime = 0 ; for ( final CacheEntry < K , V > cacheEntry : _entries . values ( ) ) { final Long expire = cacheEntry . getExpire ( ) ; if ( expire != null ) { final long unboxedExpire = expire . longValue ( ) ; if ( unboxedExpire <= currentTime ) { keysToRemove . add ( cacheEntry . getKey ( ) ) ; } else if ( _nearstExpiringTime == 0 || unboxedExpire < _nearstExpiringTime ) { _nearstExpiringTime = unboxedExpire ; } } } for ( final K key : keysToRemove ) { removeInternal ( key ) ; } } } }'", "label": "'Remove entries that are out of their maxLifetime .'"}
{"text": "'byte [ ] generateReply ( Message query , byte [ ] in , int length , Socket s ) throws IOException { final Header header ; final int maxLength ; int flags = 0 ; header = query . getHeader ( ) ; if ( header . getFlag ( Flags . QR ) ) { return null ; } if ( header . getRcode ( ) != Rcode . NOERROR ) { return errorMessage ( query , Rcode . FORMERR ) ; } if ( header . getOpcode ( ) != Opcode . QUERY ) { return errorMessage ( query , Rcode . NOTIMP ) ; } final Record queryRecord = query . getQuestion ( ) ; final TSIGRecord queryTSIG = query . getTSIG ( ) ; TSIG tsig = null ; if ( queryTSIG != null ) { tsig = _tsigs . get ( queryTSIG . getName ( ) ) ; if ( tsig == null || tsig . verify ( query , in , length , null ) != Rcode . NOERROR ) { return formerrMessage ( in ) ; } } final OPTRecord queryOPT = query . getOPT ( ) ; if ( queryOPT != null && queryOPT . getVersion ( ) > 0 ) { } if ( s != null ) { maxLength = 65535 ; } else if ( queryOPT != null ) { maxLength = Math . max ( queryOPT . getPayloadSize ( ) , 512 ) ; } else { maxLength = 512 ; } if ( queryOPT != null && ( queryOPT . getFlags ( ) & ExtendedFlags . DO ) != 0 ) { flags = FLAG_DNSSECOK ; } final Message response = new Message ( query . getHeader ( ) . getID ( ) ) ; response . getHeader ( ) . setFlag ( Flags . QR ) ; if ( query . getHeader ( ) . getFlag ( Flags . RD ) ) { response . getHeader ( ) . setFlag ( Flags . RD ) ; } response . addRecord ( queryRecord , Section . QUESTION ) ; final Name name = queryRecord . getName ( ) ; final int type = queryRecord . getType ( ) ; final int dclass = queryRecord . getDClass ( ) ; if ( type == Type . AXFR && s != null ) { return doAXFR ( name , query , tsig , queryTSIG , s ) ; } if ( ! Type . isRR ( type ) && type != Type . ANY ) { return errorMessage ( query , Rcode . NOTIMP ) ; } final byte rcode = addAnswer ( response , name , type , dclass , 0 , flags ) ; if ( rcode != Rcode . NOERROR && rcode != Rcode . NXDOMAIN ) { return errorMessage ( query , rcode ) ; } addAdditional ( response , flags ) ; if ( queryOPT != null ) { final int optflags = ( flags == FLAG_DNSSECOK ) ? ExtendedFlags . DO : 0 ; final OPTRecord opt = new OPTRecord ( ( short ) 4096 , rcode , ( byte ) 0 , optflags ) ; response . addRecord ( opt , Section . ADDITIONAL ) ; } response . setTSIG ( tsig , Rcode . NOERROR , queryTSIG ) ; return response . toWire ( maxLength ) ; }'", "label": "'/ * Note : a null return value means that the caller doesn t need to do anything . Currently this only happens if this is an AXFR request over TCP .'"}
{"text": "'@ Override protected void updateListAfterPut ( CacheEntry < K , V > newEntry ) { newEntry . setPrevious ( _last ) ; if ( _last != null ) { _last . setNext ( newEntry ) ; } setLast ( newEntry ) ; }'", "label": "'Adds the new cache entry after <code > this&#46 ; _last< / code > .'"}
{"text": "'@ Override protected void updateListAfterHit ( CacheEntry < K , V > entry ) { if ( entry != null && ! entry . equals ( _first ) ) { if ( entry . getHits ( ) > entry . getPrevious ( ) . getHits ( ) ) { // Swap the positions final CacheEntry < K , V > beforePrevious = entry . getPrevious ( ) . getPrevious ( ) ; final CacheEntry < K , V > previous = entry . getPrevious ( ) ; final CacheEntry < K , V > next = entry . getNext ( ) ; if ( beforePrevious != null ) { beforePrevious . setNext ( entry ) ; } else { _first = entry ; } entry . setPrevious ( beforePrevious ) ; previous . setPrevious ( entry ) ; previous . setNext ( next ) ; entry . setNext ( previous ) ; if ( next == null ) { setLast ( previous ) ; } else { next . setPrevious ( previous ) ; } } } }'", "label": "'Resort the linked list . If this CacheEntry has more hits than the previous one move it up .'"}
{"text": "'@ Nonnull public static < K , V > Map < K , V > putAll ( @ Nonnull Map < K , V > original , @ Nullable Object ... a ) { if ( a != null ) { final int length = a . length ; if ( length % 2 == 1 ) { throw new IllegalArgumentException ( \"You must provide an even number of arguments.\" ) ; } for ( int i = 0 ; i < length ; i += 2 ) { // noinspection unchecked original . put ( ( K ) a [ i ] , ( V ) a [ i + 1 ] ) ; } } return original ; }'", "label": "'Returns a the given map enriched with the mappings <code > a [ 0 ] = > a [ 1 ] a [ 2 ] = > a [ 3 ] ... < / code > .'"}
{"text": "'@ Nonnull public static < K , V > Map < K , V > asMap ( @ Nullable Object ... a ) { return putAll ( new LinkedHashMap < K , V > ( ) , a ) ; }'", "label": "'Returns a {'"}
{"text": "'@ Nonnull public static < K , V > Map < K , V > putAllAndMakeImmutable ( @ Nonnull Map < K , V > original , @ Nullable Object ... a ) { return asImmutableMap ( CollectionUtils . putAll ( original , a ) ) ; }'", "label": "'Returns a the given map enriched with the mappings <code > a [ 0 ] = > a [ 1 ] a [ 2 ] = > a [ 3 ] ... < / code > .'"}
{"text": "'@ Nonnull public static < K , V > Map < K , V > asImmutableMap ( @ Nullable Object ... a ) { return putAllAndMakeImmutable ( new LinkedHashMap < K , V > ( ) , a ) ; }'", "label": "'Returns a {'"}
{"text": "'@ Nonnull public static < T > Collection < T > asCollection ( @ Nullable T ... objects ) { return asList ( objects ) ; }'", "label": "'Returns a {'"}
{"text": "'@ Nonnull public static < T > Collection < T > asImmutableCollection ( @ Nullable T ... objects ) { return unmodifiableCollection ( asCollection ( objects ) ) ; }'", "label": "'Returns an unmodifiable {'"}
{"text": "'@ Nonnull public static < T > List < T > asList ( @ Nullable T ... objects ) { final List < T > result ; if ( objects == null ) { result = new ArrayList <> ( ) ; } else { final int initialCapacity = Math . max ( 16 , ( ( objects . length + 2 ) / 3 ) * 4 ) ; result = new ArrayList <> ( initialCapacity ) ; result . addAll ( new ArrayWrapper <> ( objects ) ) ; } return result ; }'", "label": "'Returns a {'"}
{"text": "'@ Nonnull public static < T > List < T > asImmutableList ( @ Nullable T ... objects ) { return unmodifiableList ( asList ( objects ) ) ; }'", "label": "'Returns an unmodifiable {'"}
{"text": "'@ Nonnull public static < T > Set < T > asSet ( @ Nullable T ... objects ) { final Set < T > result ; if ( objects == null ) { result = new LinkedHashSet <> ( ) ; } else { final int initialCapacity = Math . max ( 16 , ( ( objects . length + 2 ) / 3 ) * 4 ) ; result = new LinkedHashSet <> ( initialCapacity ) ; result . addAll ( new ArrayWrapper <> ( objects ) ) ; } return result ; }'", "label": "'Returns a {'"}
{"text": "'@ Nonnull public static < T > Set < T > asImmutableSet ( @ Nullable T ... objects ) { return addAllAndMakeImmutable ( new HashSet < T > ( ) , objects ) ; }'", "label": "'Returns an unmodifiable {'"}
{"text": "'@ Nonnull public static < T > Set < T > addAllAndMakeImmutable ( @ Nonnull Set < T > original , @ Nullable T ... objects ) { return unmodifiableSet ( addAll ( original , objects ) ) ; }'", "label": "'Returns an unmodifiable {'"}
{"text": "'@ Nonnegative public static int countSubString ( @ Nonnull String string , @ Nonnull String sub ) { int count = 0 ; int pos = 0 ; do { pos = string . indexOf ( sub , pos ) ; if ( pos != - 1 ) { count ++ ; pos += sub . length ( ) ; } } while ( pos != - 1 ) ; return count ; }'", "label": "'Count the number of occurrences of sub in s'"}
{"text": "'@ Nonnull public static List < String > splitToList ( @ Nonnull String source , @ Nonnull String delimiters , boolean returnDelimiters , boolean trim ) { final List < String > values = new ArrayList <> ( ) ; if ( source != null ) { final StringTokenizer st = new StringTokenizer ( source , delimiters , returnDelimiters ) ; while ( st . hasMoreTokens ( ) ) { String value = st . nextToken ( ) ; if ( trim ) { value = trim ( value ) ; } values . add ( value ) ; } } return values ; }'", "label": "'Split a string and return the values as an array .'"}
{"text": "'@ Nonnull public static String [ ] split ( @ Nonnull String source , @ Nonnull String delimiters , boolean returnDelimiters , boolean trim ) { final List < String > values = splitToList ( source , delimiters , returnDelimiters , trim ) ; final String [ ] result = new String [ values . size ( ) ] ; values . toArray ( result ) ; return result ; }'", "label": "'Split a string and return the values as an array .'"}
{"text": "'public static void addElement ( @ Nonnull StringBuilder buf , @ Nonnull String separator , @ Nonnull String element ) { if ( buf . length ( ) > 0 ) { buf . append ( separator ) ; } buf . append ( element ) ; }'", "label": "'Appends the separator string if <code > {'"}
{"text": "'public static void toLowerCase ( char [ ] chars ) { for ( int a = 0 ; a < chars . length ; a ++ ) { chars [ a ] = Character . toLowerCase ( chars [ a ] ) ; } }'", "label": "'Convert a string to lower case . ( Faster than String . toLowerCase )'"}
{"text": "'public static boolean startsWith ( char [ ] src , char [ ] find , int startAt ) { int startPos = startAt ; boolean result = true ; // Check ranges if ( src . length < startPos + find . length ) { result = false ; } else { final int max = find . length ; for ( int a = 0 ; a < max && result ; a ++ ) { if ( src [ startPos ] != find [ a ] ) { result = false ; } startPos ++ ; } } return result ; }'", "label": "'Test whether find can be found at position startPos in the string src .'"}
{"text": "'@ SuppressWarnings ( { \"MethodWithMultipleReturnPoints\" , \"LabeledStatement\" , \"ValueOfIncrementOrDecrementUsed\" , \"ContinueStatement\" , \"ContinueStatementWithLabel\" } ) public static int indexOf ( char [ ] src , char [ ] find , int startAt ) { int startPos = startAt ; final int max = src . length - find . length ; if ( startPos > max ) { return - 1 ; } final char find0 = find [ 0 ] ; final int len = find . length ; int j ; int k ; // Find the first character startOver : while ( startPos <= max ) { if ( src [ startPos ++ ] == find0 ) { // First character found - look for the rest j = startPos ; k = 1 ; while ( k < len ) { if ( src [ j ++ ] != find [ k ++ ] ) { continue startOver ; } } return startPos - 1 ; } } return - 1 ; }'", "label": "'Same as String . indexOf but ( slightly ) faster ; )'"}
{"text": "'public static void log ( @ Nonnull Logger logger , @ Nonnull LogLevel level , @ Nonnull String format , @ Nullable Object arg ) { if ( logger instanceof LocationAwareLogger ) { log ( ( LocationAwareLogger ) logger , level , FQCN , null , format , new Object [ ] { arg } , null ) ; } else if ( trace . equals ( level ) ) { logger . trace ( format , arg ) ; } else if ( debug . equals ( level ) ) { logger . debug ( format , arg ) ; } else if ( info . equals ( level ) ) { logger . info ( format , arg ) ; } else if ( warning . equals ( level ) ) { logger . warn ( format , arg ) ; } else if ( error . equals ( level ) || fatal . equals ( level ) ) { logger . error ( format , arg ) ; } else { log ( logger , normalize ( level ) , format , arg ) ; } }'", "label": "'<p > Log a message at the given <code > level< / code > according to the specified format and argument . < / p >'"}
{"text": "'public static boolean isEnabled ( @ Nonnull Logger logger , @ Nonnull LogLevel level , @ Nonnull Marker marker ) { final boolean result ; if ( trace . equals ( level ) ) { result = logger . isTraceEnabled ( marker ) ; } else if ( debug . equals ( level ) ) { result = logger . isDebugEnabled ( marker ) ; } else if ( info . equals ( level ) ) { result = logger . isInfoEnabled ( marker ) ; } else if ( warning . equals ( level ) ) { result = logger . isWarnEnabled ( marker ) ; } else if ( error . equals ( level ) || fatal . equals ( level ) ) { result = logger . isErrorEnabled ( marker ) ; } else { result = isEnabled ( logger , normalize ( level ) , marker ) ; } return result ; }'", "label": "'Similar to { @link #isEnabled } method except that the marker data is also taken into account .'"}
{"text": "'public static void log ( @ Nonnull Logger logger , @ Nonnull LogLevel level , @ Nonnull Marker marker , @ Nullable String msg ) { if ( logger instanceof LocationAwareLogger ) { log ( ( LocationAwareLogger ) logger , level , FQCN , marker , msg , null , null ) ; } else if ( trace . equals ( level ) ) { logger . trace ( marker , msg ) ; } else if ( debug . equals ( level ) ) { logger . debug ( marker , msg ) ; } else if ( info . equals ( level ) ) { logger . info ( marker , msg ) ; } else if ( warning . equals ( level ) ) { logger . warn ( marker , msg ) ; } else if ( error . equals ( level ) || fatal . equals ( level ) ) { logger . error ( marker , msg ) ; } else { log ( logger , normalize ( level ) , marker , msg ) ; } }'", "label": "'Log a message with the specific Marker at the given <code > level< / code > .'"}
{"text": "'@ Override protected UserProfile extractUserProfile ( final String body ) { final GoogleProfile profile = new GoogleProfile ( ) ; final JsonNode json = JsonHelper . getFirstNode ( body ) ; if ( json != null ) { profile . setId ( JsonHelper . get ( json , \"id\" ) ) ; profile . addAttribute ( EurekaAttributesDefinition . USERNAME , JsonHelper . get ( json , Google2AttributesDefinition . EMAIL ) ) ; profile . addAttribute ( EurekaAttributesDefinition . FIRSTNAME , JsonHelper . get ( json , Google2AttributesDefinition . GIVEN_NAME ) ) ; profile . addAttribute ( EurekaAttributesDefinition . LASTNAME , JsonHelper . get ( json , Google2AttributesDefinition . FAMILY_NAME ) ) ; profile . addAttribute ( EurekaAttributesDefinition . FULLNAME , JsonHelper . get ( json , Google2AttributesDefinition . NAME ) ) ; profile . addAttribute ( EurekaAttributesDefinition . EMAIL , JsonHelper . get ( json , Google2AttributesDefinition . EMAIL ) ) ; } return profile ; }'", "label": "'Returns the user s profile using the attributes that Eureka! Clinical expects .'"}
{"text": "'@ Override public Token getAccessToken ( Token requestToken , Verifier verifier ) { OAuthRequest request = new ProxyOAuthRequest ( this . api . getAccessTokenVerb ( ) , this . api . getAccessTokenEndpoint ( ) , this . proxyHost , this . proxyPort ) ; String userpass = this . config . getApiKey ( ) + \":\" + this . config . getApiSecret ( ) ; String basicAuth = \"Basic \" + javax . xml . bind . DatatypeConverter . printBase64Binary ( userpass . getBytes ( ) ) ; request . addHeader ( \"Authorization\" , basicAuth ) ; request . addBodyParameter ( \"grant_type\" , \"authorization_code\" ) ; request . addBodyParameter ( \"code\" , verifier . getValue ( ) ) ; request . addBodyParameter ( \"redirect_uri\" , config . getCallback ( ) ) ; Response response = request . send ( ) ; String body = response . getBody ( ) ; JsonNode json = JsonHelper . getFirstNode ( body ) ; if ( json != null ) { return new Token ( ( String ) JsonHelper . get ( json , \"access_token\" ) , \"\" , body ) ; } else { return null ; } }'", "label": "'Makes the call to request an access token for an authorized user .'"}
{"text": "'@ Override public void signRequest ( Token accessToken , OAuthRequest request ) { request . addHeader ( \"Authorization\" , \"Bearer \" + accessToken . getToken ( ) ) ; }'", "label": "'Adds an authorization header containing the bearer token to a request . It is intended for use in API calls after getting the access token such as requesting the user s profile .'"}
{"text": "'@ Override protected void internalInit ( ) { this . service = new GlobusOAuth20ServiceImpl ( new GlobusApi ( ) , new OAuthConfig ( this . key , this . secret , this . callbackUrl , SignatureType . Header , \"user\" , null ) , this . proxyHost , this . proxyPort ) ; }'", "label": "'Initializes the signing of Globus API calls with an access token . A superclass that overrides this method must call this method in the overridden version or you must override {'"}
{"text": "'@ Override protected String sendRequestForData ( Token accessToken , String dataUrl ) throws HttpException { final ProxyOAuthRequest request = new ProxyOAuthRequest ( Verb . GET , dataUrl , this . proxyHost , this . proxyPort ) ; if ( this . connectTimeout != 0 ) { request . setConnectTimeout ( this . connectTimeout , TimeUnit . MILLISECONDS ) ; } if ( this . readTimeout != 0 ) { request . setReadTimeout ( this . readTimeout , TimeUnit . MILLISECONDS ) ; } this . service . signRequest ( accessToken , request ) ; request . addHeader ( \"Content-Type\" , \"application/json\" ) ; final Response response = request . send ( ) ; final int code = response . getCode ( ) ; final String body = response . getBody ( ) ; if ( code != 200 ) { throw new HttpException ( code , body ) ; } return body ; }'", "label": "'Calls any Globus endpoint that requires already being authenticated . Relies on { @link #internalInit () } to setup request signing .'"}
{"text": "'@ Override protected UserProfile extractUserProfile ( final String body ) { GlobusProfile profile = new GlobusProfile ( ) ; JsonNode json = JsonHelper . getFirstNode ( body ) ; if ( json != null ) { String username = JsonHelper . get ( json , GlobusAttributesDefinition . USERNAME ) . toString ( ) ; if ( LEGACY_USERNAMES ) { username = username . split ( \"@\" ) [ 0 ] ; } profile . setId ( username ) ; profile . addAttribute ( EurekaAttributesDefinition . USERNAME , username ) ; profile . addAttribute ( EurekaAttributesDefinition . FULLNAME , JsonHelper . get ( json , GlobusAttributesDefinition . FULLNAME ) ) ; profile . addAttribute ( EurekaAttributesDefinition . EMAIL , JsonHelper . get ( json , GlobusAttributesDefinition . EMAIL ) ) ; } return profile ; }'", "label": "'Returns the user s profile using the attributes that Eureka! Clinical expects . If the system property <code > scribeupext . globus . legacyUsernames< / code > is set and has value <code > true< / code > ( case - insensitive ) this method will omit the <code > @globusid . org< / code > suffix when extracting the user s username .'"}
{"text": "'@ Override protected UserProfile extractUserProfile ( String body ) { final GitHubProfile profile = new GitHubProfile ( ) ; final JsonNode json = JsonHelper . getFirstNode ( body ) ; if ( json != null ) { profile . setId ( JsonHelper . get ( json , \"id\" ) ) ; profile . addAttribute ( EurekaAttributesDefinition . USERNAME , JsonHelper . get ( json , GitHubAttributesDefinition . LOGIN ) ) ; profile . addAttribute ( EurekaAttributesDefinition . FULLNAME , JsonHelper . get ( json , GitHubAttributesDefinition . NAME ) ) ; profile . addAttribute ( EurekaAttributesDefinition . EMAIL , JsonHelper . get ( json , GitHubAttributesDefinition . EMAIL ) ) ; profile . addAttribute ( EurekaAttributesDefinition . ORGANIZATION , JsonHelper . get ( json , GitHubAttributesDefinition . COMPANY ) ) ; } return profile ; }'", "label": "'Returns the user s profile using the attributes that Eureka! Clinical expects .'"}
{"text": "'@ Override protected UserProfile extractUserProfile ( final String body ) { final TwitterProfile profile = new TwitterProfile ( ) ; final JsonNode json = JsonHelper . getFirstNode ( body ) ; if ( json != null ) { profile . setId ( JsonHelper . get ( json , \"id\" ) ) ; profile . addAttribute ( EurekaAttributesDefinition . USERNAME , JsonHelper . get ( json , TwitterAttributesDefinition . SCREEN_NAME ) ) ; profile . addAttribute ( EurekaAttributesDefinition . FULLNAME , JsonHelper . get ( json , TwitterAttributesDefinition . NAME ) ) ; } return profile ; }'", "label": "'Returns the user s profile using the attributes that Eureka! Clinical expects .'"}
{"text": "'@ Override public String getAuthorizationUrl ( OAuthConfig config ) { Preconditions . checkValidUrl ( config . getCallback ( ) , \"Must provide a valid url as callback.\" ) ; return String . format ( AUTHORIZE_URL , config . getApiKey ( ) , OAuthEncoder . encode ( config . getCallback ( ) ) , SCOPES ) ; }'", "label": "'Returns the URL for authorizing the user .'"}
{"text": "'public static CountProjection countDistinct ( String relativePath ) { return new CountProjection ( new DistinctProjection ( new PathProjection ( relativePath , false , false ) ) ) ; }'", "label": "'<p > Creates a count distinct projection for the specified relative path . < / p >'"}
{"text": "'public boolean performFinish ( ) { final String containerName = getProjectName ( ) ; final IPath location = projectPage . useDefaults ( ) ? null : projectPage . getLocationPath ( ) ; IRunnableWithProgress op = new IRunnableWithProgress ( ) { public void run ( IProgressMonitor monitor ) throws InvocationTargetException { try { doFinish ( containerName , location , monitor ) ; } catch ( CoreException e ) { throw new InvocationTargetException ( e ) ; } finally { monitor . done ( ) ; } } } ; try { getContainer ( ) . run ( true , false , op ) ; } catch ( InterruptedException e ) { return false ; } catch ( InvocationTargetException e ) { Throwable realException = e . getTargetException ( ) ; MessageDialog . openError ( getShell ( ) , \"Error\" , realException . getMessage ( ) ) ; return false ; } return true ; }'", "label": "'This method is called when Finish button is pressed in the wizard . We will create an operation and run it using wizard as execution context .'"}
{"text": "'private void doFinish ( String containerName , IPath location , IProgressMonitor monitor ) throws CoreException { // create a sample file monitor . beginTask ( \"Creating \" + containerName , 2 ) ; monitor . worked ( 1 ) ; final Archetype archetype = new Archetype ( ) ; archetype . setGroupId ( \"org.glassmaker\" ) ; archetype . setArtifactId ( \"org.glassmaker.archetype.basic\" ) ; archetype . setVersion ( \"0.0.1\" ) ; ProjectParameters params = parametersPage . getParams ( ) ; final String groupId = params . getGroupId ( ) ; final String artifactId = params . getArtifactId ( ) ; final String version = params . getVersion ( ) ; final String javaPackage = params . getPackageName ( ) ; final Properties properties = params . getProperties ( ) ; properties . setProperty ( \"oauth2callbackurl\" , properties . getProperty ( ProjectWizardParametersPage . O_AUTH_CALLBACK ) ) ; properties . setProperty ( \"clientid\" , properties . getProperty ( ProjectWizardParametersPage . CLIENT_ID ) ) ; properties . setProperty ( \"clientsecret\" , properties . getProperty ( ProjectWizardParametersPage . CLIENT_SECRET ) ) ; List < IProject > projects = MavenPlugin . getProjectConfigurationManager ( ) . createArchetypeProjects ( location , archetype , groupId , artifactId , version , javaPackage , properties , importConfiguration , monitor ) ; }'", "label": "'The worker method . It will find the container create the file if missing or just replace its contents and open the editor on the newly created file .'"}
{"text": "'public BufferedImage drawText ( String text , int fontSize , Color color ) { Graphics g = image . getGraphics ( ) ; g . setColor ( color ) ; Font f = new Font ( \"\u5b8b\u4f53\", Fo n .BOL D , fo n Size);   g . setFont ( f ) ; int len = text . length ( ) ; g . drawString ( text , ( width - fontSize * len ) / 2 , ( height + ( int ) ( fontSize / 1.5 ) ) / 2 ) ; g . dispose ( ) ; return image ; }'", "label": "'\u5728\u56fe\u7247\u4e0a\u5199\u5b57'"}
{"text": "'public BufferedImage scale ( double scaleW , double scaleH ) { width = ( int ) ( width * scaleW ) ; height = ( int ) ( height * scaleH ) ; BufferedImage newImage = new BufferedImage ( width , height , image . getType ( ) ) ; Graphics g = newImage . getGraphics ( ) ; g . drawImage ( image , 0 , 0 , width , height , null ) ; g . dispose ( ) ; image = newImage ; return image ; }'", "label": "'\u7f29\u653e\u56fe\u7247'"}
{"text": "'public BufferedImage rotate ( ) { BufferedImage dest = new BufferedImage ( height , width , BufferedImage . TYPE_INT_ARGB ) ; for ( int i = 0 ; i < width ; i ++ ) for ( int j = 0 ; j < height ; j ++ ) { dest . setRGB ( height - j - 1 , i , image . getRGB ( i , j ) ) ; } image = dest ; return image ; }'", "label": "'\u65cb\u8f6c90\u5ea6\u65cb\u8f6c'"}
{"text": "'public void save ( File file ) { try { ImageIO . write ( image , \"png\" , file ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }'", "label": "'\u4fdd\u5b58\u56fe\u7247'"}
{"text": "'@ Override public LocalDateTime deserialize ( final JsonParser parser , final DeserializationContext context ) throws IOException , JsonProcessingException { return formatter . parseLocalDateTime ( parser . getText ( ) ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public void createControl ( Composite parent ) { Composite composite = new Composite ( parent , SWT . NULL ) ; composite . setLayout ( new GridLayout ( 3 , false ) ) ; createArtifactGroup ( composite ) ; createPropertiesGroup ( composite ) ; setArchetype ( ) ; validate ( ) ; setControl ( composite ) ; }'", "label": "'Creates page controls .'"}
{"text": "'void validate ( ) { if ( isVisible ( ) ) { String error = validateInput ( ) ; setErrorMessage ( error ) ; setPageComplete ( error == null ) ; } }'", "label": "'Validates the contents of this wizard page . <p > Feedback about the validation is given to the user by displaying error messages or informative messages on the wizard page . Depending on the provided user input the wizard page is marked as being complete or not . <p > If some error or missing input is detected in the user input an error message or informative message respectively is displayed to the user . If the user input is complete and correct the wizard page is marked as begin complete to allow the wizard to proceed . To that end the following conditions must be met : <ul > <li > The user must have provided a valid group ID . < / li > <li > The user must have provided a valid artifact ID . < / li > <li > The user must have provided a version for the artifact . < / li > < / ul > < / p >'"}
{"text": "'public void setProjectName ( String projectName ) { if ( artifactIdCombo . getText ( ) . equals ( groupIdCombo . getText ( ) ) ) { groupIdCombo . setText ( projectName ) ; } artifactIdCombo . setText ( projectName ) ; packageCombo . setText ( \"org.\" + projectName . replace ( \\' \\' , \\' \\' ) ) ; //$NON-NLS-1$ validate ( ) ; }'", "label": "'Updates the properties when a project name is set on the first page of the wizard .'"}
{"text": "'public void setParentProject ( String groupId , String artifactId , String version ) { groupIdCombo . setText ( groupId ) ; versionCombo . setText ( version ) ; validate ( ) ; }'", "label": "'Updates the properties when a project name is set on the first page of the wizard .'"}
{"text": "'protected String getDefaultJavaPackage ( ) { return ProjectWizardParametersPage . getDefaultJavaPackage ( groupIdCombo . getText ( ) . trim ( ) , artifactIdCombo . getText ( ) . trim ( ) ) ; }'", "label": "'Returns the default package name .'"}
{"text": "'public void setVisible ( boolean visible ) { super . setVisible ( visible ) ; boolean shouldValidate = false ; if ( visible ) { if ( groupIdCombo . getText ( ) . length ( ) == 0 && groupIdCombo . getItemCount ( ) > 0 ) { groupIdCombo . setText ( groupIdCombo . getItem ( 0 ) ) ; packageCombo . setText ( getDefaultJavaPackage ( ) ) ; packageCustomized = false ; } if ( shouldValidate ) { validate ( ) ; } } }'", "label": "'Loads the group value when the page is displayed .'"}
{"text": "'public String toQueryString ( Criteria criteria , CriteriaQueryBuilder queryBuilder ) { return \"NOT \" + criterion . toQueryString ( criteria , queryBuilder ) ; }'", "label": "'/ *'"}
{"text": "'public void addOrder ( Criteria criteria , Order order ) { this . orderList . add ( new MetaEntry < Order > ( criteria , order ) ) ; }'", "label": "'/ * internal'"}
{"text": "'public void commence ( HttpServletRequest req , HttpServletResponse resp , AuthenticationException authException ) throws IOException , ServletException { String redirectUrl = null ; logger . debug ( \"No auth context found. Kicking off a new auth flow.\" ) ; AuthorizationCodeFlow flow = oAuth2Util . newAuthorizationCodeFlow ( ) ; GenericUrl url = flow . newAuthorizationUrl ( ) . setRedirectUri ( getCallbackUrl ( ) ) ; url . set ( \"approval_prompt\" , \"force\" ) ; redirectUrl = url . build ( ) ; redirectStrategy . sendRedirect ( req , resp , redirectUrl ) ; }'", "label": "'Performs the redirect ( or forward ) to the login form URL .'"}
{"text": "'public String createQueryDebugString ( ) { // create query String queryString = createQueryString ( ) ; // create list of parameters List < Object > parameterValues = getQueryParametersAsList ( ) ; // create debug string return QueryLogHelper . createQueryLogMessage ( queryString , parameterValues ) ; }'", "label": "'Creates a human - readable representation of the query that will be created from this builder'"}
{"text": "'private List < Object > getQueryParametersAsList ( ) { // iterate over all restrictions of this criteria Iterator < MetaEntry < Criterion >> iter = rootCriteria . getCriterionList ( ) . iterator ( ) ; // result list List < Object > result = new ArrayList < Object > ( ) ; // loop over all criterion while ( iter . hasNext ( ) ) { // the current criterion Criterion criterion = iter . next ( ) . getEntry ( ) ; // get the values to set Object [ ] parameterValues = criterion . getParameterValues ( ) ; // null should be ignores if ( parameterValues == null ) { continue ; } // set all parameters for ( Object value : parameterValues ) { result . add ( value ) ; } } return result ; }'", "label": "'Creates an ordered list of all parameter values registered at the root criteria .'"}
{"text": "'public void initializeDefaultPreferences ( ) { IPreferenceStore store = GlassmakerUIPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CLIENT_ID , \"YOU_MUST_PROVIDE_A_CLIENT_ID\" ) ; store . setDefault ( PreferenceConstants . CLIENT_SECRET , \"YOU_MUST_PROVIDE_A_CLIENT_SECRET\" ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'protected void configure ( final HttpRequest request ) { request . getHeaders ( ) . setAuthorization ( String . format ( \"OAuth %s\" , token ) ) ; request . setParser ( new JsonObjectParser ( jsonFactory ) ) ; final ExponentialBackOff backoff = new ExponentialBackOff . Builder ( ) . setInitialIntervalMillis ( 500 ) . setMaxElapsedTimeMillis ( 60000 ) . setMaxIntervalMillis ( 30000 ) . setMultiplier ( 1.5 ) . setRandomizationFactor ( 0.5 ) . build ( ) ; request . setUnsuccessfulResponseHandler ( new HttpBackOffUnsuccessfulResponseHandler ( backoff ) ) ; }'", "label": "'Configures each request . This does 3 things : <ul > <li > Adds the authorization token to each request< / li > <li > Adds the JSON factory to the request< / li > <li > Adds exponential back off capability< / li > < / ul >'"}
{"text": "'@ Override public boolean handleResponse ( final HttpRequest request , final HttpResponse response , final boolean supportsRetry ) throws IOException { log . trace ( \"HTTP request {} resulted in {} with response {} and headers {}\" , request . getUrl ( ) . toString ( ) , response . getStatusCode ( ) , response . getStatusMessage ( ) , response . getHeaders ( ) . toString ( ) ) ; throw new HTTPException ( response . getStatusCode ( ) , response . getStatusMessage ( ) ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public static boolean isEmptyOrNull ( String ... ins ) { if ( ins == null || ins . length == 0 ) { return true ; } for ( String in : ins ) { if ( isEmptyOrNull ( in ) ) { return true ; } } return false ; }'", "label": "'\u4e00\u4e9b\u5217\u5b57\u7b26\u4e32\u662f\u5426\u4e3anull\u6216\u8005\u957f\u5ea6\u4e3a0'"}
{"text": "'public static int compare ( String str1 , String str2 ) { //\u6709\u4e00\u4e2a\u4e3anull\u7684\u8bdd\u6309\u7167\u975enull\u7684\u5927\u5904\u7406 if ( str1 == null || str2 == null ) { return Integer . compare ( ( str1 == null ) ? 0 : 1 , ( str2 == null ) ? 0 : 1 ) ; } if ( str1 . length ( ) == 0 || str2 . length ( ) == 0 ) { return str1 . length ( ) - str2 . length ( ) ; } int res = 0 ; int position = 0 ; int maxComparePosition = Math . min ( str1 . length ( ) , str2 . length ( ) ) ; while ( position < maxComparePosition ) { char ch1 = str1 . charAt ( position ) ; char ch2 = str2 . charAt ( position ) ; if ( ch1 == ch2 ) { position ++ ; continue ; } //\u4e0d\u76f8\u7b49\u7684\u8bdd\u8fd4\u56de\u5dee\u503c,\u4ee3\u8868\u5b57\u7b26\u4e32\u5927\u5c0f res = ch1 - ch2 ; break ; } //\u5982\u679c\u6700\u540e\u6bd4\u8f83\u7ed3\u679c\u662f\u76f8\u7b49\u7684\u8bdd,\u8bf4\u660e\u6bd4\u8f83\u957f\u5ea6\u5185\u7684\u5b57\u7b26\u4e32\u76f8\u7b49,\u9700\u8981\u6bd4\u8f83\u5b57\u7b26\u4e32\u957f\u5ea6 return res == 0 ? ( str1 . length ( ) - str2 . length ( ) ) : res ; }'", "label": "'\u6309\u7167ascii ( \u5b57\u5178 ) \u987a\u5e8f\u6bd4\u8f83\u5b57\u7b26\u5927\u5c0f'"}
{"text": "'public static boolean containGreaterThan ( String srcString , String desString , int number ) { boolean res = false ; int totalNumber = containStatistics ( srcString , desString ) ; if ( totalNumber > number ) { res = true ; } return res ; }'", "label": "'\u542b\u5b50\u4e32\u662f\u5426\u8d85\u8fc7\u4e00\u5b9a\u6b21\u6570'"}
{"text": "'public static int containStatistics ( String srcString , String desString ) { int length = desString . length ( ) ; String newString = srcString . replace ( desString , \"\" ) ; return ( srcString . length ( ) - newString . length ( ) ) / length ; }'", "label": "'\u542b\u5b50\u4e32\u7684\u6b21\u6570'"}
{"text": "'public static boolean containRegexGreaterThan ( String srcString , String desString , int number ) { boolean res = false ; int totalNumber = containRegexStatistics ( srcString , desString ) ; if ( totalNumber > number ) { res = true ; } return res ; }'", "label": "'\u542b\u6a21\u5f0f\u4e32\u662f\u5426\u8d85\u8fc7\u4e00\u5b9a\u6b21\u6570'"}
{"text": "'public static int containRegexStatistics ( String srcString , String desString ) { int number = 0 ; while ( true ) { String newString = srcString . replaceFirst ( desString , \"\" ) ; if ( newString . length ( ) == srcString . length ( ) ) { break ; } number ++ ; srcString = newString ; } return number ; }'", "label": "'\u542b\u6a21\u5f0f\u4e32\u7684\u6b21\u6570'"}
{"text": "'public String toQueryString ( Criteria criteria , CriteriaQueryBuilder queryBuilder ) { return new StringBuilder ( ) . append ( \"DISTINCT \" ) . append ( projection . toQueryString ( criteria , queryBuilder ) ) . toString ( ) ; }'", "label": "'/ *'"}
{"text": "'public CBConnection connect ( String url , String charset ) { this . url = url ; this . charset = charset ; return this ; }'", "label": "'\u8fde\u63a5\u5730\u5740'"}
{"text": "'public CBConnection header ( Map < String , String > header ) { if ( header != null ) { this . header = header ; } else { header . clear ( ) ; } return this ; }'", "label": "'\u6dfb\u52a0\u8bf7\u6c42\u5934\u90e8 \u6b64\u65b9\u6cd5\u5c06\u4f1a\u6e05\u7a7a\u4e4b\u524d\u6240\u6709\u5df2\u7ecf\u8bbe\u7f6e\u7684\u5934\u90e8\u4fe1\u606f'"}
{"text": "'public CBConnection header ( String key , String value ) { header . put ( key , value ) ; return this ; }'", "label": "'\u6dfb\u52a0\u8bf7\u6c42\u5934\u90e8 \u4ec5\u4ec5\u6dfb\u52a0\u4e00\u4e2a \u4e0d\u4f1a\u6e05\u7a7a\u4e4b\u524d\u5df2\u7ecf\u8bbe\u7f6e\u7684\u5934\u90e8'"}
{"text": "'public CBConnection data ( String ... data ) { if ( data . length % 2 == 0 ) { this . data = CBParam . paramsToString ( charset , data ) ; } return this ; }'", "label": "'\u8bbe\u7f6e\u8bf7\u6c42\u6570\u636e'"}
{"text": "'public CBConnection data ( Map < String , String > data ) { if ( data != null ) { this . data = CBParam . paramsToString ( charset , data ) ; } return this ; }'", "label": "'\u8bbe\u7f6e\u8bf7\u6c42\u6570\u636e'"}
{"text": "'public String execute ( ) throws IOException { if ( CBStringUtil . isEmptyOrNull ( this . url ) ) { return null ; } StringBuilder netString = new StringBuilder ( ) ; URL url = new URL ( this . url ) ; HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; //\u8bbe\u7f6e\u8bf7\u6c42\u65b9\u6cd5 conn . setRequestMethod ( method . value ) ; //\u8bbe\u7f6e\u5934\u90e8 for ( Map . Entry < String , String > item : header . entrySet ( ) ) { conn . setRequestProperty ( item . getKey ( ) , item . getValue ( ) ) ; } //\u4fdd\u6301session\u7684\u628a\u8bbe\u7f6ecookie if ( keepSession && ! CBStringUtil . isEmptyOrNull ( cookie ) && ! header . containsKey ( CBHeader . COOKIE ) && ! pauseSessionForOnce ) { conn . setRequestProperty ( CBHeader . COOKIE , cookie ) ; } pauseSessionForOnce = false ; //\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4 conn . setConnectTimeout ( timeout ) ; conn . setReadTimeout ( timeout ) ; //\u8bbe\u7f6e\u8df3\u8f6c conn . setInstanceFollowRedirects ( followRedirects ) ; if ( method == CBMethod . POST && ! CBStringUtil . isEmptyOrNull ( data ) ) { conn . setDoOutput ( true ) ; OutputStream out = conn . getOutputStream ( ) ; out . write ( data . getBytes ( ) ) ; out . flush ( ) ; out . close ( ) ; } BufferedReader buff = new BufferedReader ( new InputStreamReader ( conn . getInputStream ( ) , charset ) ) ; String line ; while ( ( line = buff . readLine ( ) ) != null ) { netString . append ( \"\\\\n\" ) ; netString . append ( line ) ; } buff . close ( ) ; //\u8bb0\u5f55cookie\u503c,\u7528\u4e8e\u4e0b\u6b21\u4f20\u9012 String tmpCookie = conn . getHeaderField ( CBHeader . SET_COOKIE ) ; if ( keepSession && CBStringUtil . isEmptyOrNull ( cookie ) && ! CBStringUtil . isEmptyOrNull ( tmpCookie ) ) { cookie = tmpCookie ; } return netString . length ( ) > 0 ? netString . substring ( 1 ) : netString . toString ( ) ; }'", "label": "'\u83b7\u53d6\u7f51\u9875\u7684\u5185\u5bb9'"}
{"text": "'protected CBConnection resetSomeState ( ) { url = null ; followRedirects = CBDefaultConfig . FOLLOW_REDIRECTS ; header . clear ( ) ; data = null ; if ( ! keepMethod ) { method = CBDefaultConfig . METHOD ; } if ( ! keepCharset ) { charset = CBDefaultConfig . CHARSET ; } return this ; }'", "label": "'\u53c2\u6570\u91cd\u7f6e \u5176\u4e2dtimeout cookie keepSession\u4e0d\u8fdb\u884c\u91cd\u7f6e'"}
{"text": "'public void saveToFile ( File file ) throws IOException { if ( CBStringUtil . isEmptyOrNull ( this . url ) ) { return ; } URL url = new URL ( this . url ) ; URLConnection conn = url . openConnection ( ) ; InputStream is = conn . getInputStream ( ) ; OutputStream os = new FileOutputStream ( file ) ; byte [ ] b = new byte [ 1024 ] ; int len ; while ( ( len = is . read ( b ) ) != - 1 ) { os . write ( b , 0 , len ) ; } os . close ( ) ; is . close ( ) ; }'", "label": "'\u4fdd\u5b58\u6307\u5b9a\u4f4d\u7f6e\u7684\u6587\u4ef6'"}
{"text": "'public void createPartControl ( Composite parent ) { viewer = new PaletteViewer ( ) ; viewer . createControl ( parent ) ; PaletteRoot root = new PaletteRoot ( ) ; String [ ] category = getCategories ( ) ; for ( int i = 0 ; i < category . length ; i ++ ) { PaletteDrawer group = new PaletteDrawer ( category [ i ] ) ; IPaletteItem [ ] items = getPaletteItems ( category [ i ] ) ; for ( int j = 0 ; j < items . length ; j ++ ) { HTMLPaletteEntry entry = new HTMLPaletteEntry ( items [ j ] . getLabel ( ) , null , items [ j ] . getImageDescriptor ( ) ) ; tools . put ( entry , items [ j ] ) ; group . add ( entry ) ; } root . add ( group ) ; } viewer . setPaletteRoot ( root ) ; viewer . getControl ( ) . addMouseListener ( new MouseAdapter ( ) { @ Override public void mouseDoubleClick ( MouseEvent e ) { //\\t\\t\\t\\tIWorkbenchPage page = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage(); \\r //\\t\\t\\t\\tIEditorPart editorPart = page.getActiveEditor();\\r //\\t\\t\\t\\tif(editorPart!=null){\\r //\\t\\t\\t\\t\\teditorPart.setFocus();\\r //\\t\\t\\t\\t}\\r if ( e . button == 1 ) { EditPart part = PaletteView . this . viewer . findObjectAt ( new Point ( e . x , e . y ) ) ; IPaletteItem item = null ; if ( part != null ) { if ( part . getModel ( ) instanceof HTMLPaletteEntry ) item = tools . get ( part . getModel ( ) ) ; } if ( item != null ) insert ( item ) ; } } } ) ; }'", "label": "'create controls and apply configurations .'"}
{"text": "'private void addPaletteItem ( String category , IPaletteItem item ) { if ( items . get ( category ) == null ) { List < IPaletteItem > list = new ArrayList < IPaletteItem > ( ) ; items . put ( category , list ) ; } List < IPaletteItem > list = items . get ( category ) ; list . add ( item ) ; }'", "label": "'Adds PaletteItem to the specified category .'"}
{"text": "'private IPaletteItem [ ] getPaletteItems ( String category ) { List < IPaletteItem > list = items . get ( category ) ; if ( list == null ) { return new IPaletteItem [ 0 ] ; } return list . toArray ( new IPaletteItem [ list . size ( ) ] ) ; }'", "label": "'Returns PaletteItems which are contained by the specified category .'"}
{"text": "'private void configureTableResizing ( final Composite parent , final Table table , final TableColumn column1 , final TableColumn column2 ) { parent . addControlListener ( new ControlAdapter ( ) { public void controlResized ( ControlEvent e ) { Rectangle area = parent . getClientArea ( ) ; Point preferredSize = table . computeSize ( SWT . DEFAULT , SWT . DEFAULT ) ; int width = area . width - 2 * table . getBorderWidth ( ) ; if ( preferredSize . y > area . height ) { // Subtract the scrollbar width from the total column // width // if a vertical scrollbar will be required Point vBarSize = table . getVerticalBar ( ) . getSize ( ) ; width -= vBarSize . x ; } Point oldSize = table . getSize ( ) ; if ( oldSize . x > width ) { // table is getting smaller so make the columns // smaller first and then resize the table to // match the client area width column1 . setWidth ( width / 2 ) ; column2 . setWidth ( width / 2 ) ; table . setSize ( width , area . height ) ; } else { // table is getting bigger so make the table // bigger first and then make the columns wider // to match the client area width table . setSize ( width , area . height ) ; column1 . setWidth ( width / 2 ) ; column2 . setWidth ( width / 2 ) ; } } } ) ; }'", "label": "'Correctly resizes the table so no phantom columns appear'"}
{"text": "'private SourceViewer createViewer ( Composite parent ) { SourceViewerConfiguration sourceViewerConfiguration = new StructuredTextViewerConfiguration ( ) { StructuredTextViewerConfiguration baseConfiguration = new StructuredTextViewerConfigurationHTML ( ) ; public String [ ] getConfiguredContentTypes ( ISourceViewer sourceViewer ) { return baseConfiguration . getConfiguredContentTypes ( sourceViewer ) ; } public LineStyleProvider [ ] getLineStyleProviders ( ISourceViewer sourceViewer , String partitionType ) { return baseConfiguration . getLineStyleProviders ( sourceViewer , partitionType ) ; } } ; SourceViewer viewer = new StructuredTextViewer ( parent , null , null , false , SWT . BORDER | SWT . V_SCROLL | SWT . H_SCROLL ) ; viewer . getTextWidget ( ) . setFont ( JFaceResources . getFont ( \"org.eclipse.wst.sse.ui.textfont\" ) ) ; //$NON-NLS-1$ IStructuredModel scratchModel = StructuredModelManager . getModelManager ( ) . createUnManagedStructuredModelFor ( \"org.glassmaker.ui.editor.CardContent\" ) ; IDocument document = scratchModel . getStructuredDocument ( ) ; viewer . configure ( sourceViewerConfiguration ) ; viewer . setDocument ( document ) ; return viewer ; }'", "label": "'Creates configures and returns a source viewer to present the template pattern on the preference page . Clients may override to provide a custom source viewer featuring e . g . syntax coloring .'"}
{"text": "'void enableTemplates ( ) { boolean enabled = fUseTemplateButton . getSelection ( ) ; if ( ! enabled ) { // save last selected template Template template = getSelectedTemplate ( ) ; if ( template != null ) fLastSelectedTemplateName = template . getName ( ) ; else fLastSelectedTemplateName = \"\" ; //$NON-NLS-1$ fTableViewer . setSelection ( null ) ; } else { setSelectedTemplate ( fLastSelectedTemplateName ) ; } fTableViewer . getControl ( ) . setEnabled ( enabled ) ; fPatternViewer . getControl ( ) . setEnabled ( enabled ) ; }'", "label": "'Enable / disable controls in page based on fUseTemplateButton s current state .'"}
{"text": "'private Template getSelectedTemplate ( ) { Template template = null ; IStructuredSelection selection = ( IStructuredSelection ) fTableViewer . getSelection ( ) ; if ( selection . size ( ) == 1 ) { template = ( Template ) selection . getFirstElement ( ) ; } return template ; }'", "label": "'Get the currently selected template .'"}
{"text": "'String getTemplateString ( ) { String templateString = null ; Template template = getSelectedTemplate ( ) ; if ( template != null ) { TemplateContextType contextType = GlassmakerUIPlugin . getDefault ( ) . getTemplateContextRegistry ( ) . getContextType ( CardContextType . CONTEXT_TYPE ) ; IDocument document = new Document ( ) ; TemplateContext context = new DocumentTemplateContext ( contextType , document , 0 , 0 ) ; try { TemplateBuffer buffer = context . evaluate ( template ) ; templateString = buffer . getString ( ) ; } catch ( Exception e ) { GlassmakerUIPlugin . logError ( \"Could not create template for new html\" , e ) ; } } return templateString ; }'", "label": "'Returns template string to insert .'"}
{"text": "'private void loadLastSavedPreferences ( ) { fLastSelectedTemplateName = \"\" ; //$NON-NLS-1$ boolean setSelection = false ; String templateName = GlassmakerUIPlugin . getDefault ( ) . getPreferenceStore ( ) . getString ( HTMLUIPreferenceNames . NEW_FILE_TEMPLATE_NAME ) ; if ( templateName == null || templateName . length ( ) == 0 ) { templateName = GlassmakerUIPlugin . getDefault ( ) . getPreferenceStore ( ) . getString ( HTMLUIPreferenceNames . NEW_FILE_TEMPLATE_ID ) ; if ( templateName != null && templateName . length ( ) > 0 ) { Template template = fTemplateStore . findTemplateById ( templateName ) ; if ( template != null ) { fLastSelectedTemplateName = template . getName ( ) ; setSelection = true ; } } } else { fLastSelectedTemplateName = templateName ; setSelection = true ; } fUseTemplateButton . setSelection ( setSelection ) ; enableTemplates ( ) ; }'", "label": "'Load the last template name used in New HTML File wizard .'"}
{"text": "'void saveLastSavedPreferences ( ) { String templateName = \"\" ; //$NON-NLS-1$ Template template = getSelectedTemplate ( ) ; if ( template != null ) { templateName = template . getName ( ) ; } GlassmakerUIPlugin . getDefault ( ) . getPreferenceStore ( ) . setValue ( \"newFileTemplateName\" , templateName ) ; GlassmakerUIPlugin . getDefault ( ) . savePluginPreferences ( ) ; }'", "label": "'Save template name used for next call to New HTML File wizard .'"}
{"text": "'private void setSelectedTemplate ( String templateName ) { Object template = null ; if ( templateName != null && templateName . length ( ) > 0 ) { // pick the last used template template = fTemplateStore . findTemplate ( templateName , CardContextType . CONTEXT_TYPE ) ; } // no record of last used template so just pick first element if ( template == null ) { // just pick first element template = fTableViewer . getElementAt ( 0 ) ; } if ( template != null ) { IStructuredSelection selection = new StructuredSelection ( template ) ; fTableViewer . setSelection ( selection , true ) ; } }'", "label": "'Select a template in the table viewer given the template name . If template name cannot be found or templateName is null just select first item in table . If no items in table select nothing .'"}
{"text": "'void updateViewerInput ( ) { Template template = getSelectedTemplate ( ) ; if ( template != null ) { fPatternViewer . getDocument ( ) . set ( template . getPattern ( ) ) ; String imageId = \"org.glassmaker.ui.templates.\" + template . getName ( ) . replace ( \" \" , \"\" ) . toLowerCase ( ) ; ImageDescriptor desc = imageRegistry . getDescriptor ( imageId ) ; if ( desc != null ) { fImage . setImage ( desc . createImage ( ) ) ; } else { fImage . setImage ( null ) ; } } else { fPatternViewer . getDocument ( ) . set ( \"\" ) ; //$NON-NLS-1$ } }'", "label": "'Updates the pattern viewer .'"}
{"text": "'@ Override public void serialize ( final DateTime value , final JsonGenerator jgen , final SerializerProvider provider ) throws IOException , JsonProcessingException { jgen . writeString ( value . toString ( formatter ) ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public static SimpleExpression like ( String relativePath , String value , MatchMode matchMode ) { return new SimpleExpression ( relativePath , matchMode . toMatchString ( value ) , \"LIKE\" ) ; }'", "label": "'Adds a like constraint to a <i > persistent field< / i > . This method requires a { @link MatchMode } to specify how wildcards are added to the value . You may also use { @link #like ( String String ) } if you want to manually specify the wildcards in the match string .'"}
{"text": "'public static Criterion ilike ( String relativePath , String value , MatchMode matchMode ) { return new ILikeExpression ( relativePath , matchMode . toMatchString ( value ) ) ; }'", "label": "'Adds a case - insensitive like constraint to a <i > persistent field< / i > . This method requires a { @link MatchMode } to specify how wildcards are added to the value . You may also use { @link #like ( String String ) } if you want to manually specify the wildcards in the match string .'"}
{"text": "'public static Criterion between ( String relativePath , Object lo , Object hi ) { return new BetweenExpression ( relativePath , lo , hi , false ) ; }'", "label": "'Adds a between constraint to a <i > persistent field< / i > .'"}
{"text": "'public static Criterion notBetween ( String relativePath , Object lo , Object hi ) { return new BetweenExpression ( relativePath , lo , hi , true ) ; }'", "label": "'Adds a not between constraint to a <i > persistent field< / i > .'"}
{"text": "'public static Conjunction and ( Criterion ... criterionList ) { Conjunction junction = new Conjunction ( ) ; for ( Criterion criterion : criterionList ) { junction . add ( criterion ) ; } return junction ; }'", "label": "'Connects multiple restrictions with an logical conjunction . Calling this method is a shortcut for creating a { @link Conjunction } by calling { @link #conjunction () } and adding all restrictions to it .'"}
{"text": "'public static Disjunction or ( Criterion ... criterionList ) { Disjunction junction = new Disjunction ( ) ; for ( Criterion criterion : criterionList ) { junction . add ( criterion ) ; } return junction ; }'", "label": "'Connects multiple restrictions with an logical disjunction . Calling this method is a shortcut for creating a { @link Disjunction } by calling { @link #disjunction () } and adding all restrictions to it .'"}
{"text": "'public static Criterion in ( String relativePath , Collection < ? > values ) { return new InExpression ( relativePath , values . toArray ( ) ) ; }'", "label": "'Adds an in restriction to a persistent field .'"}
{"text": "'public static Criterion allEq ( Map < String , Object > values ) { Conjunction conjunction = new Conjunction ( ) ; for ( Entry < String , Object > entry : values . entrySet ( ) ) { conjunction . add ( eq ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } return conjunction ; }'", "label": "'<p > Creates a conjunction of equals restrictions for each entry in the map . < / p >'"}
{"text": "'public static Criterion memberOf ( String relativePath , Object value ) { return new MemberOfExpression ( relativePath , value , false ) ; }'", "label": "'Creates a member of restriction .'"}
{"text": "'public static Criterion notMemberOf ( String relativePath , Object value ) { return new MemberOfExpression ( relativePath , value , true ) ; }'", "label": "'Creates a not member of restriction .'"}
{"text": "'public String toQueryString ( Criteria criteria , CriteriaQueryBuilder queryBuilder ) { // check whether list is empty if ( projectionList . isEmpty ( ) ) { throw new IllegalStateException ( \"A projection list must have at least one child.\" ) ; } // query builder StringBuilder builder = new StringBuilder ( ) ; // iterate over all projections from the list Iterator < Projection > iter = projectionList . iterator ( ) ; while ( iter . hasNext ( ) ) { Projection projection = iter . next ( ) ; // call toQueryString() on child builder . append ( projection . toQueryString ( criteria , queryBuilder ) ) ; // append comma if more projections follow if ( iter . hasNext ( ) ) { builder . append ( \",\" ) ; } } // return result return builder . toString ( ) ; }'", "label": "'/ *'"}
{"text": "'public String toGroupByString ( Criteria criteria , CriteriaQueryBuilder queryBuilder ) { // query builder StringBuilder builder = new StringBuilder ( ) ; // iterate over all projections from the list Iterator < Projection > iter = projectionList . iterator ( ) ; while ( iter . hasNext ( ) ) { Projection projection = iter . next ( ) ; // call toGroupByString() on child String groupBy = projection . toGroupByString ( criteria , queryBuilder ) ; // add only if result is not null if ( groupBy != null && groupBy . trim ( ) . length ( ) > 0 ) { // first add a comma if the builder already contains something if ( builder . length ( ) > 0 ) { builder . append ( \",\" ) ; } // add group by expression of child builder . append ( groupBy ) ; } } // return result if something has been written to the builder String result = builder . toString ( ) . trim ( ) ; if ( result . length ( ) > 0 ) { return result ; } return null ; }'", "label": "'/ *'"}
{"text": "'public static String md5 ( String text ) { if ( text == null ) { return null ; } if ( text . length ( ) == 0 ) { return \"\" ; } try { md1 . update ( text . getBytes ( \"UTF8\" ) ) ; return hex ( md1 . digest ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; }'", "label": "'Md5\u52a0\u5bc6'"}
{"text": "'public static String sha ( String text ) { if ( text == null ) { return null ; } if ( text . length ( ) == 0 ) { return \"\" ; } try { md2 . update ( text . getBytes ( \"UTF8\" ) ) ; return hex ( md2 . digest ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; }'", "label": "'sha\u52a0\u5bc6 \u6b64\u5904\u5bf9text\u8fdb\u884c\u53cd\u5411\uff0c\u5bf9\u7ed3\u679c\u518d\u6b21\u53cd\u5411'"}
{"text": "'private static String hex ( byte [ ] arr ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < arr . length ; ++ i ) { sb . append ( Integer . toHexString ( ( arr [ i ] & 0xFF ) | 0x100 ) . substring ( 1 , 3 ) ) ; } return sb . toString ( ) ; }'", "label": "'\u5b57\u8282\u8f6c\u6362\u4e3a16\u8fdb\u5236'"}
{"text": "'public static boolean hasNewVersion ( String oldVersion , String newVersion ) { //\u7248\u672c\u53f7\u6709\u4e00\u4e2a\u4e0d\u6b63\u5e38\u5c31\u8fd4\u56defalse if ( CBStringUtil . isEmptyOrNull ( oldVersion ) || CBStringUtil . isEmptyOrNull ( newVersion ) ) { return false ; } boolean res = false ; String [ ] oldVersionSnippet = oldVersion . split ( \"\\\\\\\\.\" ) ; String [ ] newVersionSnippet = newVersion . split ( \"\\\\\\\\.\" ) ; int maxComparePosition = Math . min ( oldVersionSnippet . length , newVersionSnippet . length ) ; int i = 0 ; for ( ; i < maxComparePosition ; i ++ ) { int newNumber = Integer . parseInt ( newVersionSnippet [ i ] ) ; int oldNumber = Integer . parseInt ( oldVersionSnippet [ i ] ) ; if ( newNumber == oldNumber ) { continue ; } if ( newNumber > oldNumber ) { res = true ; break ; } if ( newNumber < oldNumber ) { res = false ; break ; } } //\u524d\u9762\u7684\u90fd\u76f8\u7b49,\u6bd4\u8f83\u957f\u5ea6 if ( i == maxComparePosition ) { res = newVersionSnippet . length > oldVersionSnippet . length ; } return res ; }'", "label": "'\u672c\u53f7\u6bd4\u8f83 ( \u4f8b\u59821 . 10 . 0\u4e0e1 . 2 . 0\u7248\u672c\u6bd4\u8f83 ) \u8fd4\u56de\u662f\u5426\u6709\u65b0\u7248\u672c'"}
{"text": "'public void createFieldEditors ( ) { addField ( new StringFieldEditor ( PreferenceConstants . CLIENT_ID , \"Google API Client Id:\" , getFieldEditorParent ( ) ) ) ; addField ( new StringFieldEditor ( PreferenceConstants . CLIENT_SECRET , \"Google API Client Secret:\" , getFieldEditorParent ( ) ) ) ; }'", "label": "'Creates the field editors . Field editors are abstractions of the common GUI blocks needed to manipulate various types of preferences . Each field editor knows how to save and restore itself .'"}
{"text": "'public String toQueryString ( Criteria criteria , CriteriaQueryBuilder queryBuilder ) { if ( absolute ) { return path ; } else { return queryBuilder . getAbsolutePath ( criteria , path ) ; } }'", "label": "'/ *'"}
{"text": "'public String toGroupByString ( Criteria criteria , CriteriaQueryBuilder queryBuilder ) { if ( grouped ) { if ( absolute ) { return path ; } else { return queryBuilder . getAbsolutePath ( criteria , path ) ; } } return null ; }'", "label": "'/ *'"}
{"text": "'public String toQueryString ( Criteria criteria , CriteriaQueryBuilder queryBuilder ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( queryBuilder . createPositionalParameter ( ) ) ; if ( negate ) { builder . append ( \" NOT\" ) ; } builder . append ( \" MEMBER OF \" ) ; builder . append ( queryBuilder . getAbsolutePath ( criteria , relativePath ) ) ; return builder . toString ( ) ; }'", "label": "'/ *'"}
{"text": "'public static String generateAlias ( String basename , int counter , String fallback ) { // build trimmed and lower case version of the base name String lowerCaseBaseName = basename . trim ( ) . toLowerCase ( Locale . ENGLISH ) ; // use only simple characters for the alias StringBuilder builder = new StringBuilder ( ) ; for ( char c : lowerCaseBaseName . toCharArray ( ) ) { if ( c >= \\' \\' && c <= \\' \\' ) { builder . append ( c ) ; } } // add some default keyword, if builder is still empty if ( builder . length ( ) == 0 ) { if ( fallback != null && fallback . length ( ) > 0 ) { builder . append ( fallback ) ; } else { builder . append ( \"default\" ) ; } } // finally append the counter to get uniqueness builder . append ( counter ) ; // return the result return builder . toString ( ) ; }'", "label": "'Method to create unique aliases for JPA identifiers . Each alias consists of two parts . The <i > basename< / i > should be a human readable string that helps to identify which entity is referred . The <i > counter< / i > is unique number that is added to the alias to make the alias unique . It is recommended to use each counter value one once independently from the basename used .'"}
{"text": "\"public static String getLastPathComponent ( String path ) { // find last '.' character int pos = path . lastIndexOf ( ' ' ) ; // return the last path component // or the complete path, if no '.' chars were found return pos >= 0 ? path . substring ( pos + 1 ) : path ; }\"", "label": "'Returns the last component of a dot - separated path .'"}
{"text": "'public String toQueryString ( Criteria criteria , CriteriaQueryBuilder queryBuilder ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( \"NEW \" ) ; builder . append ( clazz . getName ( ) ) ; builder . append ( \\' \\' ) ; builder . append ( projectionList . toQueryString ( criteria , queryBuilder ) ) ; builder . append ( \\' \\' ) ; return builder . toString ( ) ; }'", "label": "'/ *'"}
{"text": "'public String toGroupByString ( Criteria criteria , CriteriaQueryBuilder queryBuilder ) { return projectionList . toGroupByString ( criteria , queryBuilder ) ; }'", "label": "'/ *'"}
{"text": "'protected void initialPopulateContainerNameField ( ) { super . initialPopulateContainerNameField ( ) ; IPath fullPath = getContainerFullPath ( ) ; IProject project = getProjectFromPath ( fullPath ) ; IPath root = ProjectUtils . getRootContainerForPath ( project , fullPath ) ; if ( root != null ) { return ; } root = ProjectUtils . getDefaultRootContainer ( project ) ; if ( root != null ) { setContainerFullPath ( root ) ; return ; } }'", "label": "'This method is overridden to set the selected folder to web contents folder if the current selection is outside the web contents folder .'"}
{"text": "'protected boolean validatePage ( ) { setMessage ( null ) ; setErrorMessage ( null ) ; if ( ! super . validatePage ( ) ) { return false ; } String fileName = getFileName ( ) ; IPath fullPath = getContainerFullPath ( ) ; if ( ( fullPath != null ) && ( fullPath . isEmpty ( ) == false ) && ( fileName != null ) ) { // check that filename does not contain invalid extension if ( ! extensionValidForContentType ( fileName ) ) { setErrorMessage ( \"Filename must end with .card\" ) ; return false ; } // no file extension specified so check adding default // extension doesn\\'t equal a file that already exists if ( fileName . lastIndexOf ( \\' \\' ) == - 1 ) { String newFileName = addDefaultExtension ( fileName ) ; IPath resourcePath = fullPath . append ( newFileName ) ; IWorkspace workspace = ResourcesPlugin . getWorkspace ( ) ; IStatus result = workspace . validatePath ( resourcePath . toString ( ) , IResource . FOLDER ) ; if ( ! result . isOK ( ) ) { // path invalid setErrorMessage ( result . getMessage ( ) ) ; return false ; } if ( ( workspace . getRoot ( ) . getFolder ( resourcePath ) . exists ( ) || workspace . getRoot ( ) . getFile ( resourcePath ) . exists ( ) ) ) { setErrorMessage ( \"There is a card with that name\" ) ; return false ; } } // get the IProject for the selection path IProject project = getProjectFromPath ( fullPath ) ; // if inside web project, check if inside webContent folder if ( project != null && isWebProject ( project ) ) { // check that the path is inside the webContent folder IPath [ ] webContentPaths = ProjectUtils . getAcceptableRootPaths ( project ) ; boolean isPrefix = false ; for ( int i = 0 ; ! isPrefix && i < webContentPaths . length ; i ++ ) { isPrefix |= webContentPaths [ i ] . isPrefixOf ( fullPath ) ; } if ( ! isPrefix ) { setMessage ( \"Cards must be inside the web contents\" , WARNING ) ; } } } return true ; }'", "label": "'This method is overridden to set additional validation specific to html files .'"}
{"text": "\"private boolean extensionValidForContentType ( String fileName ) { boolean valid = false ; IContentType type = getContentType ( ) ; // there is currently an extension if ( fileName . lastIndexOf ( ' ' ) != - 1 ) { // check what content types are associated with current extension IContentType [ ] types = Platform . getContentTypeManager ( ) . findContentTypesFor ( fileName ) ; int i = 0 ; while ( i < types . length && ! valid ) { valid = types [ i ] . isKindOf ( type ) ; ++ i ; } } else valid = true ; // no extension so valid return valid ; }\"", "label": "'Verifies if fileName is valid name for content type . Takes base content type into consideration .'"}
{"text": "'String addDefaultExtension ( String filename ) { StringBuffer newFileName = new StringBuffer ( filename ) ; String ext = \"card\" ; newFileName . append ( \".\" ) ; //$NON-NLS-1$ newFileName . append ( ext ) ; return newFileName . toString ( ) ; }'", "label": "'Adds default extension to the filename'"}
{"text": "'private IProject getProjectFromPath ( IPath path ) { IWorkspace workspace = ResourcesPlugin . getWorkspace ( ) ; IProject project = null ; if ( path != null ) { if ( workspace . validatePath ( path . toString ( ) , IResource . PROJECT ) . isOK ( ) ) { project = workspace . getRoot ( ) . getProject ( path . toString ( ) ) ; } else { project = workspace . getRoot ( ) . getFile ( path ) . getProject ( ) ; } } return project ; }'", "label": "'Returns the project that contains the specified path'"}
{"text": "'public static Criteria createCriteria ( EntityManager entityManager , Class < ? > persistentClass ) { errorIfClosed ( entityManager ) ; return new CriteriaImpl ( entityManager , persistentClass . getSimpleName ( ) ) ; }'", "label": "'<p > Creates a new { @link Criteria } query for a entity class . < / p >'"}
{"text": "'public static Criteria createCriteria ( EntityManager entityManager , Class < ? > persistentClass , String alias ) { return new CriteriaImpl ( entityManager , persistentClass . getSimpleName ( ) , alias ) ; }'", "label": "'<p > Creates a new { @link Criteria } query for a entity class . Sets the specified alias for the root entity . You may later use this alias to refer to the entity in { @link Criterion } { @link Projection } and { @link Order } instances . < / p >'"}
{"text": "'public static Criteria createCriteria ( EntityManager entityManager , String entityName , String alias ) { errorIfClosed ( entityManager ) ; return new CriteriaImpl ( entityManager , entityName , alias ) ; }'", "label": "'<p > Creates a new { @link Criteria } query for a named entity . Sets the specified alias for the root entity . You may later use this alias to refer to the entity in { @link Criterion } { @link Projection } and { @link Order } instances . < / p >'"}
{"text": "'public String toQueryString ( Criteria criteria , CriteriaQueryBuilder queryBuilder ) { // fallback for empty criteria list if ( criterionList . isEmpty ( ) ) { return \"1=1\" ; } // build junction StringBuilder builder = new StringBuilder ( ) ; builder . append ( \"(\" ) ; Iterator < Criterion > critIter = criterionList . iterator ( ) ; while ( critIter . hasNext ( ) ) { // add JPQL string builder . append ( critIter . next ( ) . toQueryString ( criteria , queryBuilder ) ) ; // add op if more entries follow if ( critIter . hasNext ( ) ) { builder . append ( \\' \\' ) . append ( op ) . append ( \\' \\' ) ; } } builder . append ( \")\" ) ; return builder . toString ( ) ; }'", "label": "'/ *'"}
{"text": "'public Object [ ] getParameterValues ( ) { ArrayList < Object > values = new ArrayList < Object > ( ) ; // process all criteria from criterionList for ( Criterion criterion : criterionList ) { // add all values from this criterion to result list for ( Object value : criterion . getParameterValues ( ) ) { values . add ( value ) ; } } return values . toArray ( ) ; }'", "label": "'/ *'"}
{"text": "'public AuthorizationCodeFlow newAuthorizationCodeFlow ( ) throws IOException { return new GoogleAuthorizationCodeFlow . Builder ( new NetHttpTransport ( ) , new JacksonFactory ( ) , clientId , clientSecret , Collections . singleton ( scope ) ) . setAccessType ( accessType ) . setCredentialDataStore ( getInMemoryDatastore ( ) ) . build ( ) ; }'", "label": "'Creates and returns a new {'"}
{"text": "'public String getUserId ( HttpServletRequest request ) { HttpSession session = request . getSession ( ) ; return ( String ) session . getAttribute ( \"userId\" ) ; }'", "label": "'Get the current user s ID from the session'"}
{"text": "'void createPage0 ( ) { try { textEditor = new StructuredTextEditor ( ) ; int index = addPage ( textEditor , getEditorInput ( ) ) ; setPageText ( index , \"Source\" ) ; setPartName ( textEditor . getTitle ( ) ) ; } catch ( PartInitException e ) { ErrorDialog . openError ( getSite ( ) . getShell ( ) , \"Error creating nested text editor\" , null , e . getStatus ( ) ) ; } }'", "label": "'Creates Structured Twext Editot of the multi - page editor which contains an HTML editor .'"}
{"text": "'void createPage1 ( ) { Composite composite = new Composite ( getContainer ( ) , SWT . NONE ) ; RowLayout layout = new RowLayout ( ) ; layout . wrap = false ; layout . pack = true ; layout . justify = true ; layout . type = SWT . VERTICAL ; layout . marginLeft = 5 ; layout . marginTop = 5 ; layout . marginRight = 5 ; layout . marginBottom = 5 ; layout . spacing = 0 ; composite . setLayout ( layout ) ; browser = new Browser ( composite , SWT . NONE ) ; browser . setLayoutData ( new RowData ( 640 , 360 ) ) ; Button previewOnGlass = new Button ( composite , SWT . NONE ) ; previewOnGlass . setText ( \"#throughglass\\ufeff\");   previewOnGlass . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent event ) { if ( ! setClientprovider ( ) ) { GoogleLogin . promptToLogIn ( \"Glassmaker\" ) ; } if ( GoogleLogin . getInstance ( ) . isLoggedIn ( ) ) previewOnGlass ( ) ; } } ) ; int index = addPage ( composite ) ; setPageText ( index , \"Preview\" ) ; }'", "label": "'Creates page 1 of the multi - page editor which is used to preview the page .'"}
{"text": "'public void doSaveAs ( ) { IEditorPart editor = getEditor ( 0 ) ; editor . doSaveAs ( ) ; setPageText ( 0 , editor . getTitle ( ) ) ; setInput ( editor . getEditorInput ( ) ) ; }'", "label": "'Saves the multi - page editor s document as another file . Also updates the text for page 0 s tab and updates this multi - page editor s input to correspond to the nested editor s .'"}
{"text": "'public void init ( IEditorSite site , IEditorInput editorInput ) throws PartInitException { if ( ! ( editorInput instanceof IFileEditorInput ) ) throw new PartInitException ( \"Invalid Input: Must be IFileEditorInput\" ) ; super . init ( site , editorInput ) ; }'", "label": "'The <code > MultiPageEditorExample< / code > implementation of this method checks that the input is an instance of <code > IFileEditorInput< / code > .'"}
{"text": "'public void resourceChanged ( final IResourceChangeEvent event ) { if ( event . getType ( ) == IResourceChangeEvent . PRE_CLOSE ) { Display . getDefault ( ) . asyncExec ( new Runnable ( ) { public void run ( ) { IWorkbenchPage [ ] pages = getSite ( ) . getWorkbenchWindow ( ) . getPages ( ) ; for ( int i = 0 ; i < pages . length ; i ++ ) { if ( ( ( FileEditorInput ) textEditor . getEditorInput ( ) ) . getFile ( ) . getProject ( ) . equals ( event . getResource ( ) ) ) { IEditorPart editorPart = pages [ i ] . findEditor ( textEditor . getEditorInput ( ) ) ; pages [ i ] . closeEditor ( editorPart , true ) ; } } } } ) ; } }'", "label": "'Closes all project files on project close .'"}
{"text": "'void showPage ( ) { String editorText = getDocumentProvider ( ) . getDocument ( textEditor . getEditorInput ( ) ) . get ( ) ; deletePreviewFiles ( ) ; File file = toPreviewFile ( editorText ) ; if ( file != null ) { PREVIEW_FILES_LIST . add ( file ) ; String s = \"file://\" + file . getAbsolutePath ( ) ; //$NON-NLS-1$ browser . setJavascriptEnabled ( true ) ; browser . setUrl ( s ) ; } else { browser . setText ( editorText , true ) ; } }'", "label": "'Sorts the words in page 0 and shows them in page 2 .'"}
{"text": "'public static String createQueryLogMessage ( String query , List < Object > parameterValues ) { // builder for log message StringBuilder builder = new StringBuilder ( ) ; // log the JPQL query string builder . append ( \"Query: \\\\\"\" ) ; builder . append ( query ) ; builder . append ( \"\\\\\"\" ) ; // append parameter value list if ( parameterValues != null && parameterValues . size ( ) > 0 ) { builder . append ( \", parameters: { \" ) ; // parameter value iterator Iterator < Object > parameterIterator = parameterValues . iterator ( ) ; // iterate over all parameter values while ( parameterIterator . hasNext ( ) ) { // use private helper to create string representation builder . append ( objectToString ( parameterIterator . next ( ) ) ) ; // append comma if more values follow if ( parameterIterator . hasNext ( ) ) { builder . append ( \", \" ) ; } } // closing bracket builder . append ( \" }\" ) ; } // return result return builder . toString ( ) ; }'", "label": "'Method to create a human readable log message regarding a generated query .'"}
{"text": "'private static String objectToString ( Object obj ) { // handle \\'null\\' if ( obj == null ) { return \"null\" ; } // enclose Strings in quotes if ( obj instanceof CharSequence ) { return \"\\\\\"\" + obj . toString ( ) + \"\\\\\"\" ; } // use toString() for all other objects return obj . toString ( ) ; }'", "label": "'Helper method to create a string representation of an object .'"}
{"text": "'public TimelineItem insertTimelineItem ( TimelineItem item ) throws IOException { return getMirror ( ) . timeline ( ) . insert ( item ) . execute ( ) ; }'", "label": "'Inserts a simple timeline item .'"}
{"text": "'public void insertTimelineItem ( TimelineItem item , String attachmentContentType , byte [ ] attachmentData ) throws IOException { Mirror . Timeline timeline = getMirror ( ) . timeline ( ) ; timeline . insert ( item , new ByteArrayContent ( attachmentContentType , attachmentData ) ) . execute ( ) ; }'", "label": "'Inserts an item with an attachment provided as a byte array .'"}
{"text": "'public void insertTimelineItem ( TimelineItem item , String attachmentContentType , InputStream attachmentInputStream ) throws IOException { insertTimelineItem ( item , attachmentContentType , ByteStreams . toByteArray ( attachmentInputStream ) ) ; }'", "label": "'Inserts an item with an attachment provided as an input stream .'"}
{"text": "'protected static ObjectMapper configure ( final ObjectMapper json ) { final SimpleModule jodaModule = new SimpleModule ( \"Joda\" ) ; jodaModule . addSerializer ( new JodaDateTimeSerializer ( ) ) ; jodaModule . addDeserializer ( DateTime . class , new JodaDateTimeDeserializer ( ) ) ; json . registerModule ( jodaModule ) ; // Increase performance even more json . registerModule ( new AfterburnerModule ( ) ) ; return json ; }'", "label": "'Configures the ObjectMapper . Currently adds { @link AfterburnerModule } for more speed and Joda date / time serializer / deserializers .'"}
{"text": "'@ Override public void clearCache ( final String name ) { try { final CacheResponse response = objectMapper . readValue ( requestFactory . buildPostRequest ( new ClearCacheUrl ( hostName , projectId , name ) , new EmptyContent ( ) ) . execute ( ) . getContent ( ) , CacheResponse . class ) ; validate ( response , \"cleared\" ) ; log . debug ( \"Successful request to clear to cache {}\" , name ) ; } catch ( final HTTPException e ) { if ( e . getStatusCode ( ) == 301 ) { // Swallow this since that is what happens when cleared (it // isn\\'t documented in the API spec) return ; } throw Throwables . propagate ( e ) ; } catch ( final Exception e ) { throw Throwables . propagate ( e ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void deleteCache ( final String name ) { try { final CacheResponse response = objectMapper . readValue ( requestFactory . buildDeleteRequest ( new CacheUrl ( hostName , projectId , name ) ) . execute ( ) . getContent ( ) , CacheResponse . class ) ; validate ( response , \"deleted\" ) ; } catch ( final Exception e ) { throw Throwables . propagate ( e ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void deleteItem ( final String name , final String key ) { try { final CacheResponse response = objectMapper . readValue ( requestFactory . buildDeleteRequest ( new CacheItemUrl ( hostName , projectId , name , key ) ) . execute ( ) . getContent ( ) , CacheResponse . class ) ; validate ( response , \"deleted\" ) ; } catch ( final Exception e ) { throw Throwables . propagate ( e ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public Optional < Cache > getCache ( final String name ) { try { return Optional . fromNullable ( objectMapper . readValue ( requestFactory . buildGetRequest ( new CacheUrl ( hostName , projectId , name ) ) . execute ( ) . getContent ( ) , Cache . class ) ) ; } catch ( final HTTPException e ) { if ( e . getStatusCode ( ) == 404 ) { return Optional . absent ( ) ; } throw Throwables . propagate ( e ) ; } catch ( final Exception e ) { throw Throwables . propagate ( e ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public Optional < CachedItem > getItem ( final String name , final String key ) { try { return Optional . fromNullable ( objectMapper . readValue ( requestFactory . buildGetRequest ( new CacheItemUrl ( hostName , projectId , name , key ) ) . execute ( ) . getContent ( ) , CachedItem . class ) ) ; } catch ( final HTTPException e ) { if ( e . getStatusCode ( ) == 404 ) { return Optional . absent ( ) ; } throw Throwables . propagate ( e ) ; } catch ( final Exception e ) { throw Throwables . propagate ( e ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void incrementItem ( final String name , final String key , final int amount ) { try { final IncrementCacheResponse response = objectMapper . readValue ( requestFactory . buildPostRequest ( new IncrementCacheItemUrl ( hostName , projectId , name , key ) , new JsonHttpContent ( JSON_FACTORY , new Increment ( ) . amount ( amount ) ) ) . execute ( ) . getContent ( ) , IncrementCacheResponse . class ) ; // Validate an increment, presence of a value is validation if ( null == response . getValue ( ) ) { String message = MoreObjects . firstNonNull ( response . getMessage ( ) , \"Increment value returned NULL\" ) ; throw new IllegalArgumentException ( message ) ; } } catch ( final Exception e ) { throw Throwables . propagate ( e ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public List < Cache > listCaches ( ) { try { return objectMapper . readValue ( requestFactory . buildGetRequest ( new CachesUrl ( hostName , projectId ) ) . execute ( ) . getContent ( ) , new TypeReference < List < Cache > > ( ) { } ) ; } catch ( final Exception e ) { throw Throwables . propagate ( e ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void putItem ( final String name , final CacheItemRequest request ) { try { validate ( request ) ; final CacheRequest item = new CacheRequest ( ) . value ( request . getValue ( ) ) . cas ( request . getCas ( ) ) . expires ( request . getExpireAfter ( ) ) ; // .replace(request.getOnlyIfExists()) // .add(request.getOnlyIfNotExists()); final CacheResponse response = objectMapper . readValue ( requestFactory . buildPutRequest ( new CacheItemUrl ( hostName , projectId , name , request . getKey ( ) ) , new JsonHttpContent ( JSON_FACTORY , item ) ) . execute ( ) . getContent ( ) , CacheResponse . class ) ; validate ( response , \"stored\" ) ; log . debug ( \"Successful request to add item {} with value {} to the cache {}\" , request . getKey ( ) , request . getValue ( ) , name ) ; } catch ( final Exception e ) { throw Throwables . propagate ( e ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'private void validate ( final CacheItemRequest request ) { Preconditions . checkArgument ( ! Strings . isNullOrEmpty ( request . getKey ( ) ) , \"A valid key must be supplied\" ) ; Preconditions . checkArgument ( null != request . getValue ( ) , \"A valid value must be supplied, it maybe an empty string\" ) ; Preconditions . checkArgument ( ! ( null != request . getOnlyIfExists ( ) && null != request . getOnlyIfNotExists ( ) ) , \"Cannot specify both Only If Exists and Only If Not Exists. The two conditions negate each other.\" ) ; Preconditions . checkArgument ( null == request . getExpireAfter ( ) || null != request . getExpireAfter ( ) && request . getExpireAfter ( ) > 0 , \"An expiration value must be greater then 0\" ) ; }'", "label": "'Validates that the request being made is going to end up in a valid request when processed on the server . This includes :'"}
{"text": "'private void validate ( final CacheResponse response , final String keyword ) { if ( ! response . getMessage ( ) . toLowerCase ( Locale . US ) . startsWith ( keyword ) ) { throw new IllegalArgumentException ( response . getMessage ( ) ) ; } }'", "label": "'Validates that the keyword expected was returned . Otherwise throws an exception with the message returned included .'"}
{"text": "'public String toQueryString ( Criteria criteria , CriteriaQueryBuilder queryBuilder ) { String absolutePath = queryBuilder . getAbsolutePath ( criteria , relativePath ) ; return ascending ? absolutePath : absolutePath + \" DESC\" ; }'", "label": "'Renders the order to a ORDER BY substring of JPQL query'"}
{"text": "'public TemplateStore getTemplateStore ( ) { if ( fTemplateStore == null ) { fTemplateStore = new ContributionTemplateStore ( getTemplateContextRegistry ( ) , getPreferenceStore ( ) , \"org.eclipse.wst.sse.ui.custom_templates\" ) ; try { fTemplateStore . load ( ) ; } catch ( IOException e ) { logError ( \"\" , e ) ; } } return fTemplateStore ; }'", "label": "'Returns the template store for the html editor templates .'"}
{"text": "'public ContextTypeRegistry getTemplateContextRegistry ( ) { if ( fContextTypeRegistry == null ) { ContributionContextTypeRegistry registry = new ContributionContextTypeRegistry ( ) ; registry . addContextType ( CardContextType . CONTEXT_TYPE ) ; fContextTypeRegistry = registry ; } return fContextTypeRegistry ; }'", "label": "'Returns the template context type registry for the html plugin .'"}
{"text": "'public String toQueryString ( Criteria criteria , CriteriaQueryBuilder queryBuilder ) { // query builder StringBuilder builder = new StringBuilder ( ) ; // build the basic query builder . append ( queryBuilder . getAbsolutePath ( criteria , relativePath ) ) ; builder . append ( \" IN (\" ) ; // We must add each value as a parameter, because not all JPA // implementations allow lists or arrays as parameters. if ( values != null ) { for ( int i = 0 ; i < values . length ; i ++ ) { builder . append ( queryBuilder . createPositionalParameter ( ) ) ; if ( i < values . length - 1 ) { builder . append ( \\' \\' ) ; } } } builder . append ( \")\" ) ; // return result return builder . toString ( ) ; }'", "label": "'/ *'"}
{"text": "'public String toQueryString ( Criteria criteria , CriteriaQueryBuilder queryBuilder ) { // replace alias variable by real name String queryFragment = jpql . replace ( \"{alias}\" , queryBuilder . getRequiredAlias ( criteria ) ) ; // process parameters for ( int i = 1 ; i <= values . length ; i ++ ) { // create positional parameter for this value String paramater = queryBuilder . createPositionalParameter ( ) ; /*\\n       * Replace variable with generated positional parameter.\\n       * Note: This kind of string processing is not very efficient, \\n       * because it generates a new string object in each iteration.\\n       * But we assume that the number of iterations will be\\n       * relative small, so it won\\'t be a real problem.\\n       */ queryFragment = queryFragment . replace ( \"{\" + i + \"}\" , paramater ) ; } return queryFragment ; }'", "label": "'/ *'"}
{"text": "'public Map < K , V > getMapSortByValueUp ( Map < K , V > sourceMap ) { return sortByValue ( sourceMap , GROW_UP ) ; }'", "label": "'\u6309\u7167Map\u4e2dkey\u8fdb\u884c\u5347\u5e8f\u6392\u5217'"}
{"text": "'public Map < K , V > getMapSortByValueDown ( Map < K , V > sourceMap ) { return sortByValue ( sourceMap , GROW_DOWN ) ; }'", "label": "'\u6309\u7167Map\u4e2dkey\u8fdb\u884c\u964d\u5e8f\u6392\u5217'"}
{"text": "'public Map < K , V > getMapSortByKeyUp ( Map < K , V > sourceMap ) { return sortByKey ( sourceMap , GROW_UP ) ; }'", "label": "'\u6309\u7167Map\u4e2dvalue\u8fdb\u884c\u5347\u5e8f\u6392\u5217'"}
{"text": "'public Map < K , V > getMapSortByKeyDown ( Map < K , V > sourceMap ) { return sortByKey ( sourceMap , GROW_DOWN ) ; }'", "label": "'\u6309\u7167Map\u4e2dvalue\u8fdb\u884c\u964d\u5e8f\u6392\u5217'"}
{"text": "'private Map < K , V > sortByKey ( Map < K , V > sourceMap , final int growthPattern ) { List < Entry < K , V > > list = new ArrayList < Entry < K , V > > ( sourceMap . entrySet ( ) ) ; Collections . sort ( list , new Comparator < Entry < K , V > > ( ) { @ Override public int compare ( Entry < K , V > o1 , Entry < K , V > o2 ) { K k1 = o1 . getKey ( ) ; K k2 = o2 . getKey ( ) ; return compareValue ( k1 , k2 ) * growthPattern ; } } ) ; Map < K , V > desMap = new LinkedHashMap < K , V > ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { Entry < K , V > item = list . get ( i ) ; desMap . put ( item . getKey ( ) , item . getValue ( ) ) ; } return desMap ; }'", "label": "'\u6839\u636emap\u4e2dkey\u8fdb\u884c\u6392\u5e8f'"}
{"text": "'private int compareValue ( Object v1 , Object v2 ) { if ( v1 instanceof Integer ) return Integer . compare ( ( Integer ) v1 , ( Integer ) v2 ) ; if ( v1 instanceof Float ) return Float . compare ( ( Float ) v1 , ( Float ) v2 ) ; if ( v1 instanceof Double ) return Double . compare ( ( Double ) v1 , ( Double ) v2 ) ; if ( v1 instanceof Long ) return Long . compare ( ( Long ) v1 , ( Long ) v2 ) ; if ( v1 instanceof Character ) return Character . compare ( ( Character ) v1 , ( Character ) v2 ) ; if ( v1 instanceof Short ) return Short . compare ( ( Short ) v1 , ( Short ) v2 ) ; return 0 ; }'", "label": "'\u5bf9\u952e\u503c\u5bf9\u4e2d\u503c\u8fdb\u884c\u6bd4\u8f83 \u53ea\u9488\u5bf96\u79cd\u57fa\u672c\u7c7b\u578b\uff0cshort int long float double char \u5176\u4ed6\u4e00\u5f8b\u8fd4\u56de\u76f8\u7b49'"}
{"text": "'@ Override public void setTimeout ( int connectTimeout , int readTimeout ) throws IOException { request . setConfig ( RequestConfig . custom ( ) . setSocketTimeout ( readTimeout ) . setConnectTimeout ( connectTimeout ) . build ( ) ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'protected IAction getAction ( ITextEditor editor , String actionID ) { return ( editor == null ? null : editor . getAction ( actionID ) ) ; }'", "label": "'Returns the action registed with the given text editor .'"}
{"text": "'public void setActivePage ( IEditorPart part ) { if ( activeEditorPart == part ) return ; activeEditorPart = part ; IActionBars actionBars = getActionBars ( ) ; if ( actionBars != null ) { ITextEditor editor = ( part instanceof ITextEditor ) ? ( ITextEditor ) part : null ; actionBars . setGlobalActionHandler ( ActionFactory . DELETE . getId ( ) , getAction ( editor , ITextEditorActionConstants . DELETE ) ) ; actionBars . setGlobalActionHandler ( ActionFactory . UNDO . getId ( ) , getAction ( editor , ITextEditorActionConstants . UNDO ) ) ; actionBars . setGlobalActionHandler ( ActionFactory . REDO . getId ( ) , getAction ( editor , ITextEditorActionConstants . REDO ) ) ; actionBars . setGlobalActionHandler ( ActionFactory . CUT . getId ( ) , getAction ( editor , ITextEditorActionConstants . CUT ) ) ; actionBars . setGlobalActionHandler ( ActionFactory . COPY . getId ( ) , getAction ( editor , ITextEditorActionConstants . COPY ) ) ; actionBars . setGlobalActionHandler ( ActionFactory . PASTE . getId ( ) , getAction ( editor , ITextEditorActionConstants . PASTE ) ) ; actionBars . setGlobalActionHandler ( ActionFactory . SELECT_ALL . getId ( ) , getAction ( editor , ITextEditorActionConstants . SELECT_ALL ) ) ; actionBars . setGlobalActionHandler ( ActionFactory . FIND . getId ( ) , getAction ( editor , ITextEditorActionConstants . FIND ) ) ; actionBars . setGlobalActionHandler ( IDEActionFactory . BOOKMARK . getId ( ) , getAction ( editor , IDEActionFactory . BOOKMARK . getId ( ) ) ) ; actionBars . updateActionBars ( ) ; } }'", "label": "'/ * ( non - JavaDoc ) Method declared in AbstractMultiPageEditorActionBarContributor .'"}
{"text": "'@ Override public DateTime deserialize ( final JsonParser parser , final DeserializationContext context ) throws IOException , JsonProcessingException { return formatter . parseDateTime ( parser . getText ( ) ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public String toQueryString ( Criteria criteria , CriteriaQueryBuilder queryBuilder ) { return queryBuilder . getRequiredAlias ( queryBuilder . getRootCriteria ( ) ) ; }'", "label": "'/ *'"}
{"text": "'public static void waitTime ( long millis , int nanos ) { try { Thread . sleep ( millis , nanos ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } }'", "label": "'\u7b49\u5f85'"}
{"text": "'public static String paramsToString ( String charset , String ... params ) { StringBuffer sb = new StringBuffer ( ) ; try { for ( int i = 0 ; i < params . length - 1 ; i = i + 1 ) { sb . append ( \"&\" ) ; sb . append ( URLEncoder . encode ( params [ i ] , charset ) ) ; sb . append ( \"=\" ) ; sb . append ( URLEncoder . encode ( params [ i + 1 ] , charset ) ) ; } } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } return sb . substring ( 1 ) ; }'", "label": "'convert parameters to string'"}
{"text": "'public static String paramsToString ( String charset , Map < String , String > params ) { StringBuffer sb = new StringBuffer ( ) ; try { for ( Map . Entry < String , String > item : params . entrySet ( ) ) { sb . append ( \"&\" ) ; sb . append ( URLEncoder . encode ( item . getKey ( ) , charset ) ) ; sb . append ( \"=\" ) ; sb . append ( URLEncoder . encode ( item . getValue ( ) , charset ) ) ; } } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } return sb . substring ( 1 ) ; }'", "label": "'convert parameters to string'"}
{"text": "'public String toQueryString ( Criteria criteria , CriteriaQueryBuilder queryBuilder ) { String path = queryBuilder . getAbsolutePath ( criteria , propertyName ) ; if ( ! negate ) { return path + \" IS NULL\" ; } else { return path + \" IS NOT NULL\" ; } }'", "label": "'/ *'"}
{"text": "'public synchronized void push ( ) { times . put ( String . format ( Locale . CHINA , TIME_KEY , ++ count ) , System . currentTimeMillis ( ) ) ; }'", "label": "'\u8bb0\u5f55\u5f53\u524d\u65f6\u95f4'"}
{"text": "'public void push ( String key , long time ) { if ( key . startsWith ( \"CB_TIMER\" ) ) { return ; } times . put ( key , time ) ; }'", "label": "'\u5c06\u6307\u5b9a\u65f6\u95f4\u4e0ekey\u8fdb\u884c\u5173\u8054 <p > key\u503c\u4e0d\u8981\u4ee5CB_TIMER\u5f00\u5934 CB_TIMER\u4e3a\u7cfb\u7edf\u5185\u7f6e\u8ba1\u65f6key \u4ee5CB_TIMER\u5f00\u5934\u7684key\u5c06\u81ea\u52a8\u88ab\u8fc7\u6ee4\u6389< / p >'"}
{"text": "'public long pop ( ) { if ( count < 0 ) { return - 1 ; } String key = String . format ( Locale . CHINA , TIME_KEY , count ) ; count -- ; return pop ( key ) ; }'", "label": "'\u83b7\u53d6\u6700\u540e\u4e00\u4e2apush\u5230\u5f53\u524d\u7684\u65f6\u95f4\u95f4\u9694 \u5982\u679cpop\u5df2\u7ecf\u5f39\u51fa\u4e86\u6240\u6709\u7684key \u8fd4\u56de - 1 <p > \u4e0e { @link CBTimer#push () } \u5bf9\u5e94 < / p >'"}
{"text": "'public long pop ( String key , long time ) { if ( ! times . containsKey ( key ) ) { return - 1L ; } long recordTime = times . get ( key ) ; times . remove ( key ) ; return time - recordTime ; }'", "label": "'\u83b7\u53d6\u6700\u540e\u4e00\u4e2apush key\u5230\u6307\u5b9a\u65f6\u95f4\u4e4b\u95f4\u7684\u65f6\u95f4\u95f4\u9694 <p > \u4e0e { @link CBTimer#push ( String ) } \u5bf9\u5e94 < / p >'"}
{"text": "'public Long get ( ) { return times . get ( String . format ( Locale . CHINA , TIME_KEY , count ) ) ; }'", "label": "'\u83b7\u53d6\u6700\u540e\u4e00\u6b21push\u7684\u65f6\u95f4 ( pop\u64cd\u4f5c\u4f1a\u62b5\u6d88\u4e00\u6b21push\u64cd\u4f5c ) \u5982\u679c\u6ca1\u6709\u5bf9\u5e94\u7684push\uff0c\u8fd4\u56denull'"}
{"text": "'public static String getFileContent ( String filePath , String encoding ) throws IOException { BufferedReader buff = new BufferedReader ( new InputStreamReader ( new FileInputStream ( filePath ) , encoding ) ) ; String content = getContent ( buff ) ; buff . close ( ) ; return content ; }'", "label": "'\u6309\u7167\u6307\u5b9a\u7f16\u7801\u5f97\u5230\u6587\u4ef6\u5185\u5bb9'"}
{"text": "'public static List < String > getFileContentAsList ( String filePath , String encoding ) throws IOException { return Arrays . asList ( getFileContent ( filePath , encoding ) . split ( \"\\\\\\\\n\" ) ) ; }'", "label": "'\u6309\u7167\u6307\u5b9a\u7f16\u7801\u5f97\u5230\u6587\u4ef6\u5185\u5bb9 \u4fdd\u5b58list\u4e2d'"}
{"text": "'public static List < String > getFileContentAsList ( File file , String encoding ) throws IOException { return Arrays . asList ( getFileContent ( new FileInputStream ( file ) , encoding ) . split ( \"\\\\\\\\n\" ) ) ; }'", "label": "'\u6309\u7167\u6307\u5b9a\u7f16\u7801\u5f97\u5230\u6587\u4ef6\u5185\u5bb9 \u4fdd\u5b58list\u4e2d'"}
{"text": "'public static String getFileContent ( InputStream is ) throws IOException { BufferedReader buff = new BufferedReader ( new InputStreamReader ( is , \"UTF-8\" ) ) ; String content = getContent ( buff ) ; buff . close ( ) ; return content ; }'", "label": "'\u6309\u7167UTF - 8\u7f16\u7801\u5f97\u5230\u8f93\u5165\u6d41\u5185\u5bb9'"}
{"text": "'public static byte [ ] getFileByteContent ( InputStream is , String encoding ) throws IOException { byte [ ] buffer = new byte [ 1024 ] ; int len ; ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; while ( ( len = is . read ( buffer ) ) != - 1 ) { outputStream . write ( buffer , 0 , len ) ; } outputStream . close ( ) ; is . close ( ) ; return outputStream . toByteArray ( ) ; }'", "label": "'\u6309\u7167\u6307\u5b9a\u7f16\u7801\u83b7\u53d6\u8f93\u5165\u6d41\u5b57\u8282\u5185\u5bb9'"}
{"text": "\"private static String getContent ( BufferedReader buff ) throws IOException { String line ; StringBuffer content = new StringBuffer ( ) ; while ( ( line = buff . readLine ( ) ) != null ) { content . append ( ' ' ) ; content . append ( line ) ; } return content . substring ( 1 ) . toString ( ) ; }\"", "label": "'\u83b7\u53d6BufferedReader\u5bf9\u5e94\u5b57\u7b26\u4e32'"}
{"text": "'public static void saveContentToFile ( String content , String filePath ) throws IOException { saveContentToFile ( content , filePath , DEFAULT_CHARSET ) ; }'", "label": "'\u6309\u7167UTF - 8\u7f16\u7801\u4fdd\u5b58\u5230\u76f8\u5e94\u5185\u5bb9\u5230\u6307\u5b9a\u8def\u5f84\u7684\u6587\u4ef6'"}
{"text": "'public static void saveContentToFile ( String content , String filePath , boolean append ) throws IOException { saveContentToFile ( content , new File ( filePath ) , DEFAULT_CHARSET , append ) ; }'", "label": "'\u6309\u7167UTF - 8\u7f16\u7801\u4fdd\u5b58\u5230\u76f8\u5e94\u5185\u5bb9\u5230\u6307\u5b9a\u8def\u5f84\u7684\u6587\u4ef6'"}
{"text": "'public static void saveContentToFile ( String content , File file ) throws IOException { saveContentToFile ( content , file , DEFAULT_CHARSET , false ) ; }'", "label": "'\u6309\u7167UTF - 8\u7f16\u7801\u4fdd\u5b58\u5230\u76f8\u5e94\u5185\u5bb9\u5230\u6307\u5b9a\u6587\u4ef6'"}
{"text": "'public static void saveContentToFile ( String content , File file , boolean append ) throws IOException { saveContentToFile ( content , file , DEFAULT_CHARSET , append ) ; }'", "label": "'\u6309\u7167UTF - 8\u7f16\u7801\u4fdd\u5b58\u5230\u76f8\u5e94\u5185\u5bb9\u5230\u6307\u5b9a\u6587\u4ef6'"}
{"text": "'public static void saveContentToFile ( URL url , String filePath ) throws IOException { saveContentToFile ( url , new File ( filePath ) ) ; }'", "label": "'\u4fdd\u5b58\u7f51\u7edc\u6587\u4ef6\u5230\u6307\u5b9a\u8def\u5f84'"}
{"text": "'public static void saveContentToFile ( URL url , File file ) throws IOException { InputStream is = url . openStream ( ) ; FileOutputStream fos = new FileOutputStream ( file ) ; byte [ ] b = new byte [ 1024 ] ; int len ; while ( ( len = is . read ( b ) ) != - 1 ) { fos . write ( b , 0 , len ) ; } fos . flush ( ) ; fos . close ( ) ; is . close ( ) ; }'", "label": "'\u4fdd\u5b58\u7f51\u7edc\u6587\u4ef6\u5230\u6307\u5b9a\u6587\u4ef6'"}
{"text": "'public static void saveContentToFile ( String content , String filePath , String encoding ) throws IOException { saveContentToFile ( content , new File ( filePath ) , encoding , false ) ; }'", "label": "'\u6309\u7167\u6307\u5b9a\u7f16\u7801\u4fdd\u5b58\u76f8\u5e94\u5185\u5bb9\u5230\u6307\u5b9a\u8def\u5f84\u7684\u6587\u4ef6'"}
{"text": "'public static void saveContentToFile ( String content , File file , String encoding , boolean append ) throws IOException { BufferedWriter buff = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( file , append ) , encoding ) ) ; buff . write ( content ) ; buff . flush ( ) ; buff . close ( ) ; }'", "label": "'\u6309\u7167\u6307\u5b9a\u7f16\u7801\u4fdd\u5b58\u76f8\u5e94\u5185\u5bb9\u5230\u6307\u5b9a\u6587\u4ef6'"}
{"text": "'public void startAllTasks ( ) { while ( queue . size ( ) != 0 && ! stopSign ) { ICBTask task = queue . poll ( ) ; if ( task == null ) { continue ; } setAndStartTask ( task ) ; } }'", "label": "'\u5f00\u59cb\u6267\u884c'"}
{"text": "'public void startAllTasksAndWaiting ( ) throws InterruptedException { List < ICBTask > taskList = new ArrayList <> ( ) ; while ( queue . size ( ) != 0 && ! stopSign ) { ICBTask task = queue . poll ( ) ; if ( task == null ) { continue ; } taskList . add ( task ) ; setAndStartTask ( task ) ; } for ( ICBTask task : taskList ) { if ( ! task . isTaskFinished ( ) ) { task . waitForEnd ( ) ; } } }'", "label": "'\u5f00\u59cb\u6267\u884c\u5e76\u4e14\u7b49\u5f85\u7ed3\u675f'"}
{"text": "'private void setAndStartTask ( ICBTask task ) { task . setTaskListener ( new CBTaskListener ( ) { @ Override public void onTaskStart ( ) { lock . lock ( ) ; if ( currentExecuteTaskNumber > maxTaskNumber ) { try { condition . await ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } currentExecuteTaskNumber ++ ; lock . unlock ( ) ; } @ Override public void onTaskEnd ( ) { lock . lock ( ) ; currentExecuteTaskNumber -- ; condition . signal ( ) ; lock . unlock ( ) ; } } ) ; task . startTask ( ) ; }'", "label": "'\u8bbe\u7f6e\u4efb\u52a1\u7684\u76d1\u542c\u5668\u5e76\u5f00\u59cb\u4efb\u52a1'"}
{"text": "'public void stopAllTasks ( ) { ICBTask task ; stopSign = true ; while ( ( task = queue . poll ( ) ) != null ) { task . stopTask ( ) ; } }'", "label": "'\u505c\u6b62\u4efb\u52a1'"}
{"text": "'@ Override public String encodeURL ( String href ) throws UnsupportedEncodingException { return response . encodeURL ( UrlUtils . encodeUrlPath ( href , response . getCharacterEncoding ( ) ) ) ; }'", "label": "'Encodes the URL by : <ol > <li > Encoding the path elements with the current response character encoding . < / li > <li > Calling response . encodeURL () < / li > < / ol >'"}
{"text": "'private DBI createDBI ( ) throws Exception { if ( driver != null ) { Class . forName ( driver ) . newInstance ( ) ; } return new DBI ( url , user , password ) ; }'", "label": "'Creates the datasource config based on the provided parameters .'"}
{"text": "'protected void appendLimitAndOffSet ( final StringBuilder sql , final Page page ) { sql . append ( \" LIMIT \" ) . append ( page . getPageSize ( ) ) . append ( \" OFFSET \" ) . append ( page . getOffset ( ) ) ; }'", "label": "'Appends LIMIT and OFFSET for POSTGRESQL SQL queries'"}
{"text": "'public static DocumentRoot < QName > makeSBOL2Document ( ) { NestedDocument < QName > instantiationLacI = NestedDocument ( Sbol2Terms . instantiation . componentInstantiation , sbolExample . namespacedUri ( \"module_LacI_inverter/LacI_instantiation\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . documented . name , \"LacI\" ) ) ) ; NestedDocument < QName > instantiationIPTG = NestedDocument ( Sbol2Terms . instantiation . componentInstantiation , sbolExample . namespacedUri ( \"module_LacI_inverter/IPTG\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . documented . name , \"IPTG\" ) ) ) ; NestedDocument < QName > instantiationIPTGLacI = NestedDocument ( Sbol2Terms . instantiation . componentInstantiation , sbolExample . namespacedUri ( \"module_LacI_inverter/IPTG_LacI_complex\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . documented . name , \"IPTG LacI complex\" ) ) ) ; NestedDocument < QName > instantiationpLac = NestedDocument ( Sbol2Terms . instantiation . componentInstantiation , sbolExample . namespacedUri ( \"module_LacI_inverter/pLac_instantiation\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . documented . name , \"pLac promoter\" ) ) ) ; NestedDocument < QName > instantiationcTetR = NestedDocument ( Sbol2Terms . instantiation . componentInstantiation , sbolExample . namespacedUri ( \"module_LacI_inverter/cTetR_instantiation\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . documented . name , \"cTetR\" ) ) ) ; NestedDocument < QName > instantiationTetR = NestedDocument ( Sbol2Terms . instantiation . componentInstantiation , sbolExample . namespacedUri ( \"module_LacI_inverter/TetR_instantiation\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . documented . name , \"TetR\" ) ) ) ; NestedDocument < QName > interactionIPTGBinding = NestedDocument ( Sbol2Terms . module . interaction , sbolExample . namespacedUri ( \"module_LacI_inverter/interaction/IPTG_binding\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . documented . name , \"IPTG Binding\" ) , NamedProperty ( RdfTerms . rdfType , URI . create ( \"http://purl.obolibrary.org/obo/non_covalent_binding\" ) ) , NamedProperty ( Sbol2Terms . module . hasParticipation , NestedDocument ( Sbol2Terms . module . participation , partsRegistry . namespacedUri ( \"module_LacI_inverter/interaction/IPTG_Binding/LacI_participation\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . module . role , URI . create ( \"http://purl.obolibrary.org/obo/reactant\" ) ) , NamedProperty ( Sbol2Terms . module . participant , instantiationLacI . getIdentity ( ) ) ) ) ) , NamedProperty ( Sbol2Terms . module . hasParticipation , NestedDocument ( Sbol2Terms . module . participation , partsRegistry . namespacedUri ( \"module_LacI_inverter/interaction/IPTG_Binding/IPTGLacI_participation\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . module . role , URI . create ( \"http://purl.obolibrary.org/obo/product\" ) ) , NamedProperty ( Sbol2Terms . module . participant , instantiationIPTGLacI . getIdentity ( ) ) ) ) ) , NamedProperty ( Sbol2Terms . module . hasParticipation , NestedDocument ( Sbol2Terms . module . participation , partsRegistry . namespacedUri ( \"module_LacI_inverter/interaction/IPTG_Binding/IPTG_participation\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . module . role , URI . create ( \"http://purl.obolibrary.org/obo/reactant\" ) ) , NamedProperty ( Sbol2Terms . module . participant , instantiationIPTG . getIdentity ( ) ) ) ) ) ) ) ; NestedDocument < QName > interactionLacIRepression = NestedDocument ( Sbol2Terms . module . interaction , sbolExample . namespacedUri ( \"module_LacI_inverter/interaction/LacI_repression\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . documented . name , \"LacI Repression\" ) , NamedProperty ( RdfTerms . rdfType , URI . create ( \"http://purl.obolibrary.org/obo/repression\" ) ) , NamedProperty ( Sbol2Terms . module . hasParticipation , NestedDocument ( Sbol2Terms . module . participation , partsRegistry . namespacedUri ( \"module_LacI_inverter/interaction/LacI_repression/LacI\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . module . role , URI . create ( \"http://purl.obolibrary.org/obo/repressor\" ) ) , NamedProperty ( Sbol2Terms . module . participant , instantiationLacI . getIdentity ( ) ) ) ) ) , NamedProperty ( Sbol2Terms . module . hasParticipation , NestedDocument ( Sbol2Terms . module . participation , partsRegistry . namespacedUri ( \"module_LacI_inverter/interaction/LacI_repression/pLac\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . module . role , URI . create ( \"http://purl.obolibrary.org/obo/repressed\" ) ) , NamedProperty ( Sbol2Terms . module . participant , instantiationpLac . getIdentity ( ) ) ) ) ) ) ) ; NestedDocument < QName > interactionTetRTranscriptionTranslation = NestedDocument ( Sbol2Terms . module . interaction , sbolExample . namespacedUri ( \"module_LacI_inverter/interaction/TetR_transcription_translation\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . documented . name , \"TetR Transcription Translation\" ) , NamedProperty ( RdfTerms . rdfType , URI . create ( \"http://purl.obolibrary.org/obo/genetic_production\" ) ) , NamedProperty ( RdfTerms . rdfType , URI . create ( \"http://made.up.terms.org/unicorns\" ) ) , NamedProperty ( Sbol2Terms . module . hasParticipation , NestedDocument ( Sbol2Terms . module . participation , partsRegistry . namespacedUri ( \"module_LacI_inverter/interaction/TetR_transcription_translation/TetR_participation\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . module . role , URI . create ( \"http://purl.obolibrary.org/obo/product\" ) ) , NamedProperty ( Sbol2Terms . module . participant , instantiationTetR . getIdentity ( ) ) ) ) ) , NamedProperty ( Sbol2Terms . module . hasParticipation , NestedDocument ( Sbol2Terms . module . participation , partsRegistry . namespacedUri ( \"module_LacI_inverter/interaction/TetR_transcription_translation/cTetR_participation\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . module . role , URI . create ( \"http://purl.obolibrary.org/obo/transcribed\" ) ) , NamedProperty ( Sbol2Terms . module . participant , instantiationcTetR . getIdentity ( ) ) ) ) ) , NamedProperty ( Sbol2Terms . module . hasParticipation , NestedDocument ( Sbol2Terms . module . participation , partsRegistry . namespacedUri ( \"module_LacI_inverter/interaction/TetR_transcription_translation/pLac_participation\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . module . role , URI . create ( \"http://purl.obolibrary.org/obo/modifier\" ) ) , NamedProperty ( Sbol2Terms . module . participant , instantiationpLac . getIdentity ( ) ) ) ) ) ) ) ; TopLevelDocument < QName > modelLacIInverter = TopLevelDocument ( NamespaceBindings ( utah ) , Sbol2Terms . model . model , sbolExample . namespacedUri ( \"model/LacI_inverter\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . documented . name , \"LacI Inverter Model\" ) , NamedProperty ( Sbol2Terms . model . source , URI . create ( \"http://www.async.ece.utah.edu/LacI_Inverter.xml\" ) ) , NamedProperty ( Sbol2Terms . model . language , \"SBML\" ) , NamedProperty ( Sbol2Terms . model . framework , \"ODE\" ) , NamedProperty ( Sbol2Terms . model . role , \"simulation\" ) ) ) ; TopLevelDocument < QName > moduleLacIInverter = TopLevelDocument ( Sbol2Terms . module . module , sbolExample . namespacedUri ( \"module/LacI_inverter\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . documented . name , \"LacI Inverter\" ) , NamedProperty ( Sbol2Terms . module . hasInteraction , interactionIPTGBinding ) , NamedProperty ( Sbol2Terms . module . hasInteraction , interactionLacIRepression ) , NamedProperty ( Sbol2Terms . module . hasInteraction , interactionTetRTranscriptionTranslation ) , NamedProperty ( Sbol2Terms . instantiation . hasComponentInstantiation , instantiationLacI ) , NamedProperty ( Sbol2Terms . instantiation . hasComponentInstantiation , instantiationIPTG ) , NamedProperty ( Sbol2Terms . instantiation . hasComponentInstantiation , instantiationIPTGLacI ) , NamedProperty ( Sbol2Terms . instantiation . hasComponentInstantiation , instantiationpLac ) , NamedProperty ( Sbol2Terms . instantiation . hasComponentInstantiation , instantiationcTetR ) , NamedProperty ( Sbol2Terms . instantiation . hasComponentInstantiation , instantiationTetR ) , NamedProperty ( Sbol2Terms . module . hasModel , modelLacIInverter . getIdentity ( ) ) ) ) ; return DocumentRoot ( NamespaceBindings ( RdfTerms . rdf , SbolTerms . sbol2 , partsRegistry , sbolExample , obo ) , TopLevelDocuments ( moduleLacIInverter , modelLacIInverter ) ) ; }'", "label": "'Creates an example {'"}
{"text": "'public static DocumentRoot < QName > makeSBOL2SequenceComponent ( ) { TopLevelDocument < QName > pLac = TopLevelDocument ( Sbol2Terms . component . sequenceComponent , sbolExample . namespacedUri ( \"sequenceComponent/pLac\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . documented . name , \"pLac\" ) , NamedProperty ( Sbol2Terms . documented . displayId , \"pLac\" ) , NamedProperty ( RdfTerms . rdfType , URI . create ( \"DNA\" ) ) , NamedProperty ( Sbol2Terms . component . sequenceType , URI . create ( \"http://purl.org/obo/owl/SO#SO_0000167\" ) ) ) ) ; NestedDocument < QName > instantiationpLac = NestedDocument ( Sbol2Terms . instantiation . componentInstantiation , sbolExample . namespacedUri ( \"sequenceComponent/pLac/instantiation\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . documented . name , \"pLac\" ) , NamedProperty ( Sbol2Terms . component . component , pLac . getIdentity ( ) ) ) ) ; NestedDocument < QName > pLacAnnotation = NestedDocument ( Sbol2Terms . component . sequenceAnnotation , sbolExample . namespacedUri ( \"sequenceComponent/UU_002/pLac_annotation\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . component . orientation , \"inline\" ) , NamedProperty ( Sbol2Terms . instantiation . subComponentInstantiation , instantiationpLac ) ) ) ; TopLevelDocument < QName > lacIRepressibleGeneSequence = TopLevelDocument ( Sbol2Terms . component . sequence , sbolExample . namespacedUri ( \"sequenceComponent/UU_002/sequence\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . component . elements , \"atg\" ) ) ) ; TopLevelDocument < QName > lacIRepressibleGene = TopLevelDocument ( Sbol2Terms . component . sequenceComponent , sbolExample . namespacedUri ( \"sequenceComponent/UU_002\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . documented . name , \"LacI Repressible Gene\" ) , NamedProperty ( Sbol2Terms . documented . displayId , \"UU_002\" ) , NamedProperty ( RdfTerms . rdfType , URI . create ( \"DNA\" ) ) , NamedProperty ( Sbol2Terms . component . sequenceType , URI . create ( \"http://purl.org/obo/owl/SO#SO_0000774\" ) ) , NamedProperty ( Sbol2Terms . component . annotation , pLacAnnotation ) , NamedProperty ( Sbol2Terms . component . hasSequence , lacIRepressibleGeneSequence . getIdentity ( ) ) ) ) ; return DocumentRoot ( NamespaceBindings ( SbolTerms . sbol2 ) , TopLevelDocuments ( lacIRepressibleGene , pLac , lacIRepressibleGeneSequence ) ) ; }'", "label": "'Creates an example {'"}
{"text": "'public static DocumentRoot < QName > makeDocument ( ) { return DocumentRoot ( NamespaceBindings ( SbolTerms . sbol2 ) , TopLevelDocuments ( TopLevelDocument ( SbolTerms . dnaComponent , partsRegistry . namespacedUri ( \"Part:BBa_I0462\" ) , NamedProperties ( NamedProperty ( SbolTerms . name , \"I0462\" ) , NamedProperty ( SbolTerms . description , \"LuxR protein generator\" ) , NamedProperty ( SbolTerms . dnaSequence , partsRegistry . namespacedUri ( \"Part:BBa_I0462/sequence\" ) ) , NamedProperty ( SbolTerms . sequenceAnnotation , NestedDocument ( SbolTerms . annotation , partsRegistry . namespacedUri ( \"Part:BBa_I0462/anot/1234567\" ) , NamedProperties ( NamedProperty ( SbolTerms . bioStart , 1 ) , NamedProperty ( SbolTerms . bioEnd , 12 ) , NamedProperty ( SbolTerms . strand , \"+\" ) , NamedProperty ( SbolTerms . subComponent , partsRegistry . namespacedUri ( \"Part:BBa_B0034\" ) ) ) ) ) , NamedProperty ( SbolTerms . annotation , NestedDocument ( SbolTerms . sequenceAnnotation , partsRegistry . namespacedUri ( \"Part:BBa_I0462/annotation/2345678\" ) , NamedProperties ( NamedProperty ( SbolTerms . bioStart , 19 ) , NamedProperty ( SbolTerms . bioEnd , 774 ) , NamedProperty ( SbolTerms . subComponent , partsRegistry . namespacedUri ( \"Part:BBa_C0062\" ) ) ) ) ) ) ) , TopLevelDocument ( SbolTerms . dnaSequence , partsRegistry . namespacedUri ( \"Part:BBa_I0462/sequence\" ) , NamedProperties ( NamedProperty ( SbolTerms . nucleotides , \"aaagaggagaaatactagatgaaaaacataaatgccgacgacacatacagaataattaataaaattaaagcttgtagaagcaataatgatattaatcaatgcttatctgatatgactaaaatggtacattgtgaatattatttactcgcgatcatttatcctcattctatggttaaatctgatatttcaatcctagataattaccctaaaaaatggaggcaatattatgatgacgctaatttaataaaatatgatcctatagtagattattctaactccaatcattcaccaattaattggaatatatttgaaaacaatgctgtaaataaaaaatctccaaatgtaattaaagaagcgaaaacatcaggtcttatcactgggtttagtttccctattcatacggctaacaatggcttcggaatgcttagttttgcacattcagaaaaagacaactatatagatagtttatttttacatgcgtgtatgaacataccattaattgttccttctctagttgataattatcgaaaaataaatatagcaaataataaatcaaacaacgatttaaccaaaagagaaaaagaatgtttagcgtgggcatgcgaaggaaaaagctcttgggatatttcaaaaatattaggttgcagtgagcgtactgtcactttccatttaaccaatgcgcaaatgaaactcaatacaacaaaccgctgccaaagtatttctaaagcaattttaacaggagcaattgattgcccatactttaaaaattaataacactgatagtgctagtgtagatcactactagagccaggcatcaaataaaacgaaaggctcagtcgaaagactgggcctttcgttttatctgttgtttgtcggtgaacgctctctactagagtcacactggctcaccttcgggtgggcctttctgcgtttata\" ) ) ) , TopLevelDocument ( SbolTerms . dnaComponent , partsRegistry . namespacedUri ( \"Part:BBa_B0034\" ) , NamedProperties ( NamedProperty ( SbolTerms . name , \"I0462\" ) , NamedProperty ( SbolTerms . displayId , \"BBa_B0034\" ) , NamedProperty ( RdfTerms . rdfType , URI . create ( \"http://purl.obolibrary.org/obo/SO_0000139\" ) ) ) ) , TopLevelDocument ( SbolTerms . dnaComponent , partsRegistry . namespacedUri ( \"Part:BBa_C0062\" ) , NamedProperties ( NamedProperty ( SbolTerms . name , \"luxR\" ) , NamedProperty ( SbolTerms . displayId , \"BBa_C0062\" ) , NamedProperty ( RdfTerms . rdfType , URI . create ( \"http://purl.obolibrary.org/obo/SO_0000316\" ) ) ) ) ) ) ; }'", "label": "'Creates an example {'"}
{"text": "'public static SchemaCatalog makeCoreSchemaCatalog ( ) { return SchemaCatalog ( Sbol2Terms . sbol2 . namespacedUri ( \"/schemaexample/core\" ) , ImportedSchemas ( ) , DocumentSchemas ( DocumentSchema ( Sbol2Terms . sbol2 . namespacedUri ( \"/schema/identified\" ) , Extends ( ) , IdentifierSchemas ( ) , TypeSchemas ( ) , PropertySchemas ( ) ) , DocumentSchema ( Sbol2Terms . sbol2 . namespacedUri ( \"/schema/documented\" ) , Extends ( Sbol2Terms . sbol2 . namespacedUri ( \"/schema/identified\" ) ) , IdentifierSchemas ( ) , TypeSchemas ( ) , PropertySchemas ( PropertySchema ( TypeSchemas ( TypeSchema ( Sbol2Terms . documented . displayId ) ) , cardinality . required , PropertyValueSchemas ( propertyType . string ) ) , PropertySchema ( TypeSchemas ( TypeSchema ( Sbol2Terms . documented . name ) ) , cardinality . optional , PropertyValueSchemas ( propertyType . string ) ) , PropertySchema ( TypeSchemas ( TypeSchema ( Sbol2Terms . documented . description ) ) , cardinality . optional , PropertyValueSchemas ( propertyType . string ) ) ) ) ) ) ; }'", "label": "'Creates a {'"}
{"text": "'public static SchemaCatalog makeInstantiationSchemaCatalog ( ) { return SchemaCatalog ( Sbol2Terms . sbol2 . namespacedUri ( \"/schemaexample/instantiation\" ) , ImportedSchemas ( ) , DocumentSchemas ( DocumentSchema ( Sbol2Terms . sbol2 . namespacedUri ( \"/schema/component_instantiation\" ) , Extends ( ) , IdentifierSchemas ( ) , TypeSchemas ( TypeSchema ( Sbol2Terms . instantiation . componentInstantiation ) ) , PropertySchemas ( PropertySchema ( TypeSchemas ( TypeSchema ( Sbol2Terms . instantiation . hasComponentInstantiation ) ) , cardinality . required , PropertyValueSchemas ( ReferenceValue ( Sbol2Terms . sbol2 . namespacedUri ( \"/schema/sequence_component\" ) ) ) ) ) ) ) ) ; }'", "label": "'Creates a {'"}
{"text": "'public static SchemaCatalog makeComponentSchemaCatalog ( ) { return SchemaCatalog ( Sbol2Terms . sbol2 . namespacedUri ( \"/schemaexample/component\" ) , ImportedSchemas ( Sbol2Terms . sbol2 . namespacedUri ( \"/schema/core\" ) , Sbol2Terms . sbol2 . namespacedUri ( \"/schema/instantiation\" ) ) , DocumentSchemas ( DocumentSchema ( Sbol2Terms . sbol2 . namespacedUri ( \"/schema/sequence\" ) , Extends ( ) , IdentifierSchemas ( ) , TypeSchemas ( TypeSchema ( Sbol2Terms . component . sequence ) ) , PropertySchemas ( PropertySchema ( TypeSchemas ( TypeSchema ( Sbol2Terms . component . elements ) ) , cardinality . required , PropertyValueSchemas ( propertyType . string ) ) ) ) , DocumentSchema ( Sbol2Terms . sbol2 . namespacedUri ( \"/schema/sequence_component\" ) , Extends ( Sbol2Terms . sbol2 . namespacedUri ( \"/schema/documented\" ) ) , IdentifierSchemas ( ) , TypeSchemas ( TypeSchema ( Sbol2Terms . component . sequenceComponent ) ) , PropertySchemas ( PropertySchema ( TypeSchemas ( TypeSchema ( Sbol2Terms . component . hasSequence ) ) , cardinality . optional , PropertyValueSchemas ( ReferenceValue ( Sbol2Terms . sbol2 . namespacedUri ( \"/schema/sequence\" ) ) ) ) , PropertySchema ( TypeSchemas ( TypeSchema ( Sbol2Terms . component . annotation ) ) , cardinality . many , PropertyValueSchemas ( DocumentValue ( DocumentSchema ( Sbol2Terms . sbol2 . namespacedUri ( \"/schema/sequence_annotation\" ) , Extends ( Sbol2Terms . sbol2 . namespacedUri ( \"/schema/documented\" ) ) , IdentifierSchemas ( ) , TypeSchemas ( TypeSchema ( Sbol2Terms . component . sequenceComponent ) ) , PropertySchemas ( PropertySchema ( TypeSchemas ( TypeSchema ( Sbol2Terms . instantiation . subComponentInstantiation ) ) , cardinality . required , PropertyValueSchemas ( ReferenceValue ( Sbol2Terms . sbol2 . namespacedUri ( \"/schema/component_instantiation\" ) ) ) ) , PropertySchema ( TypeSchemas ( TypeSchema ( Sbol2Terms . component . orientation ) ) , cardinality . required , PropertyValueSchemas ( propertyType . oneOf ( \"inline\" , \"reverse_compliment\" ) ) ) , PropertySchema ( TypeSchemas ( TypeSchema ( Sbol2Terms . component . start ) ) , cardinality . optional , PropertyValueSchemas ( propertyType . integer ) ) , PropertySchema ( TypeSchemas ( TypeSchema ( Sbol2Terms . component . end ) ) , cardinality . optional , PropertyValueSchemas ( propertyType . integer ) ) ) ) ) ) ) ) ) ) ) ; }'", "label": "'Creates a {'"}
{"text": "'public MavenAggregatedReport createAggregatedAction ( final MavenModuleSetBuild build , final Map < MavenModule , List < MavenBuild > > moduleBuilds ) { return new MavenDryResultAction ( build , getHealthDescriptor ( ) , defaultEncoding , new DryResult ( build , defaultEncoding , new ParserResult ( ) , false ) ) ; }'", "label": "'{'"}
{"text": "'@ SafeVarargs public static < N > TopLevelDocuments < N > TopLevelDocuments ( TopLevelDocument < N > ... documents ) { return TopLevelDocuments ( Arrays . asList ( documents ) ) ; }'", "label": "'Factory for { @link TopLevelDocuments } .'"}
{"text": "'public static < N > TopLevelDocuments < N > TopLevelDocuments ( final List < TopLevelDocument < N > > documents ) { return new TopLevelDocuments . Impl <> ( documents ) ; }'", "label": "'Factory for { @link TopLevelDocuments } .'"}
{"text": "'@ SafeVarargs public static < N > NamedProperties < N > NamedProperties ( final NamedProperty < N > ... properties ) { return NamedProperties ( Arrays . asList ( properties ) ) ; }'", "label": "'Factory for { @link NamedProperties } .'"}
{"text": "'public static < N > NamedProperties < N > NamedProperties ( final List < NamedProperty < N > > properties ) { return new NamedProperties . Impl <> ( properties ) ; }'", "label": "'Factory for { @link NamedProperties } .'"}
{"text": "'public static < N > TopLevelDocument < N > TopLevelDocument ( final N type , final URI identity , final NamedProperties < N > properties ) { return TopLevelDocument ( NamespaceBindings ( ) , type , identity , properties ) ; }'", "label": "'Factory for { @link TopLevelDocument } .'"}
{"text": "'public static < N > TopLevelDocument < N > TopLevelDocument ( final NamespaceBindings bindings , final N type , final URI identity ) { return TopLevelDocument ( bindings , type , identity , Datatree . < N > NamedProperties ( ) ) ; }'", "label": "'Factory for { @link TopLevelDocument } .'"}
{"text": "'public static < N > TopLevelDocument < N > TopLevelDocument ( final NamespaceBindings bindings , final N type , final URI identity , final NamedProperties < N > properties ) { return new TopLevelDocument . Impl <> ( bindings . getBindings ( ) , type , identity , properties . getProperties ( ) ) ; }'", "label": "'Factory for { @link TopLevelDocument } .'"}
{"text": "'public static < N > NestedDocument < N > NestedDocument ( final N type , final URI identity , final NamedProperties < N > properties ) { return NestedDocument ( NamespaceBindings ( ) , type , identity , properties ) ; }'", "label": "'Factory for { @link NestedDocument } .'"}
{"text": "'public static < N > DocumentRoot < N > DocumentRoot ( final TopLevelDocuments < N > documents ) { return DocumentRoot ( NamespaceBindings ( ) , documents ) ; }'", "label": "'Factory for { @link DocumentRoot } .'"}
{"text": "'public static < N > DocumentRoot < N > DocumentRoot ( final NamespaceBindings bindings , final TopLevelDocuments < N > documents ) { return new DocumentRoot . Impl <> ( bindings . getBindings ( ) , documents . getDocuments ( ) ) ; }'", "label": "'Factory for { @link DocumentRoot } .'"}
{"text": "'public static < N > NamedProperty < N > NamedProperty ( final N name , final PropertyValue < N > value ) { return new NamedProperty . Impl <> ( name , value ) ; }'", "label": "'Create a value property from a literal value .'"}
{"text": "'public static < N > NamedProperty < N > NamedProperty ( final N name , final String value ) { return NamedProperty ( name , Datatree . < N > Literal ( value ) ) ; }'", "label": "'Create a value property from a string value .'"}
{"text": "'public static < N > NamedProperty < N > NamedProperty ( final N name , final NestedDocument < N > value ) { return new NamedProperty . Impl <> ( name , value ) ; }'", "label": "'Create a value property from a nested document value .'"}
{"text": "'public static < N > Literal . StringLiteral < N > Literal ( final String value ) { return new Literal . StringLiteral <> ( value ) ; }'", "label": "'Create a string literal .'"}
{"text": "'public static < N > Literal . UriLiteral < N > Literal ( final URI value ) { return new Literal . UriLiteral <> ( value ) ; }'", "label": "'Create a URI literal .'"}
{"text": "'public static < N > Literal . TypedLiteral < N > Literal ( final String value , final QName type ) { return new Literal . TypedLiteral <> ( value , type ) ; }'", "label": "'Create a typed literal .'"}
{"text": "'public static QName QName ( String namespaceURI , String localPart , String prefix ) { return new QName ( namespaceURI , localPart , prefix ) ; }'", "label": "'Create a QName from a namespace URI local part and prefix .'"}
{"text": "'public static void main ( String [ ] args ) throws Exception { System . out . println ( \"SBOL 1 example\" ) ; write ( new OutputStreamWriter ( System . out ) , DataTreeCreator . makeDocument ( ) ) ; System . out . println ( ) ; System . out . println ( \"----------------------------------------\" ) ; System . out . println ( ) ; System . out . println ( \"SBOL 2 example\" ) ; write ( new OutputStreamWriter ( System . out ) , DataTreeCreator . makeSBOL2Document ( ) ) ; }'", "label": "'Exports two example DocumentRoot objects ( SBOL 1 . 1 . 0 and SBOL 2 . 0 objects ) in the GraphViz format .'"}
{"text": "'private static Properties getFilterInitParameters ( final FilterConfig config ) { Properties props = new Properties ( ) ; Enumeration en = config . getInitParameterNames ( ) ; while ( en . hasMoreElements ( ) ) { String key = ( String ) en . nextElement ( ) ; String value = config . getInitParameter ( key ) ; props . setProperty ( key , value ) ; } return props ; }'", "label": "'Converts the initial filter parameters ( typically specified in the { @code web . xml } file ) to a Java properties hashtable . The parameter names become property keys .'"}
{"text": "'public void init ( final FilterConfig filterConfig ) throws ServletException { // Get the init params Properties props = getFilterInitParameters ( filterConfig ) ; // Extract and parse all required CORS filter properties try { config = new CORSConfiguration ( props ) ; } catch ( CORSConfigurationException e ) { throw new ServletException ( e ) ; } handler = new CORSRequestHandler ( config ) ; }'", "label": "'This method is invoked by the web container to initialise the filter at startup .'"}
{"text": "'private void printMessage ( final HttpServletResponse response , final int sc , final String msg ) throws IOException , ServletException { // Set the status code response . setStatus ( sc ) ; // Write the error message response . resetBuffer ( ) ; response . setContentType ( \"text/plain\" ) ; PrintWriter out = response . getWriter ( ) ; out . println ( \"Cross-Origin Resource Sharing (CORS) Filter: \" + msg ) ; }'", "label": "'Produces a simple HTTP text / plain response with the specified status code and message .'"}
{"text": "'private void doFilter ( final HttpServletRequest request , final HttpServletResponse response , final FilterChain chain ) throws IOException , ServletException { // Tag handler . tagRequest ( request ) ; CORSRequestType type = CORSRequestType . detect ( request ) ; try { if ( type == CORSRequestType . ACTUAL ) { // Simple/actual CORS request handler . handleActualRequest ( request , response ) ; chain . doFilter ( request , response ) ; } else if ( type == CORSRequestType . PREFLIGHT ) { // Preflight CORS request, handle but don\\'t pass // further down the chain handler . handlePreflightRequest ( request , response ) ; } else if ( config . allowGenericHttpRequests ) { // Not a CORS request, but allow it through request . setAttribute ( \"cors.isCorsRequest\" , false ) ; // tag chain . doFilter ( request , response ) ; } else { // Generic HTTP requests denied request . setAttribute ( \"cors.isCorsRequest\" , false ) ; // tag printMessage ( response , HttpServletResponse . SC_FORBIDDEN , \"Generic HTTP requests not allowed\" ) ; } } catch ( InvalidCORSRequestException e ) { request . setAttribute ( \"cors.isCorsRequest\" , false ) ; // tag printMessage ( response , HttpServletResponse . SC_BAD_REQUEST , e . getMessage ( ) ) ; } catch ( CORSOriginDeniedException e ) { String msg = e . getMessage ( ) + \": \" + e . getRequestOrigin ( ) ; printMessage ( response , HttpServletResponse . SC_FORBIDDEN , msg ) ; } catch ( UnsupportedHTTPMethodException e ) { String msg = e . getMessage ( ) ; HTTPMethod method = e . getRequestedMethod ( ) ; if ( method != null ) msg = msg + \": \" + method . toString ( ) ; printMessage ( response , HttpServletResponse . SC_METHOD_NOT_ALLOWED , msg ) ; } catch ( UnsupportedHTTPHeaderException e ) { String msg = e . getMessage ( ) ; HeaderFieldName header = e . getRequestHeader ( ) ; if ( header != null ) msg = msg + \": \" + header . toString ( ) ; printMessage ( response , HttpServletResponse . SC_FORBIDDEN , msg ) ; } }'", "label": "'Filters an HTTP request / reponse pair according to the configured CORS policy . Also tags the request with CORS information to downstream handlers .'"}
{"text": "'public void created ( final UUID createdByEntityId ) { if ( this . entityId != null ) { throw new IllegalStateException ( \"This entity has already been created: entityId = \" + entityId ) ; } this . entityId = UUID . randomUUID ( ) ; this . entityVersion = 1 ; this . createdByEntityId = createdByEntityId ; this . updatedByEntityId = createdByEntityId ; this . entityCreatedOn = System . currentTimeMillis ( ) ; this . entityUpdatedOn = this . entityCreatedOn ; }'", "label": "'Call this method when the entity is updated to increment its version and update its lastupdatedByEntityId'"}
{"text": "'@ SuppressWarnings ( \"incomplete-switch\" ) @ Override public void init ( InputStream json ) throws IOException { try ( final JsonParser parser = JsonUtils . createJsonParser ( json ) ) { JsonToken tk ; while ( ( tk = parser . nextToken ( ) ) != null ) { switch ( tk ) { case FIELD_NAME : final String fieldName = parser . getCurrentName ( ) ; if ( fieldName . equals ( \"entityId\" ) ) { setEntityId ( UUID . fromString ( parser . nextTextValue ( ) ) ) ; } else if ( fieldName . equals ( \"entityVersion\" ) ) { setEntityVersion ( parser . nextLongValue ( 0 ) ) ; } else if ( fieldName . equals ( \"entityCreatedOn\" ) ) { setEntityCreatedOn ( parser . nextLongValue ( 0 ) ) ; } else if ( fieldName . equals ( \"createdByEntityId\" ) ) { setCreatedBy ( UUID . fromString ( parser . nextTextValue ( ) ) ) ; } else if ( fieldName . equals ( \"entityUpdatedOn\" ) ) { setEntityUpdatedOn ( parser . nextLongValue ( 0 ) ) ; } else if ( fieldName . equals ( \"updatedByEntityId\" ) ) { setUpdatedBy ( UUID . fromString ( parser . nextTextValue ( ) ) ) ; } else { init ( parser ) ; } break ; } } } }'", "label": "'Knows how to parse the following JSON fields :'"}
{"text": "'protected void init ( JsonParser parser ) throws IOException { LoggerFactory . getLogger ( getClass ( ) ) . warn ( \"init(JsonParser parser) invoked to handle field: {}\" , parser . getCurrentName ( ) ) ; }'", "label": "'Sub - classes should override this to parse sub - class specific fields .'"}
{"text": "'public void updated ( final UUID lastupdatedByEntityId ) { if ( this . entityId == null ) { throw new IllegalStateException ( \"The entity has not yet been created : entityId == null\" ) ; } Assert . notNull ( lastupdatedByEntityId , \"lastupdatedByEntityId is required\" ) ; entityVersion ++ ; updatedByEntityId = lastupdatedByEntityId ; entityUpdatedOn = System . currentTimeMillis ( ) ; }'", "label": "'Call this method when the entity is updated before it is persisted to increment its version and update its lastupdatedByEntityId'"}
{"text": "'private Collection < DuplicateCode > convert ( final List < Duplication > duplications , final String moduleName ) { List < DuplicateCode > annotations = new ArrayList < DuplicateCode > ( ) ; for ( Duplication duplication : duplications ) { List < DuplicateCode > codeBlocks = new ArrayList < DuplicateCode > ( ) ; boolean isDerived = false ; for ( SourceFile file : duplication . getFiles ( ) ) { // TODO: check why PMD reports a length + 1 DuplicateCode annotation = new DuplicateCode ( getPriority ( duplication . getLines ( ) ) , file . getLine ( ) , duplication . getLines ( ) , file . getPath ( ) , isDerived ) ; annotation . setSourceCode ( duplication . getCodeFragment ( ) ) ; annotation . setModuleName ( moduleName ) ; codeBlocks . add ( annotation ) ; isDerived = true ; } for ( DuplicateCode block : codeBlocks ) { block . linkTo ( codeBlocks ) ; block . setPackageName ( PackageDetectors . detectPackageName ( block . getFileName ( ) ) ) ; } annotations . addAll ( codeBlocks ) ; } return annotations ; }'", "label": "'Converts the internal structure to the annotations API .'"}
{"text": "'@ Override public void registerService ( ISemanticLocator packedServiceDescriptor ) throws ServiceExecutionException { try { BSDFLogger . getLogger ( ) . info ( \"Deploys service(s) from: \" + packedServiceDescriptor . toString ( ) ) ; Collection < ISemanticIdentifier > deployedServices = this . deploy ( packedServiceDescriptor , bsdmServiceRegistry ) ; for ( ISemanticIdentifier deployedService : deployedServices ) { this . messageBroker . registerService ( this . bsdmServiceRegistry . getService ( deployedService ) . applyConnectorURL ( this . urlContainer ) ) ; } } catch ( ModelException ex ) { BSDFLogger . getLogger ( ) . debug ( \"Cannot deploy service(s) from: \" + packedServiceDescriptor . toString ( ) + \" . Exception: \" + ex . toString ( ) ) ; throw new ServiceExecutionException ( ex . getMessage ( ) , ex ) ; } }'", "label": "'/ * With the current implementation a service must be registered before the message broker is started ... or restart the broker to activate messaging for that service .'"}
{"text": "'@ Transactional protected HashServiceConfiguration hashServiceConfiguration ( ) { Exception exception = null ; for ( int i = 0 ; i < 3 ; i ++ ) { final HashServiceConfiguration config = hashServiceConfigurationDAO . findByName ( getHashServiceConfigurationName ( ) ) ; if ( config != null ) { return config ; } try { return hashServiceConfigurationDAO . create ( newHashServiceConfiguration ( ) ) ; } catch ( Exception e ) { exception = e ; try { Thread . sleep ( ( long ) ( Math . random ( ) * 1000 ) ) ; } catch ( InterruptedException e2 ) { // ignore } } } throw new RuntimeException ( \"hashServiceConfiguration() failed\" , exception ) ; }'", "label": "'Will try to lookup the HashServiceConfiguration using the name specified by { @link #getHashServiceConfigurationName () }'"}
{"text": "'public void close ( int port ) { for ( Iterator i = _listeners . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Object k = i . next ( ) ; Object s = _listeners . get ( k ) ; if ( s instanceof SocketHandler ) { SocketHandler sh = ( SocketHandler ) s ; if ( port == - 1 || sh . isPort ( port ) ) { sh . interrupt ( ) ; sh . close ( ) ; _transactions . remove ( s ) ; _listeners . remove ( k ) ; } } } }'", "label": "'Closes a port . All connections on this port will be closed .'"}
{"text": "'protected void receive ( Command c , Map h , String b , Authenticatable y ) { long id = ( int ) ( Math . random ( ) * 10000 ) ; try { // Convert to MESSAGE and distribute if ( c == Command . COMMIT ) { synchronized ( _transactions ) { List trans = ( List ) _transactions . remove ( y ) ; trans = new ArrayList ( trans ) ; for ( Iterator i = trans . iterator ( ) ; i . hasNext ( ) ; ) { Message m = ( Message ) i . next ( ) ; try { receive ( m . command ( ) , m . headers ( ) , m . body ( ) , y ) ; } catch ( Exception e ) { // Don\\'t allow listener code to break us } } } } else if ( c == Command . ABORT ) { synchronized ( _transactions ) { _transactions . remove ( y ) ; } } else if ( _transactions . get ( y ) != null ) { synchronized ( _transactions ) { ( ( List ) _transactions . get ( y ) ) . add ( new Message ( c , h , b ) ) ; } } else { if ( h == null ) h = new HashMap ( ) ; String destination = ( String ) h . get ( \"destination\" ) ; if ( c == Command . SEND ) { if ( y instanceof IntraVMClient || _authenticator . authorizeSend ( y . token ( ) , destination ) ) { synchronized ( _listeners ) { List l = ( List ) _listeners . get ( destination ) ; if ( l != null ) { l = new ArrayList ( l ) ; for ( Iterator i = l . iterator ( ) ; i . hasNext ( ) ; ) { Listener sh = ( Listener ) i . next ( ) ; try { sh . message ( h , b ) ; } catch ( Exception e ) { // Don\\'t allow listener code to break us } } } } } else { Map error_headers = new HashMap ( ) ; error_headers . put ( \"message:\" , \"authorization refused\" ) ; error_headers . put ( \"type:\" , \"send\" ) ; error_headers . put ( \"channel:\" , destination ) ; y . error ( error_headers , \"The message:\\\\n-----\\\\n\" + b + \"\\\\n-----\\\\nAuthentication token refused for this channel\" ) ; } } else if ( c == Command . SUBSCRIBE ) { if ( y instanceof IntraVMClient || _authenticator . authorizeSubscribe ( y . token ( ) , destination ) ) { synchronized ( _listeners ) { List l = ( List ) _listeners . get ( destination ) ; if ( l == null ) { l = new ArrayList ( ) ; _listeners . put ( destination , l ) ; } if ( ! l . contains ( y ) ) l . add ( y ) ; } } else { Map error_headers = new HashMap ( ) ; error_headers . put ( \"message:\" , \"authorization refused\" ) ; error_headers . put ( \"type:\" , \"subscription\" ) ; error_headers . put ( \"channel:\" , destination ) ; y . error ( error_headers , \"The message:\\\\n-----\\\\n\" + b + \"\\\\n-----\\\\nAuthentication token refused for this channel\" ) ; } } else if ( c == Command . UNSUBSCRIBE ) { synchronized ( _listeners ) { List l = ( List ) _listeners . get ( destination ) ; if ( l != null ) l . remove ( y ) ; } } else if ( c == Command . BEGIN ) { synchronized ( _transactions ) { List trans = new ArrayList ( ) ; _transactions . put ( y , trans ) ; } } else if ( c == Command . DISCONNECT ) { synchronized ( _listeners ) { for ( Iterator i = _listeners . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { List l = ( List ) i . next ( ) ; l . remove ( y ) ; } } } } if ( h != null ) { String receipt = ( String ) h . get ( \"receipt\" ) ; if ( receipt != null ) { HashMap headers = new HashMap ( ) ; headers . put ( \"receipt-id\" , receipt ) ; y . receive ( Command . RECEIPT , headers , null ) ; } } } catch ( Exception e ) { // Don\\'t allow listener code to break us } }'", "label": "'Incoming mesages from clients come here and are delivered to listeners both intra - VM and network .'"}
{"text": "'public static final void main ( String [ ] args ) { if ( args . length != 1 ) { System . err . println ( \"A single argument -- a port -- is required\" ) ; System . exit ( 1 ) ; } int port = Integer . valueOf ( args [ 0 ] ) . intValue ( ) ; System . out . println ( Version . VERSION ) ; try { new Server ( port ) ; } catch ( Exception e ) { System . err . println ( \"Failed to start server\" ) ; e . printStackTrace ( System . err ) ; } }'", "label": "'Gozirra is probably not the best choice for a stand - alone server . If you are tempted to use it as such you might want to look at ActiveMQ which is a feature - rich MOM solution . Gozirra is intended primarily to be an ultra - light embedded messaging library .'"}
{"text": "'public void validateOpts ( Object instance ) { final Set < ConstraintViolation < Object > > set = validator . validate ( instance ) ; final StringBuilder sb = new StringBuilder ( ) ; for ( ConstraintViolation < Object > violation : set ) { final Path path = violation . getPropertyPath ( ) ; final String msg = violation . getMessage ( ) ; sb . append ( path . toString ( ) ) . append ( \" \" ) . append ( msg ) . append ( \". \" ) ; } if ( sb . length ( ) > 0 ) { // is ConstraintViolationException more appropriate,\\r // letting user choose their error message?\\r throw new ValidationException ( OPT_VIOLATION_MSG + \": \" + sb . toString ( ) ) ; } }'", "label": "'This method will only be called if we know that JSR 303 1 . 0 Bean Validation API and compliant implementation are available on classpath .'"}
{"text": "'public void validateArgs ( List < Object > args , Object instance , Method m , Command cmd ) { final Set < ConstraintViolation < Object > > set = validator . validateParameters ( instance , m , args . toArray ( ) ) ; final StringBuilder sb = new StringBuilder ( ) ; for ( ConstraintViolation < Object > violation : set ) { final Path path = violation . getPropertyPath ( ) ; final String msg = violation . getMessage ( ) ; String var = path . toString ( ) ; try { int pos = Integer . parseInt ( \"\" + var . charAt ( var . length ( ) - 1 ) ) ; Argument arg = cmd . getArguments ( ) . get ( pos ) ; sb . append ( arg . getName ( ) ) . append ( \" \" ) . append ( msg ) . append ( \". \" ) ; } catch ( Exception e ) { sb . append ( var ) . append ( \" \" ) . append ( msg ) . append ( \". \" ) ; } } if ( sb . length ( ) > 0 ) { // is ConstraintViolationException more appropriate,\\r // letting user choose their error message?\\r throw new ValidationException ( ARG_VIOLATION_MSG + \": \" + sb . toString ( ) ) ; } }'", "label": "'This method will only be called if we know that JSR 303 1 . 1 Bean Validation API and compliant implementation are available on classpath .'"}
{"text": "'public void commitW ( Map header ) throws InterruptedException { String receipt = addReceipt ( header ) ; transmit ( Command . COMMIT , header ) ; waitOnReceipt ( receipt ) ; }'", "label": "'Commits a transaction causing any messages sent since begin () was called to be delivered . This method does not return until the server has confirmed that the commit was successfull .'"}
{"text": "'public void subscribe ( String name , Listener listener , Map headers ) { synchronized ( _listeners ) { if ( listener != null ) { List list = ( List ) _listeners . get ( name ) ; if ( list == null ) { list = new ArrayList ( ) ; _listeners . put ( name , list ) ; } if ( ! list . contains ( listener ) ) list . add ( listener ) ; } } if ( headers == null ) headers = new HashMap ( ) ; headers . put ( \"destination\" , name ) ; transmit ( Command . SUBSCRIBE , headers ) ; }'", "label": "'Subscribe to a channel .'"}
{"text": "'public void subscribeW ( String name , Listener listener , Map header ) throws InterruptedException { String receipt = addReceipt ( header ) ; subscribe ( name , listener , header ) ; waitOnReceipt ( receipt ) ; }'", "label": "'Subscribe to a channel . This method blocks until it receives a receipt from the server .'"}
{"text": "'public void subscribeW ( String name , Listener listener ) throws InterruptedException { subscribeW ( name , listener , null ) ; }'", "label": "'Subscribe to a channel . This method blocks until it receives a receipt from the server .'"}
{"text": "'public void unsubscribe ( String name , Listener l ) { synchronized ( _listeners ) { List list = ( List ) _listeners . get ( name ) ; if ( list != null ) { list . remove ( l ) ; if ( list . size ( ) == 0 ) { unsubscribe ( name ) ; } } } }'", "label": "'Unsubscribe a single listener from a channel . This does not send a message to the server unless the listener is the only listener of this channel .'"}
{"text": "'public void unsubscribe ( String name , Map header ) { if ( header == null ) header = new HashMap ( ) ; synchronized ( _listeners ) { _listeners . remove ( name ) ; } header . put ( \"destination\" , name ) ; transmit ( Command . UNSUBSCRIBE , header ) ; }'", "label": "'Unsubscribe from a channel . Automatically unregisters all listeners of the channel . To re - subscribe with listeners subscribe must be passed the listeners again .'"}
{"text": "'public void unsubscribeW ( String name , Map header ) throws InterruptedException { String receipt = addReceipt ( header ) ; unsubscribe ( name , ( HashMap ) null ) ; waitOnReceipt ( receipt ) ; }'", "label": "'Unsubscribe from a channel . Automatically unregisters all listeners of the channel . To re - subscribe with listeners subscribe must be passed the listeners again . This method blocks until a receipt is received from the server .'"}
{"text": "'public void sendW ( String dest , String mesg ) throws InterruptedException { sendW ( dest , mesg , null ) ; }'", "label": "'Send a message to a channel synchronously . This method does not return until the server acknowledges with a receipt .'"}
{"text": "'public void sendW ( String dest , String mesg , Map header ) throws InterruptedException { String receipt = addReceipt ( header ) ; send ( dest , mesg , header ) ; waitOnReceipt ( receipt ) ; }'", "label": "'Send a message to a channel synchronously . This method does not return until the server acknowledges with a receipt .'"}
{"text": "'public void send ( String dest , String mesg , Map header ) { if ( header == null ) header = new HashMap ( ) ; header . put ( \"destination\" , dest ) ; transmit ( Command . SEND , header , mesg ) ; }'", "label": "'Send a message to a channel .'"}
{"text": "'public Message getNext ( String name ) { synchronized ( _queue ) { for ( int idx = 0 ; idx < _queue . size ( ) ; idx ++ ) { Message m = ( Message ) _queue . get ( idx ) ; if ( m . headers ( ) . get ( \"destination\" ) . equals ( name ) ) { _queue . remove ( idx ) ; return m ; } } } return null ; }'", "label": "'Get the next unconsumed message for a particular channel . This is non - blocking .'"}
{"text": "'public boolean hasReceipt ( String receipt_id ) { synchronized ( _receipts ) { for ( Iterator i = _receipts . iterator ( ) ; i . hasNext ( ) ; ) { String o = ( String ) i . next ( ) ; if ( o . equals ( receipt_id ) ) return true ; } } return false ; }'", "label": "'Checks to see if a receipt has come in .'"}
{"text": "'public void clearReceipt ( String receipt_id ) { synchronized ( _receipts ) { for ( Iterator i = _receipts . iterator ( ) ; i . hasNext ( ) ; ) { String o = ( String ) i . next ( ) ; if ( o . equals ( receipt_id ) ) i . remove ( ) ; } } }'", "label": "'Deletes all receipts with a given ID'"}
{"text": "'private Collection < DuplicateCode > convert ( final List < Set > duplications , final String moduleName ) { List < DuplicateCode > annotations = new ArrayList < DuplicateCode > ( ) ; for ( Set duplication : duplications ) { List < DuplicateCode > codeBlocks = new ArrayList < DuplicateCode > ( ) ; boolean isDerived = false ; for ( Block file : duplication . getBlocks ( ) ) { DuplicateCode annotation = new DuplicateCode ( getPriority ( duplication . getLineCount ( ) ) , file . getStartLineNumber ( ) , duplication . getLineCount ( ) , file . getSourceFile ( ) , isDerived ) ; annotation . setModuleName ( moduleName ) ; codeBlocks . add ( annotation ) ; isDerived = true ; } for ( DuplicateCode block : codeBlocks ) { block . linkTo ( codeBlocks ) ; String packageName = PackageDetectors . detectPackageName ( block . getFileName ( ) ) ; block . setPackageName ( packageName ) ; } annotations . addAll ( codeBlocks ) ; } return annotations ; }'", "label": "'Converts the internal structure to the annotations API .'"}
{"text": "'@ Subscribe public void logDeadEvent ( final DeadEvent deadEvent ) { final Object event = deadEvent . getEvent ( ) ; log . warn ( \"{} : DeadEvent : {} : {}\" , beanName , event . getClass ( ) . getName ( ) , event ) ; }'", "label": "'Logs dead event as warnings . Dead events are events that posted but there are no registered subscribers for that event type .'"}
{"text": "'public < T > T convert ( final Object source , final Class < T > targetclass ) { if ( source == null ) { return null ; } final Class < ? > sourceclass = source . getClass ( ) ; final SourceTargetPairKey key = new SourceTargetPairKey ( sourceclass , targetclass ) ; Converter converter = cache . get ( key ) ; if ( converter != null ) { return ( T ) converter . convert ( source , targetclass ) ; } final LinkedList < SourceTargetPairMatch > matches = new LinkedList < SourceTargetPairMatch > ( ) ; for ( SourceTargetPair pair : converters . values ( ) ) { SourceTargetPairMatch match = pair . match ( sourceclass , targetclass ) ; if ( match . matchesSource ( ) && match . matchesTarget ( ) ) { matches . add ( match ) ; } } if ( matches . size ( ) == 0 ) { throw new ConversionException ( \"No suitable converter found for target class [\" + targetclass . getName ( ) + \"] and source value [\" + sourceclass . getName ( ) + \"]. The following converters are available [\" + converters . keySet ( ) + \"]\" ) ; } Collections . sort ( matches , SourceTargetPairMatch . bestTargetMatch ( ) ) ; converter = matches . get ( 0 ) . pair . converter ; cache . put ( key , converter ) ; return ( T ) converter . convert ( source , targetclass ) ; }'", "label": "'Convert a value to a specific class .'"}
{"text": "'public Collection < FileAnnotation > parse ( final File file , final String moduleName ) throws InvocationTargetException { FileInputStream inputStream = null ; try { inputStream = new FileInputStream ( file ) ; if ( accepts ( inputStream ) ) { IOUtils . closeQuietly ( inputStream ) ; inputStream = new FileInputStream ( file ) ; Set < FileAnnotation > warnings = Sets . newHashSet ( ) ; warnings . addAll ( parse ( inputStream , moduleName ) ) ; return warnings ; } else { throw new IOException ( \"Can\\'t parse CPD file \" + file . getAbsolutePath ( ) ) ; } } catch ( IOException exception ) { throw new InvocationTargetException ( exception ) ; } finally { IOUtils . closeQuietly ( inputStream ) ; } }'", "label": "'{'"}
{"text": "'protected Priority getPriority ( final int lines ) { if ( lines >= highThreshold ) { return Priority . HIGH ; } else if ( lines >= normalThreshold ) { return Priority . NORMAL ; } else { return Priority . LOW ; } }'", "label": "'Returns the priority of the warning .'"}
{"text": "'public String getSuffix ( ) { String s = host ; if ( port != - 1 ) s = s + \":\" + port ; return s ; }'", "label": "'Returns the suffix which is made up of the host name / IP address and port ( if a non - default port is specified ) .'"}
{"text": "'public void execute ( GNUishParser p ) { if ( instance == null ) { instance = Utils . newInstance ( className ) ; } final Class < ? > clazz = instance . getClass ( ) ; final Method [ ] methods = clazz . getDeclaredMethods ( ) ; for ( Method m : methods ) { m . setAccessible ( true ) ; if ( ! m . getName ( ) . equals ( p . getCommand ( ) ) ) { continue ; } final List < Object > args = adjustArgs ( p . getArgs ( ) , m ) ; injectOpts ( p , clazz ) ; try { validateArgs ( args , instance , m , this ) ; m . invoke ( instance , args . toArray ( ) ) ; return ; } catch ( InvocationTargetException e ) { final Throwable ex = e . getTargetException ( ) ; if ( ex instanceof RuntimeException ) { throw ( RuntimeException ) e . getCause ( ) ; } else { throw new RuntimeException ( e . getTargetException ( ) ) ; } } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } System . out . println ( p . getCommand ( ) + \": command not found\" ) ; }'", "label": "'Execute this command according to the user input arguments parsed by the parser .'"}
{"text": "'private void injectOpts ( GNUishParser p , Class < ? > clazz ) { for ( Field f : clazz . getDeclaredFields ( ) ) { f . setAccessible ( true ) ; final CliOption anno = f . getAnnotation ( CliOption . class ) ; if ( anno == null ) { continue ; } String value = p . getShortOpt ( anno . shortName ( ) ) ; if ( value == null ) { value = p . getLongOpt ( f . getName ( ) ) ; if ( value == null ) { continue ; } } try { f . set ( instance , c . convert ( value , f . getType ( ) ) ) ; } catch ( ConversionException e ) { throw CliException . WRONG_OPT_TYPE ( f . getName ( ) , f . getType ( ) . getName ( ) , value ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } validateOpts ( instance ) ; }'", "label": "'Convert options to appropriate type and inject them into the command instance .'"}
{"text": "'private List < Object > adjustArgs ( List < String > args , Method m ) { final List < Object > result = new ArrayList < Object > ( ) ; final Class < ? > [ ] types = m . getParameterTypes ( ) ; if ( m . isVarArgs ( ) ) { types [ types . length - 1 ] = types [ types . length - 1 ] . getComponentType ( ) ; if ( ! String . class . isAssignableFrom ( types [ types . length - 1 ] ) ) { throw new CliException ( \"Only String varargs is supported.\" ) ; } types [ types . length - 1 ] = String . class ; } List < Object > varargs = new ArrayList <> ( ) ; for ( int i = 0 ; i < args . size ( ) ; i ++ ) { try { if ( m . isVarArgs ( ) && i >= types . length - 1 ) { varargs . add ( c . convert ( args . get ( i ) , types [ types . length - 1 ] ) ) ; } else { result . add ( c . convert ( args . get ( i ) , types [ i ] ) ) ; } } catch ( ConversionException e ) { throw CliException . WRONG_ARG_TYPE ( getArguments ( ) . get ( i ) . getName ( ) , types [ i ] . getName ( ) , args . get ( i ) ) ; } } if ( m . isVarArgs ( ) ) { result . add ( varargs . toArray ( new String [ 0 ] ) ) ; } return result ; }'", "label": "'Add or remove parameters to fit the method declaration and also convert them to appropriate data type .'"}
{"text": "'private List < MigrationResult > migratePersonality ( final MetadataManager metadataManager , final String personalityName , final Integer targetVersion , final MigratoryOption [ ] options ) { final Integer currentVersion = metadataManager . getCurrentVersion ( personalityName ) ; if ( currentVersion == null && ! migratoryConfig . isCreatePersonalities ( ) ) { throw new MigratoryException ( Reason . NEW_PERSONALITIES_DENIED ) ; } // Make sure that the current state of the personality is sane. final List < MetadataInfo > history = metadataManager . getPersonalityHistory ( personalityName ) ; final MigrationManager migrationManager = new MigrationManager ( migratoryContext , personalityName ) ; // if null, this is a new personality.Don\\'t validate it. if ( history != null && ! history . isEmpty ( ) ) { // \"No verify\" option skips this step. if ( ! MigratoryOption . containsOption ( MigratoryOption . NO_VERIFY , options ) ) { final DbValidator dbValidator = new DbValidator ( migrationManager ) ; final ValidationResult validationResult = dbValidator . validate ( history ) ; if ( validationResult . getValidationStatus ( ) != ValidationStatus . OK ) { throw new MigratoryException ( Reason . VALIDATION_FAILED , \"Validation for Personality \\'%s\\' failed\" , personalityName ) ; } } else { LOG . info ( \"Skipped verification.\" ) ; } } final MigrationPlanner migrationPlanner = new MigrationPlanner ( migrationManager , currentVersion , targetVersion ) ; migrationPlanner . plan ( ) ; LOG . info ( \"{}\" , migrationPlanner . toString ( ) ) ; switch ( migrationPlanner . getDirection ( ) ) { case FORWARD : if ( ! migratoryConfig . isAllowRollForward ( ) ) { throw new MigratoryException ( Reason . ROLL_FORWARD_DENIED ) ; } break ; case BACK : if ( ! migratoryConfig . isAllowRollBack ( ) ) { throw new MigratoryException ( Reason . ROLL_BACK_DENIED ) ; } break ; case DO_NOTHING : return null ; default : LOG . warn ( \"Encountered State {}. This should never happen!\" , migrationPlanner . getDirection ( ) ) ; return null ; } final DbMigrator migrator = new DbMigrator ( migratoryContext , migrationPlanner ) ; final List < MigrationResult > results = migrator . migrate ( options ) ; LOG . info ( \"Migration finished in \\'{}\\' steps, result is {}\" , results . size ( ) , MigrationResult . determineMigrationState ( results ) ) ; return results ; }'", "label": "'Performs the migration of a personality . This must be run under the table lock so that only one thread can use it at a time .'"}
{"text": "'public MavenAggregatedReport createAggregatedAction ( final MavenModuleSetBuild build , final Map < MavenModule , List < MavenBuild > > moduleBuilds ) { return new DryMavenResultAction ( build , getHealthDescriptor ( ) , getDefaultEncoding ( ) , new DryResult ( build , getDefaultEncoding ( ) , new ParserResult ( ) , false ) ) ; }'", "label": "'{'"}
{"text": "'@ Programmatic public Collection < String > calendarNamesFor ( final Object notable ) { final Set < String > fallback = Collections . singleton ( DEFAULT_CALENDAR_NAME ) ; if ( calendarNameRepository == null ) { return fallback ; } final Collection < String > calendarNames = calendarNameRepository . calendarNamesFor ( notable ) ; return calendarNames != null ? calendarNames : fallback ; }'", "label": "'Return the list of objects to act as calendars for the { @link Note } s to attach to the specified notable domain object as per { @link CalendarNameRepository } or a default name otherwise .'"}
{"text": "'@ Override public String loadFile ( final URI fileUri ) { try { final URL urlLocation = Resources . getResource ( this . getClass ( ) , fileUri . getPath ( ) ) ; return Resources . toString ( urlLocation , Charsets . UTF_8 ) ; } catch ( IOException e ) { throw new MigratoryException ( Reason . INTERNAL , e ) ; } }'", "label": "'This method loads a file from a classpath : / ... URI .'"}
{"text": "'@ Override public String loadFile ( final URI fileUri ) throws IOException { final File fileLocation = new File ( fileUri ) ; if ( fileLocation . exists ( ) && fileLocation . canRead ( ) ) { if ( fileLocation . isFile ( ) ) { return Files . toString ( fileLocation , charset ) ; } else { throw new MigratoryException ( Reason . INTERNAL , \"%s is not a file!\" , fileLocation ) ; } } else { throw new MigratoryException ( Reason . INTERNAL , \"Can not access %s!\" , fileLocation ) ; } }'", "label": "'This method loads a file from a file : / ... URI . This is probably not what you are looking for .'"}
{"text": "'public synchronized void receiveMessagesSyncronously ( long ms ) throws ServiceGroundingException { for ( IChannelConsumer chConsumer : this . serviceChannelConsumers ) { if ( chConsumer instanceof AbstractJMSChannelConsumer ) { AbstractJMSChannelConsumer achConsumer = ( AbstractJMSChannelConsumer ) chConsumer ; achConsumer . receiveOrWait ( ms ) ; } if ( chConsumer instanceof AbstractStompChannelConsumer ) { AbstractStompChannelConsumer achConsumer = ( AbstractStompChannelConsumer ) chConsumer ; achConsumer . receiveOrWait ( ms ) ; } } }'", "label": "'/ * Set this broker object to receive messages during a given period of time blocking execution .'"}
{"text": "'private static String serialize ( final Set set , final String sep ) { Iterator it = set . iterator ( ) ; String s = \"\" ; while ( it . hasNext ( ) ) { s = s + it . next ( ) . toString ( ) ; if ( it . hasNext ( ) ) s = s + sep ; } return s ; }'", "label": "'Serialises the items of a set into a string . Each item must have a meaningful { @code toString () } method .'"}
{"text": "'private static String [ ] parseMultipleHeaderValues ( final String headerValue ) { if ( headerValue == null ) return new String [ 0 ] ; String trimmedHeaderValue = headerValue . trim ( ) ; if ( trimmedHeaderValue . isEmpty ( ) ) return new String [ 0 ] ; return trimmedHeaderValue . split ( \"\\\\\\\\s*,\\\\\\\\s*|\\\\\\\\s+\" ) ; }'", "label": "'Parses a header value consisting of zero or more space / comma / space + comma separated strings . The input string is trimmed before splitting .'"}
{"text": "'public void tagRequest ( final HttpServletRequest request ) { final CORSRequestType type = CORSRequestType . detect ( request ) ; switch ( type ) { case ACTUAL : request . setAttribute ( \"cors.isCorsRequest\" , true ) ; request . setAttribute ( \"cors.origin\" , request . getHeader ( \"Origin\" ) ) ; request . setAttribute ( \"cors.requestType\" , \"actual\" ) ; break ; case PREFLIGHT : request . setAttribute ( \"cors.isCorsRequest\" , true ) ; request . setAttribute ( \"cors.origin\" , request . getHeader ( \"Origin\" ) ) ; request . setAttribute ( \"cors.requestType\" , \"preflight\" ) ; request . setAttribute ( \"cors.requestHeaders\" , request . getHeader ( \"Access-Control-Request-Headers\" ) ) ; break ; case OTHER : request . setAttribute ( \"cors.isCorsRequest\" , false ) ; } }'", "label": "'Tags an HTTP servlet request to provide CORS information to downstream handlers .'"}
{"text": "'public void handleActualRequest ( final HttpServletRequest request , final HttpServletResponse response ) throws InvalidCORSRequestException , CORSOriginDeniedException , UnsupportedHTTPMethodException { if ( CORSRequestType . detect ( request ) != CORSRequestType . ACTUAL ) throw new InvalidCORSRequestException ( \"Invalid simple/actual CORS request\" ) ; // Check origin against allow list Origin requestOrigin = new Origin ( request . getHeader ( \"Origin\" ) ) ; if ( ! config . isAllowedOrigin ( requestOrigin ) ) throw new CORSOriginDeniedException ( \"CORS origin denied\" , requestOrigin ) ; // Check method HTTPMethod method = null ; try { method = HTTPMethod . valueOf ( request . getMethod ( ) ) ; } catch ( Exception e ) { // Parse exception throw new UnsupportedHTTPMethodException ( \"Unsupported HTTP method: \" + request . getMethod ( ) ) ; } if ( ! config . isSupportedMethod ( method ) ) throw new UnsupportedHTTPMethodException ( \"Unsupported HTTP method\" , method ) ; // Success, append response headers response . addHeader ( \"Access-Control-Allow-Origin\" , requestOrigin . toString ( ) ) ; if ( config . supportsCredentials ) response . addHeader ( \"Access-Control-Allow-Credentials\" , \"true\" ) ; if ( ! exposedHeaders . isEmpty ( ) ) response . addHeader ( \"Access-Control-Expose-Headers\" , exposedHeaders ) ; // Tag request request . setAttribute ( \"cors.origin\" , requestOrigin . toString ( ) ) ; request . setAttribute ( \"cors.requestType\" , \"actual\" ) ; }'", "label": "'Handles a simple or actual CORS request .'"}
{"text": "'public void handlePreflightRequest ( final HttpServletRequest request , final HttpServletResponse response ) throws InvalidCORSRequestException , CORSOriginDeniedException , UnsupportedHTTPMethodException , UnsupportedHTTPHeaderException { if ( CORSRequestType . detect ( request ) != CORSRequestType . PREFLIGHT ) throw new InvalidCORSRequestException ( \"Invalid preflight CORS request\" ) ; // Check origin against allow list Origin requestOrigin = new Origin ( request . getHeader ( \"Origin\" ) ) ; if ( ! config . isAllowedOrigin ( requestOrigin ) ) throw new CORSOriginDeniedException ( \"CORS origin denied\" , requestOrigin ) ; // Parse requested method // Note: method checking must be done after header parsing, see CORS spec String requestMethodHeader = request . getHeader ( \"Access-Control-Request-Method\" ) ; if ( requestMethodHeader == null ) throw new InvalidCORSRequestException ( \"Invalid preflight CORS request: Missing Access-Control-Request-Method header\" ) ; HTTPMethod requestedMethod = null ; try { requestedMethod = HTTPMethod . valueOf ( requestMethodHeader . toUpperCase ( ) ) ; } catch ( Exception e ) { // Parse exception throw new UnsupportedHTTPMethodException ( \"Unsupported HTTP method: \" + requestMethodHeader ) ; } // Parse custom headers final String [ ] requestHeaderValues = parseMultipleHeaderValues ( request . getHeader ( \"Access-Control-Request-Headers\" ) ) ; final HeaderFieldName [ ] requestHeaders = new HeaderFieldName [ requestHeaderValues . length ] ; for ( int i = 0 ; i < requestHeaders . length ; i ++ ) { try { requestHeaders [ i ] = new HeaderFieldName ( requestHeaderValues [ i ] ) ; } catch ( IllegalArgumentException e ) { // Invalid header name throw new InvalidCORSRequestException ( \"Invalid preflight CORS request: Bad request header value\" ) ; } } // Now, do method check if ( ! config . isSupportedMethod ( requestedMethod ) ) throw new UnsupportedHTTPMethodException ( \"Unsupported HTTP method\" , requestedMethod ) ; // Author request headers check for ( int i = 0 ; i < requestHeaders . length ; i ++ ) { if ( ! config . supportedHeaders . contains ( requestHeaders [ i ] ) ) throw new UnsupportedHTTPHeaderException ( \"Unsupported HTTP request header\" , requestHeaders [ i ] ) ; } // Success, append response headers if ( config . supportsCredentials ) { response . addHeader ( \"Access-Control-Allow-Origin\" , requestOrigin . toString ( ) ) ; response . addHeader ( \"Access-Control-Allow-Credentials\" , \"true\" ) ; } else { if ( config . allowAnyOrigin ) response . addHeader ( \"Access-Control-Allow-Origin\" , \"*\" ) ; else response . addHeader ( \"Access-Control-Allow-Origin\" , requestOrigin . toString ( ) ) ; } if ( config . maxAge > 0 ) response . addHeader ( \"Access-Control-Max-Age\" , Integer . toString ( config . maxAge ) ) ; response . addHeader ( \"Access-Control-Allow-Methods\" , supportedMethods ) ; if ( ! supportedHeaders . isEmpty ( ) ) response . addHeader ( \"Access-Control-Allow-Headers\" , supportedHeaders ) ; }'", "label": "'Handles a preflight CORS request .'"}
{"text": "'protected static String formatCanonical ( final String name ) { String nameTrimmed = name . trim ( ) ; if ( nameTrimmed . isEmpty ( ) ) throw new IllegalArgumentException ( \"The header field name must not be an empty string\" ) ; // Check for valid syntax: must begin with letter, then only word and dash chars allowed if ( ! nameTrimmed . matches ( \"^[a-zA-Z][\\\\\\\\w-]*$\" ) ) throw new IllegalArgumentException ( \"Invalid header field name syntax\" ) ; String [ ] tokens = nameTrimmed . toLowerCase ( ) . split ( \"-\" ) ; String out = \"\" ; for ( int i = 0 ; i < tokens . length ; i ++ ) { char [ ] c = tokens [ i ] . toCharArray ( ) ; // Capitalise first char c [ 0 ] = Character . toUpperCase ( c [ 0 ] ) ; if ( i >= 1 ) out = out + \"-\" ; out = out + new String ( c ) ; } return out ; }'", "label": "'Applies a { @code Aaa - Bbb - Ccc } format to a header field name .'"}
{"text": "'public boolean setOptions ( String [ ] options ) throws Exception { ArgumentParser parser ; Namespace ns ; parser = ArgumentParsers . newArgumentParser ( MinDeps . class . getName ( ) ) ; parser . addArgument ( \"--java-home\" ) . type ( Arguments . fileType ( ) . verifyExists ( ) . verifyIsDirectory ( ) ) . dest ( \"javahome\" ) . required ( true ) . help ( \"The java home directory of the JDK that includes the jdeps binary, default is taken from JAVA_HOME environment variable.\" ) ; parser . addArgument ( \"--class-path\" ) . dest ( \"classpath\" ) . required ( true ) . help ( \"The CLASSPATH to use for jdeps.\" ) ; parser . addArgument ( \"--classes\" ) . type ( Arguments . fileType ( ) . verifyExists ( ) . verifyIsFile ( ) . verifyCanRead ( ) ) . dest ( \"classes\" ) . required ( true ) . help ( \"The file containing the classes to determine the dependencies for. Empty lines and lines starting with # get ignored.\" ) ; parser . addArgument ( \"--additional\" ) . type ( Arguments . fileType ( ) ) . setDefault ( new File ( \".\" ) ) . required ( false ) . dest ( \"additional\" ) . help ( \"The file with additional class names to just include.\" ) ; parser . addArgument ( \"--output\" ) . type ( Arguments . fileType ( ) ) . setDefault ( new File ( \".\" ) ) . required ( false ) . dest ( \"output\" ) . help ( \"The file for storing the determined class names in.\" ) ; parser . addArgument ( \"package\" ) . dest ( \"packages\" ) . required ( true ) . nargs ( \"+\" ) . help ( \"The packages to keep, eg \\'weka\\'.\" ) ; try { ns = parser . parseArgs ( options ) ; } catch ( ArgumentParserException e ) { parser . handleError ( e ) ; return false ; } setJavaHome ( ns . get ( \"javahome\" ) ) ; setClassPath ( ns . getString ( \"classpath\" ) ) ; setClassesFile ( ns . get ( \"classes\" ) ) ; setAdditionalFile ( ns . get ( \"additional\" ) ) ; setPackages ( ns . getList ( \"packages\" ) ) ; setOutputFile ( ns . get ( \"output\" ) ) ; return true ; }'", "label": "'Sets the commandline options .'"}
{"text": "'protected String readFile ( File file , List < String > lines ) { int i ; try { lines . addAll ( Files . readAllLines ( file . toPath ( ) ) ) ; i = 0 ; while ( i < lines . size ( ) ) { if ( lines . get ( i ) . trim ( ) . isEmpty ( ) ) { lines . remove ( i ) ; continue ; } if ( lines . get ( i ) . startsWith ( \"#\" ) ) { lines . remove ( i ) ; continue ; } i ++ ; } } catch ( Exception e ) { return \"Failed to read file: \" + file + \"\\\\n\" + e ; } return null ; }'", "label": "'Reads the file into the the provided list . Skips empty lines and lines starting with # .'"}
{"text": "'protected String check ( ) { String error ; if ( ! m_JavaHome . exists ( ) ) return \"Java home directory does not exist: \" + m_JavaHome ; if ( ! m_JavaHome . isDirectory ( ) ) return \"Java home does not point to a directory: \" + m_JavaHome ; if ( System . getProperty ( \"os.name\" ) . toLowerCase ( ) . contains ( \"windows\" ) ) m_Jdeps = new File ( m_JavaHome . getAbsolutePath ( ) + File . separator + \"bin\" + File . separator + \"jdeps.exe\" ) ; else m_Jdeps = new File ( m_JavaHome . getAbsolutePath ( ) + File . separator + \"bin\" + File . separator + \"jdeps\" ) ; if ( ! m_Jdeps . exists ( ) ) return \"jdeps binary does not exist: \" + m_Jdeps ; if ( ! m_ClassesFile . exists ( ) ) return \"File with class names does not exist: \" + m_ClassesFile ; if ( m_ClassesFile . isDirectory ( ) ) return \"File with class names points to directory: \" + m_ClassesFile ; // read classes error = readFile ( m_ClassesFile , m_Classes ) ; if ( error != null ) return error ; // read resources if ( ( m_AdditionalFile != null ) && m_AdditionalFile . exists ( ) && ( ! m_AdditionalFile . isDirectory ( ) ) ) { error = readFile ( m_AdditionalFile , m_Resources ) ; if ( error != null ) return error ; } return null ; }'", "label": "'Performs some checks .'"}
{"text": "'protected List < String > filter ( List < String > lines , String regexp , boolean invert ) { List < String > result ; Pattern pattern ; result = new ArrayList <> ( ) ; pattern = Pattern . compile ( regexp ) ; for ( String line : lines ) { if ( invert ) { if ( ! pattern . matcher ( line ) . matches ( ) ) result . add ( line ) ; } else { if ( pattern . matcher ( line ) . matches ( ) ) result . add ( line ) ; } } return result ; }'", "label": "'Filters the list of strings with a regular expression .'"}
{"text": "'protected String packagesRegExp ( ) { StringBuilder result ; int i ; String pkg ; result = new StringBuilder ( ) ; result . append ( \".* (\" ) ; for ( i = 0 ; i < m_Packages . size ( ) ; i ++ ) { if ( i > 0 ) result . append ( \"|\" ) ; pkg = m_Packages . get ( i ) ; if ( ! pkg . endsWith ( \".\" ) ) pkg = pkg + \".\" ; pkg = pkg . replace ( \".\" , \"\\\\\\\\.\" ) ; result . append ( pkg ) ; } result . append ( \").*$\" ) ; return result . toString ( ) ; }'", "label": "'Builds the regular expression for the packages to keep .'"}
{"text": "'protected String determine ( ) { String [ ] cmd ; ProcessBuilder builder ; CollectingProcessOutput output ; List < String > lines ; int i ; String line ; for ( String cls : m_Classes ) { // progress System . err . println ( cls ) ; cmd = new String [ ] { m_Jdeps . getAbsolutePath ( ) , \"-cp\" , m_ClassPath , \"-recursive\" , \"-verbose:class\" , cls } ; builder = new ProcessBuilder ( ) ; builder . command ( cmd ) ; output = new CollectingProcessOutput ( ) ; try { output . monitor ( builder ) ; } catch ( Exception e ) { return \"Failed to execute: \" + builder . toString ( ) + \"\\\\n\" + e ; } // filter output lines = new ArrayList <> ( Arrays . asList ( output . getStdOut ( ) . replace ( \"\\\\r\" , \"\" ) . split ( \"\\\\n\" ) ) ) ; lines = filter ( lines , packagesRegExp ( ) , false ) ; lines = filter ( lines , \".*\\\\\\\\$.*\" , true ) ; lines = filter ( lines , \".*\\\\\\\\.jar\\\\\\\\)\" , true ) ; // clean up for ( i = 0 ; i < lines . size ( ) ; i ++ ) { line = lines . get ( i ) ; line = line . replaceFirst ( \".* -> \" , \"\" ) ; line = line . replaceFirst ( \" .*$\" , \"\" ) ; line = line . trim ( ) ; lines . set ( i , line ) ; } // add to result m_DependentClasses . addAll ( lines ) ; System . err . println ( \"--> \" + m_DependentClasses . size ( ) ) ; } return null ; }'", "label": "'Determines the dependencies .'"}
{"text": "'public String execute ( ) { String result ; initialize ( ) ; result = check ( ) ; if ( result == null ) result = determine ( ) ; if ( result == null ) { m_Dependencies = new ArrayList <> ( ) ; m_Dependencies . addAll ( m_Classes ) ; for ( String cls : m_DependentClasses ) { if ( ! m_Dependencies . contains ( cls ) ) m_Dependencies . add ( cls ) ; } for ( String cls : m_Resources ) { if ( ! m_Dependencies . contains ( cls ) ) m_Dependencies . add ( cls ) ; } Collections . sort ( m_Dependencies ) ; } return result ; }'", "label": "'Determines the dependencies .'"}
{"text": "'public void output ( ) { if ( ( m_OutputFile == null || m_OutputFile . isDirectory ( ) ) ) { for ( String dep : m_Dependencies ) System . out . println ( dep ) ; } else { try { Files . write ( m_OutputFile . toPath ( ) , m_Dependencies , StandardOpenOption . CREATE , StandardOpenOption . TRUNCATE_EXISTING ) ; } catch ( Exception e ) { System . err . println ( \"Failed to write dependencies to: \" + m_OutputFile ) ; e . printStackTrace ( ) ; } } }'", "label": "'Outputs the dependencies on stdout .'"}
{"text": "'@ Override public int compareTo ( InstanceProvider instanceProvider ) { if ( this . getPriority ( ) . equals ( instanceProvider . getPriority ( ) ) ) { return this . getName ( ) . compareTo ( instanceProvider . getName ( ) ) ; } else { return this . getPriority ( ) . compareTo ( instanceProvider . getPriority ( ) ) ; } }'", "label": "'Default implementation of compareTo for the InstanceManager .'"}
{"text": "'@ ManagedAttribute @ Override public String [ ] getCommandCatalogNames ( ) { final Set < String > catalogNames = new TreeSet <> ( commandCatalogs . keySet ( ) ) ; return catalogNames . toArray ( new String [ catalogNames . size ( ) ] ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override @ ManagedOperation @ ManagedOperationParameters ( { @ ManagedOperationParameter ( name = \"catalogName\" , description = \"Catalog name\" ) } ) public String [ ] getCommandNames ( final String catalogName ) { Assert . hasText ( catalogName , \"catalogName is required\" ) ; final CommandCatalog catalog = getCommandCatalog ( catalogName ) ; return catalog . getCommandNames ( ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public static IOUtils getIOUtils ( ) { if ( ioUtils == null ) { try { Class clazz = Class . forName ( IO_UTILS ) ; ioUtils = ( IOUtils ) clazz . newInstance ( ) ; } catch ( ClassNotFoundException | InstantiationException | IllegalAccessException e ) { LOGGER . warn ( \"Cannot instanciate util: {}\" , e . getMessage ( ) ) ; throw new IllegalStateException ( e ) ; } } return ioUtils ; }'", "label": "'Retrieve IOUtils implementation'"}
{"text": "'public static ImageUtils getImageUtils ( ) { if ( imageUtils == null ) { try { Class clazz = Class . forName ( IMAGE_UTILS ) ; imageUtils = ( ImageUtils ) clazz . newInstance ( ) ; } catch ( ClassNotFoundException | InstantiationException | IllegalAccessException e ) { LOGGER . warn ( \"Cannot instanciate util: {}\" , e . getMessage ( ) ) ; throw new IllegalStateException ( e ) ; } } return imageUtils ; }'", "label": "'Retrieve ImageUtils implementation'"}
{"text": "'public static PriceUtils getPriceUtils ( ) { if ( priceUtils == null ) { try { Class clazz = Class . forName ( PRICE_UTILS ) ; priceUtils = ( PriceUtils ) clazz . newInstance ( ) ; } catch ( ClassNotFoundException | InstantiationException | IllegalAccessException e ) { LOGGER . warn ( \"Cannot instanciate util: {}\" , e . getMessage ( ) ) ; throw new IllegalStateException ( e ) ; } } return priceUtils ; }'", "label": "'Retrieve PriceUtils implementation'"}
{"text": "'public static ResourceUtils getResourceUtils ( ) { if ( resourceUtils == null ) { try { Class clazz = Class . forName ( RESOURCE_UTILS ) ; resourceUtils = ( ResourceUtils ) clazz . newInstance ( ) ; } catch ( ClassNotFoundException | InstantiationException | IllegalAccessException e ) { LOGGER . warn ( \"Cannot instanciate util: {}\" , e . getMessage ( ) ) ; throw new IllegalStateException ( e ) ; } } return resourceUtils ; }'", "label": "'Retrieve ResourceUtils implementation'"}
{"text": "'public static ZipUtils getZipUtils ( ) { if ( zipUtils == null ) { try { Class clazz = Class . forName ( ZIP_UTILS ) ; zipUtils = ( ZipUtils ) clazz . newInstance ( ) ; } catch ( ClassNotFoundException | InstantiationException | IllegalAccessException e ) { LOGGER . warn ( \"Cannot instanciate util: {}\" , e . getMessage ( ) ) ; throw new IllegalStateException ( e ) ; } } return zipUtils ; }'", "label": "'Retrieve ZipUtils implementation'"}
{"text": "'public static DigestUtils getDigestUtils ( ) { if ( digestUtils == null ) { try { Class clazz = Class . forName ( DIGEST_UTILS ) ; digestUtils = ( DigestUtils ) clazz . newInstance ( ) ; } catch ( ClassNotFoundException | InstantiationException | IllegalAccessException e ) { LOGGER . warn ( \"Cannot instanciate util: {}\" , e . getMessage ( ) ) ; throw new IllegalStateException ( e ) ; } } return digestUtils ; }'", "label": "'Retrieve DigestUtils implementation'"}
{"text": "'public static StringUtils getStringUtils ( ) { if ( stringUtils == null ) { try { Class clazz = Class . forName ( STRING_UTILS ) ; stringUtils = ( StringUtils ) clazz . newInstance ( ) ; } catch ( ClassNotFoundException | InstantiationException | IllegalAccessException e ) { LOGGER . warn ( \"Cannot instanciate util: {}\" , e . getMessage ( ) ) ; throw new IllegalStateException ( e ) ; } } return stringUtils ; }'", "label": "'Retrieve StringUtils implementation'"}
{"text": "'public static ResourceService getResourceService ( ) { if ( resourceService == null ) { try { Class clazz = Class . forName ( RESOURCE_SERVICE ) ; resourceService = ( ResourceService ) clazz . newInstance ( ) ; } catch ( ClassNotFoundException | InstantiationException | IllegalAccessException e ) { LOGGER . warn ( \"Cannot instanciate util: {}\" , e . getMessage ( ) ) ; throw new IllegalStateException ( e ) ; } } return resourceService ; }'", "label": "'Retrieve ResourceService implementation'"}
{"text": "'public static PricingService getPricingService ( ) { if ( pricingService == null ) { try { Class clazz = Class . forName ( PRICING_SERVICE ) ; pricingService = ( PricingService ) clazz . newInstance ( ) ; } catch ( ClassNotFoundException | InstantiationException | IllegalAccessException e ) { LOGGER . warn ( \"Cannot instanciate util: {}\" , e . getMessage ( ) ) ; throw new IllegalStateException ( e ) ; } } return pricingService ; }'", "label": "'Retrieve PricingService implementation'"}
{"text": "'public static InstanceService getInstanceService ( ) { if ( instanceService == null ) { try { Class clazz = Class . forName ( INSTANCE_SERVICE ) ; instanceService = ( InstanceService ) clazz . newInstance ( ) ; } catch ( ClassNotFoundException | InstantiationException | IllegalAccessException e ) { LOGGER . warn ( \"Cannot instanciate util: {}\" , e . getMessage ( ) ) ; throw new IllegalStateException ( e ) ; } } return instanceService ; }'", "label": "'Retrieve InstanceService implementation'"}
{"text": "'public IoWriter < QName > createIoWriter ( final XMLStreamWriter writer ) { return new IoWriter < QName > ( ) { @ Override public void write ( DocumentRoot < QName > document ) throws CoreIoException { try { writer . writeStartDocument ( ) ; writeStartElement ( RDF ) ; setPrefix ( rdf ) ; if ( ! document . getNamespaceBindings ( ) . contains ( rdf ) ) { writeNamespace ( rdf ) ; } for ( NamespaceBinding nb : document . getNamespaceBindings ( ) ) { setPrefix ( nb ) ; writeNamespace ( nb ) ; } for ( TopLevelDocument < QName > child : document . getTopLevelDocuments ( ) ) { write ( child ) ; } writer . writeEndElement ( ) ; writer . writeEndDocument ( ) ; } catch ( XMLStreamException xse ) { throw new CoreIoException ( xse ) ; } } private void write ( IdentifiableDocument < QName > doc ) throws XMLStreamException { writeStartElement ( doc . getType ( ) ) ; writeAttribute ( rdfAbout , doc . getIdentity ( ) . toString ( ) ) ; for ( NamedProperty < QName > property : doc . getProperties ( ) ) { write ( property ) ; } writer . writeEndElement ( ) ; } private void write ( final NamedProperty < QName > property ) { new PropertyValue . Visitor < QName > ( ) { @ Override public void visit ( NestedDocument < QName > v ) throws XMLStreamException { writeStartElement ( property . getName ( ) ) ; write ( v ) ; writer . writeEndElement ( ) ; } @ Override public void visit ( Literal < QName > v ) throws XMLStreamException { if ( isEmptyElementValue ( v ) ) { writeEmptyElement ( property . getName ( ) ) ; write ( v ) ; } else { writeStartElement ( property . getName ( ) ) ; write ( v ) ; writer . writeEndElement ( ) ; } } } . visit ( property . getValue ( ) ) ; } private boolean isEmptyElementValue ( Literal < QName > literal ) { return /* literal instanceof Literal.QNameLiteral || */ literal instanceof Literal . UriLiteral ; } private void write ( Literal < QName > literal ) { new Literal . Visitor < QName > ( ) { @ Override public void visit ( Literal . StringLiteral < QName > l ) throws XMLStreamException { writer . writeCharacters ( l . getValue ( ) ) ; } @ Override public void visit ( Literal . UriLiteral < QName > l ) throws XMLStreamException { writeAttribute ( rdfResource , l . getValue ( ) . toString ( ) ) ; } @ Override public void visit ( Literal . IntegerLiteral < QName > l ) throws XMLStreamException { writer . writeCharacters ( l . getValue ( ) . toString ( ) ) ; } @ Override public void visit ( Literal . DoubleLiteral < QName > l ) throws XMLStreamException { writer . writeCharacters ( l . getValue ( ) . toString ( ) ) ; } @ Override public void visit ( Literal . TypedLiteral < QName > l ) throws XMLStreamException { writer . writeCharacters ( l . getValue ( ) + \"^^\" + l . getType ( ) . getPrefix ( ) + \":\" + l . getType ( ) . getLocalPart ( ) ) ; } @ Override public void visit ( Literal . BooleanLiteral < QName > l ) throws XMLStreamException { writer . writeCharacters ( l . getValue ( ) . toString ( ) ) ; } } . visit ( literal ) ; } private void writeEmptyElement ( QName tagName ) throws XMLStreamException { writer . writeEmptyElement ( tagName . getPrefix ( ) , tagName . getLocalPart ( ) , tagName . getNamespaceURI ( ) ) ; } private void writeStartElement ( QName tagName ) throws XMLStreamException { writer . writeStartElement ( tagName . getPrefix ( ) , tagName . getLocalPart ( ) , tagName . getNamespaceURI ( ) ) ; } private void setPrefix ( NamespaceBinding binding ) throws XMLStreamException { writer . setPrefix ( binding . getPrefix ( ) , binding . getNamespaceURI ( ) ) ; } private void writeNamespace ( NamespaceBinding binding ) throws XMLStreamException { writer . writeNamespace ( binding . getPrefix ( ) , binding . getNamespaceURI ( ) ) ; } private void writeAttribute ( QName attrName , String attrValue ) throws XMLStreamException { writer . writeAttribute ( attrName . getPrefix ( ) , attrName . getNamespaceURI ( ) , attrName . getLocalPart ( ) , attrValue ) ; } } ; }'", "label": "'Creates an { @link IoWriter } using the given { @link XMLStreamWriter } object .'"}
{"text": "'public IoReader < QName > createIoReader ( final XMLStreamReader xmlReader ) throws XMLStreamException { return new IoReader < QName > ( ) { @ Override public DocumentRoot < QName > read ( ) throws CoreIoException { try { while ( xmlReader . hasNext ( ) ) { int eventType = xmlReader . next ( ) ; switch ( eventType ) { case XMLEvent . START_ELEMENT : NamespaceBindings bindings = readBindings ( ) ; Datatree . TopLevelDocuments < QName > topLevelDocuments = readTopLevelDocuments ( ) ; return Datatree . DocumentRoot ( bindings , topLevelDocuments ) ; } } } catch ( XMLStreamException e ) { throw new CoreIoException ( e ) ; } return null ; } private Datatree . NamespaceBindings readBindings ( ) throws XMLStreamException { NamespaceBinding [ ] bindings = new NamespaceBinding [ xmlReader . getNamespaceCount ( ) ] ; for ( int i = 0 ; i < xmlReader . getNamespaceCount ( ) ; i ++ ) { bindings [ i ] = Datatree . NamespaceBinding ( xmlReader . getNamespaceURI ( i ) , xmlReader . getNamespacePrefix ( i ) ) ; } return Datatree . NamespaceBindings ( bindings ) ; } /**\\r\\n       * Used to store documents and properties when reading XML in the readTopLevelDocuments method\\r\\n       */ private Stack < Object > documentStack = new Stack < Object > ( ) ; /**\\r\\n       * Used to store the TopLevelDocument objects in the readTopLevelDocuments method\\r\\n       */ private List < TopLevelDocument < QName > > topLevelDocuments = null ; /**\\r\\n       * Reads RDF document and returns TopLevelDocuments.\\r\\n       *\\r\\n       * <p>\\r\\n       * Properties and\\r\\n       * documents are stored in a Stack object and populated as more data\\r\\n       * become available The stack object holds one TopLevelDocument at a\\r\\n       * time. Once a TopLevelDocument is read it is added to the\\r\\n       * topLevelDocuments collection. For triples within a\\r\\n       * TopLevelDocument the following rules apply:\\r\\n       * </p>\\r\\n       * Starting tags:\\r\\n       * <p>\\r\\n       * If a triple contains rdf:about attribute it is assumed that the\\r\\n       * tag is the start of a NestedDocument. An empty Nested document is\\r\\n       * added to the stack.\\r\\n       * If a triple contains rdf:resource, a NamedProperty with a URI\\r\\n       * value is created and added to the stack.\\r\\n       * Otherwise a NamedProperty without a value is added to the stack\\r\\n       * </p>\\r\\n       *\\r\\n       * End tags:\\r\\n       * <p>\\r\\n       * For each end tag, an object is taken from the stack.\\r\\n       * If the object is a property The property is removed from the\\r\\n       * stack The XML value (if the value exists) is used to set the\\r\\n       * value of that property. The property is then added to the recent\\r\\n       * document in the stack. This document can be a NestedDocument or a\\r\\n       * TopLevelDocument.\\r\\n       * If the object is a NestedDocument, the document is removed from\\r\\n       * the stack. The property identifying the document in this case is\\r\\n       * the most recent object in the stack and it is also removed from\\r\\n       * the stack. The NestedDocument is then added to the parent\\r\\n       * document (it can be a another NestedDocument or a\\r\\n       * TopLevelDocument using the property relationship. This parent\\r\\n       * document is the most recent object after removing the property.\\r\\n       * If the object is TopLevelDocument, the object is removed from the\\r\\n       * stack and added to the topLevelDocuments collection\\r\\n       * </p>\\r\\n       *\\r\\n       * @return\\r\\n       * @throws XMLStreamException\\r\\n       */ private Datatree . TopLevelDocuments < QName > readTopLevelDocuments ( ) throws XMLStreamException { //Used as a buffer to read XML characters in the readTopLevelDocuments method         \\r StringBuilder currentText = null ; topLevelDocuments = new ArrayList < TopLevelDocument < QName > > ( ) ; while ( xmlReader . hasNext ( ) ) { int eventType = xmlReader . next ( ) ; switch ( eventType ) { case XMLEvent . START_ELEMENT : currentText = new StringBuilder ( 256 ) ; QName elementURI = Datatree . QName ( xmlReader . getNamespaceURI ( ) , xmlReader . getLocalName ( ) , xmlReader . getPrefix ( ) ) ; addToStack ( elementURI ) ; break ; case XMLEvent . END_ELEMENT : String literalValue = null ; if ( currentText != null ) { literalValue = currentText . toString ( ) ; currentText = null ; } updateDocumentInStack ( literalValue ) ; break ; case XMLEvent . CHARACTERS : String characters = xmlReader . getText ( ) ; if ( currentText != null ) { currentText . append ( characters ) ; } break ; } } Datatree . TopLevelDocuments < QName > documents = Datatree . TopLevelDocuments ( topLevelDocuments . toArray ( new TopLevelDocument [ topLevelDocuments . size ( ) ] ) ) ; return documents ; // return Datatree.<QName> TopLevelDocuments();\\r } private void addToStack ( QName elementURI ) throws XMLStreamException { URI identity = null ; URI resourceURI = null ; int attributes = xmlReader . getAttributeCount ( ) ; for ( int i = 0 ; i < attributes ; ++ i ) { if ( rdfAbout . getLocalPart ( ) . equals ( xmlReader . getAttributeLocalName ( i ) ) && rdfAbout . getNamespaceURI ( ) . equals ( xmlReader . getAttributeNamespace ( i ) ) ) { identity = URI . create ( xmlReader . getAttributeValue ( i ) ) ; } if ( rdfResource . getLocalPart ( ) . equals ( xmlReader . getAttributeLocalName ( i ) ) && rdfResource . getNamespaceURI ( ) . equals ( xmlReader . getAttributeNamespace ( i ) ) ) { resourceURI = URI . create ( xmlReader . getAttributeValue ( i ) ) ; } } if ( identity != null ) { Datatree . NamespaceBindings bindings = readBindings ( ) ; IdentifiableDocument < QName > document = null ; if ( documentStack . isEmpty ( ) ) { document = Datatree . TopLevelDocument ( bindings , elementURI , identity ) ; } else { document = Datatree . NestedDocument ( bindings , elementURI , identity ) ; } documentStack . push ( document ) ; } else { NamedProperty < QName > property = null ; if ( resourceURI != null ) { property = Datatree . NamedProperty ( elementURI , resourceURI ) ; } else { // TODO Make sure this is ok. The value type is not known yet!\\r property = Datatree . NamedProperty ( elementURI , \"\" ) ; } documentStack . push ( property ) ; } } private void updateDocumentInStack ( String literalValue ) throws XMLStreamException { // Get the object in the stack\\r if ( ! documentStack . isEmpty ( ) ) { Object stackObject = documentStack . pop ( ) ; if ( stackObject instanceof NamedProperty ) { NamedProperty < QName > property = ( NamedProperty < QName > ) stackObject ; // Set its property value\\r if ( literalValue != null && literalValue . length ( ) > 0 ) { property = Datatree . NamedProperty ( property . getName ( ) , literalValue ) ; } updateDocumentInStackWithProperty ( property ) ; } else if ( stackObject instanceof NestedDocument ) { NestedDocument < QName > document = ( NestedDocument < QName > ) stackObject ; // Get the property for the nested document\\r NamedProperty < QName > property = ( NamedProperty < QName > ) documentStack . pop ( ) ; property = Datatree . NamedProperty ( property . getName ( ) , document ) ; updateDocumentInStackWithProperty ( property ) ; // Skip the ending of the property tag. The nested\\r // document is attached to the parent using the property\\r // already.\\r while ( xmlReader . hasNext ( ) ) { int eventType = xmlReader . next ( ) ; if ( eventType == XMLEvent . END_ELEMENT ) { String elementURI = xmlReader . getNamespaceURI ( ) + xmlReader . getLocalName ( ) ; if ( elementURI . equals ( property . getName ( ) . getNamespaceURI ( ) + property . getName ( ) . getLocalPart ( ) ) ) { break ; } } } } else if ( stackObject instanceof TopLevelDocument ) { topLevelDocuments . add ( ( TopLevelDocument < QName > ) stackObject ) ; } } } private void updateDocumentInStackWithProperty ( NamedProperty < QName > property ) { //Add it to the document in the stack\\r IdentifiableDocument < QName > documentInStack = ( IdentifiableDocument < QName > ) documentStack . pop ( ) ; documentInStack = addProperty ( documentInStack , property ) ; //Put the document back to the stack\\r documentStack . push ( documentInStack ) ; } private IdentifiableDocument < QName > addProperty ( IdentifiableDocument < QName > document , NamedProperty < QName > property ) { List < NamedProperty < QName >> properties = new ArrayList <> ( ) ; if ( document . getProperties ( ) == null || document . getProperties ( ) . size ( ) == 0 ) { properties = Datatree . NamedProperties ( property ) . getProperties ( ) ; } else { properties . addAll ( document . getProperties ( ) ) ; // TODO if the Property value is a NestedDocument then add\\r // the property using the same property key, still works without this though!\\r properties . add ( property ) ; } NamedProperty < QName > [ ] propertyArray = properties . toArray ( new NamedProperty [ properties . size ( ) ] ) ; NamedProperties < QName > namedProperties = Datatree . NamedProperties ( propertyArray ) ; NamespaceBindings bindings = Datatree . NamespaceBindings ( ( NamespaceBinding [ ] ) document . getNamespaceBindings ( ) . toArray ( new NamespaceBinding [ document . getNamespaceBindings ( ) . size ( ) ] ) ) ; if ( document instanceof TopLevelDocument ) { document = Datatree . TopLevelDocument ( bindings , document . getType ( ) , document . getIdentity ( ) , namedProperties ) ; } else { document = Datatree . NestedDocument ( bindings , document . getType ( ) , document . getIdentity ( ) , namedProperties ) ; } return document ; } } ; }'", "label": "'Creates an {'"}
{"text": "'@ ManagedOperation ( description = \"Sets the policy governing whether core threads may time out and terminate if no tasks arrive within the keep-alive time, being replaced if needed when new tasks arrive.\" ) @ ManagedOperationParameters ( { @ ManagedOperationParameter ( name = \"value\" , description = \"true if should time out, else false\" ) } ) @ Override public void allowCoreThreadTimeOut ( final boolean value ) { super . allowCoreThreadTimeOut ( value ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ ManagedOperation ( description = \"Sets the core number of threads. If the new value is smaller than the current value, excess existing threads will be terminated when they next become idle. If larger, new threads will, if needed, be started to execute any queued tasks\" ) @ ManagedOperationParameters ( { @ ManagedOperationParameter ( name = \"corePoolSize\" , description = \"the new core size\" ) } ) @ Override public void setCorePoolSize ( final int corePoolSize ) { super . setCorePoolSize ( corePoolSize ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override @ ManagedOperation ( description = \"Sets the time limit in seconds for which threads may remain idle before being terminated.\" ) @ ManagedOperationParameters ( { @ ManagedOperationParameter ( name = \"time\" , description = \"the time in seconds to wait. A time value of zero will cause excess threads to terminate immediately after executing tasks.\" ) } ) public void setKeepAliveTimeSecs ( final int time ) { super . setKeepAliveTime ( time , TimeUnit . SECONDS ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ ManagedOperation ( description = \"Sets the maximum allowed number of threads.\" ) @ ManagedOperationParameters ( { @ ManagedOperationParameter ( name = \"maximumPoolSize\" , description = \"the new maximum\" ) } ) @ Override public void setMaximumPoolSize ( final int maximumPoolSize ) { super . setMaximumPoolSize ( maximumPoolSize ) ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'@ Override public void init ( ) throws HarvesterException { forceLocalStorage = getJsonConfig ( ) . getBoolean ( true , \"harvester\" , \"workflow-harvester\" , \"force-storage\" ) ; forceUpdate = getJsonConfig ( ) . getBoolean ( false , \"harvester\" , \"workflow-harvester\" , \"force-update\" ) ; // Order is significant renderChains = new LinkedHashMap < String , Map < String , List < String > > > ( ) ; JsonObject renderTypes = getJsonConfig ( ) . getObject ( \"renderTypes\" ) ; if ( renderTypes != null ) { for ( Object name : renderTypes . keySet ( ) ) { Map < String , List < String > > details = new HashMap < String , List < String > > ( ) ; JsonObject chain = ( JsonObject ) renderTypes . get ( name ) ; details . put ( \"fileTypes\" , JsonSimple . getStringList ( chain , \"fileTypes\" ) ) ; details . put ( \"harvestQueue\" , JsonSimple . getStringList ( chain , \"harvestQueue\" ) ) ; details . put ( \"indexOnHarvest\" , JsonSimple . getStringList ( chain , \"indexOnHarvest\" ) ) ; details . put ( \"renderQueue\" , JsonSimple . getStringList ( chain , \"renderQueue\" ) ) ; renderChains . put ( ( String ) name , details ) ; } } }'", "label": "'Basic init () function . Notice the lack of parameters . This is not part of the Plugin API but from the GenericHarvester implementation . It will be called following the constructor verifies configuration is available .'"}
{"text": "'@ Override public Set < String > getObjectId ( File uploadedFile ) throws HarvesterException { Set < String > objectIds = new HashSet < String > ( ) ; try { objectIds . add ( createDigitalObject ( uploadedFile ) ) ; } catch ( StorageException se ) { throw new HarvesterException ( se ) ; } return objectIds ; }'", "label": "'Get an individual uploaded file as a digital object . For consistency this should be in a list .'"}
{"text": "'private String createDigitalObject ( File file ) throws HarvesterException , StorageException { String objectId ; DigitalObject object ; if ( forceUpdate ) { object = StorageUtils . storeFile ( getStorage ( ) , file , ! forceLocalStorage ) ; } else { String oid = StorageUtils . generateOid ( file ) ; String pid = StorageUtils . generatePid ( file ) ; object = getStorage ( ) . createObject ( oid ) ; if ( forceLocalStorage ) { try { object . createStoredPayload ( pid , new FileInputStream ( file ) ) ; } catch ( FileNotFoundException ex ) { throw new HarvesterException ( ex ) ; } } else { object . createLinkedPayload ( pid , file . getAbsolutePath ( ) ) ; } } // update object metadata Properties props = object . getMetadata ( ) ; props . setProperty ( \"render-pending\" , \"true\" ) ; props . setProperty ( \"file.path\" , FilenameUtils . separatorsToUnix ( file . getAbsolutePath ( ) ) ) ; objectId = object . getId ( ) ; // Store rendition information if we have it String ext = FilenameUtils . getExtension ( file . getName ( ) ) ; for ( String chain : renderChains . keySet ( ) ) { Map < String , List < String > > details = renderChains . get ( chain ) ; if ( details . get ( \"fileTypes\" ) . contains ( ext ) ) { storeList ( props , details , \"harvestQueue\" ) ; storeList ( props , details , \"indexOnHarvest\" ) ; storeList ( props , details , \"renderQueue\" ) ; } } object . close ( ) ; return objectId ; }'", "label": "'Store the provided file in storage . Ensure proper queue routing is set in object properties .'"}
{"text": "'private void storeList ( Properties props , Map < String , List < String > > details , String field ) { Set < String > valueSet = new LinkedHashSet < String > ( ) ; // merge with original property value if exists String currentValue = props . getProperty ( field , \"\" ) ; if ( ! \"\" . equals ( currentValue ) ) { String [ ] currentList = currentValue . split ( \",\" ) ; valueSet . addAll ( Arrays . asList ( currentList ) ) ; } valueSet . addAll ( details . get ( field ) ) ; String joinedList = StringUtils . join ( valueSet , \",\" ) ; props . setProperty ( field , joinedList ) ; }'", "label": "'Take a list of strings from a Java Map concatenate the values together and store them in a Properties object using the Map s original key .'"}
{"text": "'public FormValidation doCheckHighThreshold ( @ QueryParameter final String highThreshold , @ QueryParameter final String normalThreshold ) { return VALIDATION . validateHigh ( highThreshold , normalThreshold ) ; }'", "label": "'Performs on - the - fly validation on threshold for high warnings .'"}
{"text": "'public FormValidation doCheckNormalThreshold ( @ QueryParameter final String highThreshold , @ QueryParameter final String normalThreshold ) { return VALIDATION . validateNormal ( highThreshold , normalThreshold ) ; }'", "label": "'Performs on - the - fly validation on threshold for normal warnings .'"}
{"text": "'public List < MetadataInfo > ensureMetadata ( final MigratoryOption [ ] options ) throws MigratoryException { if ( migratoryContext . getDbSupport ( ) . tableExists ( migratoryConfig . getMetadataTableName ( ) ) ) { return null ; } if ( migratoryConfig . isReadOnly ( ) ) { throw new MigratoryException ( Reason . IS_READONLY ) ; } // Table does not exist. The way we get one, is that we run a special migration for the internal metadata schema final MigrationPlanner migrationPlanner = new MigrationPlanner ( new MigrationManager ( migratoryContext , METADATA_MIGRATION_NAME ) , 0 , Integer . MAX_VALUE ) ; migrationPlanner . plan ( ) ; if ( migrationPlanner . getDirection ( ) != MigrationDirection . FORWARD ) { throw new MigratoryException ( Reason . INTERNAL , \"Migration planner could not plan a migration for the metadata table!\" ) ; } final DbMigrator migrator = new DbMigrator ( migratoryContext , migrationPlanner ) ; try { lock ( METADATA_MIGRATION_NAME ) ; final List < MigrationResult > results = migrator . migrate ( options ) ; return commit ( results ) ; } catch ( MigratoryException e ) { rollback ( ) ; throw e ; } catch ( RuntimeException e ) { rollback ( ) ; throw e ; } }'", "label": "'Make sure that the metadata exists . If it does not exist create the metadata table from scratch and register its creation .'"}
{"text": "'private Object createDrySourceDetail ( final AbstractBuild < ? , ? > owner , final AnnotationContainer container , final String defaultEncoding , final String fromString , final String toString ) { long from = Long . parseLong ( fromString ) ; long to = Long . parseLong ( toString ) ; FileAnnotation fromAnnotation = container . getAnnotation ( from ) ; if ( fromAnnotation instanceof DuplicateCode ) { return new SourceDetail ( owner , ( ( DuplicateCode ) fromAnnotation ) . getLink ( to ) , defaultEncoding ) ; } return null ; }'", "label": "'Creates the dry source detail view .'"}
{"text": "'public Collection < FileAnnotation > parse ( final File file , final String moduleName ) throws InvocationTargetException { String oldProperty = System . getProperty ( SAX_DRIVER_PROPERTY ) ; if ( oldProperty != null ) { System . setProperty ( SAX_DRIVER_PROPERTY , SAXParser . class . getName ( ) ) ; } FileInputStream inputStream = null ; try { for ( AbstractDryParser parser : parsers ) { inputStream = new FileInputStream ( file ) ; if ( parser . accepts ( inputStream ) ) { IOUtils . closeQuietly ( inputStream ) ; inputStream = new FileInputStream ( file ) ; Collection < DuplicateCode > result = parser . parse ( inputStream , moduleName ) ; createLinkNames ( result ) ; Set < FileAnnotation > warnings = Sets . newHashSet ( ) ; warnings . addAll ( result ) ; ContextHashCode hashCode = new ContextHashCode ( ) ; for ( FileAnnotation duplication : warnings ) { duplication . setContextHashCode ( hashCode . create ( duplication . getFileName ( ) , duplication . getPrimaryLineNumber ( ) , defaultEncoding ) ) ; } return warnings ; } } throw new IOException ( \"No parser found for duplicated code results file \" + file . getAbsolutePath ( ) ) ; } catch ( IOException exception ) { throw new InvocationTargetException ( exception ) ; } finally { IOUtils . closeQuietly ( inputStream ) ; if ( oldProperty != null ) { System . setProperty ( SAX_DRIVER_PROPERTY , oldProperty ) ; } } }'", "label": "'{'"}
{"text": "'private void createLinkNames ( final Collection < DuplicateCode > result ) { if ( workspacePath != null ) { for ( FileAnnotation duplication : result ) { duplication . setPathName ( workspacePath ) ; } } }'", "label": "'For each duplicate code annotation that does not have a package name ( i . e . for non Java sources ) a link name is generated .'"}
{"text": "'public FormValidation validateHigh ( final String highThreshold , final String normalThreshold ) { return validate ( highThreshold , normalThreshold , Messages . DRY_ValidationError_HighThreshold ( ) ) ; }'", "label": "'Performs on - the - fly validation on threshold for high warnings .'"}
{"text": "'public FormValidation validateNormal ( final String highThreshold , final String normalThreshold ) { return validate ( highThreshold , normalThreshold , Messages . DRY_ValidationError_NormalThreshold ( ) ) ; }'", "label": "'Performs on - the - fly validation on threshold for normal warnings .'"}
{"text": "'private FormValidation validate ( final String highThreshold , final String normalThreshold , final String message ) { try { int high = Integer . parseInt ( highThreshold ) ; int normal = Integer . parseInt ( normalThreshold ) ; if ( isValid ( normal , high ) ) { return FormValidation . ok ( ) ; } } catch ( NumberFormatException exception ) { // ignore and return failure } return FormValidation . error ( message ) ; }'", "label": "'Performs on - the - fly validation on thresholds for high and normal warnings .'"}
{"text": "'public Resource createCommandResourceWadl ( ) { final Resource resource = new Resource ( ) ; resource . setPath ( getName ( ) ) ; final Method method = new Method ( ) ; method . setName ( \"POST\" ) ; resource . getMethodOrResource ( ) . add ( method ) ; definePostMethodWadl ( method ) ; return resource ; }'", "label": "'Creates a relative resource for this command . The resource path is set to the command name and a POST method is added :'"}
{"text": "'public static < T , D > List < IHandler < T , D > > scan ( ) throws Exception { return scan ( false ) ; }'", "label": "'Scans the package module . application . service . handler for classes annotated with @Handler ( protocol = ... ) . For every class found with this annotation an instance of this class is created per Java - Reflection and added to the result list of handlers .'"}
{"text": "'public static < T , D > List < IHandler < T , D > > proxyScan ( ) throws Exception { return scan ( true ) ; }'", "label": "'Scans the package module . application . service . handler for classes annotated with @Handler ( protocol = ... ) . For every class found with this annotation an instance of this class is created per Java - Reflection and added to the result list of handlers . The difference between this method and the scan - Method is that this method creates a proxy - object for each created instance . The reason for doing this is that upon calling any method of these proxied - instances a small logic has to be done after this method has returned and just before the caller receives the result .'"}
{"text": "'@ Override public String loadFile ( final URI fileUri ) throws IOException { return Resources . toString ( fileUri . toURL ( ) , charset ) ; }'", "label": "'This method loads a file from a file : / ... URI . This is probably not what you are looking for .'"}
{"text": "'static void validateArgs ( List < Object > args , Object instance , Method m , Command cmd ) { if ( ! onClasspath ( JSR303_1_1_CLASSNAME ) ) { return ; } try { Object validator = getValidator ( ) ; Method validate = validator . getClass ( ) . getMethod ( \"validateArgs\" , List . class , Object . class , Method . class , Command . class ) ; validate . invoke ( validator , args , instance , m , cmd ) ; } catch ( InvocationTargetException e ) { if ( e . getTargetException ( ) instanceof RuntimeException ) { throw ( RuntimeException ) e . getCause ( ) ; } throw new RuntimeException ( e . getCause ( ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }'", "label": "'Validate that the method parameters if Bean Validation 1 . 1 is available on classpath .'"}
{"text": "'static void validateOpts ( Object instance ) { if ( ! onClasspath ( JSR303_1_0_CLASSNAME ) ) { return ; } try { Object validator = getValidator ( ) ; Method validate = validator . getClass ( ) . getMethod ( \"validateOpts\" , Object . class ) ; validate . invoke ( validator , instance ) ; } catch ( InvocationTargetException e ) { if ( e . getTargetException ( ) instanceof RuntimeException ) { throw ( RuntimeException ) e . getTargetException ( ) ; } throw new RuntimeException ( e . getTargetException ( ) ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Throwable e ) { throw new RuntimeException ( e ) ; } }'", "label": "'Validate that the options if Bean Validation is available on classpath .'"}
{"text": "'static boolean onClasspath ( String className ) { ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { cl . loadClass ( className ) ; } catch ( ClassNotFoundException e ) { return false ; } return true ; }'", "label": "'Checks to see if JSR303 implementation is available on classpath .'"}
{"text": "'public FormValidation doCheckHighThreshold ( @ QueryParameter final String highThreshold , @ QueryParameter final String normalThreshold ) { return THRESHOLD_VALIDATION . validateHigh ( highThreshold , normalThreshold ) ; }'", "label": "'Performs on - the - fly validation on threshold for high warnings .'"}
{"text": "'public FormValidation doCheckNormalThreshold ( @ QueryParameter final String highThreshold , @ QueryParameter final String normalThreshold ) { return THRESHOLD_VALIDATION . validateNormal ( highThreshold , normalThreshold ) ; }'", "label": "'Performs on - the - fly validation on threshold for normal warnings .'"}
{"text": "'public boolean accept ( final URI uri ) { for ( final MigrationLoader loader : loaders ) { if ( loader . accept ( uri ) ) { return true ; } } return false ; }'", "label": "'Returns true if this loader accepts the URI .'"}
{"text": "'public Collection < URI > loadFolder ( final URI folderUri , final String pattern ) { try { for ( final MigrationLoader loader : loaders ) { if ( loader . accept ( folderUri ) ) { return loader . loadFolder ( folderUri , pattern ) ; } } return null ; } catch ( IOException ioe ) { throw new MigratoryException ( Reason . INTERNAL , ioe ) ; } }'", "label": "'Loads a collection of URIs from a given location . The resulting URIs may or may not loadable using this loader ( e . g . a classpath folder can contain File or Jar URIs .'"}
{"text": "'public String loadFile ( final URI fileUri ) { try { for ( final MigrationLoader loader : loaders ) { if ( loader . accept ( fileUri ) ) { return loader . loadFile ( fileUri ) ; } } return null ; } catch ( IOException ioe ) { throw new MigratoryException ( Reason . INTERNAL , ioe ) ; } }'", "label": "'Load a file from an URI .'"}
{"text": "'public void run ( ) throws RuntimeException { if ( terminalArgs == null ) { terminalArgs = new String [ 0 ] ; } p = GNUishParser . parse ( terminalArgs ) ; readCommands ( ) ; if ( p . getCommand ( ) == null || \"\" . equals ( p . getCommand ( ) ) ) { Utils . printAvailableCommandsHelp ( commands ) ; return ; } final Command cmd = commands . get ( p . getCommand ( ) ) ; if ( cmd == null ) { throw CliException . COMMAND_NOT_FOUND ( p . getCommand ( ) ) ; } if ( p . help ( ) ) { Utils . printCommandHelp ( cmd ) ; return ; } try { cmd . execute ( p ) ; } catch ( Exception e ) { if ( p . debug ( ) ) { e . printStackTrace ( ) ; } if ( e instanceof RuntimeException ) { throw ( RuntimeException ) e ; } } }'", "label": "'Start evaluating the user input and eventually execute the command requested by the user .'"}
{"text": "'private void readCommands ( ) { try { final Enumeration < URL > urls = Thread . currentThread ( ) . getContextClassLoader ( ) . getResources ( XmlCommands . FILEPATH ) ; while ( urls . hasMoreElements ( ) ) { URL url = urls . nextElement ( ) ; InputStream in = url . openStream ( ) ; for ( Command command : XmlCommands . fromXml ( in ) ) { commands . put ( command . getCommand ( ) , command ) ; } } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }'", "label": "'Find all commands available on classpath .'"}
{"text": "'protected void postProcess ( final String target , final Request baseRequest , final HttpServletRequest request , final HttpServletResponse response ) throws IOException , ServletException { // NOOP }'", "label": "'The purpose of this methods is to allow the Handler to return an HTTP response . For example return an appropriate response that the request was accepted per the requirements of a REST API .'"}
{"text": "'protected Map < String , Object > preProcess ( final String target , final Request baseRequest , final HttpServletRequest request , final HttpServletResponse response ) throws IOException , ServletException { return Collections . emptyMap ( ) ; }'", "label": "'Validate the request and extract any data from the HTTP request that will be required to process the request asynchronously .'"}
{"text": "'public Map < String , List < MetadataInfo > > dbMigrate ( final MigrationPlan migrationPlan , final MigratoryOption ... options ) throws MigratoryException { init ( ) ; final InternalMigrator migrator = new InternalMigrator ( this ) ; return migrator . migrate ( migrationPlan , options ) ; }'", "label": "'Bring the current database to the requested levels .'"}
{"text": "'public Map < String , ValidationResult > dbValidate ( final Collection < String > personalities , final MigratoryOption ... options ) throws MigratoryException { init ( ) ; final InternalValidator validator = new InternalValidator ( this ) ; return validator . validate ( personalities , options ) ; }'", "label": "'Run validation on the database . Make sure that all the changes recorded in the database are the same as the ones that should be applied .'"}
{"text": "'public void dbClean ( final MigratoryOption ... options ) { init ( ) ; final InternalClean internalClean = new InternalClean ( this ) ; internalClean . clean ( options ) ; }'", "label": "'Drops all objects ( tables views procedures triggers ... ) in the current schema .'"}
{"text": "'public Map < String , StatusResult > dbStatus ( final Collection < String > personalities , final MigratoryOption ... options ) { init ( ) ; final InternalStatus internalStatus = new InternalStatus ( this ) ; return internalStatus . status ( personalities , options ) ; }'", "label": "'Returns the status ( current version ) of the database .'"}
{"text": "'public Map < String , List < MetadataInfo > > dbHistory ( final Collection < String > personalities , final MigratoryOption ... options ) throws MigratoryException { init ( ) ; final InternalHistory internalHistory = new InternalHistory ( this ) ; return internalHistory . history ( personalities , options ) ; }'", "label": "'Returns the full history of all applied migrations .'"}
{"text": "'public List < MetadataInfo > dbInit ( final MigratoryOption ... options ) throws MigratoryException { init ( ) ; final InternalInit internalInit = new InternalInit ( this ) ; return internalInit . init ( options ) ; }'", "label": "'Creates and initializes the Migratory metadata table .'"}
{"text": "'public Migratory addDbSupport ( final String dbName , final Class < ? extends DbSupport > dbSupport ) { if ( initialized ) { throw new MigratoryException ( Reason . INIT , \"Already initialized!\" ) ; } dbSupportFactory . addDbSupport ( dbName , dbSupport ) ; return this ; }'", "label": "'Add support for an additional database type . The dbName is * not * the canonical name used but the name returned from the database engine on the JDBC metadata!'"}
{"text": "'public final boolean isAllowedOrigin ( final Origin origin ) { if ( allowAnyOrigin ) return true ; if ( origin == null ) return false ; if ( allowedOrigins . contains ( origin ) ) return true ; else if ( allowSubdomains ) return isAllowedSubdomainOrigin ( origin ) ; return false ; }'", "label": "'Helper method to check whether requests from the specified origin must be allowed . This is done by looking up { @link #allowAnyOrigin } and { @link #allowedOrigins } as well as the { @link #allowSubdomains } setting .'"}
{"text": "'public final boolean isAllowedSubdomainOrigin ( final Origin origin ) { try { ValidatedOrigin validatedOrigin = origin . validate ( ) ; String scheme = validatedOrigin . getScheme ( ) ; String suffix = validatedOrigin . getSuffix ( ) ; for ( ValidatedOrigin allowedOrigin : allowedOrigins ) { if ( suffix . endsWith ( \".\" + allowedOrigin . getSuffix ( ) ) && scheme . equalsIgnoreCase ( allowedOrigin . getScheme ( ) ) ) return true ; } } catch ( OriginException e ) { return false ; } return false ; }'", "label": "'Helper method to check whether the specified origin is a subdomain origin of the { @link #allowedOrigins } . This is done by looking up the origin s scheme hostname and port and matching them with each of the { @link #allowedOrigins } .'"}
{"text": "'protected static String [ ] parseWords ( final String s ) { String s1 = s . trim ( ) ; if ( s1 . isEmpty ( ) ) return new String [ ] { } ; else return s1 . split ( \"\\\\\\\\s*,\\\\\\\\s*|\\\\\\\\s+\" ) ; }'", "label": "'Parses a string containing words separated by space and / or comma .'"}
{"text": "'@ Override public void validateInput ( final Command command , final Context ctx ) throws ValidationException { checkRequiredInputKeys ( command , ctx ) ; checkInput ( command , ctx ) ; }'", "label": "'Checks required input keys and then delegates to checkInput () ;'"}
{"text": "'@ Override public void validateOutput ( final Command command , final Context ctx ) throws ValidationException { checkRequiredOutputKeys ( command , ctx ) ; checkOutput ( command , ctx ) ; }'", "label": "'Checks required output keys and then delegates to checkOutput () ;'"}
{"text": "'List < SqlStatement > linesToStatements ( List < String > lines ) { final List < SqlStatement > statements = Lists . newArrayList ( ) ; final StringBuilder statementSql = new StringBuilder ( ) ; int count = 0 ; String delimiter = DEFAULT_STATEMENT_DELIMITER ; for ( final String line : lines ) { if ( StringUtils . isBlank ( line ) ) { continue ; } if ( statementSql . length ( ) > 0 ) { statementSql . append ( \" \" ) ; } statementSql . append ( line ) ; final String oldDelimiter = delimiter ; delimiter = changeDelimiterIfNecessary ( statementSql . toString ( ) , line , delimiter ) ; if ( ! StringUtils . equals ( delimiter , oldDelimiter ) && isDelimiterChangeExplicit ( ) ) { statementSql . setLength ( 0 ) ; continue ; // for } if ( StringUtils . endsWith ( line , delimiter ) ) { // Trim off the delimiter at the end. statementSql . setLength ( statementSql . length ( ) - delimiter . length ( ) ) ; statements . add ( new SqlStatement ( count ++ , StringUtils . trimToEmpty ( statementSql . toString ( ) ) ) ) ; LOG . debug ( \"Found statement: {}\" , statementSql ) ; if ( ! isDelimiterChangeExplicit ( ) ) { delimiter = DEFAULT_STATEMENT_DELIMITER ; } statementSql . setLength ( 0 ) ; } } // Catch any statements not followed by delimiter. if ( statementSql . length ( ) > 0 ) { statements . add ( new SqlStatement ( count ++ , StringUtils . trimToEmpty ( statementSql . toString ( ) ) ) ) ; } return statements ; }'", "label": "'Turns these lines in a series of statements .'"}
{"text": "'@ Programmatic public NotableLink findByNote ( final Note note ) { return repositoryService . firstMatch ( new QueryDefault <> ( NotableLink . class , \"findByNote\" , \"note\" , note ) ) ; }'", "label": "'region > findByNote ( programmatic )'"}
{"text": "'@ Programmatic public List < NotableLink > findByNotable ( final Object notable ) { if ( notable == null ) { return null ; } final Bookmark bookmark = bookmarkService . bookmarkFor ( notable ) ; if ( bookmark == null ) { return null ; } final String notableStr = bookmark . toString ( ) ; return repositoryService . allMatches ( new QueryDefault <> ( NotableLink . class , \"findByNotable\" , \"notableStr\" , notableStr ) ) ; }'", "label": "'region > findByNotable ( programmatic )'"}
{"text": "'@ Programmatic public NotableLink findByNotableAndCalendarName ( final Object notable , final String calendarName ) { if ( notable == null ) { return null ; } if ( calendarName == null ) { return null ; } final Bookmark bookmark = bookmarkService . bookmarkFor ( notable ) ; if ( bookmark == null ) { return null ; } final String notableStr = bookmark . toString ( ) ; return repositoryService . firstMatch ( new QueryDefault <> ( NotableLink . class , \"findByNotableAndCalendarName\" , \"notableStr\" , notableStr , \"calendarName\" , calendarName ) ) ; }'", "label": "'Each notable can only have one note per calendar thus this method returns a single object rather than a list .'"}
{"text": "'@ Programmatic public List < NotableLink > findByNotableInDateRange ( final Object notable , final LocalDate startDate , final LocalDate endDate ) { if ( notable == null ) { return null ; } final Bookmark bookmark = bookmarkService . bookmarkFor ( notable ) ; if ( bookmark == null ) { return null ; } if ( startDate == null ) { return null ; } if ( endDate == null ) { return null ; } final String notableStr = bookmark . toString ( ) ; return repositoryService . allMatches ( new QueryDefault <> ( NotableLink . class , \"findByNotableInDateRange\" , \"notableStr\" , notableStr , \"startDate\" , startDate , \"endDate\" , endDate ) ) ; }'", "label": "'region > findByNotableInDateRange ( programmatic )'"}
{"text": "'@ Programmatic public NotableLink createLink ( final Note note , final Object notable ) { final Class < ? extends NotableLink > subtype = subtypeClassFor ( notable ) ; final NotableLink link = repositoryService . instantiate ( subtype ) ; link . setNote ( note ) ; final Bookmark bookmark = bookmarkService . bookmarkFor ( notable ) ; link . setNotable ( notable ) ; link . setNotableStr ( bookmark . toString ( ) ) ; repositoryService . persistAndFlush ( link ) ; return link ; }'", "label": "'region > createLink ( programmatic )'"}
{"text": "'@ Programmatic public void updateLink ( final Note note ) { final NotableLink link = findByNote ( note ) ; sync ( note , link ) ; }'", "label": "'region > updateLink'"}
{"text": "'void sync ( final Note note , final NotableLink link ) { if ( link == null ) { return ; } link . setDate ( note . getDate ( ) ) ; link . setCalendarName ( note . getCalendarName ( ) ) ; }'", "label": "'copy over details from the {'"}
{"text": "'private String [ ] parseOpts ( String [ ] args ) { if ( args == null || args . length == 0 ) { return new String [ 0 ] ; } final List < String > remainingArgs = new ArrayList < String > ( ) ; final List < String > argsList = Arrays . asList ( args ) ; final ListIterator < String > argsIt = argsList . listIterator ( ) ; while ( argsIt . hasNext ( ) ) { String word = argsIt . next ( ) ; if ( word . startsWith ( \"--\" ) ) { // long option --foo\\r final String option = stripLeadingHyphens ( word ) ; if ( VERBOSE_LONG_OPT . equals ( option ) ) { longOpts . put ( option , \"true\" ) ; } else if ( DEBUG_LONG_OPT . equals ( option ) ) { longOpts . put ( option , \"true\" ) ; } else if ( HELP_LONG_OPT . equals ( option ) ) { longOpts . put ( option , \"true\" ) ; } else { final String arg = parseOptionArg ( option , argsIt ) ; longOpts . put ( option , arg ) ; } } else if ( word . startsWith ( \"-\" ) ) { String options = stripLeadingHyphens ( word ) ; // single short option -f\\r if ( options . length ( ) == 1 ) { // only slurp argument if option is argumented\\r final String arg = parseOptionArg ( options , argsIt ) ; shortOpts . put ( options , arg ) ; continue ; } // multiple short options -fxy, \\r // treat as non-argumented java.lang.Boolean variables, no slurp \\r for ( int i = 0 ; i < options . length ( ) ; i ++ ) { final String option = Character . toString ( options . charAt ( i ) ) ; shortOpts . put ( option , \"true\" ) ; } } else { remainingArgs . add ( word ) ; } } return remainingArgs . toArray ( new String [ 0 ] ) ; }'", "label": "'Parse the options for the command .'"}
{"text": "'public void transmit ( Command c , Map h , String b ) { _server . receive ( c , h , b , this ) ; }'", "label": "'Transmit a message to clients and listeners .'"}
{"text": "'@ Programmatic public List < Note > findByNotable ( final Object notable ) { final List < NotableLink > links = linkRepository . findByNotable ( notable ) ; return Lists . newArrayList ( Iterables . transform ( links , NotableLink . Functions . note ( ) ) ) ; }'", "label": "'region > findByNotable ( programmatic )'"}
{"text": "'@ Programmatic public Note findByNotableAndCalendarName ( final Object notable , final String calendarName ) { final NotableLink link = linkRepository . findByNotableAndCalendarName ( notable , calendarName ) ; return NotableLink . Functions . note ( ) . apply ( link ) ; }'", "label": "'region > findByNotableAndCalendarName ( programmatic )'"}
{"text": "'@ Programmatic public List < Note > findInDateRange ( final LocalDate startDate , final LocalDate endDate ) { return repositoryService . allMatches ( new QueryDefault <> ( Note . class , \"findInDateRange\" , \"startDate\" , startDate , \"endDate\" , endDate ) ) ; }'", "label": "'region > findInDateRange ( programmatic )'"}
{"text": "'@ Programmatic public Iterable < Note > findByNotableInDateRange ( final Object notable , final LocalDate startDate , final LocalDate endDate ) { final List < NotableLink > link = linkRepository . findByNotableInDateRange ( notable , startDate , endDate ) ; return Iterables . transform ( link , NotableLink . Functions . note ( ) ) ; }'", "label": "'region > findByNotableInDateRange ( programmatic )'"}
{"text": "'@ Programmatic public Note add ( final Object notable , final String noteText , final LocalDate date , final String calendarName ) { final Note note = repositoryService . instantiate ( Note . class ) ; note . setDate ( date ) ; note . setCalendarName ( calendarName ) ; note . setContent ( noteText ) ; repositoryService . persistAndFlush ( note ) ; final NotableLink link = notableLinkRepository . createLink ( note , notable ) ; // stored redundantly for querying... link . setCalendarName ( calendarName ) ; link . setDate ( date ) ; return note ; }'", "label": "'region > add ( programmatic )'"}
{"text": "'@ Programmatic public void remove ( Note note ) { final NotableLink link = linkRepository . findByNote ( note ) ; repositoryService . removeAndFlush ( link ) ; repositoryService . removeAndFlush ( note ) ; }'", "label": "'region > remove ( programmatic )'"}
{"text": "'public String getToolTip ( ) { StringBuilder message = new StringBuilder ( ) ; message . append ( \"<p>\" ) ; message . append ( Messages . DRY_Duplications_Header ( ) ) ; message . append ( \"<ul>\" ) ; for ( DuplicateCode duplication : links ) { message . append ( \"<li>\" ) ; message . append ( String . format ( \"<a href=\\\\\"link.%s.%s/#%s\\\\\">%s (%s)</a>\" , getKey ( ) , duplication . getKey ( ) , duplication . getPrimaryLineNumber ( ) , duplication . getLinkName ( ) , duplication . getPrimaryLineNumber ( ) ) ) ; message . append ( \"</li>\" ) ; } message . append ( \"</ul>\" ) ; message . append ( \"</p>\" ) ; return message . toString ( ) ; }'", "label": "'{'"}
{"text": "'public String getFormattedSourceCode ( ) { try { JavaSource source = new JavaSourceParser ( ) . parse ( new StringReader ( sourceCode ) ) ; JavaSource2HTMLConverter converter = new JavaSource2HTMLConverter ( ) ; StringWriter writer = new StringWriter ( ) ; JavaSourceConversionOptions options = JavaSourceConversionOptions . getDefault ( ) ; options . setShowLineNumbers ( false ) ; options . setAddLineAnchors ( false ) ; converter . convert ( source , options , writer ) ; return writer . toString ( ) ; } catch ( IllegalConfigurationException exception ) { return sourceCode ; } catch ( IOException exception ) { return sourceCode ; } }'", "label": "'Returns the duplicate source code fragment as formatted HTML string .'"}
{"text": "'public FileAnnotation getLink ( final long linkHashCode ) { for ( FileAnnotation link : links ) { if ( link . getKey ( ) == linkHashCode ) { return link ; } } throw new NoSuchElementException ( \"Linked annotation not found: key=\" + linkHashCode ) ; }'", "label": "'Returns the link with the specified hash code .'"}
{"text": "'public void transmit ( Command c , Map h , String b ) { try { Transmitter . transmit ( c , h , b , _output ) ; } catch ( Exception e ) { receive ( Command . ERROR , null , e . getMessage ( ) ) ; } }'", "label": "'Transmit a message to the server'"}
{"text": "'public static JAXBContext get ( final String contextPath ) { Assert . hasText ( contextPath , \"contextPath is required\" ) ; JAXBContext ctx = jaxbContexts . get ( contextPath ) ; if ( ctx == null ) { try { ctx = JAXBContext . newInstance ( contextPath ) ; } catch ( final JAXBException e ) { throw new IllegalArgumentException ( \"Failed to create JAXBContext - invalid JAXB context path: \" + contextPath , e ) ; } jaxbContexts . put ( contextPath , ctx ) ; LoggerFactory . getLogger ( JAXBContextCache . class ) . info ( \"cached : {}\" , contextPath ) ; } return ctx ; }'", "label": "'If the JAXBContext is not cached then it will create a new instance and cache it .'"}
{"text": "'public static void main ( String [ ] args ) { if ( args . length < 1 ) throw new IllegalArgumentException ( \"You must specify a job id\" ) ; String jobId = args [ 0 ] ; RmiProxyFactoryBean factoryBean = new RmiProxyFactoryBean ( ) ; factoryBean . setServiceInterface ( RouteAPI . class ) ; factoryBean . setServiceUrl ( String . format ( \"rmi://%s:%s/router\" , System . getProperty ( \"router.address\" , \"localhost\" ) , System . getProperty ( \"router.port\" , \"1097\" ) ) ) ; factoryBean . afterPropertiesSet ( ) ; RouteAPI router = ( RouteAPI ) factoryBean . getObject ( ) ; Object result = router . perform ( jobId ) ; System . out . println ( \"Got router response: \" + result ) ; }'", "label": "'java - Drouter . port = 1097 - Drouter . address = localhost - jar path / to / com . myapp . caller - 1 . 0 . 0 . jar jobId'"}
{"text": "'protected BrowserCanvas renderUrl ( URL url , Dimension pageSize ) throws IOException , SAXException { DocumentSource src = new DefaultDocumentSource ( url ) ; pageUrl = src . getURL ( ) ; InputStream is = src . getInputStream ( ) ; String mime = src . getContentType ( ) ; if ( mime == null ) mime = \"text/html\" ; int p = mime . indexOf ( \\' \\' ) ; if ( p != - 1 ) mime = mime . substring ( 0 , p ) . trim ( ) ; log . info ( \"File type: \" + mime ) ; if ( mime . equals ( \"application/pdf\" ) ) { PDDocument doc = loadPdf ( is ) ; BrowserCanvas canvas = new PdfBrowserCanvas ( doc , null , pageSize , src . getURL ( ) ) ; doc . close ( ) ; pageTitle = \"\" ; return canvas ; } else { DOMSource parser = new DefaultDOMSource ( src ) ; Document doc = parser . parse ( ) ; pageTitle = findPageTitle ( doc ) ; String encoding = parser . getCharset ( ) ; MediaSpec media = new MediaSpec ( \"screen\" ) ; //updateCurrentMedia(media); DOMAnalyzer da = new DOMAnalyzer ( doc , src . getURL ( ) ) ; if ( encoding == null ) encoding = da . getCharacterEncoding ( ) ; da . setDefaultEncoding ( encoding ) ; da . setMediaSpec ( media ) ; da . attributesToStyles ( ) ; da . addStyleSheet ( null , CSSNorm . stdStyleSheet ( ) , DOMAnalyzer . Origin . AGENT ) ; da . addStyleSheet ( null , CSSNorm . userStyleSheet ( ) , DOMAnalyzer . Origin . AGENT ) ; da . addStyleSheet ( null , CSSNorm . formsStyleSheet ( ) , DOMAnalyzer . Origin . AGENT ) ; da . getStyleSheets ( ) ; BrowserCanvas contentCanvas = new BrowserCanvas ( da . getRoot ( ) , da , src . getURL ( ) ) ; contentCanvas . getConfig ( ) . setLoadImages ( false ) ; contentCanvas . getConfig ( ) . setLoadBackgroundImages ( false ) ; contentCanvas . getConfig ( ) . setLoadFonts ( false ) ; contentCanvas . getConfig ( ) . setReplaceImagesWithAlt ( replaceImagesWithAlt ) ; contentCanvas . createLayout ( pageSize ) ; src . close ( ) ; return contentCanvas ; } }'", "label": "'==================================================================='"}
{"text": "'protected BoxNode buildTree ( ElementBox rootbox ) { //create the working list of nodes log . trace ( \"LIST\" ) ; Vector < BoxNode > boxlist = new Vector < BoxNode > ( ) ; order_counter = 1 ; createBoxList ( rootbox , boxlist ) ; //create the tree if ( useVisualBounds ) { //two-phase algorithm considering the visual bounds log . trace ( \"A1\" ) ; BoxNode root = createBoxTree ( rootbox , boxlist , true , true , true ) ; //create a nesting tree based on the content bounds System . out . println ( \"ZOOM \" + zoom ) ; log . trace ( \"A2\" ) ; Color bg = rootbox . getBgcolor ( ) ; if ( bg == null ) bg = Color . WHITE ; computeBackgrounds ( root , bg ) ; //compute the efficient background colors log . trace ( \"A2.5\" ) ; root . recomputeVisualBounds ( ) ; //compute the visual bounds for the whole tree log . trace ( \"A3\" ) ; root = createBoxTree ( rootbox , boxlist , true , true , preserveAux ) ; //create the nesting tree based on the visual bounds or content bounds depending on the settings root . recomputeVisualBounds ( ) ; //compute the visual bounds for the whole tree root . recomputeBounds ( ) ; //compute the real bounds of each node log . trace ( \"A4\" ) ; //root.applyTransforms(); //TODO test this first; actually the transform should be applied according to the drawing tree, not this tree return root ; } else { //simplified algorihm - use the original box nesting BoxNode root = createBoxTree ( rootbox , boxlist , false , true , true ) ; Color bg = rootbox . getBgcolor ( ) ; if ( bg == null ) bg = Color . WHITE ; computeBackgrounds ( root , bg ) ; //compute the efficient background colors root . recomputeVisualBounds ( ) ; //compute the visual bounds for the whole tree root . recomputeBounds ( ) ; //compute the real bounds of each node root . applyTransforms ( ) ; return root ; } }'", "label": "'==================================================================='"}
{"text": "'private void createBoxList ( Box root , Vector < BoxNode > list ) { if ( root . isDisplayed ( ) ) { if ( ! ( root instanceof Viewport ) && root . isVisible ( ) ) { BoxNode newnode = new BoxNode ( root , page , zoom ) ; newnode . setOrder ( order_counter ++ ) ; list . add ( newnode ) ; } if ( root instanceof ElementBox ) { ElementBox elem = ( ElementBox ) root ; for ( int i = elem . getStartChild ( ) ; i < elem . getEndChild ( ) ; i ++ ) createBoxList ( elem . getSubBox ( i )  , list ) ; } } }'", "label": "'Recursively creates a list of all the visible boxes in a box subtree . The nodes are added to the end of a specified list . The previous content of the list remains unchanged . The viewport box is ignored .'"}
{"text": "'private BoxNode createBoxTree ( ElementBox rootbox , Vector < BoxNode > boxlist , boolean useBounds , boolean useVisualBounds , boolean preserveAux ) { //a working copy of the box list Vector < BoxNode > list = new Vector < BoxNode > ( boxlist ) ; //an artificial root node BoxNode root = new BoxNode ( rootbox , page , zoom ) ; root . setOrder ( 0 ) ; //detach the nodes from any old trees for ( BoxNode node : list ) node . removeFromTree ( ) ; //when working with visual bounds, remove the boxes that are not visually separated if ( ! preserveAux ) { for ( Iterator < BoxNode > it = list . iterator ( ) ; it . hasNext ( ) ; ) { BoxNode node = it . next ( ) ; if ( ! node . isVisuallySeparated ( ) || ! node . isVisible ( ) ) it . remove ( ) ; } } //let each node choose it\\'s children - find the roots and parents for ( BoxNode node : list ) { if ( useBounds ) node . markNodesInside ( list , useVisualBounds ) ; else node . markChildNodes ( list ) ; } //choose the roots for ( Iterator < BoxNode > it = list . iterator ( ) ; it . hasNext ( ) ; ) { BoxNode node = it . next ( ) ; /*if (!full) //DEBUG\\n            {\\n               if (node.toString().contains(\"mediawiki\") || node.toString().contains(\"globalWrapper\"))\\n                    System.out.println(node + \" => \" + node.nearestParent);\\n            }*/ if ( node . isRootNode ( ) ) { root . appendChild ( node ) ; it . remove ( ) ; } } //recursively choose the children for ( int i = 0 ; i < root . getChildCount ( ) ; i ++ )  ( ( BoxNode ) root . getChildAt ( i ) ) . takeChildren ( list ) ; return root ; }'", "label": "'Creates a tree of box nesting based on the content bounds of the boxes . This tree is only used for determining the backgrounds .'"}
{"text": "'private void computeBackgrounds ( BoxNode root , Color currentbg ) { Color newbg = root . getBackgroundColor ( ) ; if ( newbg == null ) newbg = currentbg ; root . setEfficientBackground ( newbg ) ; root . setBackgroundSeparated ( ! newbg . equals ( currentbg ) ) ; for ( int i = 0 ; i < root . getChildCount ( ) ; i ++ ) computeBackgrounds ( ( BoxNode ) root . getChildAt ( i )  , newbg ) ; }'", "label": "'Computes efficient background color for all the nodes in the tree'"}
{"text": "'private List < URL > loadList ( String filename ) { List < URL > ret = new ArrayList < URL > ( ) ; try { BufferedReader read = new BufferedReader ( new FileReader ( filename ) ) ; String line ; while ( ( line = read . readLine ( ) ) != null ) { line = line . trim ( ) ; if ( ! line . isEmpty ( ) && ! line . startsWith ( \"#\" ) ) { ret . add ( new URL ( line ) ) ; } } read . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return ret ; }'", "label": "'==================================================================='"}
{"text": "'protected void copyFile ( File artifact , File dest , File prevent ) throws IOException , MojoExecutionException { if ( dest . exists ( ) ) { if ( prevent . exists ( ) ) //noinspection ResultOfMethodCallIgnored prevent . delete ( ) ; } else { if ( prevent . exists ( ) ) org . apache . commons . io . FileUtils . moveFile ( prevent , dest ) ; else super . copyFile ( artifact , dest ) ; } }'", "label": "'<h2 > \u628aartifact\u6587\u4ef6copy\u5230\u76ee\u6807\u6587\u4ef6\uff0c\u5982\u679c\u53e6\u5916\u4e00\u4e2a\u76f8\u5e94\u7684\u6587\u4ef6\u5b58\u5728\uff0c\u5219\u79fb\u52a8\u4e4b< / h2 >'"}
{"text": "'private String interpolate ( String content , Map < String , Object > replaces , char mode ) { Pattern pattern = mode == \\' \\' ? INTERPOLATE_PTN_A : INTERPOLATE_PTN_B ; Matcher m = pattern . matcher ( content ) ; StringBuffer sb = new StringBuffer ( ) ; while ( m . find ( ) ) { String variable = m . group ( 1 ) ; Object replace = replaces . get ( variable ) ; String replacement = replace == null ? \"\" : replace . toString ( ) ; if ( pattern . matcher ( replacement ) . find ( ) ) replacement = interpolate ( replacement , replaces , mode ) ; try { m . appendReplacement ( sb , replacement ) ; } catch ( Exception e ) { System . err . println ( e . getMessage ( ) ) ; } } m . appendTail ( sb ) ; return sb . toString ( ) . trim ( ) ; }'", "label": "'interpolate xml bat file content with $ {}'"}
{"text": "'private String interpolate ( List < String > lines , Map < String , Object > replaces , char mode ) { for ( int i = 0 ; i < lines . size ( ) ; i ++ ) { String line = lines . get ( i ) ; if ( ! line . trim ( ) . startsWith ( \"#\" ) && line . contains ( \"=\" ) ) { String [ ] array = line . split ( \"=\" ) ; String key = array [ 0 ] . trim ( ) ; // string like: neo4j.user= split array length == 1 String value ; if ( array . length == 2 ) { value = array [ 1 ] ; } else if ( array . length == 1 ) { value = \"\" ; } else { continue ; //don\\'t touch them } value = interpolate ( value , replaces , mode ) ; if ( replaces . containsKey ( key ) ) { value = replaces . get ( key ) . toString ( ) ; } lines . set ( i , key + \"=\" + value ) ; } } return StringUtils . join ( lines , lineSeparator ) ; }'", "label": "'interpolate properties file like : http . port = the . default . value'"}
{"text": "'public void setMappingFile ( URL url , String realFile ) { if ( componentFiles == null ) initFastIndexes ( \"app\" , \"lib\" , \"repository\" ) ; File file = new File ( realFile ) ; componentFiles . put ( url . getFile ( ) , file ) ; }'", "label": "'Set the real file of component url'"}
{"text": "'public File getMappingFile ( URL url ) throws IOException { if ( componentFiles == null ) initFastIndexes ( \"app\" , \"lib\" , \"repository\" ) ; String fileName = FilenameUtils . normalize ( url . getFile ( ) , true ) ; if ( ! fileName . endsWith ( \".jar\" ) ) fileName = fileName + \".jar\" ; if ( fileName . startsWith ( \"boot/\" ) || fileName . startsWith ( \"boot\\\\\\\\\" ) ) { fileName = \"net.happyonroad/\" + FilenameUtils . getName ( fileName ) ; } else if ( fileName . startsWith ( \"lib/\" ) || fileName . startsWith ( \"lib\\\\\\\\\" ) ) { /* Only 3rd lib file will be put into jar classpath*/ //\u6b63\u5e38\u7684\u7ec4\u4ef6component url\u91cc\u9762\u80af\u5b9a\u4e0d\u662flib\u5f00\u5934\uff1b // \u4f46\u662f spring-component-framework\u7684Class-Path\u6307\u5b9a\u7684\u90a3\u4e9burl\u88abnormalize\u4e4b\u540e\u5374\u4f1a\u5982\u6b64 fileName = ComponentUtils . relativePath ( fileName ) ; } File componentFile = componentFiles . get ( fileName ) ; if ( componentFile == null ) { // \u5f53\u7b2c\u4e00\u6b21\u5efa\u7acb\u7684\u5feb\u901f\u7d22\u5f15\u4e2d\u6ca1\u6709\u76f8\u5e94\u6587\u4ef6\u65f6 // \u5c1d\u8bd5\u770blib\u4e0b\u540e\u6765\u6709\u6ca1\u6709\u76f8\u5e94\u7684\u6587\u4ef6 componentFile = guessFile ( url , \"app\" , \"lib\" , \"repository\" ) ; if ( componentFile == null ) throw new IOException ( \"there is no component named as \" + fileName ) ; } return componentFile ; }'", "label": "'Get the real file of component url'"}
{"text": "'protected < T > T imports ( Class < T > serviceClass ) throws ServiceConfigurationException { return importer . imports ( serviceClass ) ; }'", "label": "'<h2 > \u5bfc\u5165\u67d0\u4e2a\u670d\u52a1< / h2 >'"}
{"text": "'protected < T > T imports ( Class < T > serviceClass , String hint ) throws ServiceConfigurationException { return importer . imports ( serviceClass , hint ) ; }'", "label": "'<h2 > \u5bfc\u5165\u67d0\u4e2a\u670d\u52a1< / h2 >'"}
{"text": "'public boolean accept ( Versionize componentOrDependency ) { boolean accept = getGroupId ( ) . equals ( componentOrDependency . getGroupId ( ) ) && getArtifactId ( ) . equals ( componentOrDependency . getArtifactId ( ) ) ; if ( ! accept ) return false ; if ( getVersion ( ) != null ) { //\u6709version\u9700\u8981\uff0c\u6682\u65f6\u4e0d\u77e5\u9053\u662f\u5426\u9700\u8981\u652f\u6301version\u7684\u8868\u8fbe\u5f0f\uff0cmaven\u81ea\u8eab\u597d\u50cf\u6ca1\u6709\u8fd9\u4e2a\u673a\u5236 accept = getVersion ( ) . equals ( componentOrDependency . getVersion ( ) ) ; if ( ! accept ) return false ; } if ( range != null ) { // Temp solution if ( componentOrDependency . getVersion ( ) == null ) return true ; accept = range . containsVersion ( new ComponentVersion ( componentOrDependency . getVersion ( ) ) ) ; if ( ! accept ) return false ; } /*\\n        if( getClassifier() != null ){\\n            accept = getClassifier().equals(componentOrDependency.getClassifier());\\n            if (!accept) return false;\\n        }\\n*/ /*\\n        if( getType() != null ){\\n            accept = getType().equals(componentOrDependency.getType());\\n            if (!accept) return false;\\n        }\\n*/ return true ; }'", "label": "'\u5224\u65ad\u67d0\u4e2a\u7ec4\u4ef6\u662f\u5426\u6ee1\u8db3\u7279\u5b9a\u4f9d\u8d56\u4fe1\u606f <pre > \u5982\uff0c dependency1 = { groupId : dnt artifactId : component } dependency2 = { groupId : dnt artifactId : component version : 1 . 0 . 0 } \u90a3\u4e48 : dependency1 . accept ( dependency2 ) = true \u53cd\u4e4b : dependency2 . accept ( dependency1 ) = false < / pre >'"}
{"text": "'public void merge ( Dependency parentDefined ) { if ( optional == null ) { setOptional ( parentDefined . isOptional ( ) ) ; } if ( version == null ) { setVersion ( parentDefined . getVersion ( ) ) ; } if ( classifier == null ) { setClassifier ( parentDefined . getClassifier ( ) ) ; } if ( scope == null ) { setScope ( parentDefined . getScope ( ) ) ; } if ( exclusions == null ) { setExclusions ( parentDefined . getExclusions ( ) ) ; } }'", "label": "'\u4e3a\u67d0\u4e2a\u4f9d\u8d56\u8865\u9f50\u4fe1\u606f'"}
{"text": "'public void interpolate ( DefaultComponent component ) { if ( groupId != null ) this . groupId = component . interpolate ( groupId ) ; if ( artifactId != null ) this . artifactId = component . interpolate ( artifactId ) ; //\u6682\u65f6\u4e3b\u8981\u5904\u7406\u4e00\u4e9b\u542f\u52a8\u76f8\u5173\u7684\u5173\u952e\u5c5e\u6027\uff0c\u5982version if ( version != null ) this . setVersion ( component . interpolate ( version ) ) ; if ( classifier != null ) this . classifier = component . interpolate ( classifier ) ; if ( scope != null ) this . scope = component . interpolate ( scope ) ; }'", "label": "'\u6839\u636e\u7ec4\u4ef6\u7684\u4e0a\u4e0b\u6587\uff0c\u66ff\u6362\u4f9d\u8d56\u4e2d\u7684\u4fe1\u606f'"}
{"text": "'public void registerResolver ( FeatureResolver resolver ) { resolver . bind ( this ) ; featureResolvers . add ( resolver ) ; reverseResolvers . add ( resolver ) ; Collections . sort ( featureResolvers , new LoadOrder ( ) ) ; Collections . sort ( reverseResolvers , new UnloadOrder ( ) ) ; }'", "label": "'\u6ce8\u518c\u4e00\u4e2a\u6269\u5c55\u7279\u6027\u89e3\u6790\u5668'"}
{"text": "'@ Override public void load ( Component component ) throws Exception { if ( isLoaded ( component ) ) return ; logger . debug ( \"Before loading {}\" , component ) ; //\u9996\u5148\u52a0\u8f7d\u7236\u7ec4\u4ef6 if ( component . getParent ( ) != null ) { //\u4e0a\u9762\u4f1a\u81ea\u52a8\u68c0\u6d4b\u662f\u5426\u5df2\u7ecf\u52a0\u8f7d\uff0c\u9632\u6b62\u91cd\u590d\u52a0\u8f7d load ( component . getParent ( ) ) ; } //\u800c\u540e\u52a0\u8f7d\u4f9d\u8d56\u7684\u7ec4\u4ef6 for ( Component depended : component . getDependedComponents ( ) ) { //\u4e0a\u9762\u4f1a\u81ea\u52a8\u68c0\u6d4b\u662f\u5426\u5df2\u7ecf\u52a0\u8f7d\uff0c\u9632\u6b62\u91cd\u590d\u52a0\u8f7d Dependency textualDependency = new Dependency ( depended . getGroupId ( ) , depended . getArtifactId ( ) ) ; Dependency actualDependency = component . getDependency ( textualDependency ) ; if ( actualDependency . isProvided ( ) || actualDependency . isTest ( ) ) continue ; load ( depended ) ; } quickLoad ( component ) ; //\u6700\u540e\uff0c\u52a0\u8f7d\u81ea\u8eab logger . debug ( \"After  loaded  {}\" , component ) ; }'", "label": "'\u81ea\u9876\u5411\u4e0b\u7684\u52a0\u8f7d\u7ec4\u4ef6'"}
{"text": "'@ Override public void unload ( Component component ) { if ( ! isLoaded ( component ) ) return ; logger . debug ( \"Before unloading {}\" , component ) ; //\u5148\u5378\u8f7d\u81ea\u8eab quickUnload ( component ) ; //\u518d\u5378\u8f7d\u4f9d\u8d56 for ( Component depended : component . getDependedComponents ( ) ) { //\u4e0a\u9762\u4f1a\u81ea\u52a8\u68c0\u6d4b\u662f\u5426\u5df2\u7ecf\u52a0\u8f7d\uff0c\u9632\u6b62\u91cd\u590d\u52a0\u8f7d unload ( depended ) ; } //\u6700\u540e\u5378\u8f7d\u5176\u7236\u7ec4\u4ef6 if ( component . getParent ( ) != null ) { //\u4e0a\u9762\u4f1a\u81ea\u52a8\u68c0\u6d4b\u662f\u5426\u5df2\u7ecf\u52a0\u8f7d\uff0c\u9632\u6b62\u91cd\u590d\u52a0\u8f7d unload ( component . getParent ( ) ) ; } logger . debug ( \"After  unloaded  {}\" , component ) ; }'", "label": "'\u5265\u6d0b\u8471\u4e00\u6837\u7684\u5378\u8f7d\u7ec4\u4ef6'"}
{"text": "'public void quickLoad ( Component component ) throws Exception { if ( component . isAggregating ( ) ) { logger . trace ( \"Needn\\'t real load aggregating component {}\" , component ) ; loadedFeatures . put ( component , FeatureResolver . AggregatingFlag ) ; } else if ( component . isPlain ( ) ) { logger . trace ( \"Needn\\'t real load plain component {}\" , component ) ; loadedFeatures . put ( component , FeatureResolver . PlainFlag ) ; } else { if ( isLoading ( component ) ) return ; long start = System . currentTimeMillis ( ) ; loading ( component ) ; ComponentResource resource = component . getResource ( ) ; if ( resource == null ) { throw new IOException ( \"The component \" + component + \" without resource\" ) ; } logger . info ( \"Loading {}\" , component ) ; List < FeatureResolver > resolvers = new ArrayList < FeatureResolver > ( featureResolvers . size ( ) ) ; for ( FeatureResolver featureResolver : featureResolvers ) { featureResolver . applyDefaults ( component ) ; if ( featureResolver . hasFeature ( component ) ) { resolvers . add ( featureResolver ) ; } } for ( FeatureResolver featureResolver : resolvers ) { featureResolver . beforeResolve ( component ) ; } for ( FeatureResolver featureResolver : resolvers ) { featureResolver . resolve ( component ) ; } for ( FeatureResolver featureResolver : resolvers ) { featureResolver . afterResolve ( component ) ; } loaded ( component ) ; logger . info ( \"Loaded  {} ({})\" , component , formatDurationHMS ( System . currentTimeMillis ( ) - start ) ) ; } }'", "label": "'\u5b9e\u9645\u5378\u8f7d\u4e00\u4e2a\u7ec4\u4ef6\uff0c\u4e0d\u8003\u8651\u4f9d\u8d56\u60c5\u51b5'"}
{"text": "'public void quickUnload ( Component component ) { if ( component . isAggregating ( ) ) { logger . trace ( \"Remove aggregating component {}\" , component ) ; loadedFeatures . remove ( component ) ; } else if ( component . isPlain ( ) ) { logger . trace ( \"Remove plain component {}\" , component ) ; loadedFeatures . remove ( component ) ; } else { if ( isUnloading ( component ) ) return ; long start = System . currentTimeMillis ( ) ; unloading ( component ) ; logger . info ( \"Unloading {}\" , component ) ; for ( FeatureResolver resolver : reverseResolvers ) { if ( resolver . hasFeature ( component ) ) { resolver . release ( component ) ; } } loadedFeatures . remove ( component ) ; unloaded ( component ) ; logger . info ( \"Unloaded  {} ({})\" , component , formatDurationHMS ( System . currentTimeMillis ( ) - start ) ) ; } }'", "label": "'\u5b9e\u9645\u5378\u8f7d\u4e00\u4e2a\u7ec4\u4ef6'"}
{"text": "'public final void parseVersion ( String version ) { unparsed = version ; int index = version . indexOf ( \"-\" ) ; String part1 ; String part2 = null ; if ( index < 0 ) { part1 = version ; } else { part1 = version . substring ( 0 , index ) ; part2 = version . substring ( index + 1 ) ; } if ( part2 != null ) { try { if ( ( part2 . length ( ) == 1 ) || ! part2 . startsWith ( \"0\" ) ) { buildNumber = Integer . valueOf ( part2 ) ; } else { qualifier = part2 ; } } catch ( NumberFormatException e ) { qualifier = part2 ; } } if ( ! part1 . contains ( \".\" ) && ! part1 . startsWith ( \"0\" ) ) { try { majorVersion = Integer . valueOf ( part1 ) ; } catch ( NumberFormatException e ) { // qualifier is the whole version, including \"-\" qualifier = version ; buildNumber = null ; } } else { boolean fallback = false ; StringTokenizer tok = new StringTokenizer ( part1 , \".\" ) ; try { majorVersion = getNextIntegerToken ( tok ) ; if ( tok . hasMoreTokens ( ) ) { minorVersion = getNextIntegerToken ( tok ) ; } if ( tok . hasMoreTokens ( ) ) { incrementalVersion = getNextIntegerToken ( tok ) ; } if ( tok . hasMoreTokens ( ) ) { fallback = true ; } // string tokenzier won\\'t detect these and ignores them if ( part1 . contains ( \"..\" ) || part1 . startsWith ( \".\" ) || part1 . endsWith ( \".\" ) ) { fallback = true ; } } catch ( NumberFormatException e ) { fallback = true ; } if ( fallback ) { // qualifier is the whole version, including \"-\" qualifier = version ; majorVersion = null ; minorVersion = null ; incrementalVersion = null ; buildNumber = null ; } } }'", "label": "'\u89e3\u6790\u7248\u672c\u5b57\u7b26\u4e32 1 . 0 . 1 - 1 1 . 0 . 1 - snapshot'"}
{"text": "'@ Override public InputStream getInputStream ( String relativePath ) throws IOException { File file = new File ( folder , relativePath ) ; if ( ! file . exists ( ) ) { String msg = String . format ( \"Can\\'t find any file with relative path = `%s` in folder: `%s`\" , relativePath , folder . getAbsolutePath ( ) ) ; throw new IllegalArgumentException ( msg ) ; } return new FileInputStream ( file ) ; }'", "label": "'//////////////////////////////////////////////////////////////////////////////////////////////////////////'"}
{"text": "'public static VersionRange createFromVersionSpec ( String spec ) throws InvalidVersionSpecificationException { if ( spec == null ) { return null ; } List < Restriction > restrictions = new ArrayList < Restriction > ( ) ; String process = spec ; ComponentVersion version = null ; ComponentVersion upperBound = null ; ComponentVersion lowerBound = null ; while ( process . startsWith ( \"[\" ) || process . startsWith ( \"(\" ) ) { int index1 = process . indexOf ( \")\" ) ; int index2 = process . indexOf ( \"]\" ) ; int index = index2 ; if ( index2 < 0 || index1 < index2 ) { if ( index1 >= 0 ) { index = index1 ; } } if ( index < 0 ) { throw new InvalidVersionSpecificationException ( \"Unbounded range: \" + spec ) ; } Restriction restriction = parseRestriction ( process . substring ( 0 , index + 1 ) ) ; if ( lowerBound == null ) { lowerBound = restriction . getLowerBound ( ) ; } if ( upperBound != null ) { if ( restriction . getLowerBound ( ) == null || restriction . getLowerBound ( ) . compareTo ( upperBound ) < 0 ) { throw new InvalidVersionSpecificationException ( \"Ranges overlap: \" + spec ) ; } } restrictions . add ( restriction ) ; upperBound = restriction . getUpperBound ( ) ; process = process . substring ( index + 1 ) . trim ( ) ; if ( process . length ( ) > 0 && process . startsWith ( \",\" ) ) { process = process . substring ( 1 ) . trim ( ) ; } } if ( process . length ( ) > 0 ) { if ( restrictions . size ( ) > 0 ) { throw new InvalidVersionSpecificationException ( \"Only fully-qualified sets allowed in multiple set scenario: \" + spec ) ; } else { version = new ComponentVersion ( process ) ; restrictions . add ( Restriction . EVERYTHING ) ; } } return new VersionRange ( version , restrictions ) ; }'", "label": "'Create a version range from a string representation'"}
{"text": "'public VersionRange restrict ( VersionRange restriction ) throws OverConstrainedVersionException { List < Restriction > r1 = this . restrictions ; List < Restriction > r2 = restriction . restrictions ; List < Restriction > restrictions ; if ( r1 . isEmpty ( ) || r2 . isEmpty ( ) ) { restrictions = Collections . emptyList ( ) ; } else { restrictions = intersection ( r1 , r2 ) ; } ComponentVersion version = null ; if ( restrictions . size ( ) > 0 ) { boolean found = false ; for ( Iterator i = restrictions . iterator ( ) ; i . hasNext ( ) && ! found ; ) { Restriction r = ( Restriction ) i . next ( ) ; if ( recommendedVersion != null && r . containsVersion ( recommendedVersion ) ) { // if we find the original, use that version = recommendedVersion ; found = true ; } else if ( version == null && restriction . getRecommendedVersion ( ) != null && r . containsVersion ( restriction . getRecommendedVersion ( ) ) ) { // use this if we can, but prefer the original if possible version = restriction . getRecommendedVersion ( ) ; } } } // Either the original or the specified version ranges have no restructions else if ( recommendedVersion != null ) { // Use the original recommended version since it exists version = recommendedVersion ; } else if ( restriction . recommendedVersion != null ) { // Use the recommended version from the specified VersionRange since there is no // original recommended version version = restriction . recommendedVersion ; } else { //TODO: the component is null throw new OverConstrainedVersionException ( \"Restricting incompatible version ranges\" , null ) ; } return new VersionRange ( version , restrictions ) ; }'", "label": "'Creates and returns a new <code > VersionRange< / code > that is a restriction of this version range and the specified version range . <p > Note : Precedence is given to the recommended version from this version range over the recommended version from the specified version range . < / p >'"}
{"text": "'public boolean isIndexed ( ) { if ( indexes == null ) { InputStream stream = null ; try { stream = getInputStream ( \"META-INF/INDEX.DETAIL\" ) ; List < String > lines = IOUtils . readLines ( stream ) ; //\u662f\u5426\u5e94\u8be5\u8bb2indexes hash\u5316\uff1f indexes = lines . toArray ( new String [ lines . size ( ) ] ) ; // to be quick searched Arrays . sort ( indexes ) ; } catch ( Exception e ) { indexes = new String [ 0 ] ; } finally { IOUtils . closeQuietly ( stream ) ; } } return indexes . length > 0 ; }'", "label": "'\u5224\u65ad\u672c\u7ec4\u4ef6\u5305\u662f\u5426\u88ab\u7d22\u5f15'"}
{"text": "'public boolean contains ( String path ) { if ( isIndexed ( ) ) { return Arrays . binarySearch ( indexes , path ) >= 0 ; } else { return getLocalResourceUnder ( path ) != null ; } }'", "label": "'\u6839\u636eindex\u4fe1\u606f\uff0c\u5224\u65ad\u672c\u7ec4\u4ef6\u5305\u662f\u5426\u5305\u542b\u7279\u70b9\u6587\u4ef6'"}
{"text": "'@ Override public AppLauncher createLauncher ( Component component ) throws IOException { AppLauncher launcher = new AppLauncher ( component , this ) ; //\u914d\u7f6e class world this . loader = createLoader ( component ) ; this . context = ( ComponentContext ) this . loader ; return launcher ; }'", "label": "'\u6839\u636eMain Resource\u7684\u5143\u4fe1\u606f\uff0c\u521b\u5efa\u76f8\u5e94\u7684Launcher\u5bf9\u8c61'"}
{"text": "'@ Override public Component resolveComponent ( String strDependency ) throws DependencyNotMeetException , InvalidComponentNameException { return repository . resolveComponent ( strDependency ) ; }'", "label": "'------------------------------------------------------------'"}
{"text": "'public void load ( Component component ) throws Exception { long start = System . currentTimeMillis ( ) ; /*\\n        Set<Component> dependedComponents = component.getAllDependedComponents();\\n        ArrayList<Component> depends = new ArrayList<Component>(dependedComponents);\\n        repository.sortComponents(depends);\\n        if( logger.isDebugEnabled() ){\\n            logger.debug(\"Loading components by: \\\\n\\\\t {}\",\\n                        org.apache.commons.lang.StringUtils.join(depends, \"\\\\n\\\\t\"));\\n        }\\n        //\u628a\u81ea\u5df1\u653e\u5728\u6700\u540e\u9762\\n        depends.add(component);\\n        //\u5df2\u7ecf\u6309\u7167\u4f9d\u8d56\u6392\u5e8f\u4e86\\n        for (Component depend : depends) {\\n            loader.quickLoad(depend);\\n        }\\n*/ loader . load ( component ) ; registerWorldAndComponents ( component ) ; banner ( \"Container starts took {}\" , formatDurationHMS ( System . currentTimeMillis ( ) - start ) ) ; publishContainerStartedEvent ( ) ; }'", "label": "'\u81ea\u9876\u5411\u4e0b\u7684\u52a0\u8f7d\u7ec4\u4ef6'"}
{"text": "'public void start ( ) { logger . info ( banner ( \"Scanning jars\" ) ) ; //\u5148\u5bfb\u627e boot/*.jar\uff0c\u5c06\u5176\u9884\u52a0\u8f7d\u4e3acomponent File bootFolder = new File ( home , \"boot\" ) ; try { scanJars ( bootFolder ) ; } catch ( Exception e ) { logger . error ( \"Failed to scan {} dir: {}\" , bootFolder , e . getMessage ( ) ) ; } File appFolder = new File ( home , \"app\" ) ; try { scanJars ( appFolder ) ; } catch ( Exception e ) { logger . error ( \"Failed to scan {} dir for jars: {}\" , appFolder , e . getMessage ( ) ) ; } //\u518d\u5bfb\u627e lib/*.jar\uff0c\u5c06\u5176\u9884\u52a0\u8f7d\u4e3acomponent File libFolder = new File ( home , \"lib\" ) ; try { scanJars ( libFolder ) ; } catch ( Exception e ) { logger . error ( \"Failed to scan {} dir for jars: {}\" , libFolder , e . getMessage ( ) ) ; } File poms = libFolder ; try { //\u800c\u540e\u518d\u904d\u5386lib/poms\u4e0b\u9762\u7684pom.xml\uff0c\u628apackaging = pom \u7684\u7236pom\u9884\u52a0\u8f7d\u8fdb\u6765 scanPoms ( poms ) ; } catch ( Exception e ) { logger . error ( \"Failed to scan {} dir for poms: {}\" , poms , e . getMessage ( ) ) ; } File pomsJar = new File ( libFolder , \"poms.jar\" ) ; if ( pomsJar . exists ( ) ) try { //\u800c\u540e\u518d\u904d\u5386lib/poms\u4e0b\u9762\u7684pom.xml\uff0c\u628apackaging = pom \u7684\u7236pom\u9884\u52a0\u8f7d\u8fdb\u6765 scanPomsJar ( pomsJar ) ; } catch ( Exception e ) { logger . error ( \"Failed to scan {} poms.jar in {}\" , poms , e . getMessage ( ) ) ; } //\u6700\u540e\u8fd8\u8981\u626b\u63cf\u6269\u5c55\u4ed3\u5e93\u76ee\u5f55 repository/*.jar File repositoryFolder = new File ( home , \"repository\" ) ; try { scanJars ( repositoryFolder ) ; } catch ( Exception e ) { logger . error ( \"Failed to scan {} dir for jars: {}\" , repositoryFolder , e . getMessage ( ) ) ; } poms = repositoryFolder ; try { //\u800c\u540e\u518d\u904d\u5386repository/poms\u4e0b\u9762\u7684pom.xml\uff0c\u628a\u4e0d\u5b58\u5728\u5bf9\u5e94jar\u7684 group pom\u9884\u52a0\u8f7d\u8fdb\u6765 scanPoms ( poms ) ; } catch ( Exception e ) { logger . error ( \"Failed to scan {} dir for poms: {}\" , poms , e . getMessage ( ) ) ; } pomsJar = new File ( repositoryFolder , \"poms.jar\" ) ; if ( pomsJar . exists ( ) ) try { //\u800c\u540e\u518d\u904d\u5386lib/poms\u4e0b\u9762\u7684pom.xml\uff0c\u628apackaging = pom \u7684\u7236pom\u9884\u52a0\u8f7d\u8fdb\u6765 scanPomsJar ( pomsJar ) ; } catch ( Exception e ) { logger . error ( \"Failed to scan poms.jar in {}: {}\" , poms , e . getMessage ( ) ) ; } logger . info ( banner ( \"Scanned  jars\" ) ) ; }'", "label": "'\u542f\u52a8\u65f6\u9884\u52a0\u8f7d lib\u76ee\u5f55 lib / poms \u4e0b\u6240\u6709\u7684\u7ec4\u4ef6\u4fe1\u606f'"}
{"text": "'@ Override public Component resolveComponent ( Dependency dependency ) throws InvalidComponentNameException , DependencyNotMeetException { List < Component > meets = resolveComponents ( dependency ) ; if ( meets . isEmpty ( ) ) { Set < Dependency > dependencies = new HashSet < Dependency > ( cache . keySet ( ) ) ; for ( Dependency dep : dependencies ) { if ( dependency . accept ( dep ) ) { Resource resource = cache . get ( dep ) ; meets . add ( resolver . resolveComponent ( dependency , resource ) ) ; //cache.remove(dep); } } } if ( meets . isEmpty ( ) ) { logger . trace ( \"Can\\'t find {} in current repository\" , dependency ) ; throw new DependencyNotMeetException ( dependency ) ; } return meets . get ( 0 ) ; }'", "label": "'------------------------------------------------------------'"}
{"text": "'@ Override public List < Component > resolveComponents ( Dependency dependency ) { logger . trace ( \"Finding   {}\" , dependency ) ; List < Component > meets = new ArrayList < Component > ( ) ; for ( Component component : components ) { if ( dependency . accept ( component ) ) { meets . add ( component ) ; } } if ( meets . isEmpty ( ) ) { logger . trace ( \"Missing   {}\" , dependency ) ; } else { logger . trace ( \"Found     {} {} components\" , dependency , meets . size ( ) ) ; } //\u5bf9\u6240\u6709\u6ee1\u8db3\u7684\u4f9d\u8d56\u8fdb\u884c\u6392\u5e8f Collections . sort ( meets ) ; //\u6392\u5e8f\u7684\u539f\u5219\u662f\u8d8a\u9ad8\u7248\u672c\u8d8a\u597d Collections . reverse ( meets ) ; return meets ; }'", "label": "'\u4ece\u5f53\u524d\u5df2\u7ecf\u89e3\u6790\u7684\u7ec4\u4ef6\u4e2d\u627e\u5230\u7b26\u5408\u4f9d\u8d56\u7684\u7ec4\u4ef6\u5217\u8868\uff0c\u8fd9\u4e0d\u4f1a\u89e6\u53d1\u5b9e\u9645\u89e3\u6790\u52a8\u4f5c'"}
{"text": "'@ Override public void sortComponents ( List < Component > components ) { //\u5c06\u7ec4\u4ef6\u96c6\u5408\u4e4b\u95f4\u7684\u4f9d\u8d56\u5173\u7cfb\u4ee5map\u7684\u5f62\u5f0f\u5c55\u73b0\u51fa\u6765 Map < Component , Set < Component > > dependencies = dependsMap ( components ) ; //\u6e05\u7a7a\u5f85\u6392\u5e8f\u7684components\uff0c\u7528\u4e8e\u505a\u7ed3\u679c\u7684\u5bb9\u5668 components . clear ( ) ; //\u57fa\u4e8e\u4f9d\u8d56\u5173\u7cfb\u8fdb\u884c\u5904\u7406 arrange ( components , dependencies ) ; }'", "label": "'\u57fa\u4e8e\u4f9d\u8d56\u5173\u7cfb\u8fdb\u884c\u6392\u5e8f\uff0c\u6700\u591a\u88ab\u4f9d\u8d56\u7684\u7ec4\u4ef6\u6392\u5728\u6700\u524d\u9762\uff0c\u6ca1\u6709\u88ab\u4f9d\u8d56\u7684\u6392\u5728\u6700\u540e\u9762 <pre > \u8fd9\u4e2a\u6392\u5e8f\u7b97\u6cd5\u4e0d\u80fd\u57fa\u4e8ejava\u7684quick sort\uff0c\u9ed8\u8ba4\u5feb\u901f\u6392\u5e8f\uff0c\u6392\u5230\u524d\u9762\u7684\uff0c\u4e0d\u4f1a\u518d\u548c\u540e\u9762\u7684\u7ee7\u7eed\u6bd4\u8f83'"}
{"text": "'@ Override public void addComponent ( Component component ) { logger . debug ( \"Register  {} into repository\" , component ) ; components . add ( component ) ; }'", "label": "'------------------------------------------------------------'"}
{"text": "'public BoxTransform concatenate ( BoxTransform src ) { if ( src . isEmpty ( ) ) return this ; else if ( this . isEmpty ( ) ) return src ; else { BoxTransform ret = new BoxTransform ( this ) ; ret . transform = new AffineTransform ( transform ) ; ret . transform . concatenate ( src . transform ) ; return ret ; } }'", "label": "'Concatenates another transformation to this transformation .'"}
{"text": "'public Rectangular transformRect ( Rectangular rect ) { if ( transform != null ) { Rectangle src = new Rectangle ( rect . getX1 ( ) , rect . getY1 ( ) , rect . getWidth ( ) , rect . getHeight ( ) ) ; Shape dest = transform . createTransformedShape ( src ) ; Rectangle destr ; if ( dest instanceof Rectangle ) destr = ( Rectangle ) dest ; else destr = dest . getBounds ( ) ; return new Rectangular ( destr ) ; } else return rect ; }'", "label": "'Transforms a rectangle to other rectangle using the given transformation .'"}
{"text": "'protected AffineTransform createTransform ( ElementBox elem ) { if ( elem . isBlock ( ) || elem . isReplaced ( ) ) { CSSDecoder dec = new CSSDecoder ( elem . getVisualContext ( ) ) ; Rectangle bounds = elem . getAbsoluteBorderBounds ( ) ; //decode the origin int ox , oy ; CSSProperty . TransformOrigin origin = elem . getStyle ( ) . getProperty ( \"transform-origin\" ) ; if ( origin == CSSProperty . TransformOrigin . list_values ) { TermList values = elem . getStyle ( ) . getValue ( TermList . class , \"transform-origin\" ) ; ox = dec . getLength ( ( TermLengthOrPercent ) values . get ( 0 ) , false , bounds . width / 2 , 0 , bounds . width ) ; oy = dec . getLength ( ( TermLengthOrPercent ) values . get ( 1 ) , false , bounds . height / 2 , 0 , bounds . height ) ; } else { ox = bounds . width / 2 ; oy = bounds . height / 2 ; } ox += bounds . x ; oy += bounds . y ; //compute the transformation matrix AffineTransform ret = null ; CSSProperty . Transform trans = elem . getStyle ( ) . getProperty ( \"transform\" ) ; if ( trans == CSSProperty . Transform . list_values ) { ret = new AffineTransform ( ) ; ret . translate ( ox , oy ) ; TermList values = elem . getStyle ( ) . getValue ( TermList . class , \"transform\" ) ; for ( Term < ? > term : values ) { if ( term instanceof TermFunction ) { final TermFunction func = ( TermFunction ) term ; final String fname = func . getFunctionName ( ) . toLowerCase ( ) ; if ( fname . equals ( \"rotate\" ) ) { if ( func . size ( ) == 1 && func . get ( 0 ) instanceof TermAngle ) { double theta = dec . getAngle ( ( TermAngle ) func . get ( 0 ) ) ; ret . rotate ( theta ) ; } } else if ( fname . equals ( \"translate\" ) ) { if ( func . size ( ) == 1 && func . get ( 0 ) instanceof TermLengthOrPercent ) { int tx = dec . getLength ( ( TermLengthOrPercent ) func . get ( 0 ) , false , 0 , 0 , bounds . width ) ; ret . translate ( tx , 0.0 ) ; } else if ( func . size ( ) == 2 && func . get ( 0 ) instanceof TermLengthOrPercent && func . get ( 1 ) instanceof TermLengthOrPercent ) { int tx = dec . getLength ( ( TermLengthOrPercent ) func . get ( 0 ) , false , 0 , 0 , bounds . width ) ; int ty = dec . getLength ( ( TermLengthOrPercent ) func . get ( 1 ) , false , 0 , 0 , bounds . height ) ; ret . translate ( tx , ty ) ; } } else if ( fname . equals ( \"translatex\" ) ) { if ( func . size ( ) == 1 && func . get ( 0 ) instanceof TermLengthOrPercent ) { int tx = dec . getLength ( ( TermLengthOrPercent ) func . get ( 0 ) , false , 0 , 0 , bounds . width ) ; ret . translate ( tx , 0.0 ) ; } } else if ( fname . equals ( \"translatey\" ) ) { if ( func . size ( ) == 1 && func . get ( 0 ) instanceof TermLengthOrPercent ) { int ty = dec . getLength ( ( TermLengthOrPercent ) func . get ( 0 ) , false , 0 , 0 , bounds . height ) ; ret . translate ( 0.0 , ty ) ; } } else if ( fname . equals ( \"scale\" ) ) { if ( func . size ( ) == 1 && isNumber ( func . get ( 0 ) ) ) { float sx = getNumber ( func . get ( 0 ) ) ; ret . scale ( sx , sx ) ; } else if ( func . size ( ) == 2 && isNumber ( func . get ( 0 ) ) && isNumber ( func . get ( 1 ) ) ) { float sx = getNumber ( func . get ( 0 ) ) ; float sy = getNumber ( func . get ( 1 ) ) ; ret . scale ( sx , sy ) ; } } else if ( fname . equals ( \"scalex\" ) ) { if ( func . size ( ) == 1 && isNumber ( func . get ( 0 ) ) ) { float sx = getNumber ( func . get ( 0 ) ) ; ret . scale ( sx , 1.0 ) ; } } else if ( fname . equals ( \"scaley\" ) ) { if ( func . size ( ) == 1 && isNumber ( func . get ( 0 ) ) ) { float sy = getNumber ( func . get ( 0 ) ) ; ret . scale ( 1.0 , sy ) ; } } else if ( fname . equals ( \"skew\" ) ) { if ( func . size ( ) == 1 && func . get ( 0 ) instanceof TermAngle ) { double ax = dec . getAngle ( ( TermAngle ) func . get ( 0 ) ) ; ret . shear ( Math . tan ( ax ) , 0.0 ) ; } else if ( func . size ( ) == 2 && func . get ( 0 ) instanceof TermAngle && func . get ( 1 ) instanceof TermAngle ) { double ax = dec . getAngle ( ( TermAngle ) func . get ( 0 ) ) ; double ay = dec . getAngle ( ( TermAngle ) func . get ( 1 ) ) ; ret . shear ( Math . tan ( ax ) , Math . tan ( ay ) ) ; } } else if ( fname . equals ( \"skewx\" ) ) { if ( func . size ( ) == 1 && func . get ( 0 ) instanceof TermAngle ) { double ax = dec . getAngle ( ( TermAngle ) func . get ( 0 ) ) ; ret . shear ( Math . tan ( ax ) , 0.0 ) ; } } else if ( fname . equals ( \"skewy\" ) ) { if ( func . size ( ) == 1 && func . get ( 0 ) instanceof TermAngle ) { double ay = dec . getAngle ( ( TermAngle ) func . get ( 0 ) ) ; ret . shear ( 0.0 , Math . tan ( ay ) ) ; } } else if ( fname . equals ( \"matrix\" ) ) { if ( func . size ( ) == 6 ) { double [ ] vals = new double [ 6 ] ; boolean typesOk = true ; for ( int i = 0 ; i < 6 ; i ++ ) { if ( isNumber ( func . get ( i ) ) ) vals [ i ] = getNumber ( func . get ( i ) ) ; else typesOk = false ; } if ( typesOk ) { ret . concatenate ( new AffineTransform ( vals ) ) ; } } } } } ret . translate ( - ox , - oy ) ; } return ret ; } else return null ; }'", "label": "'========================================================================================================================='"}
{"text": "'public static String banner ( String format , int alignLeft , int total , Object ... args ) { String message = format ; for ( Object arg : args ) { message = message . replaceFirst ( \"\\\\\\\\{\\\\\\\\}\" , arg == null ? \"null\" : arg . toString ( ) ) ; } StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < alignLeft - 1 ; i ++ ) builder . append ( \"*\" ) ; builder . append ( \" \" ) ; if ( total > alignLeft + message . length ( ) ) { builder . append ( message ) ; builder . append ( \" \" ) ; for ( int i = 0 ; i < total - 1 - alignLeft - message . length ( ) ; i ++ ) builder . append ( \"*\" ) ; } else { builder . append ( message . substring ( 0 , total - alignLeft ) ) ; } return builder . toString ( ) ; } /**\\n     * \u6309\u7167\u5de6\u5bf9\u9f509\u4e2a*\u53f7 + 1\u4e2a\u7a7a\u683c\uff0c\u603b\u957f\u5ea6\u4e3a140\u8fdb\u884c\u9ed8\u8ba4banner\u683c\u5f0f\u5316\\n     *\\n     * @param format Banner\u6d88\u606f\u683c\u5f0f\uff0c\u5185\u5d4c {}\u4f5c\u4e3a\u5360\u4f4d\u7b26\uff0c\u8bed\u6cd5\u5e94\u8be5\u4e0eSlf4j\u7684\u4e00\u6837\\n     * @param args   \u65e5\u5fd7\u7684\u53c2\u6570\\n     * @return \u53ef\u4ee5\u8f93\u51fa\u7684\u65e5\u5fd7\\n     */ public static String banner ( String format , Object . . . args ) { return banner ( format , 8 , 100 , args ) ; } } '", "label": "'\u8f93\u51fa\u4e00\u6761Banner\u6d88\u606f'"}
{"text": "'public InputStream getInputStream ( String innerPath ) throws IOException { JarEntry entry = file . getJarEntry ( innerPath ) ; if ( entry == null ) throw new IllegalArgumentException ( \"Can\\'t find \" + innerPath + \" from \" + file . getName ( ) ) ; //class loader\u53ef\u80fd\u8fd8\u6ca1\u6709\u6b63\u786e\u914d\u7f6e\u597d,\u6b64\u65f6\u76f4\u63a5\u4ecefile\u91cc\u9762\u83b7\u53d6 try { return super . getResource ( innerPath ) . getInputStream ( ) ; } catch ( IOException e ) { return file . getInputStream ( entry ) ; } }'", "label": "'//////////////////////////////////////////////////////////////////////////////////////////////////////////'"}
{"text": "'protected AbstractApplicationContext resolveByXml ( Component component , ApplicationContext parent ) { XmlComponentApplicationContext context = new XmlComponentApplicationContext ( component , parent ) ; try { Resource resource = component . getResourceLoader ( ) . getResource ( APP_XML ) ; context . load ( resource ) ; } catch ( Exception e ) { throw new ApplicationConfigurationException ( \"Can\\'t load context from application stream\" , e ) ; } return context ; }'", "label": "'XML\u65b9\u5f0f\u89e3\u6790\u72ec\u7acb\u7684\u5e94\u7528\u7a0b\u5e8f\u5305'"}
{"text": "'protected AbstractApplicationContext resolveByConfig ( Component component , ApplicationContext parent ) { String appConfig = component . getManifestAttribute ( APP_CONFIG ) ; Class appConfigClass ; try { appConfigClass = Class . forName ( appConfig , true , component . getClassLoader ( ) ) ; } catch ( ClassNotFoundException e ) { throw new ApplicationConfigurationException ( \"The app config class: \" + appConfig + \" can\\'t be loaded by the component:\" + component , e ) ; } AnnotationComponentApplicationContext context = new AnnotationComponentApplicationContext ( component , parent ) ; context . register ( appConfigClass ) ; return context ; }'", "label": "'Annotation\u65b9\u5f0f\u89e3\u6790\u72ec\u7acb\u7684\u5e94\u7528\u7a0b\u5e8f\u5305'"}
{"text": "'private Rectangular getMinimalVisualBounds ( ) { final Box box = getBox ( ) ; if ( box instanceof TextBox ) return new RectangularZ ( box . getAbsoluteBounds ( ) . intersection ( box . getClipBlock ( ) . getClippedContentBounds ( ) ) , zoom ) ; else if ( box != null && box . isReplaced ( ) ) return new RectangularZ ( box . getMinimalAbsoluteBounds ( ) . intersection ( box . getClipBlock ( ) . getClippedContentBounds ( ) ) , zoom ) ; else { Rectangular ret = null ; for ( int i = 0 ; i < getChildCount ( ) ; i ++ ) { BoxNode subnode = ( BoxNode ) getChildAt ( i ) ; Box sub = subnode . getBox ( ) ; Rectangular sb = subnode . getVisualBounds ( ) ; if ( sub . isDisplayed ( ) && subnode . isVisible ( ) && sb . getWidth ( ) > 0 && sb . getHeight ( ) > 0 ) { if ( ret == null ) ret = new Rectangular ( sb ) ; else ret . expandToEnclose ( sb ) ; } } //if nothing has been found return an empty rectangle at the top left corner if ( ret == null ) { Rectangle b = box . getAbsoluteBounds ( ) . intersection ( box . getClipBlock ( ) . getClippedContentBounds ( ) ) ; return new RectangularZ ( b . x , b . y , zoom ) ; } else return ret ; } }'", "label": "'Returns the minimal bounds of the box for enclosing all the contained boxes .'"}
{"text": "'public void recomputeVisualBounds ( ) { for ( int i = 0 ; i < getChildCount ( ) ; i ++ )  ( ( BoxNode ) getChildAt ( i ) ) . recomputeVisualBounds ( ) ; visual = computeVisualBounds ( ) ; }'", "label": "'Re - computes the visual bounds of the whole subtree .'"}
{"text": "'public void recomputeBounds ( ) { bounds = new Rectangular ( visual ) ; for ( int i = 0 ; i < getChildCount ( ) ; i ++ ) { BoxNode child = ( BoxNode ) getChildAt ( i ) ; child . recomputeBounds ( ) ; expandToEnclose ( child ) ; } }'", "label": "'Recomputes the total bounds of the whole subtree . The bounds of each box will correspond to its visual bounds . If the child boxes exceed the parent box the parent box bounds will be expanded accordingly .'"}
{"text": "\"private Rectangular computeContentBounds ( ) { Box box = getBox ( ) ; Rectangular ret = null ; if ( box instanceof Viewport ) { ret = new RectangularZ ( ( ( Viewport ) box ) . getClippedBounds ( ) , zoom ) ; } else if ( box instanceof ElementBox ) { ElementBox elem = ( ElementBox ) box ; //at least one border - take the border bounds //TODO: when only one border is present, we shouldn't take the whole border box?  if ( elem . getBorder ( ) . top > 0 || elem . getBorder ( ) . left > 0 || elem . getBorder ( ) . bottom > 0 || elem . getBorder ( ) . right > 0 ) { ret = new RectangularZ ( elem . getAbsoluteBorderBounds ( ) , zoom ) ; } //no border else { ret = new RectangularZ ( elem . getAbsoluteBackgroundBounds ( ) , zoom ) ; } } else //not an element - return the whole box ret = new RectangularZ ( box . getAbsoluteBounds ( ) , zoom ) ; //clip with the clipping bounds if ( box . getClipBlock ( ) != null ) { Rectangular clip = new RectangularZ ( box . getClipBlock ( ) . getClippedContentBounds ( ) , zoom ) ; ret = ret . intersection ( clip ) ; } return ret ; }\"", "label": "'Computes node the content bounds . They correspond to the background bounds however when a border is present it is included in the contents . Moreover the box is clipped by its clipping box .'"}
{"text": "'@ Override public int getTopBorder ( ) { Box box = getBox ( ) ; if ( box instanceof ElementBox ) return ( ( ElementBox ) box ) . getBorder ( ) . top ; else return 0 ; }'", "label": "'Obtains the top border of the box'"}
{"text": "'@ Override public int getBottomBorder ( ) { Box box = getBox ( ) ; if ( box instanceof ElementBox ) return ( ( ElementBox ) box ) . getBorder ( ) . bottom ; else return 0 ; }'", "label": "'Obtains the bottom border of the box'"}
{"text": "'@ Override public int getLeftBorder ( ) { Box box = getBox ( ) ; if ( box instanceof ElementBox ) return ( ( ElementBox ) box ) . getBorder ( ) . left ; else return 0 ; }'", "label": "'Obtains the left border of the box'"}
{"text": "'@ Override public int getRightBorder ( ) { Box box = getBox ( ) ; if ( box instanceof ElementBox ) return ( ( ElementBox ) box ) . getBorder ( ) . right ; else return 0 ; }'", "label": "'Obtains the right border of the box'"}
{"text": "'public String getEfficientColor ( ) { Box box = getBox ( ) ; do { if ( box instanceof ElementBox ) { String color = ( ( ElementBox ) box ) . getStylePropertyValue ( \"color\" ) ; if ( ! color . equals ( \"\" ) ) return color ; } box = box . getParent ( ) ; } while ( box != null ) ; return \"\" ; }'", "label": "'Get the effective text color . If the text color is set it is returned . When the color is not set the parent boxes are considered .'"}
{"text": "'public boolean containsVisibleTextString ( ) { String s = getText ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char ch = s . charAt ( i ) ; if ( ! Character . isSpaceChar ( ch ) ) return true ; } return false ; }'", "label": "'Checks if the box text is visible ( it does not contain spaces only ) . This is not equivalent to isWhitespace () because non - beraking spaces are not whitespace characters but they are not visible .'"}
{"text": "'public boolean visuallyEncloses ( BoxNode childNode ) { int cx1 = childNode . getVisualBounds ( ) . getX1 ( ) ; int cy1 = childNode . getVisualBounds ( ) . getY1 ( ) ; int cx2 = childNode . getVisualBounds ( ) . getX2 ( ) ; int cy2 = childNode . getVisualBounds ( ) . getY2 ( ) ; int px1 = getVisualBounds ( ) . getX1 ( ) ; int py1 = getVisualBounds ( ) . getY1 ( ) ; int px2 = getVisualBounds ( ) . getX2 ( ) ; int py2 = getVisualBounds ( ) . getY2 ( ) ; /*if (this.toString().contains(\"pBody\") && childNode.toString().contains(\"mediawiki\"))\\n            System.out.println(childNode + \" inside of \" + this);\\n        if (childNode.toString().contains(\"www-lupa-cz\") && this.toString().contains(\"[page]\"))\\n            System.out.println(childNode + \" inside of \" + this);*/ /*if (this.getOrder() == 70 && childNode.getOrder() == 74)\\n            System.out.println(\"jo!\");*/ //check how many corners of the child are inside enough (with some overlap) int ccnt = 0 ; if ( cx1 >= px1 + OVERLAP && cx1 <= px2 - OVERLAP && cy1 >= py1 + OVERLAP && cy1 <= py2 - OVERLAP ) ccnt ++ ; //top left if ( cx2 >= px1 + OVERLAP && cx2 <= px2 - OVERLAP && cy1 >= py1 + OVERLAP && cy1 <= py2 - OVERLAP ) ccnt ++ ; //top right if ( cx1 >= px1 + OVERLAP && cx1 <= px2 - OVERLAP && cy2 >= py1 + OVERLAP && cy2 <= py2 - OVERLAP ) ccnt ++ ; //bottom left if ( cx2 >= px1 + OVERLAP && cx2 <= px2 - OVERLAP && cy2 >= py1 + OVERLAP && cy2 <= py2 - OVERLAP ) ccnt ++ ; //bottom right //check how many corners of the child are inside the parent exactly int xcnt = 0 ; if ( cx1 >= px1 && cx1 <= px2 && cy1 >= py1 && cy1 <= py2 ) xcnt ++ ; //top left if ( cx2 >= px1 && cx2 <= px2 && cy1 >= py1 && cy1 <= py2 ) xcnt ++ ; //top right if ( cx1 >= px1 && cx1 <= px2 && cy2 >= py1 && cy2 <= py2 ) xcnt ++ ; //bottom left if ( cx2 >= px1 && cx2 <= px2 && cy2 >= py1 && cy2 <= py2 ) xcnt ++ ; //bottom right //and reverse direction - how many corners of the parent are inside of the child int rxcnt = 0 ; if ( px1 >= cx1 && px1 <= cx2 && py1 >= cy1 && py1 <= cy2 ) rxcnt ++ ; //top left if ( px2 >= cx1 && px2 <= cx2 && py1 >= cy1 && py1 <= cy2 ) rxcnt ++ ; //top right if ( px1 >= cx1 && px1 <= cx2 && py2 >= cy1 && py2 <= cy2 ) rxcnt ++ ; //bottom left if ( px2 >= cx1 && px2 <= cx2 && py2 >= cy1 && py2 <= cy2 ) rxcnt ++ ; //bottom right //shared areas int shared = getVisualBounds ( ) . intersection ( childNode . getVisualBounds ( ) ) . getArea ( ) ; double sharedperc = ( double ) shared / childNode . getBounds ( ) . getArea ( ) ; //no overlap if ( xcnt == 0 ) return false ; //fully overlapping or over a corner - the order decides else if ( ( cx1 == px1 && cy1 == py1 && cx2 == px2 && cy2 == py2 ) //full overlap || ( ccnt == 1 && xcnt <= 1 ) ) //over a corner return this . getOrder ( ) < childNode . getOrder ( ) && sharedperc >= AREAP ; //fully inside else if ( xcnt == 4 ) return true ; //partly inside (at least two corners) else if ( xcnt >= 2 ) { if ( rxcnt == 4 ) //reverse relation - the child contains the parent return false ; else //child partly inside the parent return this . getOrder ( ) < childNode . getOrder ( ) && sharedperc >= AREAP ; } //not inside else return false ; }'", "label": "'Checks if another node is located inside the visual bounds of this box .'"}
{"text": "'public boolean visuallyEncloses1 ( BoxNode childNode ) { int cx1 = childNode . getVisualBounds ( ) . getX1 ( ) ; int cy1 = childNode . getVisualBounds ( ) . getY1 ( ) ; int cx2 = childNode . getVisualBounds ( ) . getX2 ( ) ; int cy2 = childNode . getVisualBounds ( ) . getY2 ( ) ; int px1 = getVisualBounds ( ) . getX1 ( ) ; int py1 = getVisualBounds ( ) . getY1 ( ) ; int px2 = getVisualBounds ( ) . getX2 ( ) ; int py2 = getVisualBounds ( ) . getY2 ( ) ; //check how many corners of the child are inside the parent exactly int xcnt = 0 ; if ( cx1 >= px1 && cx1 <= px2 && cy1 >= py1 && cy1 <= py2 ) xcnt ++ ; //top left if ( cx2 >= px1 && cx2 <= px2 && cy1 >= py1 && cy1 <= py2 ) xcnt ++ ; //top right if ( cx1 >= px1 && cx1 <= px2 && cy2 >= py1 && cy2 <= py2 ) xcnt ++ ; //bottom left if ( cx2 >= px1 && cx2 <= px2 && cy2 >= py1 && cy2 <= py2 ) xcnt ++ ; //bottom right /*if (childNode.toString().contains(\"globalWrapper\") && this.toString().contains(\"mediawiki\"))\\n            System.out.println(\"jo!\");*/ if ( ( cx1 == px1 && cy1 == py1 && cx2 == px2 && cy2 == py2 ) ) //exact overlap return this . getOrder ( ) < childNode . getOrder ( ) ; else return xcnt == 4 ; }'", "label": "'Checks if another node is fully located inside the content bounds of this box .'"}
{"text": "'public void markNodesInside ( Vector < BoxNode > list , boolean full ) { for ( Iterator < BoxNode > it = list . iterator ( ) ; it . hasNext ( ) ; ) { BoxNode node = it . next ( ) ; if ( full ) { if ( node != this && this . contentEncloses ( node ) && ( node . isRootNode ( ) || ! this . contentEncloses ( node . nearestParent ) ) ) { node . nearestParent = this ; } } else { if ( node != this && this . visuallyEncloses ( node ) && ( node . isRootNode ( ) || ! this . visuallyEncloses ( node . nearestParent ) ) ) { node . nearestParent = this ; } } } }'", "label": "'Takes a list of nodes and selects the nodes that are located directly inside of this node s box . The {'"}
{"text": "'public void markChildNodes ( Vector < BoxNode > list ) { final Box thisBox = this . getBox ( ) ; for ( Iterator < BoxNode > it = list . iterator ( ) ; it . hasNext ( ) ; ) { BoxNode node = it . next ( ) ; if ( node != this && node . getBox ( ) . getParent ( ) == thisBox ) node . nearestParent = this ; } }'", "label": "'Takes a list of nodes and selects the nodes whose parent box is identical to this node s box . The {'"}
{"text": "'public void takeChildren ( Vector < BoxNode > list ) { for ( Iterator < BoxNode > it = list . iterator ( ) ; it . hasNext ( ) ; ) { BoxNode node = it . next ( ) ; if ( node . nearestParent . equals ( this ) ) { appendChild ( node ) ; it . remove ( ) ; } } //let the children take their children for ( int i = 0 ; i < getChildCount ( ) ; i ++ )  ( ( BoxNode ) getChildAt ( i ) ) . takeChildren ( list ) ; }'", "label": "'Goes through the parent s children takes all the nodes that are inside of this node and makes them the children of this node . Then recursively calls the children to take their nodes .'"}
{"text": "'@ Override public < T > void register ( Class < T > interfaceClass , T service ) { register ( interfaceClass , service , DEFAULT_HINT ) ; }'", "label": "'//////////////////////////////////////////////////////////////////////'"}
{"text": "'@ Override public < T > T getService ( Class < T > requiredType ) { return getService ( requiredType , ANY_HINT ) ; }'", "label": "'//////////////////////////////////////////////////////////////////////'"}
{"text": "'private < T > Map < String , Object > digMaps ( Class < T > requiredType ) { Map < String , Object > all = new HashMap < String , Object > ( ) ; Set < Class > keys = services . keySet ( ) ; for ( Class serviceClass : keys ) { if ( requiredType . isAssignableFrom ( serviceClass ) ) { //\u5982\u679c\u51fa\u73b0\u5b50\u7c7b\u578b\u4e2d\u7684\u670d\u52a1\u4e0e\u5df2\u6709\u5b58\u5728\u7684\u51b2\u7a81\u4e86\u600e\u4e48\u529e\uff1f Map < String , Object > map = services . get ( serviceClass ) ; for ( String key : map . keySet ( ) ) { Object service = map . get ( key ) ; Object exist = all . get ( key ) ; if ( exist != null ) { int n = 1 ; String newKey ; do { newKey = key + \"#\" + n ++ ; } while ( all . containsKey ( newKey ) ) ; all . put ( newKey , service ) ; } else { all . put ( key , service ) ; } } } } return all ; }'", "label": "'\u627e\u5230\u7b26\u5408\u76f8\u5e94\u7c7b\u578b\u7684\u670d\u52a1map'"}
{"text": "'public void start ( ) throws Exception { try { long start = System . currentTimeMillis ( ) ; //Ensure there is no legacy signal files FileUtils . deleteQuietly ( getSignal ( \"exit\" ) ) ; FileUtils . deleteQuietly ( getSignal ( \"exiting\" ) ) ; logger . info ( banner ( \"Loading components starts from {}\" , this . mainComponent ) ) ; environment . load ( this . mainComponent ) ; logger . info ( banner ( \"Loaded  components starts from {}\" , this . mainComponent ) ) ; if ( ! StringUtils . isEmpty ( System . getProperty ( \"app.port\" ) ) ) exportAsRMI ( ) ; addShutdownHook ( ) ; logger . info ( banner ( \"The {} is started\" , getAppName ( ) ) ) ; logger . info ( banner ( \"System starts took {}\" , formatDurationHMS ( System . currentTimeMillis ( ) - start ) ) ) ; //Thread.currentThread().setDaemon(true); //\u8ba9\u4e3b\u7ebf\u7a0b\u57fa\u4e8eSTDIO\u63a5\u53d7\u4ea4\u4e92\u547d\u4ee4 //\u4ee5\u540e\u5e94\u8be5\u8ba9CLI\u7ec4\u4ef6\u6258\u7ba1\u8fd9\u5757\u5de5\u4f5c //if (!StringUtils.isEmpty(System.getProperty(\"app.port\"))) //    processCommands(); if ( StringUtils . isEmpty ( System . getProperty ( \"app.port\" ) ) ) checkSignalPeriodically ( ) ; } catch ( Exception ex ) { logger . error ( \"Failed to start\" , ex ) ; System . exit ( 1 ) ; } }'", "label": "'\u542f\u52a8\u5f53\u524d\u7684\u7ec4\u4ef6Jar\u5305'"}
{"text": "'public void exit ( ) { if ( exiting ( ) ) { logger . debug ( \"Another thread is shutting down\" ) ; return ; } final long start = System . currentTimeMillis ( ) ; //noinspection finally File exitingSignal = getSignal ( \"exiting\" ) ; try { logger . info ( banner ( \"Unloading the main component {}\" , this . mainComponent ) ) ; FileUtils . touch ( exitingSignal ) ; environment . unload ( this . mainComponent ) ; logger . info ( banner ( \"Unloaded  the main component {}\" , this . mainComponent ) ) ; } catch ( Exception ex ) { logger . error ( ex . getMessage ( ) , ex ) ; } finally { FileUtils . deleteQuietly ( exitingSignal ) ; //\u542f\u52a8\u4e00\u4e2a\u989d\u5916\u7684\u7ebf\u7a0b\u505c\u6b62\u81ea\u8eab new Thread ( \"Stopper\" ) { @ Override public void run ( ) { logger . info ( banner ( \"System stops took {}\" , formatDurationHMS ( System . currentTimeMillis ( ) - start ) ) ) ; System . exit ( 0 ) ; } } . start ( ) ; } }'", "label": "'\u9000\u51fa'"}
{"text": "'private void exportAsRMI ( ) throws Exception { String appHost = System . getProperty ( \"app.host\" ) ; String appPort = System . getProperty ( \"app.port\" ) ; RmiServiceExporter exporter = new RmiServiceExporter ( ) ; exporter . setServiceInterface ( Executable . class ) ; String serviceName = getAppName ( ) + \"Launcher\" ; //exporter.setRegistryHost(appHost); exporter . setRegistryPort ( Integer . valueOf ( appPort ) ) ; exporter . setServiceName ( serviceName ) ; exporter . setService ( this ) ; exporter . afterPropertiesSet ( ) ; String serviceUrl = String . format ( \"rmi://%s:%s/%s\" , appHost , appPort , serviceName ) ; logger . info ( banner ( \"Export Executable Service at {}\" , serviceUrl ) ) ; }'", "label": "'\u5c06\u672c\u5bf9\u8c61\u901a\u8fc7Spring\u7684RMI\u673a\u5236\u66b4\u9732\u51fa\u53bb'"}
{"text": "'protected void process ( String command ) { try { Method method = this . getClass ( ) . getMethod ( command ) ; logger . info ( \"Try to delegate \\'{}\\' to launcher directly.\" , command ) ; method . invoke ( this ) ; logger . info ( \"Invoke \\'{}\\' to launcher directly successfully. \\\\r\\\\n\" , command ) ; } catch ( NoSuchMethodException e ) { logger . warn ( \"unrecognized command: \\'{}\\'\" , command ) ; } catch ( Exception e ) { logger . warn ( \"Failed to execute: \\'{}\\'\" , command ) ; } }'", "label": "'Process user specified command'"}
{"text": "'public static void main ( String [ ] args ) { if ( args . length < 1 ) throw new IllegalArgumentException ( \"You must specify a main dependency\" ) ; //\u8bbe\u5b9a\u7684\u8def\u5f84\u53ef\u80fd\u5305\u62eclib/\u7b49\u76ee\u5f55 String [ ] strings = args [ 0 ] . split ( \"\\\\\\\\|/\" ) ; if ( strings . length > 1 ) { args [ 0 ] = strings [ strings . length - 1 ] ; } try { // When started by Service wrapper, the context class loader is URLClassLoader of wrapper.jar //  but this main class is loaded by the framework jar\\'s ClassLoader(FactoryClassLoader) if ( AppLauncher . class . getClassLoader ( ) != ClassLoader . getSystemClassLoader ( ) ) { //\u8bf4\u660e\u662f\u57fa\u4e8eService Wrapper\u542f\u52a8 Thread . currentThread ( ) . setContextClassLoader ( MainClassLoader . getInstance ( AppLauncher . class . getClassLoader ( ) ) ) ; } else { Thread . currentThread ( ) . setContextClassLoader ( MainClassLoader . getInstance ( ) ) ; } // To register the url handler by current context class loader, instead of system bootstrap class loader URL . setURLStreamHandlerFactory ( ComponentURLStreamHandlerFactory . getFactory ( ) ) ; int exitCode = mainWithExitCode ( args ) ; System . exit ( exitCode ) ; } catch ( LaunchException e ) { System . err . println ( describeException ( e ) ) ; System . exit ( e . getExitCode ( ) ) ; } catch ( Exception e ) { System . err . println ( describeException ( e ) ) ; System . exit ( 100 ) ; } }'", "label": "'<h1 > \u652f\u6301\u7cfb\u7edf\u542f\u52a8\u4e0e\u505c\u6b62< / h1 > <p / > <h2 > \u542f\u52a8\u65b9\u5f0f< / h2 > \u5f00\u53d1\u6a21\u5f0f\u4e0b\uff0c\u901a\u8fc7\u547d\u4ee4\u884c\u4ee5\uff1a <p > <strong > java - classpath jdk / jars ; container / classes ; other / classes dnt . component . container . AppLauncher depended . group . artifact - version< / strong > < / p > \u751f\u4ea7\u6a21\u5f0f\u4e0b\uff0c\u901a\u8fc7\u547d\u4ee4\u884c\u4ee5\uff1a <p > <strong > java - Dapp . home = path / to / home - jar path / to / container . jar depended . group . artifact - version< / strong > < / p > \u7684\u65b9\u5f0f\u542f\u52a8 <p > \u5b9a\u5236\u65b9\u5f0f\uff1a \u7528\u6237\u53ef\u4ee5\u901a\u8fc7 - Dapp . launch . environment = the . launch . env . class \u7684\u65b9\u5f0f\u5b9a\u5236\u542f\u52a8\u903b\u8f91 \u4f46\u8bf7\u6ce8\u610f\u5c06\u76f8\u5e94\u7684Launch Env\u7c7b\u914d\u7f6e\u5728\u4e3bjar\u7684class - path\u4e2d\uff08\u6216\u5f00\u53d1\u73af\u5883\u7684pom\u4f9d\u8d56\u4e0b\uff09 < / p > \u9000\u51fa\u60c5\u51b5 : <ul > <li > 0 : \u6b63\u5e38\u9000\u51fa< / li > <li > 1 : Launch Env\u4e0d\u80fd\u521d\u59cb\u5316< / li > <li > 2 : \u76ee\u6807\u4e3bjar|classes\u672a\u5b9a\u4e49< / li > <li > 3 : \u76ee\u6807\u4e3bjar|classes\u65e0\u6cd5\u521d\u59cb\u5316< / li > <li > 100 : \u672a\u77e5\u5f02\u5e38< / li > <li > \u5176\u4ed6\uff1a\u4e1a\u52a1\u5f02\u5e38\uff0c\u5f85\u660e\u786e< / li > < / ul > <p / > <h2 > \u505c\u6b62\u65b9\u5f0f< / h2 > \u5f00\u53d1\u6a21\u5f0f\u4e0b\uff0c\u901a\u8fc7\u547d\u4ee4\u884c\u4ee5\uff1a <p > <strong > java - classpath jdk / jars ; container / classes ; other / classes dnt . component . container . AppLauncher depended . group . artifact - version -- stop< / strong > < / p > \u751f\u4ea7\u6a21\u5f0f\u4e0b\uff0c\u901a\u8fc7\u547d\u4ee4\u884c\u4ee5\uff1a <p > <strong > java - Dapp . home = path / to / home - jar path / to / container . jar depended . group . artifact - version -- stop< / strong > < / p > \u7684\u65b9\u5f0f\u505c\u6b62'"}
{"text": "'public static int mainWithExitCode ( String [ ] args ) throws Exception { LaunchEnvironment environment = detectEnvironment ( ) ; Component mainComponent = null ; try { logger . debug ( banner ( \"Resolving starts from {}\" , args [ 0 ] ) ) ; mainComponent = environment . resolveComponent ( args [ 0 ] ) ; logger . debug ( banner ( \"Resolved  starts from {}\" , args [ 0 ] ) ) ; AppLauncher launcher = environment . createLauncher ( mainComponent ) ; //\u53bb\u6389\u4e3b\u5165\u53e3\u53c2\u6570\u4e4b\u540e\uff0c\u5c06\u5176\u4f59\u53c2\u6570\u4f20\u5165 String [ ] newArgs = new String [ args . length - 1 ] ; System . arraycopy ( args , 1 , newArgs , 0 , args . length - 1 ) ; //\u542f\u52a8\u7a0b\u5e8f\uff0c\u6839\u636e\u5269\u4f59\u7684 newArgs\uff0c\u53ef\u80fd\u6709\u591a\u79cd\u542f\u52a8\u65b9\u5f0f // \u5305\u62ec: \u6253\u5370\u7ec4\u4ef6\u4f9d\u8d56\u5217\u8868 //      \u542f\u52a8\u7cfb\u7edf(\u5728\u5f53\u524d\u8fdb\u7a0b\u5185\u542f\u52a8\u7cfb\u7edf) //      \u505c\u6b62\u7cfb\u7edf(\u901a\u8fc7\u672c\u673aSocket\u505c\u6b62\u53e6\u5916\u4e00\u4e2a\u5df2\u7ecf\u5728\u8fd0\u884c\u7684\u7cfb\u7edf) environment . execute ( launcher , newArgs ) ; return 0 ; } catch ( ComponentException ex ) { logger . error ( \"{} : {}\" , ex . getPath ( ) , describeException ( ex ) ) ; return - 1 ; } catch ( Throwable ex ) { logger . error ( \"Failed: {}\" , describeException ( ex ) ) ; return - 1 ; } finally { if ( mainComponent != null ) { environment . unload ( mainComponent ) ; } environment . shutdown ( ) ; } }'", "label": "'\u542f\u52a8\u903b\u8f91\uff0c\u6682\u65f6\u8fd8\u6ca1\u6709\u652f\u6301\u505c\u6b62'"}
{"text": "'protected < T > void exports ( Class < T > serviceClass , T service , String hint ) { exporter . exports ( serviceClass , service , hint ) ; }'", "label": "'<h2 > \u66b4\u9732\u67d0\u4e2a\u670d\u52a1< / h2 >'"}
{"text": "'protected < T > void exports ( Class < T > serviceClass , T service ) { exporter . exports ( serviceClass , service ) ; }'", "label": "'<h2 > \u66b4\u9732\u67d0\u4e2a\u670d\u52a1 ( hint = default ) < / h2 >'"}
{"text": "'protected < T > void exports ( Class < T > serviceClass , String hint ) { localExporter ( ) . exports ( serviceClass , hint ) ; }'", "label": "'<h2 > \u66b4\u9732\u67d0\u4e2a\u670d\u52a1< / h2 >'"}
{"text": "'@ Override public String resolveVariable ( String key ) { if ( key . startsWith ( \"project.\" ) ) { return resolveVariable ( key . substring ( \"project.\" . length ( ) ) ) ; } else if ( key . startsWith ( \"pom.\" ) ) { return resolveVariable ( key . substring ( \"pom.\" . length ( ) ) ) ; } else if ( key . startsWith ( \"parent.\" ) ) { if ( parent == null ) return null ; return parent . resolveVariable ( key . substring ( \"parent.\" . length ( ) ) ) ; } else if ( key . startsWith ( \"env.\" ) ) { return System . getenv ( key . substring ( \"env.\" . length ( ) ) ) ; } if ( \"packaging\" . equals ( key ) ) key = \"type\" ; if ( Arrays . binarySearch ( ATTRIBUTE_NAMES , key ) >= 0 ) { try { Field field = getClass ( ) . getDeclaredField ( key ) ; return String . valueOf ( field . get ( this ) ) ; } catch ( Exception e ) { return null ; } } else if ( System . getProperty ( key ) != null ) { return System . getProperty ( key ) ; } else if ( properties != null ) { String property = properties . getProperty ( key ) ; if ( property == null && parent != null ) { property = parent . resolveVariable ( key ) ; } return property ; } else { // delegate parent to resolve it if ( parent == null ) return null ; return parent . resolveVariable ( key ) ; } }'", "label": "'\u5176\u5b9e\u5982\u679c\u4ee5\u5f53\u524dproject\u4e3athis\uff0c\u628aenv system\u4f5c\u4e3a\u4e0a\u4e0b\u6587\uff0c \u901a\u8fc7\u5bf9\u8c61\u56fe\u7684\u65b9\u5f0f\u63d0\u4f9b\u53d8\u91cf\u7d22\u5f15\uff0c\u5b9e\u73b0\u8d77\u6765\u66f4\u597d'"}
{"text": "'public static void inheritParentProperties ( ApplicationContext inheriting , GenericApplicationContext context ) { if ( ! ( inheriting instanceof AbstractApplicationContext ) ) return ; List < BeanFactoryPostProcessor > processors = ( ( AbstractApplicationContext ) inheriting ) . getBeanFactoryPostProcessors ( ) ; for ( BeanFactoryPostProcessor processor : processors ) { if ( processor instanceof PropertyResourceConfigurer ) context . addBeanFactoryPostProcessor ( processor ) ; } }'", "label": "'\u7ee7\u627f\u4e0a\u7ea7\u4e0a\u4e0b\u6587\u4e2d\u7684\u5c5e\u6027\u914d\u7f6e\u5668'"}
{"text": "'public static void initApplicationEventMulticaster ( GenericApplicationContext context ) { ApplicationEventMulticaster multicaster ; ConfigurableListableBeanFactory beanFactory = context . getBeanFactory ( ) ; if ( beanFactory . containsLocalBean ( APPLICATION_EVENT_MULTICASTER_BEAN_NAME ) ) { multicaster = beanFactory . getBean ( APPLICATION_EVENT_MULTICASTER_BEAN_NAME , ApplicationEventMulticaster . class ) ; } else { multicaster = new SmartApplicationEventMulticaster ( beanFactory ) ; beanFactory . registerSingleton ( APPLICATION_EVENT_MULTICASTER_BEAN_NAME , multicaster ) ; } setApplicationEventMulticaster ( context , multicaster ) ; }'", "label": "'\u4fee\u6539\u7279\u5b9a\u4e0a\u4e0b\u6587\u7684Event Multicaster\u7684\u9ed8\u8ba4\u5b9e\u73b0'"}
{"text": "'@ Bean public DataSource dataSource ( ) { // Replace this with your own datasource. return new EmbeddedDatabaseBuilder ( ) . setName ( \"test\" ) . setType ( EmbeddedDatabaseType . HSQL ) . addScript ( \"classpath:hsql-schema.sql\" ) . build ( ) ; }'", "label": "'Use this data source to create an embedded database .'"}
{"text": "'@ Bean public DataSource dataSource_plain ( ) { SimpleDriverDataSource ds = new SimpleDriverDataSource ( ) ; ds . setDriverClass ( null ) ; ds . setUrl ( \"jdbc:oracle:thin:@<server>[:<1521>]:<database_name>\" ) ; ds . setUsername ( \"\" ) ; ds . setPassword ( \"\" ) ; return ds ; }'", "label": "'Use this data source to connect to an existing database .'"}
{"text": "'public void setup ( PlatformConfiguration config , Environment env ) { this . configuration = Preconditions . checkNotNull ( config , \"Configuration cannot be null.\" ) ; this . environment = Preconditions . checkNotNull ( env , \"Environment cannot be null.\" ) ; }'", "label": "'Called when the configuration and environment come into scope .'"}
{"text": "'@ Override public void execute ( ) throws BuildException { if ( null != this . echo ) { out . emitText ( echo ) ; } validateAttributes ( ) ; StatisticProvidingMixinGenerator generator = makeInterfaceItGenerator ( ) ; try { if ( debug ) { out . emitText ( this . toString ( ) ) ; } if ( null == this . targetInterfaceParentName || targetInterfaceParentName . trim ( ) . length ( ) < 1 ) { File wroteFile = generator . generateMixinJavaFile ( getOutputDirectory ( ) , getTargetInterfaceName ( ) , getDelegateClassObject ( ) , getTargetPackageName ( ) , makeArgumentNameSource ( ) ) ; GenerationStatistics stats = generator . getStatistics ( ) ; emitGenerationResult ( wroteFile , stats ) ; } else { final Class < ? > delegateClassObject = this . getDelegateClassObject ( ) ; final Class < ? > superclass = delegateClassObject . getSuperclass ( ) ; if ( null == superclass || java . lang . Object . class . equals ( superclass ) ) { out . emitText ( \"Execution halted without generation. The attribute \\'targetInterfaceParentName\\' should be empty if the delegate class has no superclass other than Object.\" ) ; return ; } MultiFileOutputOptions options = new OptionsForSplittingChildAndParent ( this . targetPackageName , getOutputDirectory ( ) , this . targetInterfaceName , this . targetInterfaceParentName , delegateClassObject ) ; List < File > results = generator . generateMixinJavaFiles ( options , makeArgumentNameSource ( ) , delegateClassObject , superclass ) ; for ( File result : results ) { emitGenerationResult ( result , generator . getStatisticsFor ( result . getName ( ) ) . orElse ( generator . getStatistics ( ) ) ) ; } } } catch ( IOException e ) { handleIOException ( e ) ; } catch ( ClassNotFoundException e ) { handleClassNotFound ( e ) ; } catch ( Throwable t ) { handleUnexpectedError ( t ) ; } }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public static void setCache ( boolean checkCache ) { if ( OpenStates . checkCache != checkCache ) logger . fine ( \"Changing checkCache setting to:\" + checkCache ) ; OpenStates . checkCache = checkCache ; }'", "label": "'Modify whether or not the cache is first checked for files . Note that any JSON read will always be written to the cache .'"}
{"text": "'public < T > T query ( MethodMap methodMap , ArgMap argMap , Class < T > responseType ) throws OpenStatesException { BufferedReader reader = null ; HttpURLConnection conn = null ; String charSet = \"utf-8\" ; try { if ( isCaching ( methodMap , argMap ) ) { File file = getCacheFile ( methodMap , argMap ) ; long fileLength = file . length ( ) ; logger . fine ( \"Length of File in cache:\" + fileLength + \": \" + file . getName ( ) ) ; if ( fileLength == 0L ) { OpenStates . cacheFileFromAPI ( methodMap , argMap , file , responseType ) ; } reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , charSet ) ) ; } else { conn = OpenStates . getConnectionFromAPI ( methodMap , argMap ) ; charSet = getCharset ( conn ) ; // better check it first int rcode = conn . getResponseCode ( ) ; if ( rcode / 100 != 2 ) { String msg = conn . getResponseMessage ( ) ; conn . disconnect ( ) ; throw new OpenStatesException ( rcode , msg , methodMap , argMap , responseType ) ; } reader = new BufferedReader ( new InputStreamReader ( conn . getInputStream ( ) , charSet ) ) ; } return mapper . readValue ( reader , responseType ) ; } catch ( JsonParseException e ) { throw new OpenStatesException ( e , methodMap , argMap , responseType ) ; } catch ( JsonMappingException e ) { throw new OpenStatesException ( e , methodMap , argMap , responseType ) ; } catch ( URISyntaxException e ) { throw new OpenStatesException ( e , methodMap , argMap , responseType ) ; } catch ( IOException e ) { throw new OpenStatesException ( e , methodMap , argMap , responseType ) ; } finally { suspendCache = false ; if ( conn != null ) conn . disconnect ( ) ; if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { throw new OpenStatesException ( e , methodMap , argMap , responseType ) ; } } } }'", "label": "'Handles the actual API calls and caching .'"}
{"text": "'public void register ( Command command ) { Preconditions . checkArgument ( command != null , \"Parameter \\'command\\' must not be [\" + command + \"]\" ) ; register ( command . name ( ) , command ) ; }'", "label": "'Registers the specified command instance into the shell .'"}
{"text": "'public void register ( String name , Command command ) { Preconditions . checkArgument ( name != null && ! name . isEmpty ( ) , \"Parameter \\'name\\' must not be [\" + name + \"]\" ) ; Preconditions . checkArgument ( command != null , \"Parameter \\'command\\' must not be [\" + command + \"]\" ) ; commands . put ( name , command ) ; }'", "label": "'Registers the specified command instance into the shell with the specified name .'"}
{"text": "'public void unregister ( String name ) { Preconditions . checkArgument ( name != null && ! name . isEmpty ( ) , \"Parameter \\'name\\' must not be [\" + name + \"]\" ) ; commands . remove ( name ) ; }'", "label": "'Unregisters the command corresponding to the specified name from the shell .'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public void exec ( String line ) { String [ ] strings = line . split ( \"\\\\\\\\s\" ) ; if ( strings . length == 0 ) { return ; } String cmd = strings [ 0 ] ; if ( strings [ 0 ] == null || strings [ 0 ] . isEmpty ( ) ) { return ; } String [ ] args = { } ; if ( strings . length > 1 ) { args = new String [ strings . length - 1 ] ; System . arraycopy ( strings , 1 , args , 0 , args . length ) ; } Command command = commands . get ( cmd ) ; if ( command == null ) { //$NON-NLS-N$ console . println ( cmd + \": command not found\" ) ; return ; } Usage usage = command . usage ( ) ; Options opts = options . get ( command . name ( ) ) ; if ( opts == null ) { opts = new Options ( ) ; for ( Usage . Option option : usage . options ( ) ) { Option opt = new Option ( option . opt ( ) , option . longOpt ( ) , false , option . description ( ) ) ; opt . setRequired ( option . required ( ) ) ; String arg = option . arg ( ) ; if ( arg == null || arg . isEmpty ( ) ) { opt . setArgs ( 1 ) ; opt . setArgName ( arg ) ; } opts . addOption ( opt ) ; } options . put ( command . name ( ) , opts ) ; } CommandLineParser parser = new GnuParser ( ) ; CommandLine commandLine = null ; try { commandLine = parser . parse ( opts , args ) ; } catch ( ParseException e ) { console ( ) . println ( usage . toString ( ) ) ; return ; } Map < String , String > options = new HashMap <> ( ) ; for ( Option option : commandLine . getOptions ( ) ) { String opt = option . getOpt ( ) ; if ( opt != null && ! opt . isEmpty ( ) ) { options . put ( opt , option . getValue ( ) ) ; } String longOpt = option . getLongOpt ( ) ; if ( longOpt != null && ! longOpt . isEmpty ( ) ) { options . put ( longOpt , option . getValue ( ) ) ; } } Line l = new Line ( cmd , options , commandLine . getArgList ( ) ) ; try { command . run ( l ) ; } catch ( Exception e ) { e . printStackTrace ( new PrintWriter ( console . reader ( ) . getOutput ( ) ) ) ; } }'", "label": "'Executes the specified command line input .'"}
{"text": "'public void start ( ) { repl . set ( true ) ; String line = null ; while ( repl . get ( ) && ( ( line = console . readLine ( ) ) != null ) ) { exec ( line ) ; } }'", "label": "'Runs into the REPL mode .'"}
{"text": "'public Committees searchByState ( String state ) throws OpenStatesException { return api . query ( new MethodMap ( \"committees\" ) , new ArgMap ( \"state\" , state ) , Committees . class ) ; }'", "label": "'Committee Search'"}
{"text": "'public Committees searchByStateChamber ( String state , String chamber ) throws OpenStatesException { return api . query ( new MethodMap ( \"committees\" ) , new ArgMap ( \"state\" , state , \"chamber\" , chamber ) , Committees . class ) ; }'", "label": "'Committee Search This method allows searching by state and chamber . Committee objects returned by this method do not include the list of members by default .'"}
{"text": "'public Committees search ( String state , String chamber , String committee , String subcommittee ) throws OpenStatesException { return api . query ( new MethodMap ( \"committees\" ) , new ArgMap ( \"state\" , state , \"chamber\" , chamber , \"committee\" , committee , \"subcommittee\" , subcommittee ) , Committees . class ) ; }'", "label": "'Committee Search This method allows searching by a number of fields : Committee objects returned by this method do not include the list of members by default .'"}
{"text": "'public Committee detail ( String id ) throws OpenStatesException { return api . query ( new MethodMap ( \"committees\" , id ) , null , Committee . class ) ; }'", "label": "'Committee Detail This method returns the full committee object given a committee id .'"}
{"text": "'private static JMXConnector connect ( String host , String port , String login , String password ) throws IOException { // Set the service URL. JMXServiceURL serviceUrl = new JMXServiceURL ( new StringBuffer ( ) . append ( \"service:jmx:rmi://\" ) . append ( host ) . append ( \":\" ) . append ( port ) . append ( \"/jndi/rmi://\" ) . append ( host ) . append ( \":\" ) . append ( port ) . append ( \"/jmxrmi\" ) . toString ( ) ) ; // Set the service environment. Map < String , Object > serviceEnv = new HashMap < String , Object > ( ) ; serviceEnv . put ( \"jmx.remote.credentials\" , new String [ ] { login , password } ) ; // Connect to the JMX service. return JMXConnectorFactory . connect ( serviceUrl , serviceEnv ) ; }'", "label": "'Connect to the JMX service .'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public static < T > T getMBean ( Class < T > interfaceClass , ObjectName objectName , Properties environment ) throws MBeanException { JMXConnector connector = null ; // Get the JMX environment properties. String host = getProperty ( environment , MBeanUtility . JMX_HOST_KEY ) ; String port = getProperty ( environment , MBeanUtility . JMX_PORT_KEY ) ; String login = getProperty ( environment , MBeanUtility . JMX_LOGIN_KEY ) ; String password = getProperty ( environment , MBeanUtility . JMX_PASSWORD_KEY ) ; try { // Connect to the JMX service. connector = connect ( host , port , login , password ) ; // Connect to the MBean server. MBeanServerConnection mBeanServerConnection = connector . getMBeanServerConnection ( ) ; // Validate the MBean. MBeanUtility . validateMBean ( interfaceClass , objectName , mBeanServerConnection ) ; } catch ( IOException e ) { throw new MBeanException ( e , \"Unable to create the MBean represented by the interface class \" + interfaceClass . getName ( ) + \" and object name \" + objectName . getCanonicalName ( ) + \".\" ) ; } finally { close ( connector ) ; } // Create the MBean. return ( T ) Proxy . newProxyInstance ( interfaceClass . getClassLoader ( ) , new Class [ ] { interfaceClass } , new RemoteMBeanInvocationHandler < T > ( interfaceClass , objectName , host , port , login , password ) ) ; }'", "label": "'Get the MBean represented by the interface class and object name .'"}
{"text": "'private static String getProperty ( Properties properties , String key ) { // Check if the properties do not exist. if ( properties == null || properties . getProperty ( key ) == null ) { throw new IllegalArgumentException ( \"The property \" + key + \" does not exist.\" ) ; } return properties . getProperty ( key ) ; }'", "label": "'Get the property .'"}
{"text": "'@ Override public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { Object result ; JMXConnector connector = null ; try { // Connect to the JMX service. connector = connect ( this . host , this . port , this . login , this . password ) ; // Create the MBean. T object = JMX . newMXBeanProxy ( connector . getMBeanServerConnection ( ) , this . objectName , this . interfaceClass ) ; // Invoke a method on the MBean. result = method . invoke ( object , args ) ; } finally { // Close the JMX service. close ( connector ) ; } return result ; }'", "label": "'Invoke the method and return the result .'"}
{"text": "'@ Override public int complete ( String buffer , int cursor , List < CharSequence > candidates ) { SortedSet < String > commands = new TreeSet <> ( shell . commands ( ) . keySet ( ) ) ; if ( buffer == null ) { candidates . addAll ( commands ) ; } else { for ( String match : commands . tailSet ( buffer ) ) { if ( ! match . startsWith ( buffer ) ) { break ; } candidates . add ( match ) ; } } if ( candidates . size ( ) == 1 ) { candidates . set ( 0 , candidates . get ( 0 ) + \" \" ) ; } return candidates . isEmpty ( ) ? - 1 : 0 ; }'", "label": "'/ * ( non - Javadoc )'"}
{"text": "'public ResourceSelection getSelection ( final String catalog ) { checkReload ( ) ; Set < ResourceSelection > result = set . getSelections ( catalog ) ; return Iterables . getFirst ( result , null ) ; }'", "label": "'\u9009\u62e9\u67d0\u7c7b\u522b\u7684\u9ed8\u8ba4\u540d\u79f0\u8d44\u6e90\u3002'"}
{"text": "'public Set < ResourceSelection > checkDiff ( final ResourceContextConfig target ) { checkReload ( ) ; return set . checkDiff ( target . set ) ; }'", "label": "'\u68c0\u67e5\u672c\u914d\u7f6e\u4e0e\u53e6\u4e00\u914d\u7f6e\u5305\u542b\u8d44\u6e90\u4ed3\u5e93\u9009\u62e9\u7684\u5dee\u5f02\u3002'"}
{"text": "'public Set < String > catalogNames ( ) { Set < String > catalogs = new HashSet <> ( ) ; for ( ResourceSelection selection : selections ) { catalogs . add ( selection . getCatalog ( ) ) ; } return catalogs ; }'", "label": "'\u6c47\u603b\u5f97\u5230\u6240\u6709\u8d44\u6e90\u4ed3\u5e93\u9009\u62e9\u7684\u7c7b\u522b\u4fe1\u606f\u3002'"}
{"text": "'public Set < String > resourceNames ( final String catalog ) { Set < String > resources = new HashSet <> ( ) ; for ( ResourceSelection selection : selections ) { if ( selection . getCatalog ( ) . equals ( catalog ) ) { resources . add ( selection . getName ( ) ) ; } } return resources ; }'", "label": "'\u6839\u636e\u7c7b\u522b\u540d\u79f0\u83b7\u53d6\u96c6\u5408\u4e2d\u5305\u542b\u7684\u540c\u4e00\u7c7b\u522b\u7684\u8d44\u6e90\u540d\u79f0\u3002'"}
{"text": "'public Set < ResourceSelection > getSelections ( final String catalog ) { return getSelections ( catalog , ResourceSelection . generateName ( catalog ) ) ; }'", "label": "'\u9009\u62e9\u67d0\u7c7b\u522b\u7684\u9ed8\u8ba4\u540d\u79f0\u8d44\u6e90\u3002'"}
{"text": "'public Set < ResourceSelection > getSelections ( final String catalog , final String name ) { Set < ResourceSelection > result = new HashSet <> ( ) ; for ( ResourceSelection selection : selections ) { if ( selection . getCatalog ( ) . equals ( catalog ) && selection . getName ( ) . equals ( name ) ) { result . add ( selection ) ; } } return result ; }'", "label": "'\u9009\u62e9\u67d0\u7c7b\u522b\u7684\u7279\u5b9a\u540d\u79f0\u8d44\u6e90\u3002'"}
{"text": "'public Set < ResourceSelection > checkDiff ( final ResourceSelectionSet target ) { // \u66f4\u65b0\u4fe1\u606f\u5217\u8868 Set < ResourceSelection > diffs = new HashSet <> ( ) ; // \u8bfb\u53d6\u6e90\u7248\u672c Set < ResourceSelection > sourceEntrys = selections ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( \"\u6e90\u7248\u672c\uff1a{}\", source E trys);   } // \u8bfb\u53d6\u76ee\u6807\u7248\u672c Set < ResourceSelection > targetEntrys = target . selections ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( \"\u76ee\u6807\u7248\u672c\uff1a{}\", targetEn t ys);   } // \u5904\u7406\u662f\u5426\u66f4\u65b0 diffs . addAll ( targetEntrys ) ; diffs . removeAll ( sourceEntrys ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( \"\u66f4\u65b0\u7ed3\u679c\uff1a{}\", diffs);     } return diffs ; }'", "label": "'\u68c0\u67e5\u672c\u96c6\u5408\u4e0e\u53e6\u4e00\u96c6\u5408\u5305\u542b\u8d44\u6e90\u4ed3\u5e93\u9009\u62e9\u7684\u5dee\u5f02\u3002'"}
{"text": "'public static CodedMessageDefinition getDefinition ( final String code ) { Map < Locale , CodedMessageDefinition > definitions = DEFINITIONS . get ( code ) ; if ( definitions == null ) { return null ; } CodedMessageDefinition definition = definitions . get ( Locales . current ( ) ) ; if ( definition == null ) { definition = definitions . get ( Locale . ROOT ) ; } return definition ; }'", "label": "'\u83b7\u53d6\u7f16\u7801\u6d88\u606f\u5b9a\u4e49\u3002'"}
{"text": "'public static void define ( final CodedMessageDefinition definition ) { String code = definition . getCode ( ) ; Locale locale = definition . getLocale ( ) ; Map < Locale , CodedMessageDefinition > definitions = DEFINITIONS . get ( code ) ; if ( definitions == null ) { definitions = new HashMap <> ( ) ; DEFINITIONS . put ( code , definitions ) ; } definitions . put ( locale , definition ) ; }'", "label": "'\u5b9a\u4e49\u7f16\u7801\u6d88\u606f\u3002'"}
{"text": "'public static FilterBinder forInstance ( Binder binder , Filter filter ) { Preconditions . checkNotNull ( filter , \"Filter cannot be null.\" ) ; return new FilterBinder ( binder , filter . getClass ( ) , new FilterProvider ( filter ) ) ; }'", "label": "'Builds a Filter Binder using a Filter instance rather than a class . It will use a { @link io . graceland . filter . FilterProvider } as the provider .'"}
{"text": "'public static FilterBinder forClass ( Binder binder , Class < ? extends Filter > filterClass ) { Preconditions . checkNotNull ( binder , \"Binder cannot be null.\" ) ; Preconditions . checkNotNull ( filterClass , \"Filter Class cannot be null.\" ) ; return new FilterBinder ( binder , filterClass , binder . getProvider ( filterClass ) ) ; }'", "label": "'Builds a Filter Binder using a Filter Class rather than an instance . It will use the { @link com . google . inject . Binder } to create a { @link com . google . inject . Provider } used in the Filter Binder .'"}
{"text": "'public FilterBinder addPattern ( FilterPattern filterPattern ) { Preconditions . checkNotNull ( filterPattern , \"Filter Pattern cannot be null.\" ) ; filterPatterns . add ( filterPattern ) ; return this ; }'", "label": "'Adds a { @link io . graceland . filter . FilterPattern } to the final filter . You can add more than one with the binder .'"}
{"text": "'public void bind ( ) { FilterSpec fitlerSpec = new FilterSpec ( filterProvider , priority , name . or ( filterClass . getSimpleName ( ) ) , buildPatterns ( ) ) ; Multibinder . newSetBinder ( binder , FilterSpec . class , Graceland . class ) . addBinding ( ) . toInstance ( fitlerSpec ) ; }'", "label": "'Builds a {'"}
{"text": "'protected void bindJerseyComponent ( Object resource ) { Preconditions . checkNotNull ( resource , \"Resource cannot be null.\" ) ; buildBinders ( ) ; jerseyBinder . addBinding ( ) . toInstance ( resource ) ; }'", "label": "'Add a resource to the graceland platform . <p / > There are two ways of adding a resource : <ul > <li > <strong > Instance< / strong > - bind an instance of a resource directly . < / li > <li > <strong > Class< / strong > - bind a class of a resource and it will be built by the { @link com . google . inject . Injector } . < / li > < / ul >'"}
{"text": "'public Resource getResource ( final ResourceSelection selection ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( \"\u5b9a\u4f4d\u8d44\u6e90\uff1a{}\", selectio n ;   } String catalog = selection . getCatalog ( ) ; String version = selection . getVersion ( ) ; String name = selection . getName ( ) ; String path = catalog ; if ( StringUtils . isNotBlank ( version ) ) { path = path + \\' \\' + version ; } while ( true ) { try { Resource resource = root . createRelative ( path + \\' \\' + name ) ; if ( resource . exists ( ) ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( \"\u5b9a\u4f4d\u8d44\u6e90\u5230\uff1a{}\", resource);     } return resource ; } } catch ( IOException e ) { LOG . warn ( root . toString ( ) + \\' \\' + path + \\' \\' + name + \" \u89e3\u6790\u5931\u8d25\", e);     return null ; } if ( path . length ( ) <= catalog . length ( ) ) { break ; } path = path . substring ( 0 , path . lastIndexOf ( \\' \\' ) ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( \"\u672a\u627e\u5230\u8d44\u6e90\uff1a{}\", selection) ;    } return null ; }'", "label": "'\u5b9a\u4f4d\u8d44\u6e90\u3002'"}
{"text": "'public boolean hasLevel ( final CodedMessageLevel targetLevel ) { if ( level == targetLevel ) { return true ; } for ( CodedMessage message : messages ) { if ( message . hasLevel ( targetLevel ) ) { return true ; } } return false ; }'", "label": "'\u5224\u65ad\u6d88\u606f\u4e2d\u662f\u5426\u5305\u542b\u6307\u5b9a\u7ea7\u522b\u7684\u6d88\u606f\u3002'"}
{"text": "\"private void format ( final StringBuilder sb ) { CodedMessageDefinition def = CodedMessageDefinition . getDefinition ( code ) ; if ( def == null ) { sb . append ( MessageFormats . formatFallback ( code , arguments . toArray ( ) ) ) ; } else { sb . append ( MessageFormats . format ( def . getTemplate ( ) , def . getLocale ( ) , arguments . toArray ( ) ) ) ; } for ( String unformattedArgument : unformattedArguments ) { sb . append ( ' ; \\r  sb . append ( unformattedArgument ) ; } }\"", "label": "'\u5c06\u6d88\u606f\u683c\u5f0f\u5316\u4e3a\u5b57\u7b26\u4e32\u3002'"}
{"text": "'public String formatAll ( ) { StringBuilder sb = new StringBuilder ( ) ; formatAll ( sb , 0 ) ; sb . deleteCharAt ( sb . length ( ) - 1 ) ; return sb . toString ( ) ; }'", "label": "'\u5c06\u6240\u6709\u6d88\u606f\u683c\u5f0f\u5316\u4e3a\u5b57\u7b26\u4e32\u3002'"}
{"text": "\"private void formatAll ( final StringBuilder sb , final int depth ) { for ( int i = 0 ; i < depth ; i ++ ) { sb . append ( ' ' ) ; } format ( sb ) ; sb . append ( ' ' ) ; for ( CodedMessage message : messages ) { message . formatAll ( sb , depth + 1 ) ; } }\"", "label": "'\u5c06\u6240\u6709\u6d88\u606f\u683c\u5f0f\u5316\u4e3a\u5b57\u7b26\u4e32\u3002'"}
{"text": "'public Districts searchByState ( String state ) throws OpenStatesException { return api . query ( new MethodMap ( \"districts\" , state ) , null , Districts . class ) ; }'", "label": "'List districts for state .'"}
{"text": "'public Districts search ( String state , String chamber ) throws OpenStatesException { return api . query ( new MethodMap ( \"districts\" , state , chamber ) , null , Districts . class ) ; }'", "label": "'List districts for state and chamber .'"}
{"text": "'public District boundaryLookup ( String boundary_id ) throws OpenStatesException { return api . query ( new MethodMap ( \"districts\" , \"boundary\" , boundary_id ) , null , District . class ) ; }'", "label": "'Get geographic boundary for a district .'"}
{"text": "'public Metadata state ( String state ) throws OpenStatesException { return api . query ( new MethodMap ( \"metadata\" , state ) , null , Metadata . class ) ; }'", "label": "'Get detailed metadata for a particular state .'"}
{"text": "'private static < T > T createObject ( Class < T > interfaceClass ) { ServiceLoader < T > loader = ServiceLoader . load ( interfaceClass ) ; T object = null ; // Loop through the services. for ( T loadedObject : loader ) { // Check if a factory has not been found. if ( object == null ) { // Set the factory. object = loadedObject ; } else { throw new IllegalArgumentException ( \"More than one MBean object found.\" ) ; } } // Check if a object has not been found. if ( object == null ) { throw new IllegalArgumentException ( \"No MBean object found.\" ) ; } return object ; }'", "label": "'Create the MBean object .'"}
{"text": "'public static < T > T getMBean ( Class < T > interfaceClass ) throws MBeanException { return getMBean ( interfaceClass , getObjectName ( interfaceClass ) ) ; }'", "label": "'Get the MBean represented by the interface class . The object name is set to the object name returned by the getObjectName ( Class interfaceClass ) method .'"}
{"text": "'public static < T > T getMBean ( Class < T > interfaceClass , ObjectName objectName ) throws MBeanException { // Get the MBean server. MBeanServer mBeanServer = ManagementFactory . getPlatformMBeanServer ( ) ; validateMBean ( interfaceClass , objectName , mBeanServer ) ; // Create the MBean. return JMX . newMXBeanProxy ( mBeanServer , objectName , interfaceClass ) ; }'", "label": "'Get the MBean represented by the interface class and object name .'"}
{"text": "'public static < T > T getMBean ( Class < T > interfaceClass , Properties environment ) throws MBeanException { return getMBean ( interfaceClass , getObjectName ( interfaceClass ) , environment ) ; }'", "label": "'Get the MBean represented by the interface class . The object name is set to the object name returned by the getObjectName ( Class interfaceClass ) method .'"}
{"text": "'public static < T > T getMBean ( Class < T > interfaceClass , ObjectName objectName , Properties environment ) throws MBeanException { return RemoteMBeanInvocationHandler . getMBean ( interfaceClass , objectName , environment ) ; }'", "label": "'Get the MBean represented by the interface class and object name .'"}
{"text": "'public static ObjectName getObjectName ( Class interfaceClass , String key , String value ) { // Set the table. Hashtable < String , String > table = new Hashtable < String , String > ( ) ; table . put ( key , value ) ; return getObjectName ( interfaceClass , table ) ; }'", "label": "'Get the MBean object name .'"}
{"text": "'public static ObjectName getObjectName ( Class interfaceClass , Hashtable < String , String > table ) { // Check if the interface class is valid. if ( interfaceClass == null ) { throw new IllegalArgumentException ( \"The interface class is invalid.\" ) ; } ObjectName objectName ; try { // Check if the table is null. if ( table == null ) { // Initialize the table. table = new Hashtable < String , String > ( ) ; } // Add the \"type\" to the table. table . put ( \"type\" , interfaceClass . getSimpleName ( ) ) ; // Get the MBean object name. objectName = ObjectName . getInstance ( interfaceClass . getPackage ( ) . getName ( ) , table ) ; } catch ( MalformedObjectNameException e ) { throw new IllegalArgumentException ( \"Unable to get the MBean object name for \" + interfaceClass . getName ( ) + \".\" , e ) ; } return objectName ; }'", "label": "'Get the MBean object name .'"}
{"text": "'public static < T > ObjectName register ( Class < T > interfaceClass ) throws MBeanException { return register ( interfaceClass , getObjectName ( interfaceClass ) ) ; }'", "label": "'Register the MBean represented by the interface class . The MBean object name is set to the object name returned by the getObjectName ( Class interfaceClass ) method .'"}
{"text": "'public static < T > ObjectName register ( Class < T > interfaceClass , String key , String value ) throws MBeanException { return register ( interfaceClass , getObjectName ( interfaceClass , key , value ) ) ; }'", "label": "'Register the MBean represented by the interface class . The MBean object name is set to the object name returned by the getObjectName ( Class interfaceClass String key String value ) method .'"}
{"text": "'public static < T > ObjectName register ( Class < T > interfaceClass , Hashtable < String , String > table ) throws MBeanException { return register ( interfaceClass , getObjectName ( interfaceClass , table ) ) ; }'", "label": "'Register the MBean represented by the interface class . The MBean object name is set to the object name returned by the getObjectName ( Class interfaceClass Hashtable<String String > table ) method .'"}
{"text": "'public static < T > ObjectName register ( Class < T > interfaceClass , ObjectName objectName ) throws MBeanException { // Check if the interface class is valid. if ( interfaceClass == null ) { throw new IllegalArgumentException ( \"The interface class is invalid.\" ) ; } try { // Get the MBean server. MBeanServer mBeanServer = ManagementFactory . getPlatformMBeanServer ( ) ; // Check if the MBean is not registered with the MBean server. if ( ! mBeanServer . isRegistered ( objectName ) ) { // Register the MBean with the MBean server. ObjectInstance objectInstance = mBeanServer . registerMBean ( createObject ( interfaceClass ) , objectName ) ; // Get the object name for the registered MBean. objectName = objectInstance . getObjectName ( ) ; } } catch ( Exception e ) { throw new MBeanException ( e , \"Unable to register the MBean.\" ) ; } return objectName ; }'", "label": "'Register the MBean represented by the interface class .'"}
{"text": "'public static void unregister ( ObjectName objectName ) throws MBeanException { try { // Get the MBean server. MBeanServer mBeanServer = ManagementFactory . getPlatformMBeanServer ( ) ; // Check if the MBean is registered with the MBean server. if ( mBeanServer . isRegistered ( objectName ) ) { // Unregister the MBean with the MBean server. mBeanServer . unregisterMBean ( objectName ) ; } } catch ( Exception e ) { throw new MBeanException ( e , \"Unable to unregister the MBean \" + objectName . getCanonicalName ( ) + \".\" ) ; } }'", "label": "'Unregister the MBean represented by the object name .'"}
{"text": "'protected static void validateMBean ( Class interfaceClass , ObjectName objectName , MBeanServerConnection mBeanServerConnection ) throws MBeanException { try { // Check if the interface class is null. if ( interfaceClass == null ) { throw new IllegalArgumentException ( \"The interface class is null.\" ) ; } // Check if the interface class is not a MXBean interface. if ( ! JMX . isMXBeanInterface ( interfaceClass ) ) { throw new IllegalArgumentException ( \"The interface class \" + interfaceClass . getName ( ) + \" is not a MXBean interface.\" ) ; } // Check if the object name is not registered. if ( ! mBeanServerConnection . isRegistered ( objectName ) ) { throw new IllegalArgumentException ( \"The object name \" + objectName . getCanonicalName ( ) + \" is not registered.\" ) ; } // Check if the object name is not an instance of the interface class. if ( ! mBeanServerConnection . isInstanceOf ( objectName , interfaceClass . getName ( ) ) ) { throw new IllegalArgumentException ( \"The object name \" + objectName . getCanonicalName ( ) + \" is not an instance of the interface class \" + interfaceClass . getName ( ) + \".\" ) ; } } catch ( InstanceNotFoundException e ) { throw new IllegalArgumentException ( \"The object name \" + objectName . getCanonicalName ( ) + \" is not found.\" ) ; } catch ( IOException e ) { throw new MBeanException ( e , \"Unable to validate the MBean represented by the interface class \" + interfaceClass . getName ( ) + \" and object name \" + objectName . getCanonicalName ( ) + \".\" ) ; } }'", "label": "'Validate the MBean represented by the interface class and object name .'"}
{"text": "'@ Override public void initialize ( Bootstrap < PlatformConfiguration > bootstrap ) { for ( Initializer initializer : wrapper . getInitializers ( ) ) { initializer . initialize ( bootstrap ) ; LOGGER . debug ( \"Registered Initializer: {}\" , initializer . getClass ( ) . getCanonicalName ( ) ) ; } for ( Bundle bundle : wrapper . getBundles ( ) ) { bootstrap . addBundle ( bundle ) ; LOGGER . debug ( \"Registered Bundle: {}\" , bundle . getClass ( ) . getCanonicalName ( ) ) ; } for ( Command command : wrapper . getCommands ( ) ) { bootstrap . addCommand ( command ) ; LOGGER . debug ( \"Registered Command: {}\" , command . getClass ( ) . getCanonicalName ( ) ) ; } }'", "label": "'Ran when the Dropwizard service initializes . This method is responsible for setting up the { @link io . dropwizard . Bundle } s and { @link io . dropwizard . cli . Command } s .'"}
{"text": "'@ Override public void run ( PlatformConfiguration configuration , Environment environment ) throws Exception { dropwizardModule . setup ( configuration , environment ) ; for ( Configurator configurator : wrapper . getConfigurators ( ) ) { configurator . configure ( configuration , environment ) ; LOGGER . debug ( \"Registered Configurator: {}\" , configurator . getClass ( ) . getCanonicalName ( ) ) ; } for ( Object jerseyComponent : wrapper . getJerseyComponents ( ) ) { environment . jersey ( ) . register ( jerseyComponent ) ; LOGGER . debug ( \"Registered Jersey Component: {}\" , jerseyComponent . getClass ( ) . getCanonicalName ( ) ) ; } for ( Managed managed : wrapper . getManaged ( ) ) { environment . lifecycle ( ) . manage ( managed ) ; LOGGER . debug ( \"Registered Managed Object: {}\" , managed . getClass ( ) . getCanonicalName ( ) ) ; } for ( HealthCheck healthCheck : wrapper . getHealthChecks ( ) ) { environment . healthChecks ( ) . register ( healthCheck . toString ( ) , healthCheck ) ; LOGGER . debug ( \"Registered Health Check: {}\" , healthCheck . getClass ( ) . getCanonicalName ( ) ) ; } for ( Task task : wrapper . getTasks ( ) ) { environment . admin ( ) . addTask ( task ) ; LOGGER . debug ( \"Registered Task: {}\" , task . getClass ( ) . getCanonicalName ( ) ) ; } for ( FilterSpec filterSpec : wrapper . getFilterSpecs ( ) ) { registerFilterSpec ( environment , filterSpec ) ; LOGGER . debug ( \"Registered Filter {}: {}\" , filterSpec . getName ( ) , filterSpec . getFilter ( ) . getClass ( ) . getCanonicalName ( ) ) ; } }'", "label": "'Ran when the Dropwizard service starts up . This method is responsible for setting up the { @link io . dropwizard . setup . Environment } using the bindings from the loaded { @link io . graceland . plugin . Plugin } s .'"}
{"text": "'@ Override public String get ( ) { try ( final Timer . Context context = timer . time ( ) ) { final String s = randomUUID ( ) . toString ( ) ; if ( length == 0 || count == 0 ) { return s ; } final StringJoiner joiner = new StringJoiner ( \"/\" , \"\" , \"/\" + s ) ; IntStream . rangeClosed ( 0 , count - 1 ) . forEach ( x -> joiner . add ( s . substring ( x * length , ( x + 1 ) * length ) ) ) ; return joiner . toString ( ) ; } }'", "label": "'Mint a unique identifier as a UUID'"}
{"text": "'public static void loadDefinitions ( final ResourcePatternResolver resolver , final String locationPattern ) { try { Resource [ ] resources = resolver . getResources ( locationPattern ) ; for ( Resource resource : resources ) { String filename = resource . getFilename ( ) ; Locale locale = Locale . ROOT ; String filenamePrefix = \"codedMessageDefinition_\" ; if ( filename . startsWith ( filenamePrefix ) ) { locale = LocaleUtils . toLocale ( filename . substring ( filenamePrefix . length ( ) , filename . lastIndexOf ( \".xml\" ) ) ) ; } loadDefinitions ( locale , resource ) ; } } catch ( IOException e ) { LOG . error ( \"\u52a0\u8f7d\u5931\u8d25\", e);\\r     } }'", "label": "'\u52a0\u8f7d\u6240\u6709\u5339\u914d\u7684\u914d\u7f6e\u6587\u4ef6\u3002'"}
{"text": "'public static void loadDefinitions ( final Locale locale , final Resource resource ) { try { XMLConfiguration config = new XMLConfiguration ( ) ; config . setDelimiterParsingDisabled ( true ) ; config . load ( resource . getInputStream ( ) ) ; for ( HierarchicalConfiguration definitionConfig : config . configurationsAt ( \"definition\" ) ) { String code = definitionConfig . getString ( \"[@code]\" ) ; String template = definitionConfig . getString ( \"[@template]\" ) ; CodedMessageDefinition . define ( new CodedMessageDefinition ( code , locale , template ) ) ; } } catch ( IOException e ) { LOG . error ( \"\u52a0\u8f7d\u5931\u8d25\", e);\\r     } catch ( ConfigurationException e ) { LOG . error ( \"\u52a0\u8f7d\u5931\u8d25\", e);\\r     } }'", "label": "'\u4ece\u7279\u5b9a\u4f4d\u7f6e\u52a0\u8f7d\u914d\u7f6e\u6587\u4ef6\u3002'"}
{"text": "'private < T > Set < T > getSetSafely ( Key < Set < T > > key ) { try { return injector . getInstance ( key ) ; } catch ( ConfigurationException e ) { LOGGER . debug ( \"No bindings found for key: {}\" , key , e ) ; return ImmutableSet . of ( ) ; } }'", "label": "'====================='"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public ImmutableSet < Object > getJerseyComponents ( ) { Set < Object > components = getSetSafely ( Keys . JerseyComponents ) ; ImmutableSet . Builder < Object > builder = ImmutableSet . builder ( ) ; for ( Object classOrInstance : components ) { if ( classOrInstance instanceof Class ) { Object instance = injector . getInstance ( ( Class < Object > ) classOrInstance ) ; builder . add ( instance ) ; } else { builder . add ( classOrInstance ) ; } } return builder . build ( ) ; }'", "label": "'Returns a Set of Jersey components including Providers and Resources . These objects are usually fed into the { @link io . dropwizard . jersey . setup . JerseyEnvironment#register ( Class ) } method .'"}
{"text": "'public void addValue ( String value , boolean isDefault ) { p ( \"Adding \" + ( isDefault ? \"default \" : \"\" ) + \"value:\" + value + \" to parameter:\" + m_field . getName ( ) ) ; String name = m_wrappedParameter . names ( ) [ 0 ] ; if ( m_assigned && ! isMultiOption ( ) ) { throw new ParameterException ( \"Can only specify option \" + name + \" once.\" ) ; } validateParameter ( name , value ) ; Class < ? > type = m_field . getType ( ) ; Object convertedValue = m_jCommander . convertValue ( this , value ) ; boolean isCollection = Collection . class . isAssignableFrom ( type ) ; try { if ( isCollection ) { @ SuppressWarnings ( \"unchecked\" ) Collection < Object > l = ( Collection < Object > ) m_field . get ( m_object ) ; if ( l == null || fieldIsSetForTheFirstTime ( isDefault ) ) { l = newCollection ( type ) ; m_field . set ( m_object , l ) ; } if ( convertedValue instanceof Collection ) { l . addAll ( ( Collection ) convertedValue ) ; } else { // if (isMainParameter || m_parameterAnnotation.arity() > 1) { l . add ( convertedValue ) ; //        } else { //          l. } } else { m_wrappedParameter . addValue ( m_field , m_object , convertedValue ) ; } if ( ! isDefault ) m_assigned = true ; } catch ( IllegalAccessException ex ) { ex . printStackTrace ( ) ; } }'", "label": "'Add the specified value to the field . First validate the value if a validator was specified . Then look up any field converter then any type converter and if we can t find any throw an exception .'"}
{"text": "'public Set < T > resolve ( Matcher < T > matcher ) throws IOException { Set < T > classes = new HashSet < T > ( ) ; for ( URL url : paths ) { if ( url . toString ( ) . endsWith ( \".jar\" ) ) { //\\t\\t\\t\\tSystem.out.println(url); JarFile jarFile = new JarFile ( URLDecoder . decode ( url . getPath ( ) , \"UTF-8\" ) ) ; Manifest manifest = jarFile . getManifest ( ) ; if ( manifest != null ) { //\\t\\t\\t\\t\\tSystem.out.println(manifest); Attributes mainAttributes = manifest . getMainAttributes ( ) ; if ( mainAttributes != null ) { //\\t\\t\\t\\t\\t\\tSystem.out.println(mainAttributes); String classpath = mainAttributes . getValue ( Name . CLASS_PATH ) ; if ( classpath != null ) { //\\t\\t\\t\\t\\t\\t\\tSystem.out.println(classpath); StringTokenizer stringTokenizer = new StringTokenizer ( classpath ) ; while ( stringTokenizer . hasMoreTokens ( ) ) { String token = stringTokenizer . nextToken ( ) ; URL entry = new URL ( url , token ) ; if ( entry . toString ( ) . endsWith ( \"/\" ) ) { //\\t\\t\\t\\t\\t\\t\\t\\t\\tSystem.out.println(entry); classes . addAll ( getMatchedClasses ( matcher , new File ( URLDecoder . decode ( entry . getPath ( ) , \"UTF-8\" ) ) ) ) ; } else { //\\t\\t\\t\\t\\t\\t\\t\\t\\tSystem.out.println(entry); classes . addAll ( getMatchedClasses ( matcher , new JarFile ( URLDecoder . decode ( entry . getPath ( ) , \"UTF-8\" ) ) ) ) ; } } } } } classes . addAll ( getMatchedClasses ( matcher , jarFile ) ) ; } else { File base = new File ( URLDecoder . decode ( url . getPath ( ) , \"UTF-8\" ) ) ; classes . addAll ( getMatchedClasses ( matcher , base ) ) ; } } return classes ; }'", "label": "'Resolves the { @code Class } es that matches to the specified { @code Matcher } .'"}
{"text": "'public Bills searchByDate ( String state , String updated_since , String page , String per_page ) throws OpenStatesException { OpenStates . suspendCache ( ) ; Bills bills = api . query ( new MethodMap ( \"bills\" ) , new ArgMap ( \"state\" , state , \"updated_since\" , updated_since , \"page\" , page , \"per_page\" , per_page ) , Bills . class ) ; return bills ; }'", "label": "'Bill Search This method returns just a subset of the bill fields by default . NOTE : *** This method never uses the cache . Use with caution . ***'"}
{"text": "'public Bills searchByWindow ( String state , String search_window , String page , String per_page ) throws OpenStatesException { OpenStates . suspendCache ( ) ; Bills bills = api . query ( new MethodMap ( \"bills\" ) , new ArgMap ( \"state\" , state , \"search_window\" , search_window , \"page\" , page , \"per_page\" , per_page ) , Bills . class ) ; return bills ; }'", "label": "'Bill Search This method returns just a subset of the bill fields by default . NOTE : *** This method never uses the cache . Use with caution . ***'"}
{"text": "'public Bills search ( String state , String chamber , String bill_id , String bill_id__in , String q , String search_window , String updated_since , String sponsor_id , String subject , String type , String sort , String page , String per_page ) throws OpenStatesException { OpenStates . suspendCache ( ) ; Bills bills = api . query ( new MethodMap ( \"bills\" ) , new ArgMap ( \"state\" , state , \"chamber\" , chamber , \"bill_id\" , bill_id , \"bill_id__in\" , bill_id__in , \"q\" , q , \"search_window\" , search_window , \"updated_since\" , updated_since , \"sponsor_id\" , sponsor_id , \"subject\" , subject , \"type\" , type , \"sort\" , sort , \"page\" , page , \"per_page\" , per_page ) , Bills . class ) ; return bills ; }'", "label": "'Bill Search This method returns just a subset of the bill fields by default . NOTE : *** This method never uses the cache . Use with caution . ***'"}
{"text": "'public Bill detail ( String state , String session , String number ) throws OpenStatesException { return api . query ( new MethodMap ( \"bills\" , state , session , number ) , null , Bill . class ) ; }'", "label": "'Bill Detail This method returns the full detail object for a bill .'"}
{"text": "'public Bill detailById ( String bill_id ) throws OpenStatesException { return api . query ( new MethodMap ( \"bills\" , bill_id ) , null , Bill . class ) ; }'", "label": "'Bill Detail This method returns the full detail object for a bill .'"}
{"text": "'public Legislators searchByState ( String state ) throws OpenStatesException { return api . query ( new MethodMap ( \"legislators\" ) , new ArgMap ( \"state\" , state ) , Legislators . class ) ; }'", "label": "'Get Legislators by State .'"}
{"text": "'public Legislators searchByStateActive ( String state , Boolean active ) throws OpenStatesException { return api . query ( new MethodMap ( \"legislators\" ) , new ArgMap ( \"state\" , state , \"active\" , active . toString ( ) ) , Legislators . class ) ; }'", "label": "'Get Legislators by State and Active filters .'"}
{"text": "'public Legislators searchByStateTerm ( String state , String term ) throws OpenStatesException { return api . query ( new MethodMap ( \"legislators\" ) , new ArgMap ( \"state\" , state , \"term\" , term ) , Legislators . class ) ; }'", "label": "'Search for Legislators by State and Term .'"}
{"text": "'public Legislators search ( String state , Boolean active , String term , String chamber , String district , String party , String first_name , String last_name ) throws OpenStatesException { return api . query ( new MethodMap ( \"legislators\" ) , new ArgMap ( \"state\" , state , \"first_name\" , first_name , \"last_name\" , last_name , \"chamber\" , chamber , \"active\" , active == null ? null : active . toString ( ) , \"term\" , term , \"party\" , party , \"district\" , district ) , Legislators . class ) ; }'", "label": "'This method allows looking up a legislator by a number of parameters the results do not include the roles or old_roles items by default .'"}
{"text": "'public Legislator detail ( String id ) throws OpenStatesException { return api . query ( new MethodMap ( \"legislators\" , id ) , null , Legislator . class ) ; }'", "label": "'This method returns the full detail for a legislator .'"}
{"text": "'public Resource getResource ( final String catalog ) { ResourceSelection selection = contextConfig . getSelection ( catalog ) ; if ( selection == null ) { return null ; } return repository . getResource ( selection ) ; }'", "label": "'\u5b9a\u4f4d\u8d44\u6e90\u3002'"}
{"text": "'public Resource getResource ( final ResourceSelection selection ) { String catalog = selection . getCatalog ( ) ; String version = selection . getVersion ( ) ; String name = selection . getName ( ) ; if ( version == null ) { if ( name == null ) { return getResource ( catalog ) ; } else { return getResource ( catalog , name ) ; } } else { return repository . getResource ( selection ) ; } }'", "label": "'\u5b9a\u4f4d\u8d44\u6e90\u3002'"}
{"text": "'public static SystemContext get ( final String id ) { if ( ! GLOBAL_CONTEXTS . containsKey ( id ) ) { GLOBAL_CONTEXTS . putIfAbsent ( id , new DefaultSystemContext ( ) ) ; } return GLOBAL_CONTEXTS . get ( id ) ; }'", "label": "'\u83b7\u53d6\u7cfb\u7edf\u73af\u5883\u7684\u5168\u5c40\u5b9e\u4f8b\uff0c\u5982\u679c\u4e0d\u5b58\u5728\u5219\u5efa\u7acb\u9ed8\u8ba4\u7684\u7cfb\u7edf\u73af\u5883\u5b9e\u4f8b\u3002'"}
{"text": "'public static void set ( final String id , final SystemContext context ) { if ( context == null ) { GLOBAL_CONTEXTS . remove ( id ) ; } else { GLOBAL_CONTEXTS . put ( id , context ) ; } }'", "label": "'\u8bbe\u7f6e\u7cfb\u7edf\u73af\u5883\u7684\u5168\u5c40\u5b9e\u4f8b\u3002'"}
{"text": "'@ Override public String getPrefix ( ) { String pattern = super . getPrefix ( ) ; String prefix = pattern . replace ( HOSTNAME_VARIABLE , hostName ) ; prefix = prefix . replace ( \"..\" , \".\" ) ; return prefix ; }'", "label": "'Returns the prefix for the graphite reporter formatting the prefix with the host name as input . <p / > An example of this : <pre > prefix = cluster . %s . mycomponent< / pre > <p / > Will give : <pre > cluster . localhost . mycomponent< / pre > <p / > Where localhost is the host name . <p / > It will also replace double dots { @code .. } with a single dot { @code . } .'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public static < T extends TypesafeEnum < T > > Set < T > values ( Class < T > clazz ) { Set < T > set = new HashSet < T > ( ) ; if ( constants . containsKey ( clazz ) ) { set . addAll ( ( Set < T > ) constants . get ( clazz ) ) ; } return set ; }'", "label": "'Returns the instance set of the specified { @code TypesafeEnum } class .'"}
{"text": "'public int compareTo ( E o ) { if ( o . getClass ( ) != getClass ( ) ) { throw new ClassCastException ( ) ; } return ordinal - TypesafeEnum . class . cast ( o ) . ordinal ; }'", "label": "'Compares with the specified object by ordinal .'"}
{"text": "'public void setMappedClass ( Class < T > mappedClass ) { if ( this . mappedClass == null ) { initialize ( mappedClass ) ; } else { if ( ! this . mappedClass . equals ( mappedClass ) ) { throw new InvalidDataAccessApiUsageException ( \"The mapped class can not be reassigned to map to \" + mappedClass + \" since it is already providing mapping for \" + this . mappedClass ) ; } } }'", "label": "'Set the class that each row should be mapped to .'"}
{"text": "'protected void initialize ( Class < T > mappedClass ) { this . mappedClass = mappedClass ; this . mappedFields = new HashMap < String , Field > ( ) ; this . mappedProperties = new HashSet < String > ( ) ; Field fields [ ] = mappedClass . getFields ( ) ; for ( Field field : fields ) { int mod = field . getModifiers ( ) ; if ( Modifier . isPublic ( mod ) && ! Modifier . isStatic ( mod ) ) { String fieldNameV1 = field . getName ( ) . toLowerCase ( ) ; String fieldNameV2 = underscoreName ( field . getName ( ) ) ; String fieldNameV3 = underscoreNameR ( field . getName ( ) ) ; this . mappedFields . put ( fieldNameV1 , field ) ; if ( ! fieldNameV2 . equals ( fieldNameV1 ) ) { this . mappedFields . put ( fieldNameV2 , field ) ; } if ( ! fieldNameV3 . equals ( fieldNameV1 ) && ! fieldNameV3 . equals ( fieldNameV2 ) ) { this . mappedFields . put ( fieldNameV3 , field ) ; } this . mappedProperties . add ( fieldNameV2 ) ; /*\\n                this.mappedFields.put(field.getName().toLowerCase(), field);\\n                String underscoredName = underscoreName(field.getName());\\n                if (!field.getName().toLowerCase().equals(underscoredName)) {\\n                    this.mappedFields.put(underscoredName, field);\\n                }\\n                this.mappedProperties.add(underscoredName);\\n                */ } } }'", "label": "'Initialize the mapping metadata for the given class .'"}
{"text": "'protected Object getColumnValue ( ResultSet rs , int index , Field field ) throws SQLException { Object value = JdbcUtils . getResultSetValue ( rs , index , field . getType ( ) ) ; if ( value != null && value instanceof String && autoTrimStrings ) { return ( ( String ) value ) . trim ( ) ; } return value ; }'", "label": "'Retrieve a JDBC object value for the specified column . <p > The default implementation calls {'"}
{"text": "'public static < T > DtoRowMapper < T > newInstance ( Class < T > mappedClass ) { DtoRowMapper < T > newInstance = new DtoRowMapper < T > ( ) ; newInstance . setMappedClass ( mappedClass ) ; return newInstance ; }'", "label": "'Static factory method to update a new DtoRowMapper ( with the mapped class specified only once ) .'"}
{"text": "'@ SuppressWarnings ( \"unchecked\" ) public R proceed ( ) throws Throwable { try { return ( R ) method ( ) . invoke ( target , args ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } }'", "label": "'Proceeds this method invocation .'"}
{"text": "'public static String getProperty ( String key , String def ) { return System . getProperty ( key , def ) ; }'", "label": "'Returns the Java system property corresponding to the specified key ( If the system property doesn t exist this method returns the specified default value ) .'"}
{"text": "'public long stop ( ) { if ( isRunning ( ) ) { stop = System . nanoTime ( ) ; total += stop - start ; running = false ; } return Math . round ( total * getPrecision ( ) . value ) ; }'", "label": "'Stops to measure .'"}
{"text": "'public long getTime ( ) { long time = ( isRunning ( ) ) ? total + System . nanoTime ( ) - start : total ; return Math . round ( time * getPrecision ( ) . value ) ; }'", "label": "'Returns the elapsed time with specified precision since this { @code Stopwatch } instance started to measure . The result is rounded to long .'"}
{"text": "'public Events searchByState ( String state ) throws OpenStatesException { return api . query ( new MethodMap ( \"events\" ) , new ArgMap ( \"state\" , state ) , Events . class ) ; }'", "label": "'Event Search This method allows searching by state :'"}
{"text": "'public Events search ( String state , String type ) throws OpenStatesException { return api . query ( new MethodMap ( \"events\" ) , new ArgMap ( \"state\" , state , \"type\" , type ) , Events . class ) ; }'", "label": "'Event Search This method allows searching by a number of fields :'"}
{"text": "'protected HttpClient buildClient ( ) { HttpClientBuilder builder = HttpClientBuilder . create ( ) . useSystemProperties ( ) . setConnectionManager ( connManager ) ; if ( ! isBlank ( username ) && ! isBlank ( password ) ) { final URI uri = URI . create ( url ) ; final CredentialsProvider credsProvider = new BasicCredentialsProvider ( ) ; credsProvider . setCredentials ( new AuthScope ( uri . getHost ( ) , uri . getPort ( ) ) , new UsernamePasswordCredentials ( username , password ) ) ; builder = builder . setDefaultCredentialsProvider ( credsProvider ) ; } return builder . build ( ) ; }'", "label": "'Setup authentication in httpclient .'"}
{"text": "'private HttpUriRequest minterRequest ( ) { switch ( method . toUpperCase ( ) ) { case \"GET\" : return new HttpGet ( url ) ; case \"PUT\" : return new HttpPut ( url ) ; default : return new HttpPost ( url ) ; } }'", "label": "'Instantiate a request object based on the method variable .'"}
{"text": "'protected String responseToPid ( final String responseText ) throws IOException { LOGGER . debug ( \"responseToPid({})\" , responseText ) ; if ( ! isBlank ( regex ) ) { return responseText . replaceFirst ( regex , \"\" ) ; } else if ( xpath != null ) { try { return xpath ( responseText , xpath ) ; } catch ( ParserConfigurationException | SAXException | XPathExpressionException e ) { throw new IOException ( e ) ; } } else { return responseText ; } }'", "label": "'Remove unwanted text from the minter service response to produce the desired identifier . Override this method for processing more complex than a simple regex replacement .'"}
{"text": "'private static String xpath ( final String xml , final XPathExpression xpath ) throws ParserConfigurationException , SAXException , IOException , XPathExpressionException { final DocumentBuilder builder = DOCUMENT_BUILDER_FACTORY . newDocumentBuilder ( ) ; final Document doc = builder . parse ( new ByteArrayInputStream ( xml . getBytes ( ) ) ) ; return xpath . evaluate ( doc ) ; }'", "label": "'Extract the desired identifier value from an XML response using XPath'"}
{"text": "'@ Timed @ Override public String get ( ) { try { LOGGER . debug ( \"mintPid()\" ) ; final HttpResponse resp = client . execute ( minterRequest ( ) ) ; return responseToPid ( EntityUtils . toString ( resp . getEntity ( ) ) ) ; } catch ( final IOException ex ) { LOGGER . warn ( \"Error minting pid from {}: {}\" , url , ex . getMessage ( ) ) ; throw new PidMintingException ( \"Error minting pid\" , ex ) ; } catch ( final Exception ex ) { LOGGER . warn ( \"Error processing minter response\" , ex . getMessage ( ) ) ; throw new PidMintingException ( \"Error processing minter response\" , ex ) ; } }'", "label": "'Mint a unique identifier using an external HTTP API .'"}
{"text": "'public static < T extends Configuration > ConfigurationBinder < T > forClass ( Class < T > klass , Binder binder ) { return new ConfigurationBinder <> ( klass , binder ) ; }'", "label": "'The starting point for using a ConfigurationBinder . A class needs to be passed through along with a binder to eventually bind the configuration with .'"}
{"text": "'public void toInstance ( Config configuration ) { Preconditions . checkNotNull ( configuration , \"Configuration Instance cannot be null.\" ) ; if ( annotationClass == null ) { binder . bind ( configClass ) . toInstance ( configuration ) ; } else { binder . bind ( configClass ) . annotatedWith ( annotationClass ) . toInstance ( configuration ) ; } }'", "label": "'This method will bind the class to a particular instance .'"}
{"text": "'public void toFile ( String fileName ) { Preconditions . checkNotNull ( fileName , \"File Name cannot be null.\" ) ; Config configuration = buildFromFile ( fileName ) ; if ( annotationClass == null ) { binder . bind ( configClass ) . toInstance ( configuration ) ; } else { binder . bind ( configClass ) . annotatedWith ( annotationClass ) . toInstance ( configuration ) ; } }'", "label": "'This method will load the configuration using a { @link io . dropwizard . configuration . ConfigurationFactory } to load the file from the current relative working directory .'"}
{"text": "'private Config buildFromFile ( String possibleFilename ) { File configFile = new File ( possibleFilename ) ; Preconditions . checkArgument ( configFile . exists ( ) , \"File must exist at: \" + configFile . getAbsolutePath ( ) ) ; try { return new ConfigurationFactory <> ( configClass , Validation . buildDefaultValidatorFactory ( ) . getValidator ( ) , Jackson . newObjectMapper ( ) , \"graceland\" ) . build ( configFile ) ; } catch ( Exception e ) { String msg = \"Unknown exception triggered when attempting to build config from file:\" + \"\\\\n\" + \"\\\\t* Configuration Class: \" + configClass . getCanonicalName ( ) + \"\\\\n\" + \"\\\\t* File: \" + configFile . getAbsolutePath ( ) ; throw new RuntimeException ( msg , e ) ; } }'", "label": "'Builds a Configuration object from the file path given . It uses the { @link io . dropwizard . configuration . ConfigurationFactory } to build the configuration .'"}
{"text": "'@ Override protected Class < ? > load ( String clazz , InputStream stream ) { //\\t\\tSystem.out.println(clazz); try { return Class . forName ( clazz , true , classLoader ) ; } catch ( Exception e ) { //\\t\\t\\tSystem.out.println(e); return null ; } catch ( NoClassDefFoundError e ) { //\\t\\t\\tSystem.out.println(e); return null ; } }'", "label": "'Loads the class of the specified name from the specified { @code InputStream } and returns loaded class representation as { @code java . lang . Class } .'"}
{"text": "'@ Override public Set < Class < ? > > resolveByName ( final String name ) throws IOException { Matcher < Class < ? > > matcher = new Matcher < Class < ? > > ( ) { public boolean matches ( Class < ? > clazz ) { return clazz . getName ( ) . contains ( name ) ; } } ; return resolve ( matcher ) ; }'", "label": "'Resolves the classes that contains the specified name as { @code java . lang . Class } .'"}
{"text": "'@ Override public Set < Class < ? > > resolveBySuperclass ( final Class < ? > superclass ) throws IOException { Matcher < Class < ? > > matcher = new Matcher < Class < ? > > ( ) { public boolean matches ( Class < ? > clazz ) { if ( clazz . getSuperclass ( ) != null ) { if ( clazz . getSuperclass ( ) . equals ( superclass ) ) { return true ; } else { return matches ( clazz . getSuperclass ( ) ) ; } } else { return false ; } } } ; return resolve ( matcher ) ; }'", "label": "'Resolves the classes that inherits the specified superclass as { @code java . lang . Class } .'"}
{"text": "'@ Override public Set < Class < ? > > resolveByInterface ( final Class < ? > interfaceClass ) throws IOException { Matcher < Class < ? > > matcher = new Matcher < Class < ? > > ( ) { public boolean matches ( Class < ? > clazz ) { Class < ? > [ ] interfaces = clazz . getInterfaces ( ) ; for ( Class < ? > c : interfaces ) { if ( c . equals ( interfaceClass ) ) { return true ; } } if ( clazz . getSuperclass ( ) != null ) { return matches ( clazz . getSuperclass ( ) ) ; } else { return false ; } } } ; return resolve ( matcher ) ; }'", "label": "'Resolves the classes that implements the specified interface as { @code java . lang . Class } .'"}
{"text": "'@ Override public Set < Class < ? > > resolveByAnnotation ( final Class < ? extends Annotation > annotation ) throws IOException { Matcher < Class < ? > > matcher = new Matcher < Class < ? > > ( ) { public boolean matches ( Class < ? > clazz ) { Annotation [ ] annotations = clazz . getAnnotations ( ) ; for ( Annotation a : annotations ) { if ( a . annotationType ( ) . equals ( annotation ) ) { return true ; } } return false ; } } ; return resolve ( matcher ) ; }'", "label": "'Resolves the classes that is annotated by the specified annotation as { @code java . lang . Class } .'"}
{"text": "'protected void initialize ( Class < T > mappedClass ) { this . mappedClass = mappedClass ; this . mappedFields = new HashMap < String , Field > ( ) ; Field fields [ ] = mappedClass . getFields ( ) ; for ( Field field : fields ) { int mod = field . getModifiers ( ) ; if ( Modifier . isPublic ( mod ) && ! Modifier . isStatic ( mod ) ) { for ( Annotation a : field . getAnnotations ( ) ) { if ( a . annotationType ( ) . isAssignableFrom ( Column . class ) ) { Column c = ( Column ) a ; String columnName = c . name ( ) ; mappedFields . put ( columnName , field ) ; } } } } }'", "label": "'Initialize the mapping metadata for the given class .'"}
{"text": "'@ Override public T mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Assert . state ( this . mappedClass != null , \"Mapped class was not specified\" ) ; T mappedObject ; try { mappedObject = mappedClass . newInstance ( ) ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } ResultSetMetaData rsmd = rs . getMetaData ( ) ; int columnCount = rsmd . getColumnCount ( ) ; for ( int index = 1 ; index <= columnCount ; index ++ ) { String column = JdbcUtils . lookupColumnName ( rsmd , index ) ; Field field = this . mappedFields . get ( column . replaceAll ( \" \" , \"\" ) ) ; if ( field != null ) { Object value = getColumnValue ( rs , index , field ) ; if ( logger . isTraceEnabled ( ) && rowNumber == 0 ) { logger . trace ( \"Mapping column \\'\" + column + \"\\' to property \\'\" + field . getName ( ) + \"\\' of type \" + field . getType ( ) ) ; } try { field . set ( mappedObject , value ) ; } catch ( IllegalArgumentException e ) { if ( value == null && primitivesDefaultedForNullValue ) { logger . debug ( \"Intercepted IllegalArgumentException for row \" + rowNumber + \" and column \\'\" + column + \"\\' with value \" + value + \" when setting property \\'\" + field . getName ( ) + \"\\' of type \" + field . getType ( ) + \" on object: \" + mappedObject ) ; } else { throw e ; } } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } } } return mappedObject ; }'", "label": "'Extract the values for all columns in the current row . <p > Utilizes public setters and result set metadata .'"}
{"text": "'public static < T > RecordMapper < T > newInstance ( Class < T > mappedClass ) { RecordMapper < T > newInstance = new RecordMapper < T > ( ) ; newInstance . setMappedClass ( mappedClass ) ; return newInstance ; }'", "label": "'Static factory method to create a new RecordMapper ( with the mapped class specified only once ) .'"}
{"text": "'public static String generateName ( final String catalog ) { String [ ] catalogs = catalog . split ( \"/\" ) ; return catalogs [ catalogs . length - 1 ] ; }'", "label": "'\u6839\u636e\u7c7b\u522b\u751f\u6210\u9ed8\u8ba4\u7684\u540d\u79f0\u3002'"}
{"text": "'public static CodedMessage trace ( final String code , final String ... arguments ) { return new CodedMessage ( code , CodedMessageLevel . TRACE , arguments ) ; }'", "label": "'\u65b0\u5efa\u8ddf\u8e2a\u7ea7\u522b\u7684\u6d88\u606f\u3002'"}
{"text": "'public static CodedMessage debug ( final String code , final String ... arguments ) { return new CodedMessage ( code , CodedMessageLevel . DEBUG , arguments ) ; }'", "label": "'\u65b0\u5efa\u8c03\u8bd5\u7ea7\u522b\u7684\u6d88\u606f\u3002'"}
{"text": "'public static CodedMessage information ( final String code , final String ... arguments ) { return new CodedMessage ( code , CodedMessageLevel . INFORMATION , arguments ) ; }'", "label": "'\u65b0\u5efa\u6d88\u606f\u7ea7\u522b\u7684\u6d88\u606f\u3002'"}
{"text": "'public static CodedMessage warning ( final String code , final String ... arguments ) { return new CodedMessage ( code , CodedMessageLevel . WARNING , arguments ) ; }'", "label": "'\u65b0\u5efa\u8b66\u544a\u7ea7\u522b\u7684\u6d88\u606f\u3002'"}
{"text": "'public static CodedMessage error ( final String code , final String ... arguments ) { return new CodedMessage ( code , CodedMessageLevel . ERROR , arguments ) ; }'", "label": "'\u65b0\u5efa\u9519\u8bef\u7ea7\u522b\u7684\u6d88\u606f\u3002'"}
{"text": "'public static CodedMessage fatal ( final String code , final String ... arguments ) { return new CodedMessage ( code , CodedMessageLevel . FATAL , arguments ) ; }'", "label": "'\u65b0\u5efa\u81f4\u547d\u9519\u8bef\u7ea7\u522b\u7684\u6d88\u606f\u3002'"}
{"text": "'public static List < CodedMessage > load ( final Reader reader ) throws CodedMessageException { Document document ; try { Transformer transformer = TRANSFORMER_FACTORY . newTransformer ( ) ; DOMResult result = new DOMResult ( ) ; transformer . transform ( new StreamSource ( reader ) , result ) ; document = ( Document ) result . getNode ( ) ; } catch ( TransformerException e ) { throw new CodedMessageException ( e , \"CodedMessage.LoadXMLError\" ) ; } return load0 ( document . getDocumentElement ( ) ) ; }'", "label": "'\u4ece\u6587\u4ef6\u52a0\u8f7d\u3002'"}
{"text": "'public static void save ( final List < CodedMessage > messageList , final OutputStream writer ) throws CodedMessageException { try { Document document = save0 ( messageList ) ; Transformer transformer = TRANSFORMER_FACTORY . newTransformer ( ) ; transformer . setOutputProperty ( OutputKeys . ENCODING , \"UTF-8\" ) ; transformer . transform ( new DOMSource ( document ) , new StreamResult ( writer ) ) ; } catch ( TransformerException e ) { throw new CodedMessageException ( e , \"CodedMessage.SaveXMLError\" ) ; } }'", "label": "'\u4fdd\u5b58\u5230\u6587\u4ef6\u3002'"}
{"text": "'public static FilterPattern newInstance ( EnumSet < DispatcherType > dispatcherTypes , boolean matchAfter , Iterable < String > patterns ) { return new FilterPattern ( dispatcherTypes , matchAfter , ImmutableList . copyOf ( patterns ) ) ; }'", "label": "'Returns a new instance of FilterPattern using the passed in arguments .'"}
{"text": "'public static FilterPattern forPatterns ( String ... patterns ) { return new FilterPattern ( DEFAULT_DISPATCHER_TYPES , DEFAULT_MATCH_AFTER , ImmutableList . copyOf ( patterns ) ) ; }'", "label": "'Returns a new intance of FitlerPattern using default values and the patterns passed in . <p / > The default values are { @link io . graceland . filter . FilterPattern#DEFAULT_DISPATCHER_TYPES } and { @link io . graceland . filter . FilterPattern#DEFAULT_MATCH_AFTER } .'"}
{"text": "'public static ConfigurationContext load ( final ResourceRepository repository , final ResourceSelection selection ) throws ConfigurationException { LOG . debug ( \"\u4ece {} \u52a0\u8f7d\u914d\u7f6e\u96c6\u5408\", selection);\\r     Resource resource = repository . getResource ( selection ) ; if ( resource == null ) { throw new ConfigurationException ( selection + \" \u89e3\u6790\u5931\u8d25\");\\r   } ResourceContextConfig contextConfig = new ResourceContextConfig ( ) ; contextConfig . load ( resource ) ; return new ConfigurationContext ( repository , contextConfig ) ; }'", "label": "'\u4ece\u8d44\u6e90\u4ed3\u5e93\u7684\u67d0\u4f4d\u7f6e\u52a0\u8f7d\u3002'"}
{"text": "'public Resource getConfigurationResource ( final ResourceSelection selection ) throws ConfigurationException { Resource resource = getResource ( selection ) ; if ( resource == null ) { String catalog = selection . getCatalog ( ) ; String version = selection . getVersion ( ) ; String name = selection . getName ( ) ; throw new ConfigurationException ( \"\u672a\u627e\u5230\u7c7b\u522b \" + catalog + \" \u7248\u672c \"    ersion + \" \u7684 \u7f6e \" + n m );\\r     } return resource ; }'", "label": "'\u5b9a\u4f4d\u914d\u7f6e\u8d44\u6e90\u3002'"}
{"text": "'public < T extends ReloadableConfigurationContainer > T getConfiguration ( final Class < T > type , final ResourceSelection selection ) throws ConfigurationException { Resource resource = getConfigurationResource ( selection ) ; T container = ( T ) containerCache . get ( resource ) ; if ( container != null ) { container . checkReload ( ) ; return container ; } synchronized ( containerCache ) { container = ( T ) containerCache . get ( resource ) ; if ( container != null ) { container . checkReload ( ) ; return container ; } try { container = type . newInstance ( ) ; } catch ( ReflectiveOperationException e ) { throw new ConfigurationException ( \"\u914d\u7f6e\u7c7b \" + typ . etNa m e() + \"   \u5b9e \u5316 \u8d25\", e);\\r     } // \u52a0\u8f7d\u914d\u7f6e\\r LOG . debug ( \"\u4ece {}({}) \u52a0\u8f7d\u914d\u7f6e\", selectio n  resource ) \\r   try { container . load ( resource ) ; } catch ( ConfigurationException e ) { throw new ConfigurationException ( \"\u914d\u7f6e \" + r s urce.get D escription() +   \" \u52a0 \u9519\u8bef\", e);\\r     } containerCache . put ( resource , container ) ; return container ; } }'", "label": "'\u52a0\u8f7d\u914d\u7f6e\u8d44\u6e90\uff0c\u8fd4\u56de\u914d\u7f6e\u5bf9\u8c61\u3002'"}
{"text": "'public static PagableQueryParams of ( ) { return PagableQueryParams . of ( Optional . < String > absent ( ) , Optional . < Integer > absent ( ) ) ; }'", "label": "'Helper method to create an empty { @link PagableQueryParams } .'"}
{"text": "'public static PagableQueryParams of ( final Optional < String > optOffset , final Optional < Integer > optLimit ) { return PagableQueryParams . of ( optOffset , optLimit , Optional . < SortDirection > absent ( ) , Optional . < Boolean > absent ( ) ) ; }'", "label": "'Helper method to create an empty { @link PagableQueryParams } .'"}
{"text": "'public T proceed ( ) throws Throwable { try { return constructor ( ) . newInstance ( args ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } }'", "label": "'Proceeds this constructor invocation .'"}
{"text": "", "label": ""}
